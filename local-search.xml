<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>离散数学（1）</title>
    <link href="/2022/10/15/Basic/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
    <url>/2022/10/15/Basic/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="离散数学1">离散数学（1）</h1><h2 id="逻辑关系">0 逻辑关系</h2><h3 id="联结词">0.1 联结词</h3><p><span class="math display">\[p\]</span>、<spanclass="math display">\[q\]</span>、<spanclass="math display">\[r\]</span>表示原子命题（简单命题、变元、常元）。<spanclass="math display">\[1\]</span> 表示命题的真值为真，<spanclass="math display">\[0\]</span> 表示假</p><ul><li><p><spanclass="math display">\[¬p\]</span>：否定联结词（非运算）</p><table><tr><th><p>p</p></th><th><p>¬p</p></th></tr><tr><td><p>1</p></td><td><p>0</p></td></tr><tr><td><p>0</p></td><td><p>1</p></td></tr></table></li><li><p><span class="math display">\[p\andq\]</span>：合取联结词（与运算）</p><table><tr><th><p>p</p></th><th><p>q</p></th><th><p>p∧q</p></th></tr><tr><td><p>0</p></td><td><p>0</p></td><td><p>0</p></td></tr><tr><td><p>0</p></td><td><p>1</p></td><td><p>0</p></td></tr><tr><td><p>1</p></td><td><p>0</p></td><td><p>0</p></td></tr><tr><td><p>1</p></td><td><p>1</p></td><td><p>1</p></td></tr></table></li><li><p><span class="math display">\[p\orq\]</span>：析取联结词（或运算）</p><table><tr><th><p>p</p></th><th><p>q</p></th><th><p>p∨q</p></th></tr><tr><td><p>0</p></td><td><p>0</p></td><td><p>0</p></td></tr><tr><td><p>0</p></td><td><p>1</p></td><td><p>1</p></td></tr><tr><td><p>1</p></td><td><p>0</p></td><td><p>1</p></td></tr><tr><td><p>1</p></td><td><p>1</p></td><td><p>1</p></td></tr></table></li><li><p><span class="math display">\[p→q\]</span>：蕴含联结词（<spanclass="math display">\[p\]</span> 是 <spanclass="math display">\[q\]</span> 的充分条件，<spanclass="math display">\[q\]</span> 是 <spanclass="math display">\[p\]</span> 的必要条件）</p><table><tr><th><p>p</p></th><th><p>q</p></th><th><p>p→q</p></th></tr><tr><td><p>0</p></td><td><p>0</p></td><td><p>1</p></td></tr><tr><td><p>0</p></td><td><p>1</p></td><td><p>1</p></td></tr><tr><td><p>1</p></td><td><p>0</p></td><td><p>0</p></td></tr><tr><td><p>1</p></td><td><p>1</p></td><td><p>1</p></td></tr></table><blockquote><p>如果认为所有猫都爱睡觉，也就是说：如果有一只猫（<spanclass="math display">\[p\]</span>），那么这只猫喜欢睡觉（<spanclass="math display">\[p\rarr q\]</span>）。</p><p>这样的话：</p><p>如果不是一只猫（<spanclass="math display">\[p=0\]</span>），那么它可以不爱睡觉（<spanclass="math display">\[q=0\]</span>），也可以爱睡觉（<spanclass="math display">\[q=1\]</span>）</p><p>如果是一只猫（<spanclass="math display">\[p=1\]</span>），那么它不可以不爱睡觉（<spanclass="math display">\[q=0\]</span>），只可以爱睡觉（<spanclass="math display">\[q=1\]</span>）</p></blockquote></li><li><p><spanclass="math display">\[p↔q\]</span>：等价联结词（等于，充分必要条件）</p><table><tr><th><p>p</p></th><th><p>q</p></th><th><p>p↔︎q</p></th></tr><tr><td><p>0</p></td><td><p>0</p></td><td><p>1</p></td></tr><tr><td><p>0</p></td><td><p>1</p></td><td><p>0</p></td></tr><tr><td><p>1</p></td><td><p>0</p></td><td><p>0</p></td></tr><tr><td><p>1</p></td><td><p>1</p></td><td><p>1</p></td></tr></table></li></ul><h3 id="命题公式">0.2 命题公式</h3><p>单个命题变元（或常元）是命题公式。</p><p>若 <span class="math display">\[p\]</span>、<spanclass="math display">\[q\]</span> 是命题公式，那么 <spanclass="math display">\[¬p\]</span>、<span class="math display">\[p\andq\]</span>、<span class="math display">\[p\or q\]</span>、<spanclass="math display">\[p→q\]</span>、<spanclass="math display">\[p↔q\]</span>都是命题公式。命题公式的长度是有限的。</p><p>联结词的优先级是： <span class="math display">\[¬\]</span>、<spanclass="math display">\[\and \or\]</span>、<spanclass="math display">\[→↔\]</span></p><p>将值永远为 <span class="math display">\[0\]</span>的命题公式称为矛盾式（永假式），如 <span class="math display">\[p \and¬p\]</span></p><p>将值可能为 <span class="math display">\[1\]</span>的命题公式称为可满足式。</p><p>将值永远为 <span class="math display">\[1\]</span>的命题公式称为重言式（永真式），如 <spanclass="math display">\[p\and(p\orq)↔p\]</span>。永真式是可满足式的一种</p><h3 id="等值式">0.3 等值式</h3><p>等值式：如果 <span class="math display">\[p↔q\]</span> 是永真式，则<span class="math display">\[p⇔q\]</span>，表示 <spanclass="math display">\[p\]</span> 与 <spanclass="math display">\[q\]</span> 的取值完全相同，可以互相代替</p><table><tr><th>p</th><th>q</th><th>p→q</th><th>¬p∨q</th><th>(p→q)↔︎(¬p∨q)</th></tr><tr><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></table><p><span class="math display">\[∴p→q⇔¬p∨q\]</span></p><p><strong>基本的等值式</strong></p><ul><li><p>幂等率：<span class="math display">\[p⇔p\or p{\qquad}p⇔p\andp\]</span></p></li><li><p>交换律：<span class="math display">\[p\or q⇔p\or q{\qquad}p\andq⇔q\and p\]</span></p></li><li><p>结合律：<span class="math display">\[(p\or q)\or r⇔p\or(q\orr){\qquad}(p\and q)\and r⇔p\and(q\and r)\]</span></p></li><li><p>分配律：<span class="math display">\[p\or(q\and r)⇔(p\orq)\and(p\or r){\qquad}p\and(q\or r)⇔(p\and q)\or(p\andr)\]</span></p></li><li><p>德·摩根律：<span class="math display">\[¬(p\or q)⇔¬p\and¬q{\qquad}¬(p\and q)⇔¬p\or ¬q\]</span></p></li><li><p>吸收律：<span class="math display">\[p\or(p\andq)⇔p{\qquad}p\and(p\or q)⇔p\]</span></p></li><li><p>零律：<spanclass="math display">\[p\or1⇔1{\qquad}p\and0⇔0\]</span></p></li><li><p>同一律：<spanclass="math display">\[p\or0⇔p{\qquad}p\and1⇔p\]</span></p></li><li><p>排中律：<span class="math display">\[p\or¬p⇔1\]</span></p></li><li><p>矛盾律：<span class="math display">\[p\and¬p⇔0\]</span></p></li><li><p>双重否定律：<span class="math display">\[¬¬p⇔p\]</span></p></li><li><p>蕴含等值式：<spanclass="math display">\[p→q⇔¬p∨q\]</span></p></li><li><p>等价等值式：<spanclass="math display">\[p↔q⇔(p→q)\and(q→p)\]</span></p></li><li><p>等价否定等值式（否命题）：<spanclass="math display">\[p↔q⇔¬p↔¬q\]</span></p></li><li><p>假言易位（逆否）：<spanclass="math display">\[p→q⇔¬q→¬p\]</span></p></li><li><p>归谬论（反证法）：<spanclass="math display">\[(p→q)\and(p→¬q)⇔¬p\]</span></p></li></ul><h3 id="命题逻辑推理">0.4 命题逻辑推理</h3><p>前提：<spanclass="math display">\[A_1，A_2，A_3,...，A_k\]</span></p><p>结论：<span class="math display">\[B\]</span></p><p>推理的形式结构：<span class="math display">\[(A_1\and A_2\and A_3\and... \and A_k)→B\]</span></p><p>如果 <span class="math display">\[A→B\]</span> 是永真式，则可以记为<span class="math display">\[A⇒B\]</span></p><p><strong>重要的推理定律</strong></p><ul><li><p>附加律：<span class="math display">\[A⇒(A\or B)\]</span></p></li><li><p>化简律：<span class="math display">\[(A\and B)⇒A{\qquad}(A\andB)⇒B\]</span></p></li><li><p>假言推理：<span class="math display">\[(A→B)\andA⇒B\]</span></p></li><li><p>拒取式：<span class="math display">\[(A→B)\and¬B⇒¬A\]</span></p></li><li><p>析取三段论：<span class="math display">\[(A\orB)\or¬A⇒B{\qquad}(A\or B)\or¬B⇒A\]</span></p></li><li><p>假言三段论：<spanclass="math display">\[(A→B)\and(B→C)⇒(A→C)\]</span></p></li><li><p>等价三段论：<spanclass="math display">\[(A↔B)\and(B↔C)⇒(A↔C)\]</span></p></li><li><p>构造性两难：<span class="math display">\[(A→B)\and(C→D)\and(A\orC)⇒(B\or D)\]</span></p></li></ul><h3 id="谓词">0.5 谓词</h3><p><strong>基本概念</strong></p><ul><li><p>个体：表示客体的词。</p><p>使用 <span class="math display">\[a,b,c,\ldots\]</span> 表示<strong>个体常元</strong>，使用 <spanclass="math display">\[x,y,z,\ldots\]</span> 表示<strong>个体变元</strong>。</p><p>个体的函数仍是个体。将个体变元的取值范围称为<strong>个体域</strong>。</p></li><li><p>谓词：表示个体间关系或性质的词。</p><p>常用 <span class="math display">\[F,G,H,\ldots\]</span> 表示<strong>谓词常元</strong> 或 <strong>谓词变元</strong>。</p><p><span class="math display">\[F(x)\]</span> 表示 <spanclass="math display">\[x\]</span> 具有性质 <spanclass="math display">\[F\]</span>。如：<spanclass="math display">\[F(x)\]</span> 表示 " 是黑色的"，而 <spanclass="math display">\[a\]</span> 表示 "黑板"，则 <spanclass="math display">\[F(a)\]</span> 表示 "黑板是黑色的"</p><p><span class="math display">\[F(x,y)\]</span> 表示 <spanclass="math display">\[x\]</span> 和 <spanclass="math display">\[y\]</span> 具有关系 <spanclass="math display">\[F\]</span>。如：<spanclass="math display">\[F(x,y)\]</span> 表示 "<spanclass="math display">\[x&gt;y\]</span>"，则 <spanclass="math display">\[F(5,2)\]</span> 表示 <spanclass="math display">\[5&gt;2\]</span></p></li><li><p>量词：表示数量的词</p><p>全称量词：<span class="math display">\[∀\]</span>表示任意、全部。如：<span class="math display">\[∀x\]</span>表示个体域中的所有 <span class="math display">\[x\]</span>；<spanclass="math display">\[∀xF(x)\]</span> 表示个体域中所有 <spanclass="math display">\[x\]</span> 都有性质 <spanclass="math display">\[F\]</span></p><p>存在量词：<span class="math display">\[∃\]</span>表示存在、有一个。如：<span class="math display">\[∃x\]</span>表示存在个体域里的 <span class="math display">\[x\]</span>；<spanclass="math display">\[∃xF(x)\]</span> 表示在个体域中存在 <spanclass="math display">\[x\]</span> 有性质 <spanclass="math display">\[F\]</span></p></li></ul><p><strong>命题符号化</strong></p><p>一阶逻辑中命题逻辑化的两个基本公式：</p><ul><li><p><span class="math display">\[∀x(F(x)\rarr G(x))\]</span></p><p>个体域中所有具有性质 <span class="math display">\[F\]</span>的个体都具有性质 <span class="math display">\[G\]</span></p></li><li><p><span class="math display">\[∃x(F(x)\and G(x))\]</span></p><p>个体域中存在同时具有性质 <span class="math display">\[F\]</span>和性质 <span class="math display">\[G\]</span> 的个体</p></li></ul><p><strong>一阶谓词逻辑公式及其分类</strong></p><p>一阶谓词逻辑公式，简称公式。其形成逻辑类似于命题逻辑公式。而且，<spanclass="math display">\[A\]</span> 是公式时，<spanclass="math display">\[∀xA\]</span> 及 <spanclass="math display">\[∃xA\]</span> 也是公式</p><p>在公式 <span class="math display">\[∀xA\]</span> 及 <spanclass="math display">\[∃xA\]</span> 中，称 <spanclass="math display">\[x\]</span> 为 <strong>指导变元</strong>，称 <spanclass="math display">\[A\]</span> 为相应量词的<strong>辖域</strong>。在该辖域中，<spanclass="math display">\[x\]</span> 的所有出现都是<strong>约束出现</strong>。所有非约束出现的变元都是<strong>自由出现</strong></p><p><strong>解释</strong></p><p>对于给定的公式 <span class="math display">\[A\]</span>，如果指定<span class="math display">\[A\]</span> 的个体域是已知的 <spanclass="math display">\[D\]</span>，使用特定的个体常元取代 <spanclass="math display">\[A\]</span> 中的个体常元，用特定函数取代 <spanclass="math display">\[A\]</span> 中的函数变元，用特定的谓词取代 <spanclass="math display">\[A\]</span> 中的谓词变元，就构成了 <spanclass="math display">\[A\]</span> 的一个解释。</p><p>一个公式 <span class="math display">\[A\]</span>可以有多种解释。当给出一种解释后，就能判断该解释的真假。</p><p>若 <span class="math display">\[A\]</span>在任何解释下都为真，称之为永真式。还有永假式、可满足式。</p><p>若 <span class="math display">\[A\harr B\]</span> 是永真式，则称<span class="math display">\[A\]</span> 与 <spanclass="math display">\[B\]</span> 等值，记为 <spanclass="math display">\[A⇔B\]</span>，并称之为等值式。</p><p>以下是一些基本的等值式</p><ul><li><p>在有限个体域 <span class="math display">\[D=\lbracea_1,a_2,\ldots,a_n\rbrace\]</span> 中消去量词等值式</p><p><span class="math display">\[\quad ∀xA(x)⇔A(a_1)\and A(a_2)\and\ldots \and A(a_n)\]</span></p><p><span class="math display">\[\quad ∃xA(x)⇔A(a_1)\or A(a_2)\or \ldots\or A(a_n)\]</span></p></li><li><p>量词否定等值式</p><p><span class="math display">\[\quad ¬∀xA(x)⇔∃x¬A(x)\]</span></p><p><span class="math display">\[\quad ¬∃xA(x)⇔∀x¬A(x)\]</span></p></li><li><p>量词辖域收缩和扩张等值式（<span class="math display">\[B\]</span>中不含 <span class="math display">\[x\]</span>）</p><p><span class="math display">\[\quad ∀x(A(x)\or B)⇔∀xA(x)\orB\]</span></p><p><span class="math display">\[\quad ∃x(A(x)\or B)⇔∃xA(x)\orB\]</span></p><p><span class="math display">\[\quad ∀x(A(x)\and B)⇔∀xA(x)\andB\]</span></p><p><span class="math display">\[\quad ∃x(A(x)\and B)⇔∃xA(x)\andB\]</span></p><p><span class="math display">\[\quad ∀x(A(x)\rarr B)⇔∃xA(x)\rarrB\]</span></p><p><span class="math display">\[\quad ∃x(A(x)\rarr B)⇔∀xA(x)\rarrB\]</span></p><p><span class="math display">\[\quad ∀x(B\rarr A(x))⇔B\rarr∀xA(x)\]</span></p><p><span class="math display">\[\quad ∃x(B\rarr A(x))⇔B\rarr∃xA(x)\]</span></p></li><li><p>量词分配等值式</p><p><span class="math display">\[\quad ∀x(A(x)\and B(x))⇔∀xA(x)\andB(x)\]</span></p><p><span class="math display">\[\quad ∃x(A(x)\or B(x))⇔∃xA(x)\orB(x)\]</span></p></li></ul><p><strong>前束范式</strong></p><p>若公式具有形式 <span class="math display">\[Q_1 x_1 Q_2 x_2\ldots Q_kx_k B\]</span>，则称其为 <strong>前束范式</strong>。其中 <spanclass="math display">\[Q_i(i\le i \le k)\]</span> 为 <spanclass="math display">\[∃\]</span> 或 <spanclass="math display">\[∀\]</span>，<spanclass="math display">\[B\]</span> 中不含量词</p><p>换名规则：将公式 <span class="math display">\[A\]</span>中某量词辖域中出现的某个约束的个体变元及相应指导变元 <spanclass="math display">\[x_i\]</span> 都改成公式中没有出现过的 <spanclass="math display">\[x_j\]</span>，所得公式 <spanclass="math display">\[A&#39;⇔A\]</span></p><p>一些重要的推理定律（注意：不是等值式）</p><ul><li><span class="math display">\[∀xA(x)\or ∀xB(x)⇒∀xA(x)\orB(x)\]</span></li><li><span class="math display">\[∃x(A(x)\and B(x))⇒∃xA(x)\and∃xB(x)\]</span></li><li><span class="math display">\[∀x(A(x)\rarr B(x))⇒∀xA(x)\rarr∀xB(x)\]</span></li><li><span class="math display">\[∀x(A(x)\rarr B(x))⇒∃xA(x)\rarr∃xB(x)\]</span></li></ul><h2 id="集合论">1 集合论</h2><h3 id="集合">1.1 集合</h3><p>集合：指定范围内所有满足给定条件的对象的聚集。其中的每个对象称为该集合的元素。集合中的元素是无序且不同的。</p><p>通常用大写英文字母表示集合（<spanclass="math display">\[A\]</span>、<spanclass="math display">\[A_1\]</span>），用小写字母表示元素（<spanclass="math display">\[a\]</span>、<spanclass="math display">\[a_1\]</span>）</p><p>常用集合：</p><ul><li><spanclass="math display">\[N\]</span>：自然数集，也就是全体非负整数集</li><li><span class="math display">\[Z\]</span>：整数集</li><li><span class="math display">\[Q\]</span>：有理数集</li><li><span class="math display">\[R\]</span>：实数集</li></ul><p><strong>如何描述一个集合</strong></p><ul><li><p>枚举法</p><p>列举出集合中的全部或部分元素，其余元素使用省略号表示</p><p>如：<span class="math display">\[A =\lbrace1,2,3,4\rbrace\]</span>、<span class="math display">\[B = \lbracea,b,c,d,\ldots\rbrace\]</span></p></li><li><p>叙述法</p><p>通过刻画集合中元素具有的某种性质来表示一个集合</p><p>如：<span class="math display">\[P=\lbracex|P(x)\rbrace\]</span>、<span class="math display">\[L=\lbracex|x是英文字母中的所有元音字母\rbrace\]</span></p></li><li><p>文氏图</p><p>利用平面上的点来做成对集合的图解方法。一般用平面上的方形或圆形表示集合，用平面上的圆点来表示元素</p></li></ul><p><strong>集合的基本概念</strong></p><ul><li><p><strong>属于</strong></p><p>若 <span class="math display">\[a\]</span> 是 <spanclass="math display">\[A\]</span> 中的元素，则称 <spanclass="math display">\[a\]</span> 属于 <spanclass="math display">\[A\]</span>。记为 <spanclass="math display">\[a\in A\]</span>。否则，称 a 不属于 A，记为 <spanclass="math display">\[a\notin A\]</span></p></li><li><p><strong>子集</strong></p><p>如果一个集合中的所有元素都是另一集合的元素，这种关系称为包含关系。记为<span class="math display">\[A \subseteq B\]</span>。否则记为 <spanclass="math display">\[A \not\subseteq B\]</span>。</p><p>符号化形式：</p><p><span class="math display">\[\quad B\subseteq A⇔∀x(x\in B \rarr x\inA)\]</span></p><p><span class="math display">\[\quad B\not\subseteq A⇔∃x(x\in B \andx\not\in A)\]</span></p></li><li><p><strong>相等</strong></p><p>当且仅当两个集合的元素完全相同时，称两个集合相等。记为 <spanclass="math display">\[A = B\]</span>。否则，称两个集合不相等，记为<span class="math display">\[A\neq B\]</span>。</p><p>符号化形式：</p><p><span class="math display">\[\quad A=B ⇔ (A \subseteq B)\and (B\subseteq A)\]</span></p><p><span class="math display">\[\quad A=B ⇔∀x(x\in B \and x\inA)\]</span></p></li><li><p><strong>真子集</strong></p><p>如果 <span class="math display">\[A \subseteq B\]</span> 并且 <spanclass="math display">\[A \neq B\]</span> 则称 A 是 B 的真子集，记为<span class="math display">\[A \subset B\]</span>。否则记为 <spanclass="math display">\[A \not\subset B\]</span></p><p>符号化形式：</p><p><span class="math display">\[\quad B\subset A⇔A\subseteq B \and A\neq B\]</span></p><p><span class="math display">\[\quad B\not\subset A⇔∃x(x\in A\andx\not\in B)\and A \neq B\]</span></p></li><li><p><strong>基数</strong></p><p>集合中的元素个数称为集合的基数。A 的基数记为 <spanclass="math display">\[|A|\]</span></p><p><span class="math display">\[\emptyset\]</span> 是 0元集，只含一个元素的集合是 1 元集，以此类推。</p><p>若一个集合的基数是有限的，称该集合为有限集。否则为无限集。</p></li><li><p><strong>空集</strong></p><p>不含任何元素的集合称为空集，记为 <spanclass="math display">\[\emptyset\]</span>。空集是最小的集合</p><p>空集是唯一的（<span class="math display">\[\emptyset _1=\emptyset_2\]</span>）</p><p>空集是一切集合的子集（<span class="math display">\[\emptyset\subseteqA\]</span>）</p></li><li><p><strong>全集</strong></p><p>针对一个具体范围，我们考虑的所有对象的集合叫做全集，记为 <spanclass="math display">\[U\]</span> 或 <spanclass="math display">\[E\]</span>。全集是相对的。</p></li><li><p><strong>幂集</strong></p><p>由一个集合的所有子集组成的集合称为其幂集。记为 <spanclass="math display">\[P(A)\]</span>。用描述法表示为 <spanclass="math display">\[P(A)=\lbrace x|x\subseteqA\rbrace\]</span></p></li><li><p><strong>集族</strong></p><p>除幂集外，其他形式的由集合构成的集合称为集族</p></li><li><p><strong>多重集</strong></p><p>设全集为 <span class="math display">\[E\]</span>，<spanclass="math display">\[E\]</span> 中元素可以多次出现的集合 <spanclass="math display">\[A\]</span> 称为多重集。那个出现次数称为 <spanclass="math display">\[A\]</span> 的重复度。</p><p>集合可以视为是重复度为 1 的多重集</p></li><li><p><strong>并集</strong></p><p>由两个集合 <span class="math display">\[A,B\]</span>所有元素构成的集合为其并集，记作 <span class="math display">\[A\cupB\]</span></p><p>其描述法表示为：<span class="math display">\[A\cup B=\lbrace x|x\inA\or x\in B\rbrace\]</span></p><p>并运算可以推广到有限个或可数个集合（初级并）</p><p><span class="math display">\[\quadA_1{\cup}A_2{\cup}{\ldots}{\cup}A_n={\lbrace}x|∃i(1{\le}i{\le}n{\and}x{\in}A_i){\rbrace}\]</span></p><p><span class="math display">\[\quad{\bigcup_{i=1}^{n}\\}{A_i=A_1{\cup}A_2{\cup}{\ldots}{\cup}A_n}\]</span></p></li><li><p><strong>交集</strong></p><p>由两个集合 <span class="math display">\[A,B\]</span>共有的元素构成的集合为其交集，记作 <span class="math display">\[A\capB\]</span></p><p>其描述法表示为：<span class="math display">\[A\cap B=\lbrace x|x\inA\and x\in B\rbrace\]</span></p><p>交运算可以推广到有限个或可数个集合（初级交）</p><p><span class="math display">\[\quadA_1{\cap}A_2{\cap}{\ldots}{\cap}A_n={\lbrace}x|∀i(1{\le}i{\le}n{\rarr}x{\in}A_i){\rbrace}\]</span></p><p><span class="math display">\[\quad{\bigcap_{i=1}^{n}\\}A_i=A_1{\cap}A_2{\cap}{\ldots}{\cap}A_n\]</span></p></li><li><p><strong>不相交</strong></p><p>如果 <span class="math display">\[A{\cap}B=\emptyset\]</span>，则称<span class="math display">\[A\]</span> 和 <spanclass="math display">\[B\]</span> 是不相交的</p></li><li><p><strong>相对补</strong></p><p>对于集合 <span class="math display">\[A,B\]</span>，由属于 <spanclass="math display">\[A\]</span> 但不属于 <spanclass="math display">\[B\]</span> 的元素组成的集合称为 <spanclass="math display">\[B\]</span> 对 <spanclass="math display">\[A\]</span> 的相对补集。记作 <spanclass="math display">\[A-B\]</span></p><p>描述法表示为：<spanclass="math display">\[A-B={\lbrace}x|x{\in}A{\and}x{\not\in}B{\rbrace}\]</span></p></li><li><p><strong>对称差</strong></p><p>由属于 <span class="math display">\[A\]</span> 但不属于 <spanclass="math display">\[B\]</span>，或属于 <spanclass="math display">\[B\]</span> 却不属于 <spanclass="math display">\[A\]</span> 的元素组成的集合称为 <spanclass="math display">\[B\]</span> 对 <spanclass="math display">\[A\]</span> 的对称差。记为 <spanclass="math display">\[A{\oplus}B\]</span></p><p>描述法表示为：<spanclass="math display">\[A{\oplus}B={\lbrace}x|(x{\in}A{\and}x{\not\in}B){\or}(x{\in}B{\and}x{\not\in}A){\rbrace}\]</span></p><p><spanclass="math display">\[A{\oplus}B=(A-B){\cup}(B-A)=(A{\cup}B)-(A{\cap}B)\]</span></p></li><li><p><strong>绝对补集</strong></p><p>设 <span class="math display">\[E\]</span> 为全集，<spanclass="math display">\[A{\subseteq}E\]</span>，称 <spanclass="math display">\[A\]</span> 对 <spanclass="math display">\[E\]</span> 的相对补集为 <spanclass="math display">\[A\]</span> 的绝对补集。记为 <spanclass="math display">\[\tilde\ {A}\]</span></p><p>描述法表示为：<span class="math display">\[\tilde\{A}={\lbrace}x|x{\in}E{\and}x{\notin}A{\rbrace}\]</span>，由于 <spanclass="math display">\[x{\in}E=1\]</span> 又有 <spanclass="math display">\[\tilde\ A={\lbrace}x|x{\notin}A{\rbrace}\]</span></p></li><li><p><strong>广义并集</strong></p><p>由一个集族 <span class="math display">\[{\mathcal A}\]</span>中全体元素的元素组成的集合为其广义并，记为 <spanclass="math display">\[{\bigcup}{\mathcal A}\]</span>（大并 <spanclass="math display">\[{\mathcal A}\]</span>）</p><p>描述法表示为：<span class="math display">\[{\bigcup}{\mathcalA}={\lbrace}x|{\exist}z(x{\in}z{\and}z{\in}{\mathcalA}){\rbrace}\]</span></p></li><li><p><strong>广义交集</strong></p><p>由一个集族 <span class="math display">\[{\mathcal A}\]</span>中全体元素的共有元素组成的集合为其广义交，记为 <spanclass="math display">\[{\bigcap}{\mathcal A}\]</span>（大交 <spanclass="math display">\[{\mathcal A}\]</span>）</p><p>描述法表示为：<span class="math display">\[{\bigcap}{\mathcalA}={\lbrace}x|{\forall}z(x{\in}{\mathcalA}{\rarr}z{\in}z){\rbrace}\]</span></p><p>空集不能求广义交。即 <spanclass="math display">\[{\cap}{\emptyset}\]</span> 无意义</p></li></ul><p><strong>集合运算的优先级</strong></p><table><tr><th>优先级</th><th>运算</th><th>类型</th><th>顺序</th></tr><tr><th>1</th><td>绝对补、幂集、广义交、广义并</td><td>一元运算</td><td>从右向左</td></tr><tr><th>2</th><td>初级并、初级交、相对补、对称差等</td><td>二元运算</td><td>从左向右</td></tr></table><p><strong>容斥原理</strong></p><p>设 <span class="math display">\[A_1,A_2,{\dots},A_n\]</span> 为 n个集合，则有</p><p><spanclass="math display">\[\quad|{\bigcup_{i=1}^{n}\\}A_i|={\sum_{i=1}^{n}\\}|A_i|-{\sum_{i&lt;j}\\}|A_i{\cap}A_j|+{\sum_{i&lt;j&lt;k}\\}|A_i{\cap}A_j{\cap}A_k|-{\ldots}+(-1)^{n-1}|A_1{\cap}A_2{\cap}{\ldots}{\cap}A_n|\]</span></p><h3 id="基本的集合恒等式">1.2 基本的集合恒等式</h3><p>设 <span class="math display">\[E\]</span> 为全集，<spanclass="math display">\[A,B,C\]</span> 是 <spanclass="math display">\[E\]</span> 的任意子集。则有：</p><ul><li><p>幂等律：<spanclass="math display">\[A{\cup}A=A{\qquad}A{\cap}A=A\]</span></p></li><li><p>交换律：<spanclass="math display">\[A{\cup}B=B{\cup}A{\qquad}A{\cap}B=B{\cap}A\]</span></p></li><li><p>结合律：<spanclass="math display">\[A{\cup}(B{\cup}C)=(A{\cup}B){\cup}C{\qquad}A{\cap}(B{\cap}C)=(A{\cap}B){\cap}C\]</span></p></li><li><p>分配律：<spanclass="math display">\[A{\cup}(B{\cap}C)=(A{\cup}B){\cap}(A{\cup}C){\qquad}A{\cap}(B{\cup}C)=(A{\cap}B){\cup}(A{\cap}C)\]</span></p></li><li><p>德·摩根定律：<span class="math display">\[\tilde\(A{\cup}B)=\tilde\ A{\cap}\tilde\ B{\qquad}\tilde\ (A{\cap}B)=\tilde\A{\cup}\tilde\ B\]</span></p><p><spanclass="math display">\[E-(A{\cup}B)=(E-A){\cap}(E-B){\qquad}E-(A{\cap}B)=(E-A){\cup}(E-B)\]</span></p><p><span class="math display">\[\tilde\(A_1{\cup}A_2{\cup\ldots\cup}A_n)=\tilde\ A_1{\cap}\tilde\A_2{\cap\ldots\cap}\tilde\ A_n{\qquad}\tilde\(A_1{\cap}A_2{\cap\ldots\cap}A_n)=\tilde\ A_1{\cup}\tilde\A_2{\cup\ldots\cup}\tilde\ A_n\]</span></p></li><li><p>吸收律：<spanclass="math display">\[A{\cup}(A{\cap}B)=A{\qquad}A{\cap}(A{\cup}B)=A\]</span></p></li><li><p>零律：<spanclass="math display">\[A{\cup}E=E{\qquad}A{\cap\emptyset}={\emptyset}\]</span></p></li><li><p>同一律：<spanclass="math display">\[A{\cap}E=A{\qquad}A{\cup\emptyset}=A\]</span></p></li><li><p>排中律：<span class="math display">\[A{\cup}\tilde\A=E\]</span></p></li><li><p>矛盾律：<span class="math display">\[A{\cap}\tilde\A={\emptyset}\]</span></p></li><li><p>余补律：<span class="math display">\[{\tilde\E}={\emptyset}{\qquad}{\tilde\ \emptyset}=E\]</span></p></li><li><p>双重否定律：<span class="math display">\[{\tilde\ \tilde\A}=A\]</span></p></li><li><p>补交转换律：<span class="math display">\[A-B=A{\cap}{\tilde\B}\]</span></p></li></ul><p>设 <spanclass="math display">\[{\lbrace}A_{\alpha}{\rbrace}_{\alpha\inS}\]</span> 为集族，<span class="math display">\[B\]</span>为一集合。则有：</p><ul><li><p>分配律：<spanclass="math display">\[B{\cup}(\bigcap{\lbrace{A_{\alpha}}\rbrace}_{\alpha\inS})={\bigcap_{\alpha\inS}\\}(B{\cup}A_{\alpha}){\qquad}B{\cap}(\bigcup{\lbrace{A_{\alpha}}\rbrace}_{\alpha\inS})={\bigcup_{\alpha\in S}\\}(B{\cap}A_{\alpha})\]</span></p></li><li><p>德·摩根律：<spanclass="math display">\[{\tilde\\}(\bigcup{\lbrace{A_{\alpha}}\rbrace}_{\alpha\inS})={\bigcap_{\alpha\inS}\\}{\tilde\\A_{\alpha}}{\qquad}{\tilde\\}(\bigcap{\lbrace{A_{\alpha}}\rbrace}_{\alpha\inS})={\bigcup_{\alpha\in S}\\}{\tilde\\A_{\alpha}}\]</span></p><p><span class="math display">\[\quadB-({\bigcup{\lbrace{A_{\alpha}}\rbrace}_{\alpha\inS}})={\bigcap_{\alpha\inS}\\}(B-A_{\alpha}){\qquad}B-({\bigcap{\lbrace{A_{\alpha}}\rbrace}_{\alpha\inS}})={\bigcup_{\alpha\in S}\\}(B-A_{\alpha})\]</span></p></li><li><p>幂集：<spanclass="math display">\[A{\subseteq}B{\Harr}P(A){\subseteq}P(B){\qquad}P(A-B){\subseteq}(P(A)-P(B)){\cup}{\lbrace\empty\rbrace}\]</span></p></li></ul><h3 id="有序对和笛卡尔积">1.3 有序对和笛卡尔积</h3><ul><li><p><strong>有序对</strong></p><p><span class="math display">\[\quad{\langle}a,b{\rangle}={\lbrace}{\lbrace}a{\rbrace},{\lbrace}a,b{\rbrace}{\rbrace}\]</span></p><p>其中 <span class="math display">\[a\]</span> 为第一元素，<spanclass="math display">\[b\]</span> 为第二元素。<spanclass="math display">\[{\langle}a,b{\rangle}\]</span> 也记作 <spanclass="math display">\[(a,b)\]</span></p><p>有定理：<spanclass="math display">\[{\langle}a,b{\rangle}={\langle}c,d{\rangle}{\Harr}(a=c){\and}(b=d)\]</span></p></li><li><p><strong>有序三元组</strong></p><p><span class="math display">\[\quad{\langle}a,b,c{\rangle}={\langle}{\langle}a,b{\rangle},c{\rangle}\]</span></p></li><li><p><strong>有序 n 元组</strong></p><p><span class="math display">\[\quad{\langle}a_1,a_2,{\ldots},a_n{\rangle}={\langle}{\langle}a_1,a_2,{\ldots},a_{n-1}{\rangle},a_n{\rangle}\]</span></p><p>有定理：<spanclass="math display">\[{\langle}a_1,a_2,{\ldots},a_n{\rangle}={\langle}b_1,b_2,{\ldots},b_n{\rangle}{\Harr}a_i=b_i,i=1,2,{\ldots},n\]</span></p></li><li><p><strong>笛卡尔积</strong></p><p>有集合 <span class="math display">\[A,B\]</span>，由 <spanclass="math display">\[A\]</span> 中的每个元素（做第一元素）与 <spanclass="math display">\[B\]</span>中的每个元素（做第二元素）组合，形成的所有有序对的集合称为笛卡尔积（卡式积），记为<span class="math display">\[A{\times}B\]</span></p><p>笛卡尔积的性质：</p><ul><li><p>非交换性：<spanclass="math display">\[(A{\not=}B{\and}A{\not=\empty\and}B{\not=\empty}){\Harr}(A{\times}B{\not=}B{\times}A)\]</span></p></li><li><p>非结合性：<spanclass="math display">\[(A{\not=\empty\and}B{\not=\empty\and}C{\not=\empty}){\Harr}((A{\times}B){\times}C{\not=}A{\times}(B{\times}C))\]</span></p></li><li><p>分配律：<span class="math display">\[A\times (B\cup C)=(A\timesB)\cup(A\times C)\quad\]</span> 等</p></li><li><p>其他：<spanclass="math display">\[A{\times}B={\empty}{\Harr}A={\empty\or}B={\empty}\qquadA\not=\empty\and A\times B\subseteq A\times C\Harr B\subseteqC\]</span></p><p><span class="math display">\[\quad A\subseteq C\and B\subseteq D\RarrA\times B\subseteq C\times D\]</span></p></li></ul></li><li><p><strong>n 维笛卡尔积</strong></p><p><span class="math display">\[\quad A_1\times A_2\times\ldots\timesA_n=\lbrace\langle x_1,x_2,\ldots,x_n\rangle|x_1\in A_1\and x_2\inA_2\and\ldots\and x_n\in A_n\rbrace\]</span></p><p><span class="math display">\[\quad A^n=A\times A\times A\ldots\timesA\]</span></p><p><span class="math display">\[\quad|A_i|=n_i,i=1,2,\ldots,n\Rarr|A_1\times A_2\times\ldots\timesA_n|=n_1\times n_2\times\ldots\times n_n\]</span></p><p>n 维卡式积的性质与二维卡式积相似</p></li></ul><h3 id="二元关系">1.4 二元关系</h3><ul><li><p><strong>n 元关系</strong></p><p>元素全是有序 n 元组的集合称为 n 元关系。</p><p>对于二元关系，有几种表示方法。设 <spanclass="math display">\[F\]</span> 是二元关系，有：</p><ul><li>中缀记法：<span class="math display">\[xFy\qquad\]</span>如 <spanclass="math display">\[2&lt;15\]</span></li><li>前缀记法：<span class="math display">\[F(x,y)\quadFxy\qquad\]</span>如 <spanclass="math display">\[&lt;(2,15)\]</span></li><li>后缀记法：<span class="math display">\[\langle x,y\rangle\in F\quadxyF\qquad\]</span>如 <span class="math display">\[\langle 2,15\rangle\in&lt;\]</span></li></ul></li><li><p>任何 <span class="math display">\[A\times B\]</span> 的子集就是<span class="math display">\[A\]</span> 到 <spanclass="math display">\[B\]</span> 的<strong>二元关系</strong>。</p><p><span class="math display">\[\quad R\,是\,A\,到\,B\,的二元关系\HarrR\subseteq A\times B\Harr R\in P(A\times B)\]</span></p><p>若 <span class="math display">\[|A|=m,|B|=n,|A\timesB|=mn\]</span>，故 <span class="math display">\[|P(A\timesB)|=2^{mn}\]</span>，即 <span class="math display">\[A\]</span> 到 <spanclass="math display">\[B\]</span> 的不同二元关系有 <spanclass="math display">\[2^{mn}\]</span> 个</p></li><li><p>任何 <span class="math display">\[A\times A\]</span> 的子集就是<span class="math display">\[A\]</span> 上的二元关系。</p><p><span class="math display">\[\quad R\,是\,A\,上的二元关系\HarrR\subseteq A\times A\Harr R\in P(A\times A)\]</span></p><p>若 <span class="math display">\[|A|=m,|A\times A|=m^2\]</span>，故<span class="math display">\[|P(A\times A)|=2^{m^2}\]</span>，即不同的<span class="math display">\[A\]</span> 上二元关系有 <spanclass="math display">\[2^{m^2}\]</span> 个</p></li><li><p><strong>一些特殊关系</strong></p><p>设 <span class="math display">\[A\]</span> 是集合，则可定义 <spanclass="math display">\[A\]</span> 上的：</p><ul><li>空关系：<span class="math display">\[\empty\]</span></li><li>恒等关系：<span class="math display">\[I_A=\lbrace\langlex,x\rangle|x\in A\rbrace\]</span></li><li>全域关系：<span class="math display">\[E_A=A\times A=\lbrace\langlex,y\rangle|x\in A\and y\in A\rbrace\]</span></li></ul><p>设 <span class="math display">\[A\subseteq Z\]</span>，则可定义 <spanclass="math display">\[A\]</span> 上的：</p><ul><li><p>整除关系：<span class="math display">\[D_A=\lbrace\langlex,y\rangle|x\in A\and y\in A\and x|y\rbrace\]</span></p></li><li><p>小于等于关系：<span class="math display">\[{LE}_A\]</span></p><p>小于关系：<span class="math display">\[L_A\]</span></p><p>大于等于关系：<span class="math display">\[{GE}_A\]</span></p><p>大于关系：<span class="math display">\[G_A\]</span></p></li></ul><p>设 <span class="math display">\[A\]</span> 是集合，则可定义 <spanclass="math display">\[P(A)\]</span> 上的：</p><ul><li>包含关系</li><li>真包含关系</li></ul></li><li><p><strong>定义域、值域、域</strong></p><p>对于任意集合 <span class="math display">\[R\]</span>，可以定义</p><p>其定义域：<span class="math display">\[\operatorname{dom}R=\lbracex|\exist y(xRy)\rbrace\]</span></p><p>其值域：<span class="math display">\[\operatorname{ran}R=\lbracey|\exist y(xRy)\rbrace\]</span></p><p>其域：<spanclass="math display">\[\operatorname{fld}R=\operatorname{dom}R\cup\operatorname{ran}R\]</span></p><p>如：集合 <span class="math display">\[R_1=\lbracea,b\rbrace,R_2=\lbrace a,b,\langle c,d\rangle,\langlee,f\rangle\rbrace\]</span>，当 <span class="math display">\[a,b\]</span>不是有序对时，<span class="math display">\[R_1,R_2\]</span>不是关系。</p><p><spanclass="math display">\[\quad\operatorname{dom}R_1=\empty\qquad\operatorname{ran}R_1=\empty\qquad\operatorname{fld}R_1=\empty\]</span></p><p><span class="math display">\[\quad\operatorname{dom}R_2=\lbracec,e\rbrace\qquad\operatorname{ran}R_2=\lbraced,f\rbrace\qquad\operatorname{fld}R_2=\lbracec,d,e,f\rbrace\]</span></p></li><li><p><strong>逆、合成</strong></p><p>对于任意集合 <span class="math display">\[F,G\]</span> 可以定义</p><p>逆：<span class="math display">\[F^{-1}=\lbrace\langlex,y\rangle|yFx\rbrace\]</span></p><p>合成（逆序合成、左合成）：<span class="math display">\[F\circG=\lbrace\langle x,y\rangle|\exist z(xGz\and zFy)\rbrace\]</span></p><p>有以下定理：</p><ul><li><span class="math display">\[(R_1\circ R_2)\circ R_3=R_1\circ(R_2\circ R_3)\]</span></li><li><span class="math display">\[(F\circ G)^{-1}=F^{-1}\circG^{-1}\]</span></li></ul></li><li><p><strong>限制、象</strong></p><p>对于任意集合 <span class="math display">\[F,A\]</span> 可以定义</p><p>限制：<span class="math display">\[F\restriction A=\lbrace\langlex,y\rangle|xFy\and x\in A\rbrace\]</span></p><p>象：<spanclass="math display">\[F[A]=\operatorname{ran}(F\restrictionA)\]</span></p></li><li><p><strong>单根</strong></p><p>对于集合 <span class="math display">\[F\]</span> 可以定义单根</p><p><span class="math display">\[\quad F\,是单根的\Harr\forally(y\in\operatorname{ran}F\rarr \exist!x(x\in\operatorname{dom}F\andxFy))\Harr(\forally\in\operatorname{ran}F)(\exist!x\in\operatorname{dom}F)(xFy)\]</span></p><p>上面的 <span class="math display">\[\exist!\]</span>表示：存在唯一的</p><p><span class="math display">\[\forall x(x\in A\rarr B(x))\]</span>缩写为 <span class="math display">\[(\forall x\in A)B(x)\]</span></p><p><span class="math display">\[\exist x(x\in A\and B(x))\]</span>缩写为 <span class="math display">\[(\exist x\inA)B(x)\]</span></p></li><li><p><strong>单值</strong></p><p>对于集合 <span class="math display">\[F\]</span> 可以定义单根</p><p><span class="math display">\[\quad F\,是单值的\Harr\forallx(x\in\operatorname{dom}F\rarr \exist!y(y\in\operatorname{ran}F\andxFy))\Harr(\forallx\in\operatorname{dom}F)(\exist!y\in\operatorname{ran}F)(xFy)\]</span></p><p>函数就可以被视作单值的二元关系</p></li></ul><h3 id="关系的表示">1.5 关系的表示</h3><p>关系的表示有三种方法</p><ul><li>集合</li><li>关系矩阵</li><li>关系图</li></ul><h4 id="关系矩阵">关系矩阵</h4><p><span class="math display">\[\quad A=\lbracea_1,a_2,\ldots,a_n\rbrace,\,B=\lbraceb_1,b_2,\ldots,b_m\rbrace,\,R=A\times B\]</span></p><p>则 <span class="math display">\[R\]</span> 的关系矩阵有</p><p><span class="math display">\[\quad M(R)=(r_{ij})_{n\times m}\qquadM(R)(i,j)=r_{ij}=\begin{cases}1,\quad a_iRb_j\\0,\quad否则\end{cases}\]</span></p><blockquote><p>如，<span class="math display">\[A=\lbrace a,b,c\rbrace,\,B=\lbraced,e,f\rbrace,\,R=\lbrace\langle a,d\rangle,\langle a,f\rangle,\langleb,f\rangle,\langle c,e\rangle\rbrace\]</span></p><p>则 <span class="math display">\[M(R)=\left[ \begin{matrix}1\quad0\quad 1\\0\quad 0\quad 1\\0\quad 1\quad0\end{matrix}\right]\]</span></p></blockquote><p>集合表达式与关系矩阵可以唯一相互确定</p><ul><li><p><strong>矩阵转置</strong>：<spanclass="math display">\[M(R^{-1})=(M(R))^{T}\]</span></p></li><li><p><strong>逻辑乘</strong>：<span class="math display">\[M(R_1\circR_2)=M(R_2)\bullet M(R_1)\]</span>，其中乘法对应逻辑的 <spanclass="math display">\[\and\]</span>，加法对应逻辑的 <spanclass="math display">\[\or\]</span></p><blockquote><p><strong><em>有关矩阵的乘法</em></strong></p><p>设 <span class="math display">\[A\]</span> 为 <spanclass="math display">\[m\times p\]</span> 的矩阵，<spanclass="math display">\[B\]</span> 为 <spanclass="math display">\[p\times n\]</span> 的矩阵，那么称 <spanclass="math display">\[m\times n\]</span> 的矩阵 <spanclass="math display">\[C\]</span> 为矩阵 <spanclass="math display">\[A\]</span> 与 <spanclass="math display">\[B\]</span> 的乘积，记作 <spanclass="math display">\[C=AB\]</span> 或 <spanclass="math display">\[C=A\times B\]</span></p><p>此时，矩阵 <span class="math display">\[C\]</span> 中第 <spanclass="math display">\[i\]</span> 行 <spanclass="math display">\[j\]</span> 列的元素有：<spanclass="math display">\[\quad c_{ij}={\sum_{k=1}^{p}\\}(a_{ik}\timesb_{kj})=a_{i1}\times b_{1j}+a_{i2}\times b_{2j}+\ldots+a_{ip}\timesb_{pj}\]</span></p><p>对于矩阵 <span class="math display">\[A,B\]</span> 仅当 <spanclass="math display">\[A\,的行数\,=\,B\,的列数\]</span>时才能进行矩阵相乘。</p><p>如存在矩阵 <spanclass="math display">\[A=\left[\begin{matrix}a_1\quad a_2\quada_3\end{matrix}\right],\,B=\left[\begin{matrix}b_1\\b_2\\b_3\end{matrix}\right]\]</span></p><p>则 <span class="math display">\[A\times B=\left[\begin{matrix}a_1\times b_1\quad a_1\times b_2\quad a_1\timesb_3\\a_2\times b_1\quad a_2\times b_2\quad a_2\times b_3\\a_3\timesb_1\quad a_3\times b_2\quad a_3\timesb_3\end{matrix}\right]\]</span></p></blockquote></li></ul><h4 id="关系图">关系图</h4><p><span class="math display">\[\quad A=\lbracea_1,a_2,\ldots,a_n\rbrace,\,B=\lbraceb_1,b_2,\ldots,b_m\rbrace,\,R=A\times B\]</span></p><p>则 <span class="math display">\[R\]</span> 的关系图 <spanclass="math display">\[G(R)\]</span>：</p><ul><li>以 <span class="math display">\[∘\]</span> 表示 <spanclass="math display">\[A,B\]</span> 中元素（称为顶点），以 <spanclass="math display">\[\rarr\]</span> 表示 <spanclass="math display">\[R\]</span> 中元素</li><li>若 <span class="math display">\[a_iRb_j\]</span> 则从顶点 <spanclass="math display">\[a_i\]</span> 向顶点 <spanclass="math display">\[b_j\]</span> 引有向边 <spanclass="math display">\[\langle a_i,b_j\rangle\]</span></li></ul><p>下面是 <span class="math display">\[A=\lbracea,b,c\rbrace,\,R=\lbrace{\langle a,a\rangle},{\langlea,b\rangle},{\langle b,a\rangle},{\langle b,c\rangle}\rbrace\]</span>的关系图 <span class="math display">\[G(R)\]</span>（我尽力了）</p><pre><code class=" mermaid">graph LRa((a)) --&gt; b((b)) --&gt; c((c))b --&gt; aa --&gt; a</code></pre><p>关系图、关系矩阵、关系表达式间都能相互确定。</p><p>对于 <span class="math display">\[G(A\timesB)\]</span>，关系图中的边都是由 <span class="math display">\[A\]</span>中元素指向 <span class="math display">\[B\]</span> 的</p><h3 id="关系的性质">1.6 关系的性质</h3><ul><li><p><strong>自反性</strong></p><p>对于关系 <span class="math display">\[R\subseteq A\timesA\]</span>，其自反性有：</p><p><span class="math display">\[\quad R\,是自反的\Harr\forall x(x\inA\rarr xRx)\Harr(\forall x\in A)xRx\]</span></p><p>相反地有</p><p><span class="math display">\[\quad R\,是非自反的\Harr\exist x(x\inA\and\neg xRx)\]</span></p><p>关于自反性有如下定理：</p><p><span class="math display">\[\quad\begin{align}&amp;R\,是自反的\\\Harr\,&amp;I_A\subseteqR\\\Harr\,&amp;R^{-1}\,是自反的\\\Harr\,&amp;M(R)\,主对角线上的元素全是\,1\\\Harr\,&amp;G(R)的每个顶点处都有环\end{align}\]</span></p></li><li><p><strong>反自反性</strong></p><p>对于关系 <span class="math display">\[R\subseteq A\timesA\]</span>，其反自反性有：</p><p><span class="math display">\[\quad R\,是反自反的\Harr\forall x(x\inA\rarr \neg xRx)\Harr(\forall x\in A)\neg xRx\]</span></p><p>相反地有</p><p><span class="math display">\[\quad R\,是非反自反的\Harr\exist x(x\inA\and xRx)\]</span></p><p>可以想见，对于 <span class="math display">\[R\subseteq A\timesA,\,Q=(A\times A)-R\]</span>，如果 <spanclass="math display">\[R\]</span> 是反自反的，那么 <spanclass="math display">\[Q\]</span> 就是自反的</p><p>关于反自反性有如下定理：</p><p><spanclass="math display">\[\quad\begin{align}&amp;R\,是反自反的\\\Harr\,&amp;I_A\capR=\emptyset\\\Harr\,&amp;R^{-1}\,是反自反的\\\Harr\,&amp;M(R)\,主对角线上的元素全是\,0\\\Harr\,&amp;G(R)的每个顶点处都无环\end{align}\]</span></p></li><li><p><strong>对称性</strong></p><p>对于关系 <span class="math display">\[R\subseteq A\timesA\]</span>，其对称性有：</p><p><spanclass="math display">\[\quad\begin{align}&amp;R\,是对称的\\\Harr\,&amp;\forallx\forall y(x\in A\and y\in A\and xRy\rarr yRx)\Harr(\forall x\inA)(\forall y\in A)[xRy\rarr yRx]\end{align}\]</span></p><p>相反地有</p><p><span class="math display">\[\quad R\,是非对称的\Harr\exist x\existy(x\in A\and y\in A\and xRy\and\neg yRx)\]</span></p><p>关于对称性有如下定理：</p><p><span class="math display">\[\quad\begin{align}&amp;R\,是对称的\\\Harr\,&amp;R^{-1}=R\\\Harr\,&amp;R^{-1}\,是对称的\\\Harr\,&amp;M(R)\,是对称的\\\Harr\,&amp;G(R)\,的所有边都有反向边\end{align}\]</span></p></li><li><p><strong>反对称性</strong></p><p>对于关系 <span class="math display">\[R\subseteq A\timesA\]</span>，其反对称性有：</p><p><span class="math display">\[\quad\begin{align}&amp;R\,是反对称的\\\Harr\,&amp;\forall x\forall y(x\inA\and y\in A\and xRy\and yRx\rarr A=B)\\\Harr\,&amp;(\forall x\inA)(\forall y\in A)[xRy\and yRx\rarr A=B]\end{align}\]</span></p><p>相反地有</p><p><span class="math display">\[\quad R\,是非反对称的\Harr\exist x\existy(x\in A\and y\in A\and xRy\and yRx \and A\not=B)\]</span></p><p>可见，反对称性可能与对称性同时存在</p><p>关于非反对称性有如下定理：</p><p><span class="math display">\[\quad\begin{align}&amp;R\,是反对称的\\\Harr\,&amp;R^{-1}\cap R\subseteqI_A\\\Harr\,&amp;R^{-1}\,是反对称的\\\Harr\,&amp;在\,M(R)\,中，\foralli\forall j(i\not=j\and r_{ij}=1\rarrr_{ji}=0)\\\Harr\,&amp;G(R)\,的所有不同点间有不多于\,1\,条边\end{align}\]</span></p></li><li><p><strong>传递性</strong></p><p>对于关系 <span class="math display">\[R\subseteq A\timesA\]</span>，其传递性有：</p><p><spanclass="math display">\[\quad\begin{align}&amp;R\,是传递的\\\Harr\,&amp;\forallx\forall y\forall z(x\in A\and y\in A\and z\in A\and xRy\and yRz\rarrxRz)\\\Harr\,&amp;(\forall x\in A)(\forall y\in A)(\forall z\inA)[xRy\and yRz\rarr xRz]\end{align}\]</span></p><p>相反地有</p><p><spanclass="math display">\[\begin{align}\quad&amp;R\,是非传递的\Harr\existx\exist y\exist z(x\in A\and y\in A\and z\in A\and xRy\and yRz\and \negxRz)\end{align}\]</span></p><p>关于传递性有如下定理：</p><p><spanclass="math display">\[\quad\begin{align}&amp;R\,是传递的\\\Harr\,&amp;R\circR\subseteq R\\\Harr\,&amp;R^{-1}\,是传递的\\\Harr\,&amp;\forall i\forallj,M(R\circ R)(i,j)\le M(R)(i,j)\\\Harr\,&amp;在\,G(R)\,中，\foralla_i\forall a_j\forall a_k，若有有向边\,\langlea_i,a_j\rangle\,和\,\langle a_j,a_k\rangle ，则必有有向边\,\langlea_i,a_k\rangle\end{align}\]</span></p></li></ul><h3 id="关系的幂运算和闭包">1.7 关系的幂运算和闭包</h3><ul><li><p><strong>关系的 n 次幂</strong></p><p>对于关系 <span class="math display">\[R\subseteq A\times A,n\inN\]</span>，有 <spanclass="math display">\[\begin{cases}R^0=I_A\\R^{n+1}=R^n\circR(n\ge0)\end{cases}\]</span></p><p>显然 <span class="math display">\[R^n\subseteq A\times A,n\inN\]</span></p><p>对于 <span class="math display">\[R\subseteq A\times A,\, m,n\inN\]</span>，有如下定理：</p><p><span class="math display">\[\quad R^m\circ R^n=R^{m+n}\qquad(R^m)^n=R^{mn}\]</span></p></li><li><p><strong>闭包</strong></p><p>包含给定元素，并具有指定性质的最小集合称为闭包</p><p>闭包是任何 <span class="math display">\[包含\,R\,的某种集合\]</span>的子集合，或者所有 <spanclass="math display">\[包含\,R\,的某种集合\]</span> 的交集。</p><ul><li><p>自反闭包：<span class="math display">\[r(R)\]</span>，包含 <spanclass="math display">\[R\]</span> 的具有自反性的闭包</p><p><span class="math display">\[\quad R\subseteq r(R)\qquadr(R)是自反的\qquad \forall S((R\subseteq S\and S 自反)\rarrr(r)\subseteq S)\]</span></p><p><span class="math display">\[\quad r(R)=R\cup I_A\]</span></p></li><li><p>对称闭包：<span class="math display">\[s(R)\]</span>，包含 <spanclass="math display">\[R\]</span> 的具有对称性的闭包</p><p><span class="math display">\[\quad R\subseteq s(R)\qquads(R)是对称的\qquad \forall S((R\subseteq S\and S 对称)\rarrs(r)\subseteq S)\]</span></p><p><span class="math display">\[\quad s(R)=R\cup R^{-1}\]</span></p><p>传递关系的对称闭包不一定是传递的</p></li><li><p>传递闭包：<span class="math display">\[t(R)\]</span>，包含 <spanclass="math display">\[R\]</span> 的具有传递性的闭包</p><p><span class="math display">\[\quad R\subseteq t(R)\qquadt(R)是传递的\qquad \forall S((R\subseteq S\and S 传递)\rarrt(r)\subseteq S)\]</span></p><p><span class="math display">\[\quad t(R)=R\cup R^2\cupR^3\cup\dots\]</span></p></li></ul><p>闭包有如下定理：</p><p><span class="math display">\[\quad R\,是自反的\Harr r(R)=R\quadR\,是对称的\Harr s(R)=R\quad R\,是传递的\Harr t(R)=R\]</span></p><p><span class="math display">\[\quad R_1\subseteq R_2\subseteq A\timesA\Rarr\quad r(R_1)\subseteq r(R_2)\quad s(R_1)\subseteq s(R_2)\quadt(R_1)\subseteq t(R_2)\]</span></p><p><span class="math display">\[\quad r(R_1\cup R_2)=r(R_1)\cupr(R_2);\quad s(R_1\cup R_2)=s(R_1)\cup s(R_2)\quad t(R_1\cupR_2){\color{Red}{\supseteq}}t(R_1)\cup t(R_2)\]</span></p></li></ul><h3 id="等价关系和划分">1.8 等价关系和划分</h3><ul><li><p><strong>等价关系</strong></p><p>有 <span class="math display">\[A\not=\empty\quad R\subseteq A\timesA\]</span>，若 <span class="math display">\[R\]</span>是自反、对称、传递的，则称 <span class="math display">\[R\]</span>是等价关系</p><p>由于 <span class="math display">\[st(R)\subseteq ts(R)\]</span>，对<span class="math display">\[R\]</span> 依次求闭包只有 <spanclass="math display">\[tsr(R)=trs(R)=rts(R)\]</span> 是等价闭包</p></li><li><p><strong>等价类</strong></p><p>设 <span class="math display">\[R\]</span> 是 <spanclass="math display">\[A\not=\empty\]</span> 上的等价关系，<spanclass="math display">\[x\in A\]</span>，则 <spanclass="math display">\[x\]</span> 关于 <spanclass="math display">\[R\]</span> 的等价类是 <spanclass="math display">\[[x]_R=\lbrace y|y\in A\andxRy\rbrace\]</span></p><p>简称 <span class="math display">\[x\]</span> 的等价类，记为 <spanclass="math display">\[[x]\]</span></p><p>设 <span class="math display">\[R\]</span> 是 <spanclass="math display">\[A\not=\empty\]</span> 上的等价关系，<spanclass="math display">\[\forall x,y\in A\]</span>，有以下定理</p><p><span class="math display">\[\quad [x]_R\not=\empty\]</span></p><p><span class="math display">\[\quad xRy\Rarr[x]_R=[y]_R\]</span></p><p><span class="math display">\[\quad\negxRy\Rarr[x]_R\cap[y]_R=\empty\]</span></p><p><span class="math display">\[\quad\bigcup\lbrace[x]_R|x\in A\rbrace=A\]</span></p></li><li><p><strong>商集</strong></p><p>设 <span class="math display">\[R\]</span> 是 <spanclass="math display">\[A\not=\empty\]</span> 上的等价关系，<spanclass="math display">\[A\]</span> 关于 <spanclass="math display">\[R\]</span> 的商集是 <spanclass="math display">\[A/R=\lbrace[x]_R|x\in A\rbrace\]</span></p><p>若 <span class="math display">\[A=\lbracea_1,a_2,\ldots,a_n\rbrace\]</span> 上有等价关系 <spanclass="math display">\[I_A,E_A,R_{ij}=I_A\cup\lbrace\langlea_i,a_j\rangle,\langle a_j,a_i\rangle\rbrace,a_i,a_j\inA,i\not=j\]</span></p><p><span class="math display">\[\quad A/I_A=\lbrace\lbracea_1\rbrace,\lbrace a_2\rbrace,\ldots,\lbracea_n\rbrace\rbrace\]</span></p><p><span class="math display">\[\quad A/E_A=\lbrace\lbracea_1,a_2,\ldots,a_n\rbrace\rbrace\]</span></p><p><span class="math display">\[\quad A/R_{ij}=A/I_A\cup\lbrace\lbracea_i,a_j\rbrace\rbrace-\lbrace\lbrace a_i\rbrace,\lbracea_j\rbrace\rbrace\]</span></p></li><li><p><strong>划分</strong></p><p><span class="math display">\[A\not=\empty\]</span> 的一个划分是 <spanclass="math display">\[{\mathcal A}\subseteq P(A)\]</span> 满足</p><ol type="1"><li><span class="math display">\[\empty\not\in\mathcal A\]</span></li><li><span class="math display">\[\forall x,y(x,y\in\mathcal A\and x\not=y\Rarr x\cap y=\empty)\]</span></li><li><span class="math display">\[\bigcup\mathcal A=A\]</span></li></ol><p><span class="math display">\[\mathcal A\]</span>中的元素称为划分块</p><p>若 <span class="math display">\[A\not=\empty\]</span>则有以下定理</p><p><span class="math display">\[\quad R\,是\,A\,上的等价关系\RarrA/R\,是\,A\,的划分\]</span></p><p><span class="math display">\[\quad\mathcal A\,是\,A\,的划分\Rarr同块关系\,R_{\mathcal A}\,是\,A上的等价关系\quad xR_{\mathcalA}y\Harr\exist z(z\in\mathcal A\and x\in z\and y\in z)\]</span>，此时<span class="math display">\[R_{\mathcal A}\]</span> 称为 <spanclass="math display">\[\mathcal A\]</span> 所定义的等价关系</p></li><li><p><strong>Stirling 子集数</strong></p><p>把 n 个编号的球放到 k 个相同的箱子里，不同放法的总数 <spanclass="math display">\[\begin{Bmatrix}n\\k\end{Bmatrix}\]</span> 称为Stirling 子集数</p><p>Srirling 子集数也是将 n 元集分成 k 个非空子集的分法总数</p><p>递推公式有 <spanclass="math display">\[\begin{Bmatrix}n\\k\end{Bmatrix}=\begin{cases}\begin{align}&amp;0\quad&amp;k=0\\&amp;1\quad &amp;n=k\or k=1\\&amp;2^{n-1}-1\quad&amp;k=2\\&amp;C_n^2\quad&amp;n=k+1\\&amp;k\begin{Bmatrix}n-1\\k\end{Bmatrix}+\begin{Bmatrix}n-1\\k-1\end{Bmatrix}\quad&amp;k &gt; 1\end{align}\end{cases}\]</span></p><p>k&gt;1 时，可以让 n-1 个元素分成 k 个子集后，加入第 n 个元素。或者让n-1 个元素分成 k 个子集后，让第 n 个元素自成一个子集。</p></li><li><p><strong>加细</strong></p><p>有 <span class="math display">\[\mathcal{A,B}\]</span> 是 <spanclass="math display">\[A\]</span> 的划分。若 <spanclass="math display">\[\mathcal A\]</span> 的划分块都含于 <spanclass="math display">\[\mathcal B\]</span> 的某个划分块中，则称 <spanclass="math display">\[\mathcal A\]</span> 是 <spanclass="math display">\[\mathcal B\]</span> 的加细</p></li></ul><h3 id="序关系">1.9 序关系</h3><ul><li><p><strong>偏序关系、偏序集</strong></p><p>设 <span class="math display">\[A\not=\empty,\,R\subseteq A\timesA\]</span>，若 <span class="math display">\[R\]</span> 是<strong>自反、反对称、传递的</strong>，则称 <spanclass="math display">\[R\]</span> 是 <spanclass="math display">\[A\]</span> 上的偏序关系。用 <spanclass="math display">\[\preccurlyeq\]</span> 表示偏序关系，读作“小于等于”</p><p><span class="math display">\[\quad\langle x,y\rangle\in R\HarrxRy\Harr x\preccurlyeq y\]</span></p><p>设 <span class="math display">\[\preccurlyeq\]</span> 是 <spanclass="math display">\[A\]</span> 上的偏序关系，则称 <spanclass="math display">\[\langle A,\preccurlyeq\rangle\]</span>为偏序集</p></li><li><p><strong>可比、严格小于、覆盖</strong></p><p>对于 <span class="math display">\[\langleA,\preccurlyeq\rangle,\,x,y\in A\]</span>，存在 <spanclass="math display">\[x\preccurlyeq y\or y\preccurlyeq x\]</span>，则称<span class="math display">\[x\]</span> 和 <spanclass="math display">\[y\]</span> 可比</p><p>若 <span class="math display">\[x\not= y\]</span>，则称 <spanclass="math display">\[x\]</span> 严格小于 <spanclass="math display">\[y\]</span>，即 <spanclass="math display">\[x\preccurlyeq y\and x\not=y\Harr x\precy\]</span></p><p>若不存在 <span class="math display">\[z\]</span> 使 <spanclass="math display">\[x\prec z\]</span> 且 <spanclass="math display">\[z\prec y\]</span>，则称 <spanclass="math display">\[y\]</span> 覆盖 <spanclass="math display">\[x\]</span>，即 <spanclass="math display">\[x\prec y\and\neg\exist z(z\in A\and x\prec z\precy)\]</span></p></li><li><p><strong>哈斯图</strong></p><p>对于 <span class="math display">\[\langleA,\preccurlyeq\rangle,\,x,y\in A\]</span></p><p>用顶点表示 <span class="math display">\[A\]</span> 中元素，当且仅当<span class="math display">\[y\]</span> 覆盖 <spanclass="math display">\[x\]</span> 时，<spanclass="math display">\[y\]</span> 在 <spanclass="math display">\[x\]</span> 上方，在 <spanclass="math display">\[x,y\]</span> 间画无向边，即形成哈斯图</p></li><li><p><strong>全序关系（线序关系）</strong></p><p>对于偏序集 <span class="math display">\[\langleA,\preccurlyeq\rangle\]</span>，若其中任意元素 <spanclass="math display">\[x,y\]</span> 都可比，则称 <spanclass="math display">\[\preccurlyeq\]</span> 是 <spanclass="math display">\[A\]</span> 上从全序关系，称 <spanclass="math display">\[\langle A,\preccurlyeq\rangle\]</span>为全序集</p><p><span class="math display">\[\quad \langleA,\preccurlyeq\rangle\,是全序集\Harr 哈斯图是一条直线\]</span></p></li><li><p><strong>拟序关系</strong></p><p>有 <span class="math display">\[A\not=\empty,\,R\subseteq A\timesA\]</span>，若 <span class="math display">\[R\]</span> 是<strong>反自反、传递的（反自反性与传递性蕴含反对称性）</strong>，则称<span class="math display">\[R\]</span> 为 <spanclass="math display">\[A\]</span> 上的拟序关系。用 <spanclass="math display">\[\prec\]</span> 表示拟序关系，称 <spanclass="math display">\[\langle A,\prec\rangle\]</span> 为拟序集</p><p>若 <span class="math display">\[\preccurlyeq\]</span> 是 <spanclass="math display">\[A\]</span> 上的偏序关系，<spanclass="math display">\[\prec\]</span> 是 <spanclass="math display">\[A\]</span> 上的拟序关系，则</p><ul><li><span class="math display">\[\prec\]</span> 是反对称的</li><li><span class="math display">\[\preccurlyeq-I_A\]</span> 是 <spanclass="math display">\[A\]</span> 上的拟序关系</li><li><span class="math display">\[\prec\cup I_A\]</span> 是 <spanclass="math display">\[A\]</span> 上的偏序关系</li></ul><p>若 <span class="math display">\[\prec\]</span> 是 <spanclass="math display">\[A\]</span> 上的拟序关系，则</p><ul><li><span class="math display">\[x\prec y,\,x=y,\,y\prec x\]</span>中最多只有一个式子成立</li><li><span class="math display">\[(x\prec y\or x=y)\and(y\prec x\orx=y)\Rarr x=y\]</span></li></ul></li><li><p><strong>三歧性、拟线序</strong></p><p>有 <span class="math display">\[A\not=\empty\]</span>，<spanclass="math display">\[\prec\]</span> 是 <spanclass="math display">\[A\]</span> 上的拟序关系，若 <spanclass="math display">\[x\prec y,\,x=y,\,y\prec x\]</span> 中<strong>有且仅有</strong> 一式成立，则称 <spanclass="math display">\[\prec\]</span> 具有三歧性。同时称 <spanclass="math display">\[\prec\]</span> 为 <spanclass="math display">\[A\]</span> 上的拟线序关系，称 <spanclass="math display">\[\langle A,\prec\rangle\]</span>为拟线序集</p></li><li><p><strong>最大（小）元、极大（小）元、上（下）界</strong></p><p>对于偏序集 <span class="math display">\[\langleA,\preccurlyeq\rangle,B\subseteq A,y\in B\]</span></p><p><span class="math display">\[\quad y\,是\,B\,的最大元\Harr\forallx(x\in B\rarr x\preccurlyeq y)\]</span></p><p><span class="math display">\[\quad y\,是\,B\,的最小元\Harr\forallx(x\in B\rarr y\preccurlyeq x)\]</span></p><p><span class="math display">\[\quad y\,是\,B\,的极小元\Harr\forallx(x\in B\and y\preccurlyeq x\rarr x= y)\]</span></p><p><span class="math display">\[\quad y\,是\,B\,的极大元\Harr\forallx(x\in B\and x\preccurlyeq y\rarr x= y)\]</span></p><p>对于 <span class="math display">\[z\in A\]</span></p><p><span class="math display">\[\quad z\,是\,A\,的上界\Harr\forallx(x\in B\rarr x\preccurlyeq z)\]</span></p><p><span class="math display">\[\quad z\,是\,A\,的下界\Harr\forallx(x\in B\rarr z\preccurlyeq x)\]</span></p></li><li><p><strong>良序</strong></p><p>任何非空子集都有最小元的偏序关系</p><p>公理：任何集合都能被赋予一个良序</p><p>良序中的序数分为三类</p><ul><li><span class="math display">\[0\]</span></li><li>后继序数（有头有尾）：<spanclass="math display">\[1,2,\dots,\omega+1,\omega+2,\dots\]</span></li><li>极限序数（有头无尾）：<spanclass="math display">\[\omega,2\omega,\omega^2,\omega^\omega,\dots\]</span></li></ul></li><li><p><strong>链、反链</strong></p><p>设 <span class="math display">\[\langleA,\preccurlyeq\rangle\]</span> 为偏序集，<spanclass="math display">\[B\subseteq A\]</span></p><p><span class="math display">\[\quad B\,是\,A\,中的链\Harr\forallx\forall y(x\in B\and y\in B\rarr x\,与\,y\,可比)\]</span></p><p><span class="math display">\[\quad B\,是\,A\,中的反链\Harr\forallx\forall y(x\in B\and y\in B\and x\not= y\rarrx\,与\,y\,不可比)\]</span></p><p><span class="math display">\[\quad|B|\]</span> 称为（反）链的长度</p><p>设 <span class="math display">\[\langleA,\preccurlyeq\rangle\]</span> 为偏序集，<spanclass="math display">\[A\]</span> 中最长链长度为 <spanclass="math display">\[n\]</span>，则</p><ul><li><span class="math display">\[A\]</span> 中存在极大元</li><li><span class="math display">\[A\]</span> 存在 <spanclass="math display">\[n\]</span>个划分块的划分，使每个划分块都是反链</li><li>若 <span class="math display">\[|A|=mn+1\]</span>，则 <spanclass="math display">\[A\]</span> 中要么有长度为 <spanclass="math display">\[m+1\]</span> 的反链，要么有长度为 <spanclass="math display">\[n+1\]</span> 的链</li></ul></li></ul><h3 id="函数">1.10 函数</h3><p>函数：也称映射。单值的二元关系。<span class="math display">\[\forallx\in\operatorname{dom}F,\,\forall y,z\in\operatorname{ran}F,\,xFy\andxFz\rarr y=z\]</span></p><p>函数的记号：<span class="math display">\[F(x)=y\Harr \langlex,y\rangle\in F\Harr xFy\]</span></p><ul><li><p><strong>偏函数</strong></p><p>设 <span class="math display">\[F\]</span> 是函数，<spanclass="math display">\[\operatorname{dom}F\subseteqA\and\operatorname{ran}F\subseteq B\]</span> 则称之为 <spanclass="math display">\[A\]</span> 到 <spanclass="math display">\[B\]</span> 的偏函数。记作 <spanclass="math display">\[F:A\rarr B\]</span></p><p>其中 <span class="math display">\[A\]</span> 称为 <spanclass="math display">\[F\]</span> 的前域。</p><p><span class="math display">\[A\]</span> 到 <spanclass="math display">\[B\]</span> 的全体偏函数记为 <spanclass="math display">\[A\rarr B=\lbrace F|F:A\rarr B\rbrace\]</span></p><p>显然 <span class="math display">\[A\rarr B\subseteq P(A\timesB)\]</span></p></li><li><p><strong>真偏函数</strong></p><p><span class="math display">\[{dom\,}F\subset A\]</span>，记作 <spanclass="math display">\[F:A\shortparallel\!\!\!\rarr B\]</span>。<spanclass="math display">\[A\]</span> 到 <spanclass="math display">\[B\]</span> 的全体真偏函数记为 <spanclass="math display">\[A\shortparallel\!\!\!\rarr B=\lbraceF|F:A\shortparallel\!\!\!\rarr B\rbrace\]</span></p><p>所以，就有 <span class="math display">\[A\shortmid\!\!\!\rarrB=A\rarr B\cup A\shortparallel\!\!\!\rarr B\qquadF:A\shortmid\!\!\!\rarr B\Rarr F:\operatorname{dom}F\rarrB\]</span></p></li><li><p><strong>全函数</strong></p><p><span class="math display">\[\operatorname{dom}F=A\]</span>，记作<span class="math display">\[F:A\shortmid\!\!\!\rarr B\]</span>。<spanclass="math display">\[A\]</span> 到 <spanclass="math display">\[B\]</span> 的全体全函数记为 <spanclass="math display">\[B^A=A\rarr B=\lbrace F|F:A\shortmid\!\!\!\rarrB\rbrace\]</span></p><p><span class="math display">\[A,B\]</span> 中存在空集 <spanclass="math display">\[\empty\]</span> 时，<spanclass="math display">\[B^A\]</span> 分为以下几种情况</p><ul><li><span class="math display">\[A,B\]</span> 是空集：<spanclass="math display">\[B^A=\empty^{\empty}=\lbrace\empty\rbrace\]</span></li><li>仅 <span class="math display">\[A\]</span> 是空集：<spanclass="math display">\[B^A=B^{\empty}=\lbrace\empty\rbrace\]</span></li><li>仅 <span class="math display">\[B\]</span> 是空集：<spanclass="math display">\[B^A=\empty^{A}=\empty\]</span></li></ul><p>其余时候，<spanclass="math display">\[|B^A|=|B|^{|A|}\]</span></p></li><li><p><strong>全函数的性质</strong></p><ul><li>单射：<span class="math display">\[F\]</span> 是单根的。</li><li>满射：<spanclass="math display">\[\operatorname{ran}F=B\]</span></li><li>双射：<span class="math display">\[F\]</span>即是单射也是满射。</li></ul><p>若有 <span class="math display">\[F:A\rarrB,\,|A|=n,\,|B|=m\]</span>，则</p><ul><li><span class="math display">\[n&lt;m\]</span> 时，<spanclass="math display">\[A\rarr B\]</span> 中无满射、双射。单射数量是<span class="math display">\[m(m-1)\ldots(m-n+1)\]</span></li><li><span class="math display">\[n&gt;m\]</span> 时，<spanclass="math display">\[A\rarr B\]</span> 中无单射、双射。满射数量是<spanclass="math display">\[m!\begin{Bmatrix}n\\m\end{Bmatrix}\]</span></li><li><span class="math display">\[n=m\]</span> 时，<spanclass="math display">\[A\rarr B\]</span> 中双射个数为 <spanclass="math display">\[n!\]</span></li></ul></li><li><p><strong>象、原象</strong></p><p>给定映射 <span class="math display">\[f:A\rarr B,\,A&#39;\subseteqA,\,B&#39;\subseteq B\]</span></p><p>则 <span class="math display">\[A&#39;\]</span> 的像 <spanclass="math display">\[f(A&#39;)=\lbrace y|x\inA&#39;,xfy\rbrace\]</span></p><p><span class="math display">\[B&#39;\]</span> 的原像 <spanclass="math display">\[f^{-1}(B&#39;)=\lbrace x|y\in B&#39;,xfy\rbrace\]</span></p><p>有 <span class="math display">\[f(A)=\operatorname{ran}f\quadf^{-1}(B)=\operatorname{dom}f=A\]</span></p></li><li><p><strong>特殊函数</strong></p><ul><li><p>常数函数：<span class="math display">\[f:A\rarr B,\,\exist b\inB,\,\forall x\in A,\,f(x)=b\]</span></p></li><li><p>恒等函数：<span class="math display">\[I_A:A\rarrA,\,I_A(x)=x\]</span></p></li><li><p>特征函数：<spanclass="math display">\[\chi_A:E\rarr\lbrace0,1\rbrace,\,\chi_A(x)=1\Harrx\in A\]</span></p><p>此时当 <span class="math display">\[\empty\subset A\subset E\]</span>时，<span class="math display">\[\chi_A\]</span> 是满射</p></li></ul></li><li><p><strong>单调函数</strong></p><p>设 <span class="math display">\[f:A\rarr B\]</span> 且 <spanclass="math display">\[\lang A,\le_A\rang,\lang B,\le_B\rang\]</span>是偏序集</p><p>单调增：<span class="math display">\[\forall x,y\in A,\,x\le_Ay\Rarrf(x)\le_Bf(y)\]</span></p><p>单调减：<span class="math display">\[\forall x,y\in A,\,x\le_Ay\Rarrf(y)\le_Bf(x)\]</span></p><p>严格单调：将上面的 <span class="math display">\[\le\]</span> 换为<span class="math display">\[&lt;\]</span>。此时是单射</p></li><li><p><strong>自然映射</strong></p><p>设 <span class="math display">\[R\]</span> 是 <spanclass="math display">\[A\]</span> 上的等价关系</p><p>自然映射（典型映射）：<span class="math display">\[f:A\rarrA/R,\,f(x)=[x]_R\]</span></p><p>当 <span class="math display">\[R=I_A\]</span> 时，<spanclass="math display">\[f\]</span> 是单射</p><p>又有 <span class="math display">\[f:A\rarr B,\,g:B\rarr C\]</span> 则<span class="math display">\[f\circ g:A\rarr C,\,F\circg(x)=f(g(x))\]</span></p><p>若 <span class="math display">\[f:A\rarr B\]</span> 是双射，则 <spanclass="math display">\[f^{-1}=B\rarr A\]</span> 也是双射。此时称 <spanclass="math display">\[f^{-1}\]</span> 为 <spanclass="math display">\[f\]</span> 的 <strong>反函数</strong></p></li><li><p><strong>单边逆</strong></p><p>若 <span class="math display">\[f:A\rarr B,\,g:B\rarr A\]</span></p><p>左逆：<span class="math display">\[g\,是\,f\,的左逆\Harr g\circf=I_A\]</span></p><p>右逆：<span class="math display">\[g\,是\,f\,的右逆\Harr f\circg=I_B\]</span></p><p><span class="math display">\[\quad f\,存在左逆\Harrf\,是单射\]</span></p><p><span class="math display">\[\quad f\,存在右逆\Harrf\,是满射\]</span></p><p><span class="math display">\[\quad f\,存在左逆、右逆\Harrf\,是双射\Harr f\,的左逆、右逆相等\]</span></p></li></ul><h3 id="自然数">1.11 自然数</h3><ul><li><p><strong>封闭</strong></p><p>有函数 <span class="math display">\[F\]</span>，<spanclass="math display">\[A\subseteq\operatorname{dom}F\]</span></p><p>则有：<span class="math display">\[A\,在函数\,F\,下封闭\HarrF(A)\subseteq A\Harr F:A\rarr A\HarrF\,是\,A\,上一元运算\]</span></p></li><li><p><strong>皮亚诺公理</strong></p><p>皮亚诺公理定义了自然数的集合。</p><p>对于三元组 <span class="math display">\[\lang M,F,e\rang,\,F:M\rarrM\]</span></p><ul><li><p><span class="math display">\[e\in M\]</span></p></li><li><p><span class="math display">\[M\]</span> 在 <spanclass="math display">\[F\]</span> 下封闭</p></li><li><p><span class="math display">\[e\notin\operatorname{ran}F\]</span></p></li><li><p><span class="math display">\[F\]</span> 是单射</p></li><li><p><span class="math display">\[A\subseteq M\and e\in A\andA\,在\,F\,下封闭\Rarr A=M\]</span></p><p>（极小性公理/数学归纳法原理。即 <spanclass="math display">\[M\]</span> 是满足条件的最小集合）</p></li></ul></li><li><p><strong>后继</strong></p><p>对于集合 <span class="math display">\[A\]</span>，其后继 <spanclass="math display">\[A^+=A\cup\lbrace A\rbrace\]</span></p><p><span class="math display">\[\quad A\subseteq A^+\and A\inA^+\]</span></p></li><li><p><strong>归纳集</strong></p><p><spanclass="math display">\[\quad\begin{align}&amp;A\,是归纳集\\\Harr\,&amp;\empty\inA\and\forall x(x\in A\rarr x^+\inA)\\\Harr\,&amp;A\,含有\,\empty\,且对后继封闭\end{align}\]</span></p></li><li><p><strong>后继函数</strong></p><p><span class="math display">\[\quad\sigma:N\rarr N,\,\forall n\inN,\,\sigma(n)=n^+\]</span></p></li><li><p><strong>传递集</strong></p><p>对于集合 <span class="math display">\[A\]</span>，<spanclass="math display">\[\forall x\in a\in A\Rarr x\in A\]</span>，则称<span class="math display">\[A\]</span> 为传递集</p><p>$<span class="math display">\[$\quad\begin{align}&amp;A\,是传递集\\\Harr\,&amp;{\bigcup\\}A\subseteq A\\\Harr\,&amp;\forall a(a\in A\rarr a\subseteq A)\\\Harr\,&amp;A\subseteq P(A)\\\Harr\,&amp;P(A)\,是传递集\end{align}\]</span>$$</p><p>另外，<spanclass="math display">\[A\,是传递集\Rarr{\bigcup\\}(A^+)=A\]</span></p></li></ul><h4 id="集合论中的数学归纳法">集合论中的数学归纳法</h4><p>目标：证明 <span class="math display">\[\forall n\inN\]</span>，<span class="math display">\[P(n)\]</span> 为真</p><ol type="1"><li><p>构造 <span class="math display">\[S=\lbrace n|n\in N\andP(n)\rbrace\]</span></p></li><li><p>证明 <span class="math display">\[S\]</span> 是归纳集</p><p>$<span class="math display">\[$\quad\begin{align}&amp;\empty\inS\\&amp;\forall n(n\in s\rarr n^+\inS)\\∴\quad&amp;S=N\end{align}\]</span>$$</p></li></ol><h4 id="使用集合来构造-peano-系统">使用集合来构造 Peano 系统</h4><p><strong>自然数</strong>：属于每个归纳集的集合。</p><p><strong>自然数集（<spanclass="math display">\[N\]</span>）</strong>：包含于每个归纳集的集合。</p><p>$<span class="math display">\[$\quad\begin{align}&amp;0=\empty\\&amp;1=\empty^+=\lbrace\empty\rbrace=\lbrace 0\rbrace\\&amp;2=\empty^{++}=\lbrace\empty,\lbrace\empty\rbrace\rbrace=\lbrace0,1\rbrace\\&amp;\dots\\&amp;n=(n-1)^+=\lbrace0,1,2,\ldots,n-1\rbrace\end{align}\]</span>$$</p><p>如此一来，让自然数作为集合，可以进行运算</p><p>$<span class="math display">\[$\quad\begin{align}&amp;2\cap3=\lbrace0,1\rbrace\cap\lbrace0,1,2\rbrace=\lbrace0,1\rbrace=2=\operatorname{min}(2,3)\\&amp;2\cup3=\lbrace0,1\rbrace\cup\lbrace0,1,2\rbrace=\lbrace0,1,2\rbrace=3=\operatorname{max}(2,3)\\&amp;3-2=\lbrace0,1,2\rbrace-\lbrace0,1\rbrace=\lbrace2\rbrace\\&amp;2-3=\lbrace0,1\rbrace-\lbrace0,1,2\rbrace=\empty\\&amp;\bigcupn=\bigcup\lbrace0,1,\dots,n-1\rbrace=n-1=\operatorname{max}(0,1,\dots,n-1)\\&amp;\bigcapn=\bigcap\lbrace0,1,\dots,n-1\rbrace=0=\operatorname{min}(0,1,\dots,n-1)\\&amp;0\in1\in2\in3\in\dots\qquad0\subseteq1\subseteq2\subseteq3\subseteq\dots\end{align}\]</span>$$</p><p>于是有以下定理：</p><ul><li><p>自然数集是归纳集，且是最小的归纳集</p><p>自然数是传递集，自然数集也是传递集</p></li><li><p><span class="math display">\[\lang N,\sigma,0\rang\]</span> 是Peano 系统</p></li><li><p><span class="math display">\[\forall m,n\in N,m^+\in n^+\Harrm\in n\]</span></p></li><li><p>任何自然数都不是自己的元素。</p></li><li><p><span class="math display">\[\empty\]</span> 属于 <spanclass="math display">\[0\]</span> 以外的任意自然数</p></li><li><p>任何自然数的元素都是其子集</p><p><span class="math display">\[\quad n\in N\Rarr\forall x(x\in n\rarrx\subseteq n)\]</span></p></li><li><p>三歧性</p><p>对于 <span class="math display">\[\forall m,n\inN\]</span>，以下三式恰有一式成立</p><p><span class="math display">\[\quad m\in n,\quad m=n,\quad n\inm\]</span></p></li><li><p><span class="math display">\[N\]</span> 上的递归定理</p><p>设 <span class="math display">\[A\]</span> 为集合，<spanclass="math display">\[a\in A,\,F:A\rarr A\]</span></p><p>则存在唯一的函数 <span class="math display">\[h:N\rarrA\]</span>，使得 <span class="math display">\[h(0)=a\]</span>，且 <spanclass="math display">\[\forall n\in N,\,h(n^+)=F((h(n)))\]</span></p><p>如此一来，就可以递归地定义函数。如</p><p><span class="math display">\[\quad\begin{align}&amp;a\in A,\,F:A\rarrA\\&amp;\begin{cases}h(0)=a\\h(n+1)=F(h(n)),\,\forall n\inN\end{cases}\end{align}\]</span></p></li></ul><p>定义自然数集上的二元运算：</p><ul><li><p><strong>加法</strong></p><p><span class="math display">\[\quad +:N\times N\rarr N\]</span></p><p><span class="math display">\[\quad+(\lang2,3\rang)=5,\quad2+3=5\]</span></p><p>将 <span class="math display">\[m\]</span>看成固定值，就能定义一元函数 <spanclass="math display">\[+m\]</span>。再将 <spanclass="math display">\[m\]</span> 扩展到每个自然数，就有了所有的 <spanclass="math display">\[+m\]</span></p><p><span class="math display">\[\quad\begin{align}&amp;m\inN,\,A_m:N\rarrN\\&amp;\begin{cases}A_m(0)=m\\A_m(n^+)=(A_m(n))^+\end{cases}\end{align}\]</span></p><p>加法有以下性质</p><ul><li><span class="math display">\[m+0=m\]</span></li><li><span class="math display">\[m+n^+=(m+n)^+\qquadm^++n=(m+n)^+\]</span></li><li><span class="math display">\[m+n=n+m\]</span></li></ul></li><li><p><strong>乘法</strong></p><p><span class="math display">\[\quad\bullet:N\times N\rarrN\]</span></p><p><span class="math display">\[\quad\bullet(\lang2,3\rang)=6,\quad2\bullet3=6\]</span></p><p>可以定义 <span class="math display">\[\bullet m \]</span> 函数</p><p><span class="math display">\[\quad\begin{align}&amp;m\inN,\,M_m:N\rarrN\\&amp;\begin{cases}M_m(0)=0\\M_m(n^+)=M_m(n)+m\end{cases}\end{align}\]</span></p><p>乘法有如下性质</p><ul><li><span class="math display">\[1\bullet n=n\bullet 1=n\]</span></li><li><span class="math display">\[n\bullet m=m\bullet n\]</span></li><li><span class="math display">\[(m\bullet n)\bullet k=m\bullet(n\bullet k)\]</span></li><li><span class="math display">\[k\not=0\and m\bullet k=n\bullet k\Rarrm=n\]</span></li><li><span class="math display">\[m\bullet (n+k)=(m\bullet n)+(m\bulletk)\]</span></li></ul></li></ul><p>自然数有两个基本性质</p><ul><li><p><strong>匹配</strong></p><p>在自然数集合与另一集合间建立双射，可以统计集合的大小</p><p><span class="math display">\[\quad\begin{align}&amp;\lbracea\rbrace\rarr\lbrace 0\rbrace=1\\&amp;\lbrace a,b\rbrace\rarr\lbrace0,1\rbrace=2\\&amp;\lbrace a,b,c\rbrace\rarr\lbrace0,1,2\rbrace=3\\&amp;\ldots\end{align}\]</span></p></li><li><p><strong>计数</strong></p><p>任意自然数集合都有最小元素，任意自然数间可以比较大小</p><p><spanclass="math display">\[\quad\begin{align}&amp;0\rarr1\rarr2\rarr3\rarr\ldots\\&amp;a\rarrb\\&amp;a\rarr b\rarr c\\&amp;\ldots\end{align}\]</span></p></li></ul><h3 id="等势有穷集无穷集">1.12 等势、有穷集、无穷集</h3><ul><li><p><strong>等势</strong></p><p><span class="math display">\[\quad A\,与\,B\,等势\Harr\exist双射\,f:A\rarr B\]</span></p><p>记作 <span class="math display">\[A\approx B\]</span></p><p>则有：</p><p><span class="math display">\[\quad\begin{align}&amp;Z\approx N\qquadN\times N\approx N\qquad N\approx Q\qquad (0,1)\approxR\qquad[0,1]\approx(0,1)\\&amp;P(A)\approx 2^A=A\rarr 2\\&amp;A\approxA\qquad A\approx B\Rarr B\approx A\qquad A\approx B\and B\approx C\RarrA\approx C\\&amp;N\not\approx R\qquad A\not\approxP(A)\end{align}\]</span></p></li><li><p><strong>有穷集</strong></p><p>与某一自然数 <span class="math display">\[n\]</span>等势的集合称为有穷集。</p><p><span class="math display">\[\quad A\,是有穷集\Harr \exist n(A\approxn\and n\in N)\Harr B\subset A\rarr A\not\approx B\]</span></p><p>不存在与自身真子集等势的自然数，也不存在与自身真子集等势的有穷集</p></li><li><p><strong>无穷集</strong></p><p>不能与任何自然数 <span class="math display">\[n\]</span>等势的集合</p><p><span class="math display">\[\quad A\,是无穷集\Harr n\in N\rarrA\not\approx n\Harr B\subset A\rarr B\approx A\]</span></p><p>与自身真子集等势的集合是无穷集，自然数集也是无穷集</p></li></ul><h3 id="基数">1.13 基数</h3><ul><li><p><strong>基数</strong></p><p>对每个集合 <span class="math display">\[A\]</span>，定义 <spanclass="math display">\[\operatorname{card}A\]</span></p><ul><li><spanclass="math display">\[\operatorname{card}A=\operatorname{card}B\HarrA\approx B\]</span></li><li>对于有穷集：<span class="math display">\[\operatorname{card}A=n\HarrA\approx n\]</span></li><li>对于无穷集：<spanclass="math display">\[\operatorname{card}N=\aleph_0\]</span></li><li>对于实数集：<spanclass="math display">\[\operatorname{card}R=\aleph_1=\aleph\]</span></li></ul><p><span class="math display">\[0,1,2,\dots,\aleph_0,\aleph\]</span>都称作基数</p><p>其中 <span class="math display">\[0,1,2,\ldots\]</span>称为有穷基数；<span class="math display">\[\aleph_0,\aleph\]</span>称为无穷基数</p><p>若 <span class="math display">\[{card\,}A=\aleph_i\]</span> 则 <spanclass="math display">\[\operatorname{card}P(A)=\aleph_{i+1}\]</span></p><p>可以用希腊字符 <spanclass="math display">\[\kappa,\lambda,\mu\]</span> 等表示任意基数。<spanclass="math display">\[\operatorname{card}A\]</span> 是对 <spanclass="math display">\[|A|\]</span> 的推广</p><p>有穷基数小于任何无穷基数，<span class="math display">\[0\]</span>是有穷基数的最小值。<spanclass="math display">\[\operatorname{rand}A&lt;\operatorname{rand}P(A)\]</span></p></li><li><p><span class="math display">\[K_\kappa\]</span></p><p>设 <span class="math display">\[\kappa\]</span> 是任意基数，令 <spanclass="math display">\[K_\kappa=\lbracex|x\,是集合且\,\operatorname{card}x=\kappa\rbrace\]</span></p><ul><li><span class="math display">\[\kappa=0\]</span> 时，<spanclass="math display">\[K_\kappa=\lbrace\empty\rbrace\]</span>是集合</li><li><span class="math display">\[\kappa\not=0\]</span> 时，<spanclass="math display">\[K_\kappa\]</span> 不是集合，而是类</li></ul></li><li><p><strong>优势、劣势</strong></p><p>如果存在 <span class="math display">\[A\]</span> 到 <spanclass="math display">\[B\]</span> 的单射，则必然有 <spanclass="math display">\[\operatorname{rand}A\le\operatorname{rand}B\]</span></p><p>则称 <span class="math display">\[A\]</span> 较 <spanclass="math display">\[B\]</span> 劣势（<spanclass="math display">\[B\]</span> 较 <spanclass="math display">\[A\]</span> 优势），记为 <spanclass="math display">\[A\preccurlyeq\bullet B\]</span> 或 <spanclass="math display">\[B\succcurlyeq\bullet A\]</span></p><p>若有 <spanclass="math display">\[\operatorname{rand}A&lt;\operatorname{rand}B\]</span>则称为绝对劣势（绝对优势），记为 <spanclass="math display">\[A\prec\bullet B\]</span> 或 <spanclass="math display">\[B\succ\bullet A\]</span></p><p>显然 <span class="math display">\[A\subseteq B\RarrA\preccurlyeq\bullet B\quad A\subset B\Rarr A\succcurlyeq\bulletB\]</span></p><p><span class="math display">\[\quad A\preccurlyeq\bull B\andB\preccurlyeq\bull A\Rarr A\approx B\]</span></p><p><span class="math display">\[\quad\kappa\le\lambda\and\lambda\le\kappa\Rarr\kappa=\lambda\]</span></p><p><span class="math display">\[\quad A\subseteq B\subseteq C\andA\approx C\Rarr A\approx B\approx C\]</span></p><p><span class="math display">\[\quadR\approx(N\rarr2)=2^N\]</span></p></li><li><p><strong>可数集（可列集）</strong></p><p>基数不超过 <span class="math display">\[\aleph_0\]</span>的集合称为可数集。<span class="math display">\[n\in N\]</span>称为有穷可数集，<span class="math display">\[N\]</span>称为无穷可数集</p><p>倘若 <span class="math display">\[A\]</span>是有穷可数集，则其可以表示成 <span class="math display">\[A=\lbracea_1,a_2,\dots,a_n\}\]</span></p></li><li><p><strong>基数运算</strong></p><p>基数间也能进行运算</p><p>有集合 <span class="math display">\[K,L\]</span> 且 <spanclass="math display">\[K\cap L=\empty\]</span>，基数 <spanclass="math display">\[\kappa =\operatorname{rand}K,\lambda=\operatorname{rand}L\]</span></p><p>则 <spanclass="math display">\[\kappa+\lambda=\operatorname{rand}(K\cupL)\qquad\kappa\bull\lambda=\operatorname{rand}(K\timesL)\qquad\kappa^\lambda=\operatorname{rand}\lbrace A|A:K\rarrL\}\]</span></p><p>有 <spanclass="math display">\[rand\,P(K)=2^\kappa\qquad\aleph=2^{\aleph_0}\]</span></p><p>基数运算的性质</p><ul><li><p><spanclass="math display">\[\kappa+\lambda=\lambda+\kappa\qquad(\kappa+\lambda)+\mu=\kappa+(\lambda+\mu)\qquad\kappa\le\lambda\Rarr\kappa-\mu\le\lambda-\mu\]</span></p><p><spanclass="math display">\[\kappa\bull(\lambda+\mu)=\kappa\bull\lambda+\kappa\bull\mu\qquad\kappa^\lambda\bull\kappa^\mu=\kappa^{\lambda+\mu}\]</span></p><p><spanclass="math display">\[(\kappa\not=0\or\mu\not=0)\and\kappa\le\lambda\Rarr\mu^\kappa\le\mu^\lambda\]</span></p></li><li><p>若 <span class="math display">\[\kappa\]</span> 是无穷基数则有<span class="math display">\[\kappa\bull\kappa=\kappa\]</span></p><p>即，对于任意无穷集都能和自身的二元关系建立双射</p></li><li><p>若 <span class="math display">\[\kappa\]</span> 是无穷基数，<spanclass="math display">\[\lambda\]</span> 是基数，则有 <spanclass="math display">\[\kappa+\lambda=\kappa\bullet\lambda=max\lbrace\kappa,\lambda\}\]</span></p></li><li><p>若 <span class="math display">\[\kappa\]</span> 是无穷基数，则<span class="math display">\[\kappa^\kappa=2^\kappa\]</span></p></li></ul></li></ul><h3 id="公理化集合论">1.14 公理化集合论</h3><blockquote><p>罗素悖论：罗素悖论是由罗素发现的一个集合论悖论。若有 <spanclass="math display">\[A=\lbrace x|x\not\inx\rbrace\]</span>，则无法判断 <span class="math display">\[A\inA\]</span> 的真假。</p><p>罗素悖论的提出引发了第三次数学危机。为了尝试解决该危机，提出了公理化集合论。ZF公理系统是其中的一种。</p></blockquote><h4 id="zf-公理系统">ZF 公理系统</h4><ul><li><p>空集公理：<spanclass="math display">\[\empty\,是集合\]</span></p></li><li><p>外延公理：所含元素相同的两个集合相等</p><p><span class="math display">\[\quad A=B\Harr\forall x(x\in A\harr x\inB)\]</span></p></li><li><p>无序对公理：<span class="math display">\[a,b\,是集合\Rarr\lbracea,b\rbrace\,是集合\]</span></p></li><li><p>子集公理：<span class="math display">\[A\,是集合\Rarr\lbrace x\inA|P(x)\rbrace\,是集合\]</span></p></li><li><p>并集公理：<span class="math display">\[{\mathcalA}\,是集族\Rarr{\bigcup\\}{\mathcal A}\,是集合\]</span></p></li><li><p>幂集公理：<span class="math display">\[A\,是集合\RarrP(A)\,是集合\]</span></p></li><li><p>替换公理：<span class="math display">\[F\,是\,A\,上的函数\Rarr\lbrace f(x)|x\in A\}\,是集合\]</span></p></li><li><p>正则公理：<span class="math display">\[A\not=\empty\Rarr\existB(B\in A\and B\cap A=\empty)\]</span></p></li><li><p>无限公理：存在归纳集。</p><p><span class="math display">\[\quad A\,是归纳集\Harr(\empty\inA)\and(a\in A\rarr a\cup\lbrace a\rbrace\in A)\]</span></p></li></ul><p>以上公理组成了 ZF 公理系统。加上下面的选择公理（策梅洛公理）即构成ZFC 公理系统</p><ul><li><p>选择公理：<span class="math display">\[\mathcal A\]</span>是元素互不相交的非空集族。从该集族每个元素中选择一个元素，那些选择的元素构成一个集合</p><p><span class="math display">\[\quad\forall a,b\in{\mathcal A}(a\capb\not=\empty\rarr a=b)\Rarr\exist C(\forall x\in{\mathcal A}\rarr |x\capC|=1)\]</span></p><p>以下公理都是该公理的等价形式：</p><ul><li>广义选择公理：对于任何非空集族都有选择函数 <spanclass="math display">\[f:\mathcal{A\rarr\bigcup A},\,f(x)\inx\in\mathcal A\]</span></li><li>良序原理：任何集合都可以良序化</li><li>Zorn 原理：链总有上界的非空偏序集存在极大元</li><li>Hausdorff 极大原理：任何链都包含于极大链</li><li>三歧性原理：<spanclass="math display">\[A,B\,是集合\Rarr|A|\le|B|\or|B|\le|A|\]</span></li></ul></li></ul><h2 id="图论">2 图论</h2><h3 id="图">2.1 图</h3><ul><li><p><strong>无序积</strong></p><p><span class="math display">\[\quad A\&amp;B=\lbrace\lbrace x,y\}|x\inA\and y\in B\}\]</span></p><p>其中，记 <span class="math display">\[\lbracex,y\}=(x,y)\]</span>，允许 <span class="math display">\[x=y\]</span>，且<span class="math display">\[(x,y)=(y,x)\]</span></p></li><li><p><strong>无向图</strong></p><p><span class="math display">\[V(G)\]</span> 是顶点集，<spanclass="math display">\[E(G)\]</span> 是边集，且 <spanclass="math display">\[V\not=\empty\]</span>、<spanclass="math display">\[E\subseteq V\&amp;V\]</span></p><p>则无向图 <span class="math display">\[G=\lang V,E\rang\]</span></p><p>比如：无向图 <span class="math display">\[G=\lang V,E\rang\quadV=\lbrace a,b,c,d\}\quad E=\lbrace (a,b),(b,c),(b,c),(b,d)\}\]</span>的样子如下所示</p><pre><code class=" mermaid">graph LRA((a))---B((b))---C((c))B---CB---D((d))</code></pre></li><li><p><strong>有向图</strong></p><p><span class="math display">\[V(D)\]</span> 是顶点集，<spanclass="math display">\[E(D)\]</span> 是边集，且 <spanclass="math display">\[V\not=\empty\]</span>、<spanclass="math display">\[E\subseteq V\times V\]</span></p><p>则有向图 <span class="math display">\[D=\lang V,E\rang\]</span></p><p>比如：有向图 <span class="math display">\[D=\lang V,E\rang\quadV=\lbrace a,b,c,d\}\quad E=\lbrace \lang a,b\rang,\lang a,c\rang,\langb,c\rang,\lang b,d\rang\}\]</span> 的样子如下所示</p><pre><code class=" mermaid">graph LRA((a))--&gt;B((b))--&gt;C((c))C--&gt;BB--&gt;D((d))</code></pre></li><li><p><strong>n 阶图</strong></p><p><span class="math display">\[\quad|V(G)|=n\]</span></p><p>当 <span class="math display">\[n&lt;\infin\]</span> 时称为<strong>有限图</strong>。当 <spanclass="math display">\[E=\empty\]</span> 时称为<strong>零图</strong>。当 <spanclass="math display">\[V=E=\empty\]</span> 时称为<strong>空图</strong></p><p>1 阶的零图 <span class="math display">\[N_1\]</span> 称为平凡图</p><p>下面是一些例子</p><pre><code class=" mermaid">graph BTsubgraph 1阶图l1(( ))endsubgraph N4n41(( ))n42(( ))n43(( ))n4(( ))endsubgraph N1n1(( ))endsubgraph 2阶图direction LRl2(( ))---l21(( ))endsubgraph 3阶图direction LRl3(( ))---l31(( ))l32(( ))---l32l3end</code></pre></li><li><p><strong>标定图、非标定图、底图</strong></p><p>标定图：顶点或边 带标记的图</p><p>非标定图：顶点和边 不带标记的图</p><p>底图（基图）：有向图去掉边的方向后得到的无向图</p></li><li><p><strong>相邻、邻接、关联</strong></p><p>有边相连的两个顶点是 <strong>相邻</strong> 的，有公共顶点的两条边是<strong>相邻</strong> 的</p><p>在有向图中，有向边的起点 <strong>邻接</strong>到 终点，终点 邻接于起点</p><p>一条边的端点与该边是关联的</p><p>关联次数：</p><pre><code class=" mermaid">graph TBA1((1))---A2((1))B1((2))---B1C1((+1))--&gt;C2(( -1))D1((?))--无法表示--&gt;D1</code></pre></li><li><p><strong>环、孤立点、平行边</strong></p><p>两边是同一顶点的边称为 <strong>环</strong></p><p>没有边相连的顶点称为 <strong>孤立点</strong></p><p>两端顶点相同的边称为<strong>平行边</strong>，在有向图中，平行边的方向必须相同</p></li><li><p><strong>邻域、闭邻域、关联集</strong></p><p>邻域：一个点的相邻点构成的集合称为<strong>邻域（开邻域）</strong></p><p><span class="math display">\[\quad N_G(v)=\lbrace u\in V(G)|(u,v)\inE(G)\and u\not=v\}\]</span></p><p>闭邻域：一个点及其相邻点构成的集合称为 <strong>闭邻域</strong></p><p><span class="math display">\[\quad\overline{N_G(v)}=N_G(v)\cup\lbracev\}\]</span></p><p>关联集：一个点关联的边构成 <strong>关联集</strong></p><p><span class="math display">\[\quad I_G(v)=\lbracee|e\,与\,v\,关联\}\]</span></p><p>后继：在有向图中，一个点的后继点构成的集合</p><p><span class="math display">\[\quad{\Gamma_D}^+(v)=\lbrace u\inV(D)|\lang v,u\rang\in E(D)\and u\not= v\}\]</span></p><p>前驱：在有向图中，一个点的前驱点构成的集合</p><p><span class="math display">\[\quad{\Gamma_D}^-(v)=\lbrace u\inV(D)|\lang u,v\rang\in E(D)\and u\not= v\}\]</span></p><p>有向图的开邻域：<spanclass="math display">\[N_D(v)={\Gamma_D}^+(v)\cup{\Gamma_D}^-(v)\]</span></p><p>有向图的闭邻域：<spanclass="math display">\[\overline{N_D(v)}=N_D(v)\cup\lbracev\}\]</span></p></li><li><p><strong>顶点的度</strong></p><p>度：<spanclass="math display">\[d_G(v)=与\,v\,关联的边的次数之和\]</span></p><p>出度：<spanclass="math display">\[{d_D}^+(v)=与\,v\,关联的出边的次数之和\]</span></p><p>入度：<spanclass="math display">\[{d_D}^-(v)=与\,v\,关联的入边的次数之和\]</span></p><p>最大度：<spanclass="math display">\[\Delta(G)=\operatorname{max}\lbrace d_G(v)|v\inV(G)\}\]</span></p><p>最小度：<spanclass="math display">\[\delta(G)=\operatorname{min}\lbrace d_G(v)|v\inV(G)\}\]</span></p><p>最大出度、最大入度、最小出度、最小入度</p></li><li><p><strong>握手定理</strong></p><p>设 <span class="math display">\[G=\lang V,E\rang\]</span>是无向图，<span class="math display">\[V=\lbracev_1,v_2,\dots,v_n\},\,|E|=m\]</span></p><p>则 <spanclass="math display">\[d(v_1)+d(v_2)+\dots+d(v_n)=2m\]</span></p><p>推论：任何图中，奇数度顶点的个数是偶数</p></li><li><p><strong>简单图</strong></p><p>没有环和平行边的图称为 <strong>简单图</strong></p><p>对于简单图，其最大度 <span class="math display">\[0\le\Delta(G)\len-1\]</span></p></li><li><p><strong>正则图</strong></p><p>所有顶点的度相等的图称为 <strong>正则图</strong>，度为 <spanclass="math display">\[k\]</span> 则称为 <spanclass="math display">\[k\,正则图\]</span></p></li><li><p><strong>度数列、可图化</strong></p><p>由所有顶点的度构成的数列称为 <strong>度数列</strong></p><p><span class="math display">\[\quadd=(d(v_1),d(v_2),\dots,d(v_n))\]</span></p><p>若存在图 <span class="math display">\[G\]</span> 使得 <spanclass="math display">\[G\]</span> 的度数列是 <spanclass="math display">\[d\]</span>，则称 <spanclass="math display">\[d\]</span> 是 <strong>可图化</strong> 的</p><p><span class="math display">\[\quad d\,可图化\Harrd_1+d_2+\dots+d_n\equiv 0(\operatorname{mod}2)\]</span></p><p>若存在简单图 <span class="math display">\[G\]</span> 使得 <spanclass="math display">\[G\]</span> 的度数列是 <spanclass="math display">\[d\]</span>，则称 <spanclass="math display">\[d\]</span> 是 <strong>可简单图化</strong> 的</p><p><span class="math display">\[\quad\begin{align}&amp;d\,可简单图化\\\Harr&amp;d&#39;=(d_2-1,d_3-1,\dots,d_n-1)\,可简单图化\\\Harr&amp;\forallr(r\ge1\and r\le n-1)\rarr d_1+d_2+\dots+d_r\le r(r-1)+\min \lbracer,d_{r+1}\}+\min \lbrace r,d_{r+2}\}+\dots+\min \lbracer,d_{n}\}\\\Harr&amp;n-1\ge d_1\ge d_2\ge\dots\ge d_n\ge 0\Rarrd_1+d_2+\dots+d_n\le n(n-1)\end{align}\]</span></p></li><li><p><strong>同构</strong></p><p>对于图 <span class="math display">\[G_1,G_2\]</span></p><p>如果存在双射 <span class="math display">\[f:V(G_1)\rarrV(G_2)\]</span> 使得 <span class="math display">\[\forall a,b\inV(G_1),\,(a,b)\in E(G_1)\harr (f(a),f(b))\in E(G_2)\]</span> 就称 <spanclass="math display">\[G_1\]</span> 与 <spanclass="math display">\[G_2\]</span> 同构。记为 <spanclass="math display">\[G_1\cong G_2\]</span></p><p>同构的图，其图论性质完全一致</p><p>对于有向图 <span class="math display">\[D_1,D_2\]</span>同理，存在双射 <span class="math display">\[f:V(D_1)\rarrV(D_2)\]</span> 使得 <span class="math display">\[\forall a,b\inV(D_1),\,\lang a,b\rang\in E(D_1)\harr \lang f(a),f(b)\rang\inE(D_2)\]</span> 就称 <span class="math display">\[D_1\]</span> 与 <spanclass="math display">\[D_2\]</span> 同构，记为 <spanclass="math display">\[D_1\cong D_2\]</span></p><ul><li><p><strong>NAUTY 算法</strong></p><p>一种计算两个图是否是同构的算法</p><p>详见 <ahref="https://pallini.di.uniroma1.it/Introduction.html"><strong>这个网站</strong></a></p></li></ul></li><li><p>一些图族</p><p>完全图：无向图的每个顶点都与所有其他顶点相邻。n 阶的完全图记为 <spanclass="math display">\[K_n\]</span></p><p>竞赛图：完全图的每条边都是有向边</p><p>r 部图：该图的顶点可以分为 r组，每条边的两个端点位于不同的组</p></li><li><p><strong>子图、生成子图</strong></p><p>对于图 <span class="math display">\[G,G&#39;\]</span>，若有 <spanclass="math display">\[V&#39;\subseteq V\and E&#39;\subseteqE\]</span>，则 <span class="math display">\[G&#39;\]</span> 是 <spanclass="math display">\[G\]</span> 的<strong>子图</strong>，记为 <spanclass="math display">\[G&#39;\subseteq G\]</span></p><p>若 <span class="math display">\[G&#39;\subseteq G\and(V&#39;\subsetV\and E&#39;\subset E)\]</span>，则 <spanclass="math display">\[G&#39;\]</span> 是 <spanclass="math display">\[G\]</span> 的<strong>真子图</strong>，记为 <spanclass="math display">\[G&#39;\subset G\]</span></p><p>若 <span class="math display">\[G&#39;\subseteq G\andV&#39;=V\]</span>，则 <span class="math display">\[G&#39;\]</span> 是<span class="math display">\[G\]</span>的<strong>生成子图</strong></p></li><li><p><strong>导出子图</strong></p><p>若 <span class="math display">\[V_1\subset V,\, E_1=E\capV_1\&amp;V_1\]</span> 则称 <span class="math display">\[G[V_1]=\langV_1,E_1\rang\]</span> 是由 <span class="math display">\[V_1\]</span><strong>导出的子图</strong></p><p>若 <span class="math display">\[\empty\not=E_1\subset E,\,V_1=\lbrace v|v\,与\,E_1\,中的边关联\}\]</span> 则称 <spanclass="math display">\[G[E_1]=\lang V_1,E_1\rang\]</span> 是由 <spanclass="math display">\[E_1\]</span> <strong>导出的子图</strong></p></li><li><p><strong>补图</strong></p><p>对于图 <span class="math display">\[G=\lang V,E\rang\]</span>，其补图<span class="math display">\[\overline G=\langV,E(K_n)-E\rang\]</span></p><p>如果 <span class="math display">\[G\cong\overlineG\]</span>，则称其为 <strong>自补图</strong></p></li><li><p><strong>删除</strong></p><p>删除边 <span class="math display">\[e\]</span>：<spanclass="math display">\[G-e=\lang V,E-\lbrace e\}\rang\]</span></p><p>删除边集 <span class="math display">\[E&#39;\]</span>：<spanclass="math display">\[G-E&#39;=\lang V,E-E&#39;\rang\]</span></p><p>删除顶点 <span class="math display">\[v\]</span>及其关联的所有边：<span class="math display">\[G-v=\lang V-\lbracev\},E-I_G(v)\rang\]</span></p><p>删除顶点集 <span class="math display">\[V&#39;\]</span>及关联的所有边：<span class="math display">\[G-V&#39;=\langV-V&#39;,E-I_G(V&#39;)\rang\]</span></p></li><li><p><strong>收缩、加边</strong></p><p>删除 <span class="math display">\[e\]</span>，合并 <spanclass="math display">\[u\]</span> 与 <spanclass="math display">\[v\]</span>：<spanclass="math display">\[G{\setminus}e:e=(i,v)\]</span></p><p>在 <span class="math display">\[u,v\]</span> 间增加新边：<spanclass="math display">\[G\cup(u,v)=\lang V,E\cup\lbrace(u,v)\}\rang\]</span>，也可以写为 <spanclass="math display">\[G+(u,v)\]</span></p></li><li><p><strong>不交</strong></p><p>对于 <span class="math display">\[G_1,G_2\]</span></p><p><span class="math display">\[\quad G_1\,与\,G_2\,不交\Harr V_1\capV_2=\empty\]</span></p><p><span class="math display">\[\quad G_1\,与\,G_2\,边不交\Harr E_1\capE_2=\empty\]</span></p></li><li><p><strong>并图、交图、差图、环和</strong></p><p>对于无孤立点的图 <span class="math display">\[G_1,G_2\]</span></p><p>并图：<span class="math display">\[G_1\cup G_2=\lang V(E_1\cupE_2),E_1\cup E_2\rang\]</span></p><p>交图：<span class="math display">\[G_1\cap G_2=\lang V(E_1\capE_2),E_1\cap E_2\rang\]</span></p><p>差图：<span class="math display">\[G_1-G_2=\langV(E_1-E_2),E_1-E_2\rang\]</span></p><p>环和：<span class="math display">\[G_1\oplus G_2=\lang V(E_1\oplusE_2),E_1\oplus E_2\rang\]</span></p></li><li><p><strong>联图</strong></p><p><span class="math display">\[G_1,G_2\]</span> 是不交的无向图</p><p>其联图 <span class="math display">\[G_1+G_2=\lang V_1\cup V_2,E_1\cupE_2\cup(V_1\&amp;V_2)\rang\]</span></p><p><span class="math display">\[\quad K_r+K_s=K_{r+s}\quadN_r+N_s=K_{r,s}\quad n=n_1+n_2,\,m=m_1+m_2+n_1n_2\]</span></p></li></ul><h3 id="通路回路">2.2 通路、回路</h3><ul><li><p><strong>通路、回路</strong></p><p>图中邻接的点与边的交替序列构成 <strong>通路</strong></p><p><span class="math display">\[\quad\Gamma=v_1,e_1,v_2,e_2,\dots,v_n\]</span></p><p>通路的起止都是顶点。通路中边的数量称为通路的<strong>长度</strong></p><p>如果通路的起止点是同一顶点，则称该通路为 <strong>回路</strong></p><p>没有重复边的通路（回路）称为<strong>简单通路（简单回路）</strong></p><p>有重复边的通路（回路）称为 <strong>复杂通路（复杂回路）</strong></p><p>没有重复顶点的通路（回路）称为<strong>初级通路/路径（初级回路/圈）</strong></p><p>可以只用边的序列来表示通路。简单图可以只用顶点的序列表示通路。</p><p>图中最长圈的长度称为图的 <strong>周长</strong>。不含圈时，长度为<span class="math display">\[0\]</span> 或 <spanclass="math display">\[\infin\]</span></p><p>有以下定理：</p><ul><li><p>在 <span class="math display">\[n\]</span> 阶图 <spanclass="math display">\[G\]</span> 中，若从不同顶点 <spanclass="math display">\[v_i\]</span> 到 <spanclass="math display">\[v_j\]</span> 有通路，则从 <spanclass="math display">\[v_i\]</span> 到 <spanclass="math display">\[v_j\]</span> 有长度小于等于 <spanclass="math display">\[n-1\]</span> 的通路</p><p>推论：在 <span class="math display">\[n\]</span> 阶图 <spanclass="math display">\[G\]</span> 中，若从不同顶点 <spanclass="math display">\[v_i\]</span> 到 <spanclass="math display">\[v_j\]</span> 有通路，则从 <spanclass="math display">\[v_i\]</span> 到 <spanclass="math display">\[v_j\]</span> 有长度小于等于 <spanclass="math display">\[n-1\]</span> 的路径</p></li><li><p><span class="math display">\[G\,是二部图\HarrG\,中无奇圈\]</span></p></li><li><p>若无向图 <span class="math display">\[G\]</span> 是连通图，则<span class="math display">\[G\]</span> 的边数 <spanclass="math display">\[m\ge n-1\]</span></p></li></ul></li><li><p><strong>极大路径</strong></p><p>在无向简单图中，路径的两个端点不与路径本身以外的顶点相邻，这样的路径称为<strong>极大路径</strong></p><p>在有向图中，路径起点的前驱、终点的后继，都在路径本身上，这样的路径称为<strong>极大路径</strong></p></li><li><p><strong>连通图、分离图</strong></p><p>图中的两个顶点 <span class="math display">\[u,v\]</span>间存在通路，则称 <span class="math display">\[u\]</span> 与 <spanclass="math display">\[v\]</span> 连通。记作：<spanclass="math display">\[u\sim v\]</span></p><p>每个顶点都与自身连通。即 <span class="math display">\[u\simu\]</span></p><p>连通关系是 自反、对称、传递的。连通关系是等价关系。彼此联通的顶点集合构成<strong>连通分支</strong>。记为 <spanclass="math display">\[G[v_i]\]</span></p><p>设 <span class="math display">\[V/\sim=\lbraceV_i|i=1,\dots,k\}\]</span>，则连通分支数 <spanclass="math display">\[p(G)=|V/\sim|\]</span></p><p>连通分支数为 1 的图称为 <strong>连通图</strong></p><p>连通分支大于 1 的图称为 <strong>分离图</strong></p><p><span class="math display">\[u,v\]</span> 间最短的通路称为<strong>短程线（测地线）</strong></p></li><li><p><strong>距离、直径</strong></p><p><span class="math display">\[u,v\]</span> 间短程线的长度称为其<strong>距离</strong>，记为 <spanclass="math display">\[d_G(u,v)\]</span></p><p>图中所有距离的最大值称为图的 <strong>直径</strong>。<spanclass="math display">\[d(G)=\max(d_G(u,v)|u,v\in V(G))\]</span></p><p>有 <spanclass="math display">\[d(K_n)=1(n\ge2),\,d(C_n)=n/2\]</span>，并且约定零图的直径：<spanclass="math display">\[d(N_i)=\begin{cases}0,\quad i=1\\\infin,\quadi&gt;1\end{cases}\]</span></p></li><li><p><strong>距离函数</strong></p><p>距离函数具有三个特征</p><ul><li>非负性：<span class="math display">\[d(u,v)\ge0\and d(u,v)=0\Harru=v\]</span></li><li>对称性：<span class="math display">\[d(u,v)=d(v,u)\]</span></li><li><span class="math display">\[\Delta\]</span>不等式：<spanclass="math display">\[d(u,v)+d(v,w)\ge d(u,w)\]</span></li></ul><p>任何函数只要满足上述三条特征就能作为距离函数使用。</p></li><li><p><strong>可达、弱连通</strong></p><p>对于有向图 <span class="math display">\[D=\langV,E\rang\]</span>，若从 <span class="math display">\[u\]</span> 到 <spanclass="math display">\[v\]</span> 有有向通路，则称从 <spanclass="math display">\[u\]</span> <strong>可达</strong> <spanclass="math display">\[v\]</span>，记作 <spanclass="math display">\[u\rarr v\]</span></p><p>规定 <span class="math display">\[u\rarr u\]</span>。可达关系是自反、传递的。可达关系的导出子图是 <strong>单向连通分支</strong></p><p>若 <span class="math display">\[u\rarr v\and v\rarr u\]</span> 则称<span class="math display">\[u,v\]</span><strong>双向可达</strong>，记作 <span class="math display">\[u\harrv\]</span></p><p>双向可达关系是等价关系。其等价类的导出子图称为<strong>强连通分支（双向连通分支）</strong></p><p>若有向图的基图是连通图，则称其为<strong>弱连通</strong>，其导出子图称为 <strong>弱连通分支</strong></p><p>有如下定理：</p><ul><li><p>对于竞赛图，一定有一条路经过每一个点恰好一次</p></li><li><p><span class="math display">\[有向图\,D\,强连通\HarrD\,中有回路经过每个点至少一次\]</span></p><p>这个回路不一定是简单回路</p></li><li><p><span class="math display">\[有向图\,D\,单向连通\HarrD\,中有通路经过每个顶点至少一次\]</span></p><p>这个通路不一定是简单通路</p></li></ul></li></ul><h3 id="连通度">2.3 连通度</h3><ul><li><p><strong>点割集、边割集</strong></p><p>设有图 <span class="math display">\[G\langV,E\rang\]</span>，非空点集 <span class="math display">\[V&#39;\subsetV\]</span>，非空边集 <span class="math display">\[E&#39;\subsetE\]</span></p><p>若满足 <span class="math display">\[p(G-V&#39;)&gt;p(G)\]</span>，且<span class="math display">\[\forall V&#39;&#39;\subsetV&#39;,\,p(G-V&#39;&#39;)=p(G)\]</span> 则称 <spanclass="math display">\[V&#39;\]</span> 是 <spanclass="math display">\[G\]</span> 的一个 <strong>点割集</strong>。</p><p>若满足 <span class="math display">\[p(G-E&#39;)&gt;p(G)\]</span>，且<span class="math display">\[\forall E&#39;&#39;\subsetE&#39;,\,p(G-E&#39;&#39;)=p(G)\]</span> 则称 <spanclass="math display">\[E&#39;\]</span> 是 <spanclass="math display">\[G\]</span> 的一个 <strong>边割集</strong>。</p><p>对于边割集，有引理：<spanclass="math display">\[p(G-E&#39;)=p(G)+1\]</span></p><p>若 <span class="math display">\[E&#39;\subseteq I_G(v)\]</span>则称其为 <strong>扇形割集</strong></p></li><li><p><strong>割点、割边（桥）</strong></p><p><span class="math display">\[\quad v\,是割点\Harr\lbracev\}\,是割集\]</span></p><p><span class="math display">\[\quad (u,v)\,是割边\Harr\lbrace(u,v)\}\,是割集\]</span></p><p><span class="math display">\[I_G(v)\]</span>不一定是边割集（不一定极小）。当且仅当 <spanclass="math display">\[v\]</span> 不是割点时，<spanclass="math display">\[I_G(v)\]</span> 是边割集</p><p>有如下引理：</p><ul><li>设 <span class="math display">\[E&#39;\]</span>是<font color="#AF00A0">非完全图</font> <spanclass="math display">\[G\]</span> 的最小边割集。若 <spanclass="math display">\[G-E&#39;\]</span> 的两个连通分支是 <spanclass="math display">\[G_1,G_2\]</span>，则存在 <spanclass="math display">\[u\in V(G_1),v\in V(G_2)\]</span> 使得 <spanclass="math display">\[(u,v)\not\in E(G)\]</span></li></ul></li><li><p><strong>点连通度、边连通度</strong></p><p>点连通度：为了破坏连通性（<spanclass="math display">\[p(G-V&#39;)&gt;p(G)\]</span>），至少要破坏多少个顶点</p><p>边连通度：为了破坏连通性（<spanclass="math display">\[p(G-E&#39;)&gt;p(G)\]</span>），至少要破坏多少条边</p><p>设 <span class="math display">\[G\]</span> 是无向连通非完全图</p><p>点连通度 <span class="math display">\[\kappa(G)=\min\lbrace|V&#39;|\,|V&#39;\,是\,G\,的点割集\}\]</span></p><p>边连通度 <span class="math display">\[\lambda (G)=\min\lbrace|E&#39;|\,|E&#39;\,是\,G\,的边割集\}\]</span></p><p>规定：<span class="math display">\[\kappa(K_n)=n-1\]</span>，若 <spanclass="math display">\[G\]</span> 非联通则 <spanclass="math display">\[\kappa(G)=0,\,\lambda(G)=0\]</span></p></li><li><p><strong>K-（边）连通图</strong></p><p>k-连通图：<span class="math display">\[\kappa(G)\ge k\]</span></p><p>k-边连通图：<span class="math display">\[\lambda(G)\ge k\]</span></p><p>有定理：</p><ul><li>对于 3-正则图 <span class="math display">\[G\]</span>，必定有 <spanclass="math display">\[\kappa(G)=\lambda(G)\]</span></li><li>对于任意 <span class="math display">\[G\]</span>，都有 <spanclass="math display">\[\kappa(G)\le\lambda(G)\le\delta(G)\]</span>，也就是说k-连通图 一定是 k-边连通图</li></ul></li><li><p><strong>x-y 割、独立路径、边不交路径</strong></p><p>设 <span class="math display">\[x,y\]</span> 是 <spanclass="math display">\[G\]</span> 中的不相邻顶点</p><p>若存在 <span class="math display">\[S\subseteq V(G)-\lbracex,y\}\]</span>，使得在 <span class="math display">\[G-S\]</span> 中<span class="math display">\[x,y\]</span> 不连通，则称 <spanclass="math display">\[S\]</span> 为 <spanclass="math display">\[G\]</span> 中的 <strong>x-y 割</strong>。</p><p>两条除起点与终点外无其他公共顶点的路径称为<strong>独立路径</strong></p><p>两条无公共边（但可能有公共顶点）的路径称为<strong>边不交路径</strong></p><p>有如下定理：</p><ul><li><p><font color="#E020E0">最小</font>的 x-y割包含的定点数，等于<font color="#E020E0">最大</font>的 x-y独立路径的条数</p></li><li><p><strong>2-连通图</strong>的<font color="#20AEA0">充要条件</font></p><p><span class="math display">\[\begin{align}&amp;3\,阶以上无向图是\,2-连通图\\\Harr&amp;图中任意两点都共圈\\\Harr&amp;图中任意两顶点间都有\,2\,条以上独立路径\end{align}\]</span></p></li><li><p><strong>2-边连通图</strong>的<font color="#20AEA0">充要条件</font></p><p><span class="math display">\[\begin{align}&amp;3\,阶以上无向图是\,2-边连通图\\\Harr&amp;图中任意两点都共简单回路\\\Harr&amp;图中任意两顶点间都有\,2\,条以上边不交路径\end{align}\]</span></p></li><li><p><strong>k-连通图</strong>的<font color="#20AEA0">充要条件</font></p><p><span class="math display">\[\begin{align}&amp;3\,阶以上无向图是k-连通图\\\Harr&amp;图中任意两顶点间都有\,k\,条以上独立路径\end{align}\]</span></p></li><li><p><strong>k-边连通图</strong>的<font color="#20AEA0">充要条件</font></p><p><span class="math display">\[\begin{align}&amp;3\,阶以上无向图是k-边连通图\\\Harr&amp;图中任意两顶点间都有\,k\,条以上边不交\end{align}\]</span></p></li><li><p><strong>割点</strong> 的<font color="#20AEA0">充要条件</font></p><p><span class="math display">\[\begin{align}&amp;无向连通图中顶点\,v\,是割点\\\Harr&amp;存在\,u,w\in V(G)-\lbrace v\}，使得\,u,w\,间的路径都经过\,v\end{align}\]</span></p></li><li><p><strong>桥</strong> 的<font color="#20AEA0">充要条件</font></p><p><span class="math display">\[\begin{align}&amp;无向连通图中边\,e\,是桥\\\Harr&amp;图中任意圈都不经过\,e\\\Harr&amp;可把\,V(G)\,划分为\,V_1,V_2，任意\,u\inV_1\,和\,v\in V_2\,间的路径都经过\,e\end{align}\]</span></p></li></ul></li><li><p><strong>块</strong></p><p>极大无割点的连通子图称为一个 <strong>块</strong></p><p>有如下定理：</p><ul><li><p><strong>块</strong> 的<font color="#20AEA0">充要条件</font></p><p><span class="math display">\[\begin{align}&amp;3\,阶以上无向图是块\\\Harr&amp;图中任意两顶点都共圈\\\Harr&amp;图中任意顶点与任意边都共圈\\\Harr&amp;图中任意两边都共圈\\\Harr&amp;对于任意边，图中任意两点间都存在经过该边的路径\\\Harr&amp;对于图中任意三点，都存在路径连接其中两点，并经过第三点\\\Harr&amp;对于图中任意三点，都存在路径连接其中两点，且不经过第三点\\\end{align}\]</span></p></li><li><p>n 阶简单连通图的 <spanclass="math display">\[\kappa,\lambda,\delta\]</span>间有且仅有三种可能：</p><ul><li><spanclass="math display">\[\kappa=\lambda=\delta=n-1\]</span>（完全图）</li><li><spanclass="math display">\[1\le2\delta-n+2\le\kappa\le\lambda=\delta\len-2\]</span>（即 <span class="math display">\[\delta\ge n/2\]</span>时）</li><li><spanclass="math display">\[n\le\kappa\le\lambda\le\delta&lt;n/2\]</span></li></ul></li></ul></li></ul><h3 id="欧拉图哈密顿图">2.4 欧拉图、哈密顿图</h3><ul><li><p><strong>欧拉图</strong></p><p>经过图中所有边的简单通路称为 <strong>欧拉通路</strong></p><p>有欧拉通路的图称为 <strong>半欧拉图</strong></p><p>经过图中所有边的简单回路称为 <strong>欧拉回路</strong></p><p>有欧拉回路的图称为 <strong>欧拉图</strong></p><p>有如下定理：</p><ul><li><p><strong>无向欧拉图</strong>的<font color="#20AEA0">充要条件</font></p><p><span class="math display">\[\begin{align}&amp;无向图连通图是欧拉图\\\Harr&amp;图中所有顶点的度都是偶数\\\Harr&amp;图是若干边不交的圈的并\end{align}\]</span></p></li><li><p><strong>无向半欧拉图</strong>的<font color="#20AEA0">充要条件</font></p><p><span class="math display">\[\begin{align}&amp;无向图连通图是半欧拉图\\\Harr&amp;图中恰有两个奇数度顶点\end{align}\]</span></p></li><li><p><strong>有向欧拉图</strong>的<font color="#20AEA0">充要条件</font></p><p><span class="math display">\[\begin{align}&amp;有向图连通图是欧拉图\\\Harr&amp;\forall v\in V(G),\,d^+(v)=d^-(v)\\\Harr&amp;图是若干边不交的有向圈的并\end{align}\]</span></p></li><li><p><strong>有向半欧拉图</strong>的<font color="#20AEA0">充要条件</font></p><p><span class="math display">\[\begin{align}&amp;有向图连通图是半欧拉图\\\Harr&amp;恰有一个顶点入度=出度+1，另一个顶点入度=出度-1，其余顶点入度=出度\\\end{align}\]</span></p></li></ul></li><li><p><strong>计算欧拉图的方法</strong></p><ul><li><p><strong>避桥法</strong></p><p>从任意一顶点起，沿没有走过的边（优先选择非桥边）到达下一顶点。最终能得到欧拉回路，或宣布该图不是欧拉图。</p></li><li><p><strong>逐步插入回路法</strong></p><p>每次求出一个简单回路。把新求出的回路插入老回路，合并成更大回路，直到得到欧拉回路，或宣布该图不是欧拉图。</p></li></ul></li><li><p><strong>哈密顿图</strong></p><p>经过图中所有顶点的初级通路称为 <strong>哈密顿通路</strong></p><p>有哈密顿通路的图称为 <strong>半哈密顿图</strong></p><p>经过图中所有顶点的初级回路称为 <strong>哈密顿回路</strong></p><p>有哈密顿回路的图称为 <strong>哈密顿图</strong></p><p>有如下定理：</p><ul><li><p><strong>无向哈密顿图</strong>的<font color="#AE20A0">必要条件</font>（不是充分条件）</p><p>设无向哈密顿图图 <span class="math display">\[G=\langV,E\rang\]</span>，则有 <span class="math display">\[\forallV_1(V_1\not=\empty\and V_1\subset V)\rarrp(G-V_1)\le|V_1|\]</span></p></li><li><p><strong>无向半哈密顿图</strong>的<font color="#AE20A0">必要条件</font>（不是充分条件）</p><p>设无向半哈密顿图 <span class="math display">\[G=\langV,E\rang\]</span>，则有 <span class="math display">\[\forallV_1(V_1\not=\empty\and V_1\subset V)\rarrp(G-V_1)\le|V_1|+1\]</span></p></li><li><p><strong>无向哈密顿图</strong>的<font color="#EEA000">充分条件</font>（不是必要条件）</p><p>对于 <span class="math display">\[n(n\ge3)\]</span>阶无向简单图，若其中任意不相邻顶点 <spanclass="math display">\[u,v\]</span> 都有 <spanclass="math display">\[d(u)+d(v)\gen\]</span>，则该图是哈密顿图</p></li><li><p><strong>无向半哈密顿图</strong>的<font color="#EEA000">充分条件</font>（不是必要条件）</p><p>对于 <span class="math display">\[n(n\ge2)\]</span>阶无向简单图，若其中任意不相邻顶点 <spanclass="math display">\[u,v\]</span> 都有 <spanclass="math display">\[d(u)+d(v)\gen-1\]</span>，则该图是半哈密顿图</p></li><li><p><strong>有向半哈密顿图</strong>的<font color="#EEA000">充分条件</font>（不是必要条件）</p><p><span class="math display">\[n(n\ge2)\]</span>阶竞赛图是有向半哈密顿图</p></li><li><p><strong>有向哈密顿图</strong>的<font color="#EEA000">充分条件</font>（不是必要条件）</p><p>强连通的竞赛图是有向半哈密顿图</p></li><li><p>完全图 <span class="math display">\[K_{2n+1}\]</span>必定同时包含 <span class="math display">\[n\]</span>组边不重的哈密顿回路，且这些哈密顿回路包含所有边。</p><p>对 <span class="math display">\[i=1,2,\dots,k\]</span>，令 <spanclass="math display">\[P_i=v_i,v_{i-1},v_{i+1},v_{i-2},v_{i+2},\dots,v_{i-(k-1)},v_{i+(k-1)},v_{i-k}\]</span></p><p>将 <span class="math display">\[P_i\]</span> 中的下标 <spanclass="math display">\[\operatorname{mod}{2k}\]</span> 后转换到 <spanclass="math display">\[\lbrace 1,2,\dots,2k+1\}\]</span></p><p>则所有 <spanclass="math display">\[C_i=v_{2k+1},P_i,v_{2k+1}\]</span>都是哈密顿回路</p><p>推论：</p><p>完全图 <span class="math display">\[K_{2n}\]</span> 必定同时包含<span class="math display">\[n-1\]</span> 组边不重的哈密顿回路，此外剩余<span class="math display">\[n\]</span> 条彼此不相邻的边。</p></li></ul></li></ul><h3 id="树">2.5 树</h3><ul><li><p><strong>树</strong></p><p>连通无回路的图称为 <strong>树</strong>，记作 <spanclass="math display">\[T\]</span></p><p>树中度为 1 的顶点称为 <strong>树叶</strong>，2 以上的顶点称为<strong>分支点</strong></p><p>无树叶、无分支点的树称为 <strong>平凡树</strong></p><p>每个连通分支都是树的无回路图称为 <strong>森林</strong></p><p>有如下定理：</p><ul><li><p>对于 <span class="math display">\[n\]</span> 阶 <spanclass="math display">\[m\]</span> 边无向图 <spanclass="math display">\[G\]</span>，树的等价定义：</p><p><span class="math display">\[\quad\begin{align}&amp;G\,是树\\\Harr&amp;G\,中任何两个顶点间有唯一的路径\\\Harr&amp;G\,无圈\and m=n-1\\\Harr&amp;G\,连通\and m=n-1\\\Harr&amp;G\,极小连通\\\Harr&amp;G\,极大无回\end{align}\]</span></p><p><strong>极小连通</strong>：连通且所有边都是桥</p><p><strong>极大无回</strong>：无圈且新增任何边都会产生唯一的圈</p></li><li><p>任何非平凡树都至少有 2 个树叶</p></li></ul></li><li><p><strong>无向树的计数</strong></p><p>用 <span class="math display">\[t_n\]</span> 来表示 <spanclass="math display">\[n(n\ge1)\]</span> 阶非同构无向树的个数</p><p>除了一个点外，其他顶点都是树叶的树称为 <strong>星</strong>。记作<span class="math display">\[S_n=K_{1,n-1}\]</span></p></li><li><p><strong>生成树</strong></p><p>对于图 <span class="math display">\[G\]</span>，若其子图 <spanclass="math display">\[T\]</span> 是树，且包含 <spanclass="math display">\[G\]</span> 中所有顶点，则称 <spanclass="math display">\[T\]</span> 是 <spanclass="math display">\[G\]</span> 的 <strong>生成树</strong></p><p><span class="math display">\[T\]</span> 中的边 <spanclass="math display">\[e\in E(T)\]</span> 称为 <strong>树枝</strong></p><p>不在 <span class="math display">\[T\]</span> 中的边 <spanclass="math display">\[e\in E(G)-E(T)\]</span> 称为<strong>弦</strong></p><p>由弦构成的图称为 <strong>余树</strong>，记为 <spanclass="math display">\[G[E(G)-E(T)]=\overline{T}\]</span></p><p>有如下定理</p><ul><li><p><span class="math display">\[无向图\,G\,连通\HarrG\,有生成树\]</span></p><p>若 <span class="math display">\[G\]</span> 是 <spanclass="math display">\[n\]</span> 阶 <spanclass="math display">\[m\]</span> 边的无向连通图，则 <spanclass="math display">\[m\ge n-1\]</span></p><p>若 <span class="math display">\[T\]</span> 是 <spanclass="math display">\[n\]</span> 阶 <spanclass="math display">\[m\]</span> 边无向连通图的生成树，则 <spanclass="math display">\[|\overline{E(T)}|=m-n+1\]</span></p><p>若 <span class="math display">\[T\]</span> 是无向连通图 <spanclass="math display">\[G\]</span> 的生成树，<spanclass="math display">\[C\]</span> 是 <spanclass="math display">\[G\]</span> 中的圈，则 <spanclass="math display">\[C\]</span> 中必定有弦</p></li><li><p>设 <span class="math display">\[T\]</span> 是连通图 <spanclass="math display">\[G\]</span> 的生成树，<spanclass="math display">\[S\]</span> 是 <spanclass="math display">\[G\]</span> 中的割集，则 <spanclass="math display">\[S\]</span> 中必有树枝</p></li><li><p>设 <span class="math display">\[T\]</span> 是连通图 <spanclass="math display">\[G\]</span> 的生成树，<spanclass="math display">\[e\]</span> 是 <spanclass="math display">\[G\]</span> 的弦，则在 <spanclass="math display">\[T\cup e\]</span> 中存在包含 <spanclass="math display">\[e\]</span> 的圈，且不同的 <spanclass="math display">\[e\]</span> 对应不同的圈</p></li></ul></li><li><p><strong>基本回路</strong></p><p>设 <span class="math display">\[G\]</span> 是 <spanclass="math display">\[n\]</span> 阶 <spanclass="math display">\[m\]</span> 边的无向连通图，<spanclass="math display">\[T\]</span> 是其生成树，<spanclass="math display">\[\overline{T}=\lbracee&#39;_1,e&#39;_2,\dots,e&#39;_{m-n+1}\}\]</span> 是余树</p><p>则 <span class="math display">\[T\cup e&#39;_r\]</span> 中的唯一回路<span class="math display">\[C_r\]</span> 称为<strong>基本回路</strong></p><p>由所有 <span class="math display">\[C_r\]</span> 构成的集合 <spanclass="math display">\[\lbrace C_1,C_2,\dots,C_{m-n+1}\}\]</span> 称为<strong>基本回路系统</strong></p><p>基本回路系统包含的圈的个数称为 <strong>圈秩</strong>：<spanclass="math display">\[\xi(G)=m-n+1\]</span></p><p>有如下定理</p><ul><li>设 <span class="math display">\[T\]</span> 是连通图 <spanclass="math display">\[G\]</span> 的生成树，<spanclass="math display">\[e\]</span> 是其树枝，则 <spanclass="math display">\[G\]</span> 中存在由树枝 <spanclass="math display">\[e\]</span>和其他弦组成的割集，且不同树枝对应不同的割集</li></ul></li><li><p><strong>基本割集</strong></p><p>设 <span class="math display">\[G\]</span> 是 <spanclass="math display">\[n\]</span> 阶 <spanclass="math display">\[m\]</span> 边的无向连通图，<spanclass="math display">\[T=\lbrace e_1,e_2,\dots,e_{n-1}\}\]</span>是其生成树</p><p>则 <span class="math display">\[e_r\]</span> 对应的唯一割集 <spanclass="math display">\[S_r\]</span> 称为 <strong>基本割集</strong></p><p>由所有 <span class="math display">\[S_r\]</span> 构成的集合称为<strong>基本割集系统</strong></p><p><strong>割集的秩</strong>：<spanclass="math display">\[\eta(G)=n-1\]</span></p></li><li><p><strong>生成树的计数</strong></p><p>对于标定图，其生成树的计数记为 <spanclass="math display">\[\tau(G)\]</span>。<spanclass="math display">\[T_1\not= T_2:E(T_1)\not=E(T_2)\]</span></p><p>删除边记为 <span class="math display">\[G-e\]</span>，收缩记为 <spanclass="math display">\[G\setminus e\]</span></p><p>有如下定理：</p><ul><li><p><span class="math display">\[\tau(G)=\tau(G-e)+\tau(G\setminuse)\]</span></p><p>即，<span class="math display">\[\tau(G)\]</span> 是所有不过边 <spanclass="math display">\[e\]</span> 的生成树，加上过边 <spanclass="math display">\[e\]</span> 的生成树</p></li><li><p><span class="math display">\[n\ge2\Rarr\tau(K_n)=n^{n-2}\]</span></p></li></ul></li></ul><h3 id="图的矩阵表示">2.6 图的矩阵表示</h3><ul><li><p><strong>有向图关联矩阵</strong></p><p>设 <span class="math display">\[D=\lang V,E\rang\]</span>是无环有向图，<span class="math display">\[V=\lbracev_1,v_2,\dots,v_n\},\,E=\lbrace e_1,e_2,\dots,e_m\}\]</span></p><p>则关联矩阵 <span class="math display">\[M(D)=[m_{ij}]_{n\timesm}\]</span> 有 <span class="math display">\[m_{ij}=\begin{cases}1,\quadv_i\,是\,e_j\,的起点\\0,\quad v_i\,与\,e_j\,不关联\\-1\,\quadv_i\,是\,e_j\,的终点\end{cases}\]</span></p><p>示范一个关联矩阵：<spanclass="math display">\[M(D)=\begin{align}\begin{bmatrix}-1&amp;-1&amp;1&amp;0&amp;0&amp;0\\1&amp;1&amp;0&amp;1&amp;0&amp;0\\0&amp;0&amp;-1&amp;-1&amp;1&amp;-1\\0&amp;0&amp;0&amp;0&amp;-1&amp;1\end{bmatrix}\end{align}\]</span>，可见每条边都有一个起点和终点</p><p>有向图关联矩阵的性质如下：</p><ul><li><p>每列和为零：<spanclass="math display">\[\sum^n_{i=1}m_{ij}=0\]</span></p></li><li><p>每一行的绝对值的和为 <spanclass="math display">\[d(v)\]</span>：<spanclass="math display">\[d(v_i)=\sum^m_{j=1}m_{ij}\]</span></p><p>其中 <span class="math display">\[1\]</span> 的个数为 <spanclass="math display">\[d^+(v)\]</span>，<spanclass="math display">\[-1\]</span> 的个数为 <spanclass="math display">\[d^-(v)\]</span></p></li><li><p>握手定理（矩阵和为零）：<spanclass="math display">\[\sum^n_{i=1}\sum^m_{j=1}m_{ij}=0\]</span></p></li><li><p>相同的两列是平行边</p></li></ul></li><li><p><strong>无向图的关联矩阵</strong></p><p>设 <span class="math display">\[G=\lang V,E\rang\]</span>是无环无向图，<span class="math display">\[V=\lbracev_1,v_2,\dots,v_n\},\,E=\lbrace e_1,e_2,\dots,e_m\}\]</span></p><p>则关联矩阵 <span class="math display">\[M(G)=[m_{ij}]_{n\timesm}\]</span> 有 <span class="math display">\[m_{ij}=\begin{cases}1,\quadv_i\,与\,e_j\,关联\\0,\quad v_i\,与\,e_j\,不关联\end{cases}\]</span></p><p>无向图关联矩阵有如下性质：</p><ul><li><p>每列和为 <span class="math display">\[2\]</span>：<spanclass="math display">\[\sum^n_{i=1}m_{ij}=2\]</span></p></li><li><p>每一行的绝对值的和为 <spanclass="math display">\[d(v)\]</span>：<spanclass="math display">\[d(v_i)=\sum^m_{j=1}m_{ij}\]</span></p></li><li><p>平行所有 <span class="math display">\[1\]</span> 对应的边构成<strong>断集</strong>：<span class="math display">\[[\lbracev_i\},\overline{\lbrace v_i\}}]\]</span></p></li><li><p>相同的两列是平行边</p></li><li><p>在非连通图中，连通分支能形成对角块，这样的矩阵叫做<strong>伪对角阵</strong></p><p><span class="math display">\[\quadM(G)=\begin{bmatrix}M(G_1)\\&amp;M(G_2)\\&amp;&amp;\ddots\\&amp;&amp;&amp;M(G_i)\end{bmatrix}\]</span></p></li><li><p>无向连通图的图关联矩阵的秩是 <spanclass="math display">\[n-1\]</span>：<spanclass="math display">\[G\,连通\Rarr r(M(G))=n-1\]</span></p><blockquote><p><strong><em>有关矩阵的秩</em></strong></p><p>若矩阵的某一行（列）的元素都是 <spanclass="math display">\[0\]</span>，则该行（列）称为<strong>零行（列）</strong></p><p>对矩阵进行如下变换称为 <strong>初等变换</strong></p><ul><li>对调两行</li><li>将一行的元素全部乘 <spanclass="math display">\[k\,(k\not=0)\]</span></li><li>把某一行元素的 <span class="math display">\[k\,(k\not=0)\]</span>倍加到另一行上</li></ul><p>对一个矩阵进行初等变换后，矩阵中非零行（列）的个数就是该矩阵的<strong>秩</strong>，记为 <span class="math display">\[r(A)\]</span></p><p>对于矩阵 <span class="math display">\[A_{m\times n}\]</span>，若<span class="math display">\[r(A)=m\]</span> 则称为行满秩矩阵，若 <spanclass="math display">\[r(A)=n\]</span> 则称为列满秩矩阵</p></blockquote><p>可知，删除任意顶点后，该关联矩阵变为满秩。那个删除的顶点称为<strong>参考点</strong>，得到的矩阵称为<strong>基本关联矩阵</strong>，记作 <spanclass="math display">\[M_f(G)\]</span></p><p>有以下推论：</p><p><span class="math display">\[\quad G,有\,p\,个连通分支\Rarrr(M_f(G))=n-p\]</span></p><p><span class="math display">\[\quad G\,连通\Harrr(M(G))=r(M_f(G))=n-1\]</span></p></li><li><p>对于连通图 <span class="math display">\[G\]</span>，设 <spanclass="math display">\[M&#39;_f\]</span> 是 <spanclass="math display">\[M(G)\]</span> 中任意 <spanclass="math display">\[n-1\]</span> 列（<spanclass="math display">\[M(G)\]</span> 本就有 <spanclass="math display">\[n-1\]</span> 行）组成的方阵</p><p><span class="math display">\[M&#39;_f=\lbracee_{i1},e_{i2},\dots,e_{i(n-1)}\}\]</span> ，导出子图 <spanclass="math display">\[T=G[\lbracee_{i1},e_{i2},\dots,e_{i(n-1)}\}]\]</span></p><p>则 <spanclass="math display">\[M&#39;_f\,的行列式\,|M&#39;_f|\not=0\HarrT\,是\,G\,的生成树\]</span></p><blockquote><p><strong><em>有关方阵的行列式</em></strong></p><p>行列式是由 <span class="math display">\[n\times n\]</span>的方阵，所有取自不同行不同列的 <span class="math display">\[n\]</span>个元素的不同取法各自乘积的代数和</p><p><span class="math display">\[\quad {\sum_{j_1j_2\dotsj_n}\\}(-1)^{\tau(j_1j_2\dots j_n)}a_{1j_1}a_{1j_2}\dotsa_{1j_n}\]</span></p><p>其中 <span class="math display">\[\tau(j_1j_2\dots j_n)\]</span>是排列 <span class="math display">\[j_1j_2\dots j_n\]</span>的逆序数。<strong>逆序数</strong>是从一个排列中任取两个元素，其组合为逆序的取法的数量。如排列 <spanclass="math display">\[1423\]</span> 中，逆序组合有 <spanclass="math display">\[42、43\]</span>，故逆序数为 <spanclass="math display">\[2\]</span></p><p>举例来说，对于三阶方阵 <spanclass="math display">\[\begin{bmatrix}a_{11}&amp;a_{12}&amp;a_{13}\\a_{21}&amp;a_{22}&amp;a_{23}\\a_{31}&amp;a_{32}&amp;a_{33}\end{bmatrix}\]</span>，其取法有六种（<spanclass="math display">\[123,132,213,231,312,321\]</span>）</p><p>故其行列式为：<spanclass="math display">\[a_{11}a_{22}a_{33}-a_{11}a_{23}a_{32}-a_{12}a_{21}a_{33}+a_{12}a_{23}a_{31}+a_{13}a_{21}a_{32}-a_{13}a_{22}a_{31}\]</span></p><p>对于三阶以上的行列式，正常情况只能通过定义来求解</p></blockquote><p>于是就能用关联矩阵求生成树：</p><ol type="1"><li>忽略环，求关联矩阵</li><li>任选参考点，求出基本关联矩阵</li><li>求所有 <span class="math display">\[n-1\]</span>阶的子方阵，行列式非零的是生成树</li></ol></li></ul></li><li><p><strong>有向图邻接矩阵</strong></p><p>设 <span class="math display">\[D=\lang V,E\rang\]</span>是无环有向图，<span class="math display">\[V=\lbracev_1,v_2,\dots,v_n\},E=\lbrace e_1,e_2,\dots,e_m\}\]</span></p><p>邻接矩阵 <span class="math display">\[A(D)=[a_{ij}]_{n\timesn}\]</span> 有 <spanclass="math display">\[a_{ij}=从\,v_i\,到\,v_j\,的边数\]</span></p><p>有向图邻接矩阵有如下性质：</p><ul><li><p>每一行的和为点的出度：<spanclass="math display">\[\sum^n_{j=1}a_{ij}=d^+(v_i)\]</span></p></li><li><p>每一列的和为点的入度：<spanclass="math display">\[\sum^n_{i=1}a_{ij}=d^-(v_j)\]</span></p></li><li><p>握手定理（矩阵和等于边数）：<spanclass="math display">\[\sum^n_{i=1}\sum^n_{j=1}a_{ij}=\sum^n_{i=1}d^-(v_j)=m\]</span></p></li><li><p>环的个数为：<spanclass="math display">\[\sum^n_{i=1}a_{ii}\]</span></p></li><li><p>若 <span class="math display">\[A^r=A^{r-1}\bulletA,\,(r\ge2),\,A^r=[a^r_{ij}]_{n\times n}\]</span>，<spanclass="math display">\[B^r=A+A^2+\dots+A^r=[b^r_{ij}]_{n\timesn}\]</span></p><p>则 <span class="math display">\[a^r_{ij}\]</span> 表示从 <spanclass="math display">\[v_i\]</span> 到 <spanclass="math display">\[v_j\]</span> 的长度为 <spanclass="math display">\[r\]</span> 的通路总数</p><p><spanclass="math display">\[\sum^n_{i=1}\sum^n_{j=1}a^r_{ij}\]</span>即长度为 <span class="math display">\[r\]</span> 的通路总数，<spanclass="math display">\[\sum^n_{i=1}a^r_{ii}\]</span> 是长度为 <spanclass="math display">\[r\]</span> 的回路总数</p><p>另外 <span class="math display">\[b^r_{ij}\]</span> 表示从 <spanclass="math display">\[v_i\]</span> 到 <spanclass="math display">\[v_j\]</span> 的长度不超过 <spanclass="math display">\[r\]</span> 的通路总数</p><p><spanclass="math display">\[\sum^n_{i=1}\sum^n_{j=1}b^r_{ij}\]</span>即这样的通路总数，<spanclass="math display">\[\sum^n_{i=1}b^r_{ii}\]</span>是这样的回路总数</p></li></ul></li><li><p><strong>有向图可达矩阵</strong></p><p>设 <span class="math display">\[D=\lang V,E\rang\]</span> 是有向图<span class="math display">\[V=\lbrace v_1,v_2,\dots,v_n\}\]</span></p><p>则可达矩阵 <span class="math display">\[P(D)=[p_{ij}]_{n\timesn}\]</span> 有 <spanclass="math display">\[p_{ij}=\begin{cases}1,&amp;从\,v_i\,可达\,v_j\\1,&amp;从\,v_i\,不可达\,v_j\end{cases}\]</span></p><p>可达矩阵的性质：</p><ul><li>主对角线都是 <span class="math display">\[1\]</span></li><li>对于强连通图，所有元素都是 <spanclass="math display">\[1\]</span></li><li>对角块是连通分支的可达矩阵称为伪对角阵</li><li><span class="math display">\[\forall i\not=j,\,p_{ij}=1\Harrb^{n-1}_{ij}&gt;0\]</span></li></ul></li><li><p><strong>无向图相邻矩阵</strong></p><p>设 <span class="math display">\[G=\lang V,E\rang\]</span>是无环无向图，<span class="math display">\[V=\lbracev_1,v_2,\dots,v_n\},E=\lbrace e_1,e_2,\dots,e_m\}\]</span></p><p>相邻矩阵 <span class="math display">\[A(G)=[a_{ij}]_{n\timesn},\,a_{ii}=0\]</span> 有 <spanclass="math display">\[a_{ij}=\begin{cases}1,&amp;v_i\,与\,v_j\,相邻且\,i\not=j\\0,&amp;v_i\,与\,v_j\,不相邻\end{cases}\]</span></p><p>相邻矩阵的性质：</p><ul><li><p><span class="math display">\[A(G)\]</span> 对称：<spanclass="math display">\[a_{ij}=a_{ji}\]</span></p></li><li><p>每行（列）的和为顶点的度：<spanclass="math display">\[\sum^n_{i=1}a_{ij}=d(v_j)\]</span></p></li><li><p>握手定理：<spanclass="math display">\[\sum^n_{i=1}\sum^n_{j=1}a_{ij}=\sum^n_{i=1}d(v_j)=2m\]</span></p></li><li><p>设 <span class="math display">\[A^r=A^{r-1}\bulletA,\,(r\ge2),\,A^r=[a^r_{ij}]_{n\times n}\]</span>，<spanclass="math display">\[B^r=A+A^2+\dots+A^r=[b^r_{ij}]_{n\timesn}\]</span></p><p>则 <span class="math display">\[a^r_{ij}\]</span> 是从 <spanclass="math display">\[v_i\]</span> 到 <spanclass="math display">\[v_j\]</span> 的长度为 <spanclass="math display">\[r\]</span> 的通路总数，<spanclass="math display">\[\sum^n_{i=1}a^r_{ii}\]</span> 即长度为 <spanclass="math display">\[r\]</span> 的回路总数</p><p>有 <span class="math display">\[a^2_{ii}=d(v_i)\]</span></p><p>两点间的最小距离有：<span class="math display">\[G\,连通\Rarr距离\,d(v_i,v_j)=\min\lbrace r|a^r_{ij}\not=0\}\]</span></p></li></ul></li><li><p><strong>连通矩阵</strong></p><p>设 <span class="math display">\[G=\lang V,E\rang\]</span>是无向简单图，<span class="math display">\[V=\lbracev_1,v_2,\dots,v_n\},E=\lbrace e_1,e_2,\dots,e_m\}\]</span></p><p>连通矩阵 <span class="math display">\[P(G)=[p_{ij}]_{n\timesn}\]</span> 有 <spanclass="math display">\[p_{ij}=\begin{cases}1,&amp;若\,v_i\,与\,v_j\,连通\\0,&amp;若\,v_i\,与\,v_j\,不连通\end{cases}\]</span></p><p>连通矩阵的性质：</p><ul><li>主对角线都是 <span class="math display">\[1\]</span></li><li>连通图的所有元素都是 <span class="math display">\[1\]</span></li><li>对角块是连通分支的连通矩阵称为伪对角阵</li><li>若 <spanclass="math display">\[B^r=A+A^2+\dots+A^r=[b^r_{ij}]_{n\timesn}\]</span>，则 <span class="math display">\[\forall i\not=j,\,p_{ij}=1\Harr b^{n-1}_{ij}&gt;0\]</span></li></ul></li></ul><h3 id="平面图">2.7 平面图</h3><ul><li><p><strong>平面图</strong></p><p>边与边不在非顶点处相交（简称不相交）的图称为<strong>平面图</strong>。</p><p>可以画在平面上，使得边与边不在非顶点处相交的图称为<strong>可平面图</strong>。这样的一种画法称为该图的一个<strong>平面嵌入（平面表示）</strong></p><p>相对的，画在曲面上，使得边与边不相交的画法称为<strong>曲面嵌入</strong>；在球面上的画法称为<strong>球面嵌入</strong></p><p>有：<span class="math display">\[可平面嵌入\Harr可球面嵌入\]</span>。让球面嵌入对平面投影，就能得到一个平面嵌入。</p></li><li><p><strong>面</strong></p><p>在平面图中，不含顶点与边的极大连通曲面 <spanclass="math display">\[R\]</span> 称为<strong>区域</strong>。面积无限的区域称为 <strong>外部区域</strong></p><p>与 <span class="math display">\[R\]</span>关联的边和顶点构成的子图称为<strong>区域边界</strong>。区域及该区域边界构成 <strong>面</strong></p><p>面中区域边界的长度 <span class="math display">\[\deg(R)\]</span> 称为<strong>面的次数</strong>。显然 <spanclass="math display">\[\sum^r_{i=1}\deg(R_i)=2m\]</span></p><p>另外，任何平面嵌入的内部面，都可能成为另一种平面嵌入的外部面。</p></li><li><p><strong>极大平面图、极小非平面图</strong></p><p>添加任意一条边后变成非平面图的平面图称为<strong>极大平面图</strong>。<span class="math display">\[K_5\]</span>去掉一条边后就是极大平面图</p><p><span class="math display">\[n(n\ge 3)\]</span>阶简单连通平面图是极大平面图的充要条件是：<spanclass="math display">\[\forall R,\,\deg(R)=3\]</span></p><p>删除任意一条边后变成平面图的非平面图称为<strong>极小非平面图</strong>。<spanclass="math display">\[K_5,\,K_{3,3}\]</span> 就是极小非平面图</p></li><li><p><strong>欧拉公式</strong></p><p>若 <span class="math display">\[G\]</span> 是平面图，则 <spanclass="math display">\[n-m+r=2\]</span>，其中 <spanclass="math display">\[r\]</span> 是 <spanclass="math display">\[G\]</span> 的面数</p><p>欧拉公式的推广形式：若 <span class="math display">\[G\]</span>是平面图，则 <span class="math display">\[n-m+r=1+p\]</span>，其中 <spanclass="math display">\[r\]</span> 是 <spanclass="math display">\[G\]</span> 的面数，<spanclass="math display">\[p\]</span> 是 <spanclass="math display">\[G\]</span> 的连通分支数</p><p>于是有以下定理</p><ul><li><p>若 <span class="math display">\[G\]</span> 是连通平面图，且各面次数至少是 <spanclass="math display">\[\ell(\ell\ge3)\]</span>，则 <spanclass="math display">\[m\le\dfrac{(n-2)\ell}{\ell-2}\]</span></p></li><li><p>若 <span class="math display">\[G\]</span> 是有 <spanclass="math display">\[p\]</span> 个连通分支的连通平面图，各面次数至少是 <spanclass="math display">\[\ell(\ell\ge3)\]</span>，则 <spanclass="math display">\[m\le\dfrac{(n-p-1)\ell}{\ell-2}\]</span></p></li><li><p>若 <span class="math display">\[n(n\ge 3)\]</span> 阶简单平面图<span class="math display">\[G\]</span> 有 <spanclass="math display">\[m\]</span> 条边，则 <spanclass="math display">\[m\le 3n-6\]</span></p><p>若 <span class="math display">\[G\]</span> 是简单极大平面图，则 <spanclass="math display">\[m=3n-6\]</span></p></li><li><p>若 <span class="math display">\[G\]</span> 是简单平面图，则 <spanclass="math display">\[\delta(G)\le 5\]</span></p></li></ul></li><li><p><strong>同胚</strong></p><p>插入 <span class="math display">\[2\]</span> 度顶点：把 <spanclass="math display">\[(u,v)\]</span> 变成 <spanclass="math display">\[(u,w),\,(w,v)\]</span></p><p>删除 <span class="math display">\[2\]</span> 度顶点：<spanclass="math display">\[\deg(w)=2\]</span>，把 <spanclass="math display">\[(u,w),\,(w,v)\]</span> 变成 <spanclass="math display">\[(u,v)\]</span></p><p>反复删除或插入 <span class="math display">\[2\]</span>度顶点后同构，则称两个平面图 <strong>同胚</strong></p><p>有如下定理：</p><ul><li><span class="math display">\[图\,G\,是平面图\HarrG\,没有与\,K_5\,或\,K_{3,3}\,同胚的子图\]</span></li><li><span class="math display">\[图\,G\,是平面图\HarrG\,没有可以边收缩到\,K_5\,或\,K_{3,3}\,的子图\]</span></li></ul></li><li><p><strong>对偶图</strong></p><p>设平面图 <span class="math display">\[G=\lang V,E\rang\]</span>，其面集合是 <span class="math display">\[R\]</span></p><p>另有 <span class="math display">\[G^*=\langV^*,E^*\rang\]</span>，面集合为 <spanclass="math display">\[R^*\]</span>，若 <spanclass="math display">\[V^*\]</span> 与 <spanclass="math display">\[R\]</span>、<spanclass="math display">\[E^*\]</span> 与 <spanclass="math display">\[E\]</span> 可以一一对应，则 <spanclass="math display">\[G^*\]</span> 与 <spanclass="math display">\[G\]</span> 是 <strong>对偶图</strong></p><p>对偶图有如下性质：</p><ul><li>对偶图必定是连通平面图</li><li>环与桥相互对偶</li><li>平行边对偶于 2 个面之间的多条边界</li><li><span class="math display">\[n^*=r,\,m^*=m\]</span></li><li><span class="math display">\[r*=n-p+1\]</span></li><li><spanclass="math display">\[d_{G^*}(v_i^*)=\deg_G(R_i)\]</span></li><li>即使 <span class="math display">\[G_1\cong G_2\]</span> 也不能得出<span class="math display">\[G_1^*\cong G_2^*\]</span></li><li><span class="math display">\[G\,连通\Harr G\congG^{**}\]</span></li></ul></li><li><p><strong>外（可）平面图</strong></p><p>若平面图所有的顶点都在一个面的边界上，则称其为<strong>外平面图</strong></p><ul><li>充要条件：<span class="math display">\[G\,是外平面图\HarrG\,不含与\,K_4\,或\,K_{2,3}\,同构的子图\]</span></li></ul></li><li><p><strong>极大外平面图</strong></p><p>加入任意边后不是外平面图的简单外平面图称为<strong>极大外平面图</strong></p><ul><li><p>充要条件：</p><p>对于 <span class="math display">\[n(n\ge3)\]</span> 阶外平面图 <spanclass="math display">\[G\]</span>，其所有顶点在外部面边界上，则</p><p><span class="math display">\[\quad\begin{align}&amp;G\,是极大外平面图\\\Harr&amp;G\,外部面边界是\,n\frac{}{}圈、内部面边界是\,3\frac{}{}圈\end{align}\]</span></p></li><li><p>必要条件</p><p>对于 <span class="math display">\[n(n\ge3)\]</span> 阶外平面图 <spanclass="math display">\[G\]</span>，其所有顶点在外部面边界上，则其具有以下性质</p><ul><li><span class="math display">\[G\]</span> 有 <spanclass="math display">\[n-2\]</span> 个内部面</li><li><span class="math display">\[m=2n-3\]</span></li><li>至少有 <span class="math display">\[3\]</span> 个顶点的度数 <spanclass="math display">\[\le3\]</span></li><li>至少有 <span class="math display">\[2\]</span> 个顶点的度数 <spanclass="math display">\[=2\]</span></li><li><span class="math display">\[\kappa=2\]</span></li></ul></li></ul></li><li><p><strong>平面哈密顿图</strong></p><p>有如下定理：</p><ul><li><p><span class="math display">\[4\]</span>连通平面图是哈密顿图</p></li><li><p>对于 <span class="math display">\[n\]</span>阶简单平面哈密顿图，哈密顿回路内部次数为 <spanclass="math display">\[i\]</span> 的面数 <spanclass="math display">\[r_i&#39;\]</span>，外部为 <spanclass="math display">\[r_i&#39;&#39;\]</span>，则有</p><p><spanclass="math display">\[\quad\sum^n_{i=3}(i-2)(r_i&#39;-r_i&#39;&#39;)=0\]</span></p></li></ul></li></ul><h3 id="着色">2.8 着色</h3><ul><li><p><strong>点着色</strong></p><p>给无环图的每个顶点指定一种颜色，使得所有相邻顶点拥有不同颜色。</p><p>颜色集记为 <span class="math display">\[C=\lbrace1,2\dots,k\}\]</span>，则着色 <span class="math display">\[f:V\rarrC,\,\forall u\forall v(u,v\in V\and u\,与\,v\,相邻\rarr f(u)\not=f(v))\]</span></p><p>颜色集的大小 <span class="math display">\[|C|=k\]</span> 则称为<strong>k-着色</strong></p><p>可以 k-着色 但不能 k-1着色的图称为<strong>k-色图</strong>，着色所需的最少颜色数称为<strong>色数</strong></p><p><strong>点色数</strong>记为 <spanclass="math display">\[\chi(G)\]</span>，<strong>边色数</strong> <spanclass="math display">\[\chi&#39;(G)\]</span>，<strong>面色数</strong><span class="math display">\[\chi^*(G)\]</span></p><p>点色数的性质：</p><ul><li><p><span class="math display">\[\chi(G)=1\HarrG\,是零图\]</span></p></li><li><p><span class="math display">\[\chi(K_n)=n\]</span></p></li><li><p><span class="math display">\[\chi(G)=2\HarrG\,是非零图的二部图\]</span></p></li><li><p><span class="math display">\[G\,可以\,2\frac{}{}着色\HarrG\,是二部图\Harr G\,无奇圈\]</span></p></li><li><p><spanclass="math display">\[\chi(C_n)=\begin{cases}2,&amp;n\,是偶数\\3,&amp;n\,是奇数\end{cases}\]</span></p></li><li><p><spanclass="math display">\[\chi(W_n)=\begin{cases}4,&amp;n\,是偶数\\3,&amp;n\,是奇数\end{cases}\]</span></p></li><li><p><spanclass="math display">\[\chi(G)\le\Delta(G)+1\]</span></p></li><li><p><spanclass="math display">\[n(n\ge3)阶非完全图\,G\,非奇圈\Rarr\chi(G)\le\Delta(G)\]</span></p></li><li><p>对图 <span class="math display">\[G\]</span> 进行着色，设 <spanclass="math display">\[V_i=\lbrace v|v\in V(G)\andv\,着同色\,i\},\,i=1,2,\dots,\chi(G)\]</span></p><p>则 <span class="math display">\[\Pi=\lbraceV_1\,V_2\,\dots\,V_{\chi(G)}\}\]</span> 是 <spanclass="math display">\[V(G)\]</span> 的划分。<spanclass="math display">\[V_i\]</span> 中的点构成独立集</p><p>设 <span class="math display">\[R=\lbrace (u,v)|u,v\in V(G)\andu,v\,着同色\}\]</span>，则 <span class="math display">\[R\]</span> 是<span class="math display">\[V(G)\]</span> 上的等价关系</p></li></ul></li><li><p><strong>色多项式</strong></p><p>若标定图中至少有一个顶点着色不同，我们认为其是不同的着色</p><p>色多项式 <spanclass="math display">\[f(G,k)=图\,G\,的不同的\,k\frac{}{}着色的总数\]</span></p><p>对于完全图：<spanclass="math display">\[f(K_n,k)=k(k-1)\dots(k-n+1)=f(K_{n-1},k)(k-n+1)\]</span></p><p>对于零图：<span class="math display">\[f(N_n,k)=k^n\]</span></p><p>色多项式的递推公式：</p><ul><li><p>若 <span class="math display">\[e\]</span> 是 <spanclass="math display">\[G\]</span> 中的边，则 <spanclass="math display">\[f(G,k)=f(G-e,k)-f(G\setminuse,k)\]</span></p></li><li><p>若 <span class="math display">\[e\]</span> 不是 <spanclass="math display">\[G\]</span> 中的边，则 <spanclass="math display">\[f(G,k)=f(G\cup e,k)+f(G\setminuse,k)\]</span></p><p>以此法多次递推后，最终能得到一群完全图。故有</p><p><spanclass="math display">\[f(G,k)=f(K_{n1},k)+f(K_{n2},k)+\dots+f(K_{nr},k)\]</span>，<spanclass="math display">\[\chi(G)=\min(n1,n2,\dots,nr)\]</span></p></li></ul><p>色多项式的性质：</p><ul><li><p><span class="math display">\[f(G,k)\]</span> 是 <spanclass="math display">\[n\]</span> 次多项式，系数正负号交替</p><p><span class="math display">\[k^n\]</span> 系数为 <spanclass="math display">\[1\]</span>，<spanclass="math display">\[k^{n-1}\]</span> 系数为 <spanclass="math display">\[-m\]</span>，<spanclass="math display">\[m\]</span> 为边数，常数项为 <spanclass="math display">\[0\]</span></p><p>最低非零项为 <span class="math display">\[k^p\]</span>，<spanclass="math display">\[p\]</span> 是连通分支数。</p><p>不同的连通分支相乘</p></li><li><p><span class="math display">\[T\,是\,n\,阶树\Harrf(T,k)=k(k-1)^{n-1}\]</span></p><p><span class="math display">\[C\,是\,n\,阶圈\Rarrf(C,k)=(k-1)^n+(-1)*n(k-1)\]</span></p></li><li><p>设 <span class="math display">\[V_1\]</span> 是 <spanclass="math display">\[G\]</span> 的点割集，且 <spanclass="math display">\[G[V_1]\]</span> 是 <spanclass="math display">\[G\]</span> 的完全子图 <spanclass="math display">\[K_{|V1|}\]</span></p><p>若 <span class="math display">\[G-V_1\]</span> 有 <spanclass="math display">\[p\]</span> 个连通分支 <spanclass="math display">\[G_1,G_2,\dots,G_p(p\ge2)\]</span>，且 <spanclass="math display">\[H_i=G[V_1\cup V(G_i)]\]</span></p><p>则 <spanclass="math display">\[f(G,k)=\dfrac{\Pi^p_{i=1}f(H_i,k)}{f(G[V_1],k)^{p-1}}\]</span></p></li></ul></li><li><p><strong>地图</strong></p><p>连通无桥平面图的平面嵌入及其所有的面称为<strong>地图</strong>。平面地图的面称为 <strong>国家</strong>。</p><p>若两个国家的公共边界至少有一条公共边，称两个国家<strong>相邻</strong></p><p>有：<span class="math display">\[地图\,G\,能\,k\frac{}{}面着色\Harr对偶图\,G^*\,能\,k\frac{}{}点着色\]</span></p><p>以及：<spanclass="math display">\[连通无环平面图\,G\,能\,k\frac{}{}面着色\Harr对偶图\,G^*\,能\,k\frac{}{}点着色\]</span></p><p>五色定理：任何平面图都可以 5-着色</p></li><li><p><strong>边着色</strong></p><p>给无环图的每条边指定一种颜色，使得所有相邻边拥有不同颜色。</p><p>有以下定理：</p><ul><li><p><span class="math display">\[G\,是简单图\Rarr\Delta(G)\le\chi&#39;(G)\le\Delta(G)+1\]</span></p></li><li><p><span class="math display">\[G\,是二部图\Rarr\Delta(G)=\chi&#39;(G)\]</span></p></li><li><p>对于完全图：<spanclass="math display">\[\chi&#39;(K_n)=\begin{cases}n,&amp;n\,为奇数\\n-1&amp;n\,为偶数\end{cases}\]</span></p></li><li><p>对图 <span class="math display">\[G\]</span> 进行 k-边着色，<spanclass="math display">\[k\ge\chi&#39;(G)\]</span></p><p>令 <span class="math display">\[R=\lbrace(e_i,e_j)|e_i\,与\,e_j\,着同色\,i\}\]</span>，则 <spanclass="math display">\[R\]</span> 是 <spanclass="math display">\[V(G)\]</span> 上的等价关系</p><p>商集合 <span class="math display">\[E/R=\lbraceE_1,E_2,\dots,E_k\}\]</span> 是 <span class="math display">\[E\]</span>的划分，划分块中的元素着同色。同色边构成边独立集</p></li></ul></li></ul><h3 id="支配集点覆盖集点独立集">2.9 支配集、点覆盖集、点独立集</h3><ul><li><p><strong>支配集</strong></p><p>对于 <span class="math display">\[G=\lang V,E\rang\]</span>，存在<span class="math display">\[e=(u,v)\in E\]</span>，则称 <spanclass="math display">\[u\]</span> <strong>支配</strong> <spanclass="math display">\[v\]</span>（<spanclass="math display">\[v\]</span> 支配 <spanclass="math display">\[u\]</span>）</p><p>若 <span class="math display">\[V^*\subseteq V\]</span> 有 <spanclass="math display">\[\forall u\in V-V^*\rarr \exist v\inV^*,\,u\,支配\,v\]</span>，则称 <spanclass="math display">\[V^*\]</span> 是 <strong>支配集</strong></p><p>真子集都非支配集的支配集称为 <strong>极小支配集</strong></p><p>顶点数最少的支配集称为<strong>最小支配集</strong>。最小支配集的顶点数 <spanclass="math display">\[\gamma_0(G)\]</span> 为<strong>支配数</strong></p><p>有如下定理：</p><ul><li>若无向图 <span class="math display">\[G\]</span> 无孤立点，<spanclass="math display">\[V^*_1\]</span> 是极小支配集，则存在极小支配集<span class="math display">\[V_2^*\]</span>，且 <spanclass="math display">\[V_1^*\cap V_2^*=\empty\]</span></li></ul></li><li><p><strong>独立集</strong></p><p>对于 <span class="math display">\[G=\lang V,E\rang\]</span>，若 <spanclass="math display">\[V^*\subseteq V,\,\forall u,v\inV^*,\,u\,与\,v\,不相邻\]</span>，则称 <spanclass="math display">\[V^*\]</span> 是 <strong>独立集</strong></p><p>真母集都非独立集的独立集称为 <strong>极大独立集</strong></p><p>定点树最多的独立集称为<strong>最大独立集</strong>，最大独立集的顶点数 <spanclass="math display">\[\beta_0(G)\]</span> 为<strong>点独立数</strong></p><p>有如下定理：</p><ul><li>对于无向图 <span class="math display">\[G\]</span>，<spanclass="math display">\[V^*\,是极大独立集\RarrV^*\,是极小支配集\]</span></li><li>对于无向图 <span class="math display">\[G\]</span>，<spanclass="math display">\[\gamma_0(G)\le \beta_0(G)\]</span></li></ul></li><li><p><strong>团</strong></p><p>对于 <span class="math display">\[G=\lang V,E\rang\]</span>，若 <spanclass="math display">\[V^*\subseteq V\]</span>，且 <spanclass="math display">\[G[V^*]\]</span> 是完全子图，则称 <spanclass="math display">\[V^*\]</span> 是 <strong>团</strong></p><p>真母集都不是团的团称为 <strong>极大团</strong></p><p>顶点数最多的团称为 <strong>最大团</strong>，最大团的顶点数 <spanclass="math display">\[\nu_0(G)\]</span> 为 <strong>团数</strong></p><p>有如下定理：</p><ul><li><p>对于无向图 <span class="math display">\[G\]</span>，<spanclass="math display">\[V^*\,是\,G\,的团\HarrV^*\,是\,\overline{G}\,的独立集\]</span></p></li><li><p>对于无向图 <span class="math display">\[G\]</span>，<spanclass="math display">\[\nu_0(G)=\beta_0(\overline{G})\]</span></p><p><span class="math display">\[V^*\,是\,G\,的极大(最大)团\HarrV^*\,是\,\overline{G}\,的极大(最大)独立集\]</span></p></li></ul></li><li><p><strong>点覆盖</strong></p><p>对于 <span class="math display">\[G=\lang V,E\rang\]</span>，若 <spanclass="math display">\[V^*\subseteq V\]</span>，且 <spanclass="math display">\[\forall e\in E\]</span>，都有 <spanclass="math display">\[\exist v\in V^*,\,v\,关联\,e\]</span>，则称 <spanclass="math display">\[V^*\]</span> 是 <strong>点覆盖</strong></p><p>真子集都非点覆盖的点覆盖称为 <strong>极小点覆盖</strong></p><p>顶点数最小的点覆盖称为 <strong>最小点覆盖</strong>，其顶点数 <spanclass="math display">\[\alpha_0(G)\]</span> 为<strong>点覆盖数</strong></p><p>有如下定理：</p><ul><li><p>对于无向图 <spanclass="math display">\[G\]</span>，若其无孤立点，则其点覆盖是支配集。否则，点覆盖加所有孤立点就是支配集</p><p>有 <spanclass="math display">\[\gamma_0(G)\le\alpha_0(G)\]</span></p></li><li><p>对于无向图 <spanclass="math display">\[G\]</span>，若其无孤立点，则 <spanclass="math display">\[V^*\,是点覆盖\Harr V-V^*\,是独立集\]</span></p><p>且 <span class="math display">\[V^*\,是最小(极小)点覆盖\HarrV-V^*\,是最小(极小)独立集\]</span></p><p>此时 <spanclass="math display">\[\alpha_0+\beta_0=n\]</span></p></li><li><p><spanclass="math display">\[\alpha_0,\beta_0,\nu_0,\gamma_0\]</span>之间的关系：</p><ul><li><spanclass="math display">\[\alpha_0+\beta_0=n\]</span>（无孤立点时）</li><li><span class="math display">\[\gamma_0\le\beta_0\]</span></li><li><spanclass="math display">\[\gamma_0\le\alpha_0\]</span>（无孤立点时）</li><li><spanclass="math display">\[\nu_0(G)=\beta_0(\overline{G})\]</span></li><li><span class="math display">\[\alpha_0,\beta_0,\nu_0\]</span>都是难解的</li></ul></li></ul></li></ul><h3 id="边覆盖匹配">2.10 边覆盖、匹配</h3><ul><li><p><strong>边覆盖</strong></p><p>对于 <span class="math display">\[G=\lang V,E\rang\]</span>，若 <spanclass="math display">\[E^*\subseteq E\]</span>，且 <spanclass="math display">\[\forall v\in V\]</span> 都有 <spanclass="math display">\[\exist e\in E,\,e\,关联\,v\]</span>，则 <spanclass="math display">\[E^*\]</span> 是 <strong>边覆盖</strong></p><p>真子集都非边覆盖的边覆盖称为 <strong>极小边覆盖</strong></p><p>边数最小的边覆盖称为 <strong>最小边覆盖</strong>，其边数 <spanclass="math display">\[\alpha_1(G)\]</span> 为<strong>边覆盖数</strong></p></li><li><p><strong>匹配</strong></p><p>对于无向图 <span class="math display">\[G=\langV,E\rang\]</span>，<span class="math display">\[E^*\subseteqE\]</span>，若 <span class="math display">\[\forall e,f\in E^*\]</span>且 <span class="math display">\[e,f\]</span> 不相邻，则 <spanclass="math display">\[E^*\]</span> 是 <strong>匹配</strong></p><p>真母集都非匹配的匹配称为 <strong>极大匹配</strong></p><p>边数最多的匹配称为 <strong>最大匹配</strong>，其边数 <spanclass="math display">\[\beta_1(G)\]</span> 称为<strong>匹配数</strong></p><p>匹配中关联的顶点称为 <strong>饱和点</strong>，此外的顶点称为<strong>非饱和点</strong></p><p>没有非饱和点的匹配称为 <strong>完美匹配</strong></p><p>有如下定理：</p><ul><li><p><span class="math display">\[G\,有完美匹配\Harr\forallV&#39;\subset V(G),p_奇(G-V&#39;)\le|V&#39;|\]</span></p><p>其中 <span class="math display">\[p_奇\]</span>是奇数阶的连通分支数</p><p>（推论）无桥的 3-正则图 有完美匹配</p></li><li><p>对于无孤立点的无向图 <spanclass="math display">\[G\]</span>，定有 <spanclass="math display">\[\alpha_1+\beta_1=n\]</span></p><p>设 <span class="math display">\[M\]</span>是其最大匹配，其所有非饱和点 <span class="math display">\[v\]</span>各取一条关联边组成边集 <span class="math display">\[N\]</span>，则 <spanclass="math display">\[W=M\cup N\]</span> 是最小边覆盖</p><p>设 <span class="math display">\[W_1\]</span> 是其最小边覆盖，若 <spanclass="math display">\[W_1\]</span>中有邻边即删除其中一边，直至无邻边。设那些删除的边为 <spanclass="math display">\[N_1\]</span>，则 <spanclass="math display">\[M_1=W_1-N_1\]</span> 为最大匹配</p></li><li><p>若无向图 <span class="math display">\[G\]</span> 无孤立点，<spanclass="math display">\[M\]</span> 是其匹配，<spanclass="math display">\[N\]</span> 是其点覆盖，<spanclass="math display">\[Y\]</span> 是独立集，<spanclass="math display">\[W\]</span> 是边覆盖，则</p><ul><li><span class="math display">\[|M|\le|W|\]</span>。若 <spanclass="math display">\[|M|=|W|\]</span>，则 <spanclass="math display">\[M\]</span> 是完美匹配，<spanclass="math display">\[W\]</span> 是最小边覆盖</li><li><span class="math display">\[|M|\le|N|\]</span>。若 <spanclass="math display">\[|M|=|N|\]</span>，则 <spanclass="math display">\[M\]</span> 是最大匹配，<spanclass="math display">\[N\]</span> 是最小点覆盖</li><li><span class="math display">\[|Y|\le|W|\]</span>。若 <spanclass="math display">\[|Y|=|W|\]</span>，则 <spanclass="math display">\[Y\]</span> 是最大独立集，<spanclass="math display">\[W\]</span> 是最小边覆盖</li><li><span class="math display">\[\beta_1\le\alpha_0\]</span>，<spanclass="math display">\[\beta_0\le\alpha_1\]</span></li></ul></li><li><p><spanclass="math display">\[\alpha_0,\beta_0,\nu_0,\gamma_0,\alpha_1,\beta_1\]</span>之间的关系：</p><ul><li><spanclass="math display">\[\gamma_0\le\alpha_0\quad\gamma_0\le\beta_0\quadn=\alpha_0+\beta_0\]</span></li><li><spanclass="math display">\[\nu_0(\overline{G})=\beta_0(G)\le\alpha_1\quad\alpha_1+\beta_1=n\]</span></li><li><span class="math display">\[\beta_1\le\alpha_1\quad\beta_1\le\alpha_0\]</span></li><li><span class="math display">\[\alpha_1,\beta_1\]</span>是容易计算的</li></ul></li></ul></li><li><p><strong>交错路径</strong></p><p>在匹配中和匹配外交替选取边的路径称为 <strong>交错路径</strong></p><p>两个端点都是非饱和点的交错路径称为<strong>可增广（交错）路径</strong></p><p>有如下定理：</p><ul><li><p>设 <span class="math display">\[M_1,M_2\]</span> 是 <spanclass="math display">\[G\]</span> 中的不同匹配，则 <spanclass="math display">\[G[M_1\oplus M_2]\]</span> 的每个连通分支是 <spanclass="math display">\[M_1,M_2\]</span>中的边组成的交错圈或交错路径</p></li><li><p>设 <span class="math display">\[M\]</span> 是 <spanclass="math display">\[G\]</span> 中的匹配，<spanclass="math display">\[\Gamma\]</span> 是 <spanclass="math display">\[M\]</span> 的可增广路径，则 <spanclass="math display">\[M&#39;=M\oplus E(\Gamma)\]</span> 也是匹配，且<span class="math display">\[|M&#39;|=|M|+1\]</span></p><p>这个定理可以求出最大匹配</p><p><span class="math display">\[M\,是\,G\,中的最大匹配\HarrG\,中无\,M\,的可增广路径\]</span></p></li></ul></li><li><p><strong>二部图的匹配</strong></p><p>对于二部图 <span class="math display">\[G=\langV_1,V_2,E\rang,\,|V_1|\le|V_2|\]</span>，若匹配 <spanclass="math display">\[M\]</span> 有 <spanclass="math display">\[|M|=|V_1|\]</span> 则称其为<strong>完备匹配</strong></p><p>有如下定理：</p><ul><li><p><span class="math display">\[二部图\,G\,有完美匹配\HarrG\,满足霍尔条件\]</span></p><p><strong>霍尔条件</strong>（相异性条件）：<spanclass="math display">\[\forall S\subseteqV_1,\,|S|\le|N(S)|\]</span>。<span class="math display">\[N(S)=\lbraceu|\exist v\in S,(v,u)\in E\}=\bigcup_{v\in S}\Gamma(v)\]</span></p><p>换句话说，对于较少顶点侧的任意点集，其对应的另一侧点集大小不少于该点集大小</p></li><li><p><span class="math display">\[二部图\,G\,有完美匹配\RarrG\,满足\,t\frac{}{}条件\]</span></p><p><strong>t-条件</strong>：二部图 <span class="math display">\[G=\langV_1,V_2,E\rang,\,t\ge1\]</span>。<spanclass="math display">\[V_1\]</span>的每个顶点<font color="RED">至少</font>关联 t 条边，且 <spanclass="math display">\[V_2\]</span>的每个顶点<font color="RED">至多</font>关联 t 条边</p></li><li><p>k-正则二部图存在 k 个边不重的完备匹配</p></li><li><p>二部图 <span class="math display">\[G=\langV_1,V_2,E\rang\]</span> 无孤立点，则 <spanclass="math display">\[\alpha_0=\beta_1\]</span></p></li></ul></li></ul><h3 id="带权图">2.11 带权图</h3><ul><li><p><strong>带权图</strong></p><p>对于图 <span class="math display">\[G=\lang V,E,W\rang,\,W:E\rarrR\]</span>。其中 <span class="math display">\[W(e)\]</span> 称为图的<strong>权</strong></p></li><li><p><strong>有效算法</strong></p><p>复杂度是多项式函数的算法称为 <strong>有效算法</strong></p><p>如 O(n)、O(n<sup>3</sup>)、O(n㏒n)等复杂度都是有效算法。O(2<sup>n</sup>) 等不是有效算法</p><p>有多项式复杂度算法的问题称为 <strong>易解问题</strong>，否则称为<strong>难解问题</strong></p></li><li><p><strong>中国邮递员问题</strong></p><p>对于一个带权图，求经过所有边的最短回路</p><p>中国邮递员问题是一个易解问题。方法如下：</p><ol type="1"><li>求该带权图 <span class="math display">\[G\]</span>的所有奇数度顶点间的短程线。这些顶点和短程线构成带权完全图 <spanclass="math display">\[K\]</span></li><li>求出 <span class="math display">\[K\]</span> 的最小完美匹配 <spanclass="math display">\[M\]</span></li><li>用 <span class="math display">\[M\]</span> 给 <spanclass="math display">\[G\]</span> 沿短程线加边得到 <spanclass="math display">\[G^*\]</span>，<spanclass="math display">\[G^*\]</span> 的欧拉回路 <spanclass="math display">\[\Gamma\]</span> 就是答案</li></ol></li><li><p><strong>货郎问题</strong></p><p>对于一个带权图，求经过所有顶点的最短回路</p><p>货郎问题是一个难解问题</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础课目</tag>
      
      <tag>数学</tag>
      
      <tag>离散数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Go&gt;9 反射、网络编程</title>
    <link href="/2022/07/25/Go/9%20%E5%8F%8D%E5%B0%84%E3%80%81%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/07/25/Go/9%20%E5%8F%8D%E5%B0%84%E3%80%81%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="反射网络编程">9 反射、网络编程</h1><h2 id="反射">9.1 反射</h2><p>反射可以在运行时动态获取变量信息，包括类型、类别。如果是结构体，还能获取其字段、方法。</p><p>通过反射，可以操作任意类型的对象。可以修改变量的值，调用关联的方法。</p><p>变量相关的内容包含在 reflect 包中</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;reflect&quot;</span></code></pre></div><h3 id="reflect.value">reflect.Value</h3><p>在 reflect.Value 结构体中，包含了与变量相关的信息</p><p><strong>相关函数</strong></p><ul><li><p><code>ValueOf(i interface&#123;&#125;) Value</code>：返回指定对象的reflect.Value 结构体</p><div class="code-wrapper"><pre><code class="hljs go">i := <span class="hljs-number">100</span>v := reflect.ValueOf(i)</code></pre></div></li><li><p><code>(v Value) Elem() Value</code>：返回该指针对象指向的对象的reflect.Value 结构体</p></li><li><p><code>(v Value) Int() int</code>：获取该对象包含的 int 值。</p><p>对象本身不是 int、int 64... 时，会产生 panic</p><p>其余类型也有对应方法，如：<code>Bool() bool</code> 等</p></li><li><p><code>(v Value) SetInt(i int)</code>：将对象包含的 int值改为指定的值</p><p>其余类型也有对应方法，如：<code>SetBool(b bool)</code> 等</p><p>通用方法<code>(v Value) Set(i Value)</code>：将对象包含的值改为指定的值</p><p><strong>对象必须是一个指针类型的 Value，用 Elem()方法获取的值：</strong></p><div class="code-wrapper"><pre><code class="hljs go">i := <span class="hljs-number">1</span>v := reflect.ValueOf(&amp;i)v.Elem().SetInt(<span class="hljs-number">1000</span>)fmt.Println(i)<span class="hljs-comment">// 1000</span><span class="hljs-keyword">type</span> A <span class="hljs-keyword">struct</span>&#123; i <span class="hljs-type">int</span> &#125;a := A&#123;<span class="hljs-number">0</span>&#125;b := A&#123;<span class="hljs-number">-100</span>&#125;v := reflect.ValueOf(&amp;a)v.Elem().Set(reflect.ValueOf(&amp;b).Elem())fmt.Println(a)<span class="hljs-comment">// &#123;-100&#125;</span></code></pre></div></li><li><p><code>(v Value) Method(i int) Value</code>：获得结构体的第 i个方法</p><p>方法是依据其方法名字符的 ASCII 码按照<strong>字典顺序进行排序</strong> 的。</p><p>只有首字母大写的方法才被计入</p><p><code>(v Value) NumMethod() int</code>：获得该结构体的方法数量</p><p><code>(v Value) MethodByName(name string) Value</code>：按标识符获得结构体的方法</p></li><li><p><code>(v Value) Field(i int) Value</code>：返回结构体的第 i个字段。也是字典顺序。</p><p><code>(v Value) NumField() int</code>：获得该结构体的字段数量</p><p><code>(v Value) FieldByName(name string) Value</code>：按标识符获得结构体的字段</p></li><li><p><code>(v Value) Call(in []Value) []Value</code>：传入指定参数，并调用这个方法</p></li></ul><p><strong>Value 的转换：</strong></p><p>变量、interface{}、reflect.Value 是可以相互转换的：</p><pre><code class=" mermaid">graph LRA(变量) --赋值---&gt; B(interface) --ValueOf 函数---&gt; C(reflect.Value)C --Interface 方法---&gt; B --类型断言---&gt; A</code></pre><p>interface{} 通过 reflect.ValueOf() 函数转换为 reflect.Value</p><p>reflect.Value 通过 Interface() 方法转换为 interface{}</p><p>而 interface{} 通过类型断言可以转换为原本变量类型</p><div class="code-wrapper"><pre><code class="hljs go">i := <span class="hljs-number">100</span><span class="hljs-comment">// i 的类型是 int</span>iv := reflect.ValueOf(i)<span class="hljs-comment">// iv 的类型是 reflect.Value</span>ii := iv.Interface()<span class="hljs-comment">// ii 的类型是 interface&#123;&#125;</span>i0 := ii.(<span class="hljs-type">int</span>)<span class="hljs-comment">// i0 的类型是 int</span>fmt.Println(i, iv, ii, i0)<span class="hljs-comment">// 100 100 100 100</span></code></pre></div><h3 id="reflect.type">reflect.Type</h3><p>在 reflect.Type 接口中，包含了与类型相关的信息</p><p><strong>相关函数</strong></p><ul><li><p><code>TypeOf(i interface&#123;&#125;) Type</code>：返回指定对象的reflect.Type 接口</p><div class="code-wrapper"><pre><code class="hljs go">i := <span class="hljs-number">100</span>t := reflect.TypeOf(i)</code></pre></div></li><li><p><code>(v Value) Type() Type</code>：返回该 Value 的对象的 Type接口</p></li><li><p><code>(t Type) Name() string</code>：返回指定对象的类型</p></li><li><p><code>(t Type) Field(i int)</code>：获取该结构体的第 i 个字段</p><p>获取这个字段的 tag：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> A <span class="hljs-keyword">struct</span> &#123;I <span class="hljs-type">int</span> <span class="hljs-string">`json:&quot;tag_of_A_I&quot;`</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a := A&#123;<span class="hljs-number">1</span>&#125;t := reflect.TypeOf(a)fmt.Println(t.Field(<span class="hljs-number">0</span>).Tag.Get(<span class="hljs-string">&quot;json&quot;</span>))<span class="hljs-comment">// tag_of_A_I</span>&#125;</code></pre></div></li><li><p><code>New (t Type) Value</code>：这是 reflect包下的一个函数。</p><p>创建一个指定类型的变量，其值为 <strong>该类型的零值</strong> 的<strong>指针</strong>。</p></li></ul><h3 id="reflect.kind">reflect.Kind</h3><p>reflect.Kind 是一组常量，其指示了一些类别。</p><p><strong>相关函数</strong></p><ul><li><p><code>(v Value) Kind() Kind</code>：返回 Value 对象的分类。类别是reflect.Kind</p><p><code>(t Type) Kind() Kind</code>：在 Type中也实现了这个方法</p></li></ul><p>Kind 是一组常量（一组数字），对 Kind 进行比较的方法：</p><div class="code-wrapper"><pre><code class="hljs go">i := <span class="hljs-number">100</span>k := reflect.ValueOf(i).Kind()<span class="hljs-keyword">if</span> k == reflect.Int &#123;    fmt.Println(<span class="hljs-string">&quot;is int&quot;</span>)&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> k == reflect.Map &#123;    fmt.Println(<span class="hljs-string">&quot;is map&quot;</span>)&#125;</code></pre></div><p><strong>Kind 与 Type 的区别：</strong></p><p>下面的四组例子说明了 Kind 与 Type 的区别：</p><div class="code-wrapper"><pre><code class="hljs go">m := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;&#125;fmt.Println(reflect.TypeOf(m))<span class="hljs-comment">// map[int]int</span>fmt.Println(reflect.ValueOf(m).Kind())<span class="hljs-comment">// map</span>i := <span class="hljs-number">100</span>fmt.Println(reflect.TypeOf(i))<span class="hljs-comment">// int</span>fmt.Println(reflect.ValueOf(i).Kind())<span class="hljs-comment">// int</span>p := &amp;ifmt.Println(reflect.TypeOf(i))<span class="hljs-comment">// *int</span>fmt.Println(reflect.ValueOf(i).Kind())<span class="hljs-comment">// ptr</span><span class="hljs-keyword">type</span> A <span class="hljs-keyword">struct</span>&#123;&#125;a := A&#123;&#125;fmt.Println(reflect.TypeOf(a))         <span class="hljs-comment">// main.A</span>fmt.Println(reflect.ValueOf(a).Kind()) <span class="hljs-comment">// struct</span></code></pre></div><p>Kind 与 Type 可能相同，也可能不同。Type 即变量的类型，而 Kind是变量的类别。</p><h2 id="网络编程">9.2 网络编程</h2><p>网络编程有两种：</p><ul><li><p>TCP Socket 编程</p><p>是网络编程的主流。底层是 TCP/IP 协议。</p></li><li><p>b/s 结构的 HTTP 编程</p><p>使用浏览器访问服务器时，就是使用 HTTP 协议。HTTP 协议底层仍是 TCP/IP协议</p></li></ul><p>net 包中，提供了与网络开发相关的方法</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;net&quot;</span></code></pre></div><p>net 包提供了可移植的网络 I/O 接口，包括 TCP/IP、UDP、域名解析和 Unix域 Socket</p><p><strong>相关接口 / 结构体</strong></p><ul><li><p>Listener：网络监听器</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Listener <span class="hljs-keyword">interface</span> &#123;    <span class="hljs-comment">// Addr 返回该接口的网络地址</span>    Addr() Addr        <span class="hljs-comment">// Accept 等待并返回下一连接到该接口的连接</span>    Accept() (c Conn, err <span class="hljs-type">error</span>)        <span class="hljs-comment">// Close 关闭该接口，使任何阻塞的 Accept 操作不再阻塞并返回错误</span>    Close() <span class="hljs-type">error</span>&#125;</code></pre></div></li><li><p>Conn：面向流的网络连接</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Conn <span class="hljs-keyword">interface</span> &#123;    <span class="hljs-comment">// Read 从连接中读取数据。可能在超时后返回错误，该错误的 Timeout() 返回 true</span>    Read(b []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)        <span class="hljs-comment">// Write 向连接中写入数据。可能在超时后返回错误，该错误的 Timeout() 返回 true</span>    Write(b []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)        <span class="hljs-comment">// Close 关闭该连接。此后任何阻塞的 Read 或 Write 不再阻塞或返回错误</span>    Close() <span class="hljs-type">error</span>        <span class="hljs-comment">// LocalAddr 返回本地网络地址</span>    LocalAddr() Addr        <span class="hljs-comment">// RemoteAddr 返回远端网络地址</span>    RemoteAddr() Addr        <span class="hljs-comment">// SetDeadline 设定读写时限。超时后，I/O 操作会失败而不会阻塞。0 表示不设时限</span>    SetDeadline(t time.Time) <span class="hljs-type">error</span>        <span class="hljs-comment">// SetReadDeadline 设定读操作的等待时限</span>    SetReadDeadline(t time.Time) <span class="hljs-type">error</span>        <span class="hljs-comment">// SetWriteDeadline 设定写操作的等待时限</span>    SetWriteDeadline(t time.Time) <span class="hljs-type">error</span>&#125;</code></pre></div></li><li><p>Addr：代表一个网络终端地址</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Addr <span class="hljs-keyword">interface</span> &#123;    <span class="hljs-comment">// Network 返回其网络名</span>    Network() <span class="hljs-type">string</span>        <span class="hljs-comment">// String 以字符串格式返回地址</span>    String() <span class="hljs-type">string</span>&#125;</code></pre></div></li></ul><h3 id="服务端">9.2.1 服务端</h3><p>持续监听一个指定端口。每当端口捕捉到通讯请求时，启动一个协程处理那个通信请求。</p><p><strong>相关函数</strong></p><ul><li><p><code>func Listen(net, laddr string) (Listner, error)</code></p><p>返回一个在本地网络地址 laddr 上监听的Listener。未监听到时会持续阻塞</p><p>net是网络类型。其可以是："tcp"、"tcp4"、"tcp6"、"unix"、"unixpacket"</p></li></ul><p><strong>示例</strong></p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">server</span><span class="hljs-params">()</span></span> &#123;port := <span class="hljs-string">&quot;0.0.0.0:9016&quot;</span>lis, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, port)<span class="hljs-comment">// [1]</span><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;异……常……&quot;</span>)<span class="hljs-keyword">return</span>&#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(<span class="hljs-string">&quot;向着星辰……&quot;</span>)&#125;    <span class="hljs-keyword">defer</span> lis.Close()<span class="hljs-comment">// [7]</span><span class="hljs-keyword">for</span> &#123;conn, e := lis.Accept()<span class="hljs-comment">// [2]</span><span class="hljs-keyword">if</span> e != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;异……常……&quot;</span>)&#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(conn.RemoteAddr().String(), <span class="hljs-string">&quot;通讯请求&quot;</span>)<span class="hljs-comment">// [3]</span><span class="hljs-keyword">go</span> serve(conn)&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">serve</span><span class="hljs-params">(conn net.Conn)</span></span> &#123;<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-built_in">recover</span>()conn.Close()&#125;()<span class="hljs-keyword">defer</span> conn.Close()<span class="hljs-comment">// [6]</span>    data := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<span class="hljs-keyword">for</span> &#123;n, err := conn.Read(data)<span class="hljs-comment">// [4]</span><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;fmt.Println(conn.RemoteAddr().String(), <span class="hljs-string">&quot;消息：&quot;</span>, <span class="hljs-type">string</span>(data[:n]))&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> err == io.EOF &#123;<span class="hljs-comment">// [5]</span>fmt.Println(conn.RemoteAddr().String(), <span class="hljs-string">&quot;已退出&quot;</span>)&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">panic</span>(err)&#125;<span class="hljs-keyword">return</span>&#125;&#125;&#125;</code></pre></div><ol type="1"><li><p><code>func Listen(net, laddr string) (Listner, error)</code></p><p>指定方式、端口，获得 Listener</p></li><li><p><code>func (l *Listener) Accept() (c Conn, err error)</code></p><p>用指定端口持续监听连接请求，获得Conn。没有连接请求时会阻塞。</p></li><li><p><code>func (c *Conn) RemoteAddr() Addr</code></p><p>获取指定连接中的远端地址</p><p><code>func (a *Addr) String() string</code></p><p>获得表示该地址的字符串</p></li><li><p><code>func (c *Conn) Read(b []byte) (n int, err error)</code></p><p>持续地从连接中读取输入内容。没有输入内容时会阻塞。</p></li><li><p><code>io.EOF</code></p><p>当那个连接中断时，返回该错误信息</p></li><li><p><code>func (c *Conn) Close() error</code></p><p><code>func (l *Listener) Close() error</code></p><p>通讯结束后，应关闭连接</p></li></ol><h3 id="客户端">9.2.2 客户端</h3><p>向指定地址发送通信请求。</p><p><strong>相关函数</strong></p><ul><li><p><code>func Dial(network, address string) (Conn, error)</code></p><p>在网络 network 上连接地址 address，返回一个 Conn 接口</p><p>network可以是："tcp"、"tcp4"、"tcp6"、"udp"、"udp4"、"udp6、"ip"、"ip4"、"ip6"、"unix"、"unixgram"、"unixpacket"</p><p>对于 TCP 和 UDP 网络，地址格式为 <code>host:port</code> 或<code>[host]:port</code>。如：</p><div class="code-wrapper"><pre><code class="hljs go">net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;0.0.0.0:9000&quot;</span>)</code></pre></div><p>对于 IP 网络，器 network 必须是 "ip"、"ip4"、"ip6"后跟冒号和协议号或协议名，地址需是 IP 地址字面值。如：</p><div class="code-wrapper"><pre><code class="hljs go">net.Dial(<span class="hljs-string">&quot;ip6:ospf&quot;</span>, <span class="hljs-string">&quot;::1&quot;</span>)</code></pre></div></li></ul><p><strong>示例</strong></p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;os&quot;</span>    <span class="hljs-string">&quot;bufio&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">client</span><span class="hljs-params">()</span></span> &#123;port := <span class="hljs-string">&quot;0.0.0.0:9016&quot;</span>conn, err := net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, port)<span class="hljs-comment">// [1]</span><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">defer</span> conn.Close()<span class="hljs-comment">// [5]</span><span class="hljs-keyword">for</span> &#123;read := bufio.NewReader(os.Stdin)<span class="hljs-comment">// [2]</span>s, _ := read.ReadString(<span class="hljs-string">&#x27;\n&#x27;</span>)<span class="hljs-comment">// [3]</span>conn.Write([]<span class="hljs-type">byte</span>(s))<span class="hljs-comment">// [4]</span>&#125;&#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(<span class="hljs-string">&quot;前面的区域，以后再探索吧！&quot;</span>)&#125;&#125;</code></pre></div><ol type="1"><li><p><code>func Dial(network, address string) (Conn, error)</code></p><p>尝试与指定地址进行通讯。己方的端口由系统随机分配</p></li><li><p><code>func NewReader(rd io.Reader) *Reader</code></p><p>获取一个读取键盘输入的输入流</p><p><code>os.Stdin</code></p><p>指向标准输入的文件。标准输入的文件默认是键盘输入</p></li><li><p><code>func (b *Reader) ReadString(delim byte) (line string, err error)</code></p><p>从上述键盘输入流获取输入的字符串</p></li><li><p><code>func (c *Conn) Write(b []byte) (n int, err error)</code></p><p>向连接中写入数据</p></li><li><p><code>func (c *Conn) Close() error</code></p><p>通讯结束后，应关闭连接</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Go&gt;8 goroutine 和 channel</title>
    <link href="/2022/07/01/Go/8%20goroutine%20%E5%92%8C%20channel/"/>
    <url>/2022/07/01/Go/8%20goroutine%20%E5%92%8C%20channel/</url>
    
    <content type="html"><![CDATA[<h1 id="goroutine-和-channel">8 goroutine 和 channel</h1><h2 id="单元测试">8.1 单元测试</h2><blockquote><p>传统的测试方法需要在 main 函数中调用，每次要修改 main函数，很不方便。</p><p>测试多个模块时都要写在 main 函数，也不便于管理。</p></blockquote><p>Golang 中带有一个轻量级的测试框架 testing 和自带的 go test命令来实现单元测试和性能测试。</p><p>testing框架可以基于该框架编写针对相应函数的测试用例，也能基于该框架写相应压力测试用例。</p><p>通过单元测试，能解决以下问题：</p><ul><li>确保每个函数可运行，且运行结果正确</li><li>确保写出来的代码是好的</li><li>及时发现程序设计或实现的逻辑错误，使问题及早暴露。性能测试重点在于发现程序设计上的一些问题，让程序在高并发状态下也能稳定运行。</li></ul><h4 id="单元测试流程">单元测试流程</h4><ol start="0" type="1"><li><p>原本的文件，其中包含待测试的函数</p><blockquote><p><em>example</em></p></blockquote><p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">act</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-comment">// 待测试函数</span><span class="hljs-keyword">return</span> -n&#125;</code></pre></div></p></li><li><p>创建 xxx_test.go测试用例文件，放在与被测试函数相同的包中。该文件包含 TestXxx测试用例函数。</p><blockquote><p><em>example_test.go</em></p></blockquote><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;testing&quot;</span><span class="hljs-comment">// 导入 testing 包</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAct</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-comment">// 测试用例函数</span><span class="hljs-keyword">if</span> n := act(<span class="hljs-number">10</span>); n != <span class="hljs-number">-10</span> &#123;t.Fatalf(<span class="hljs-string">&quot;wrong, expect 10, get %v&quot;</span>, n)&#125; <span class="hljs-keyword">else</span> &#123;t.Logf(<span class="hljs-string">&quot;correct&quot;</span>)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestHello</span><span class="hljs-params">(t *testing.T)</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;★&quot;</span>)&#125;</code></pre></div><p>在 test 包下，提供了自动化测试的函数支持：</p><ul><li><p><code>func (t *testing.T) Logf(format string, args ...interface&#123;&#125;)</code></p><p>输出一段测试信息</p></li><li><p><code>func (t *testing.T) FailNow()</code></p><p>将当前测试标识为失败并停止执行该测试。之后，继续进行下一测试</p></li><li><p><code>func (t *testing.T) Fatalf(format string, args ...interface&#123;&#125;)</code></p><p>相当于调用 Logf 后调用 FailNow</p></li></ul></li><li><p>使用 <code>go test</code> 指令，将所有 xxx_test.go文件引入，并自动执行所有 TestXxx 的函数</p><div class="code-wrapper"><pre><code class="hljs cmd">******&gt; go test [-v] [xxx.go xxx_test.go] [-test.run TestXxx]</code></pre></div><p><code>[ ]</code> 是可选项。其中：</p><ul><li><p><code>-v</code>：无论运行正确还是错误，都输出日志。否则，仅发生错误时输出日志</p></li><li><p><code>xxx.go xxx_test.go</code>：要测试单个测试用例文件时，将那些文件名写在后面</p></li><li><p><code>-test.run TestXxx</code>：只测试指定的测试用例函数</p></li></ul></li><li><p>最后，输出</p><div class="code-wrapper"><pre><code class="hljs cmd">******&gt; go test -v=== RUN   TestAct<span class="hljs-function">    test_test.go:12: <span class="hljs-title">correct</span></span><span class="hljs-function">--- <span class="hljs-title">PASS</span>: <span class="hljs-title">TestAct</span> (0.00<span class="hljs-title">s</span>)</span><span class="hljs-function">=== <span class="hljs-title">RUN</span>   <span class="hljs-title">TestHello</span></span><span class="hljs-function">★</span><span class="hljs-function">--- <span class="hljs-title">PASS</span>: <span class="hljs-title">TestHello</span> (0.00<span class="hljs-title">s</span>)</span><span class="hljs-function"><span class="hljs-title">PASS</span></span><span class="hljs-function"><span class="hljs-title">ok</span>      ******/<span class="hljs-title">main</span>       0.040<span class="hljs-title">s</span></span></code></pre></div><p>其中 PASS 表示测试用例运行成功，FAIL 表示测试用例运行失败</p></li></ol><h4 id="注意事项">注意事项</h4><ul><li>测试用例的文件名必须是 <code>xxx_test.go</code> 格式。即文件名以<code>_test.go</code> 结尾</li><li>测试用例函数名是 <code>TestXxx</code> 格式。其中 <code>Xxx</code>部分必须大写开头，一般是被测试的函数名</li><li>一个测试用例文件中，可以有多个测试用例函数。那些测试用例函数会被全部调用</li><li>测试用例函数不需要放在 main函数中，但也能被执行。这就是测试用例的方便之处</li></ul><h2 id="goroutine-协程">8.2 goroutine 协程</h2><p><strong>进程</strong>：程序在操作系统中的一次执行过程。进程是系统分配资源和调度的基本单位</p><p><strong>线程</strong>：进程的一个执行实例，是程序执行的最小单元，是比进程更小的能独立运行的基本单位</p><p>一个进程可以创建或销毁多个线程。一个进程中的多个线程可以并发执行。</p><p>一个程序至少有一个进程。一个进程至少有一个线程</p><p><strong>并发</strong>：多线程程序在单核上运行。各个线程会被轮流执行，同一时间只有一个线程执行。</p><p><strong>并行</strong>：多线程程序在多核上运行。各个线程在不同 CPU上同时执行</p><h4 id="go-协程和主线程">Go 协程和主线程</h4><blockquote><p>Go 的主线程（进程/线程）上，可以起多个协程。协程是轻量级的线程</p><p>主线程是一个物理线程，是重量级的，非常耗费 CPU 资源</p><p>协程是从主线程开启的，是轻量级线程，是逻辑态，资源消耗小</p><p>Go 的协程机制是重要的特点，可以轻松开启上万个协程。这也是 Go语言在并发上的优势</p></blockquote><p>Go 协程的特点：</p><ul><li>有独立栈空间</li><li>共享程序堆空间</li><li>调度由用户控制</li><li>协程是轻量级的线程</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">act</span><span class="hljs-params">(str <span class="hljs-type">string</span>)</span></span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;fmt.Println(str, i)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">go</span> act(<span class="hljs-string">&quot;goroutine&quot;</span>)<span class="hljs-comment">// 该函数在协程中运行</span>act(<span class="hljs-string">&quot;main&quot;</span>)<span class="hljs-comment">// 该函数在主线程中运行</span>&#125;</code></pre></div><p>上述代码的执行流程示意图如下：</p><pre><code class=" mermaid">graph LRA[程序开始] --&gt; B(主线程开启协程) --继续执行--&gt; C(主线程调用函数) --&gt; d[程序结束]B -.协程.-&gt; BB(协程调用函数)</code></pre><p>主线程和协程同时进行。</p><ul><li><p>如果主线程结束了，那么即使协程还未执行完毕，则协程也会退出。但协程也能在主线程结束前自行结束（如完成任务）</p></li><li><p>在协程中出现 panic 而未处理时，会导致整个程序崩溃。</p><p>在 goroutine 中使用 recover，解决协程中出现的 panic</p></li></ul><h4 id="mpg-模式">MPG 模式</h4><p>M：操作系统的主线程（物理线程）</p><p>P：协程需要的上下文环境</p><p>G：协程</p><p><font color="#FF0000" size="6">☆</font></p><h4 id="设置-go-运行的-cpu-数">设置 Go 运行的 CPU 数</h4><p>为了充分利用多 CPU 的优势，在 Go 语言中，可以设置运行 CPU 数量</p><p>在 runtime 包中包含了 Go 运行环境的互操作。</p><ul><li><p><code>func NumCPU() int</code>：返回本地机器的逻辑 CPU的个数</p></li><li><p><code>func GOMAXPROCS(n int) int</code>：设置可同时执行的最大 CPU数，返回之前的设置</p><p>在 Go 1.8 后，默认让程序在多核上运行。Go 1.8前还需要手动设置</p></li></ul><h2 id="channel-管道">8.3 channel 管道</h2><p>使用 goroutine 效率较高，但可能出现 并发/并行安全问题。在编译时增加<code>-race</code> 就能发现资源竞争问题。</p><p>要解决不同 goroutine 间的通信问题，有两种方法：</p><h3 id="线程加锁">8.3.1 线程加锁</h3><p>同一资源同一时间只能被一个协程访问，资源被占用时会被锁定。访问锁定资源的协程会阻塞并被移入等待队列。直到锁定解除时，再让等待队列中的协程依次出列，并访问该资源。</p><p>实现方法：全局变量互斥锁</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;sync&quot;</span><span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">var</span> (    lock sync.Mutex<span class="hljs-comment">// lock 是变量名，类型是 sync.Mutex</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">act</span><span class="hljs-params">(str <span class="hljs-type">string</span>)</span></span> &#123;lock.Lock()<span class="hljs-comment">// 加锁，直到全部输出完毕</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;fmt.Println(str, i)&#125;lock.Unlock()<span class="hljs-comment">// 解锁</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">go</span> act(<span class="hljs-string">&quot;goroutine&quot;</span>)<span class="hljs-keyword">go</span> act(<span class="hljs-string">&quot;A&quot;</span>)<span class="hljs-keyword">go</span> act(<span class="hljs-string">&quot;?????&quot;</span>)time.Sleep(<span class="hljs-number">10</span>)act(<span class="hljs-string">&quot;main&quot;</span>)<span class="hljs-comment">// 因为互斥锁的存在，输出字符串时不会被插队</span>&#125;</code></pre></div><p>sync 包提供了基本的同步单元，如互斥锁，适用于低水平程序线程</p><p>sync.Mutex是一个互斥锁，可以创建为其他结构体的字段。其零值为未上锁状态</p><ul><li><p><code>func (m *Mutex) Lock()</code>：将 Mutex 变为锁定状态</p><p>已加锁时，会阻塞，直到 m 解锁</p></li><li><p><code>func (m *Mutex) Unlock()</code>：将 Mutex 解锁</p><p>未加锁时会产生错误</p></li></ul><h3 id="channel-的使用">8.3.2 channel 的使用</h3><p>线程加锁的方法仍有缺陷。协程的完成任务的时间难以确定，也不利于多协程对全部变量的读写操作。</p><p>所以就要使用 channel 啦</p><p>channel 的本质是一个队列，数据先进先出。channel是数据安全的，不需要加锁。</p><p>channel 是有类型的，一个 string 类型的 channel 只能存放 string类型数据</p><h4 id="声明定义-channel">声明/定义 channel：</h4><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> c1 <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span><span class="hljs-comment">// 一个存放 int 的 channel</span>c2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>, <span class="hljs-number">2</span>)</code></pre></div><p>channel 是引用类型。channel 需初始化后（make 后）才能写入数据</p><p>channel 中只能存放那个指定的数据类型</p><p>不过，也可以试试这个</p><div class="code-wrapper"><pre><code class="hljs go">cc := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-number">0</span>)</code></pre></div><p>因为任何类型都实现了空接口，所以这个 channel存放的是任意类型的数据。但使用数据时可能需要类型断言。</p><h4 id="加入数据">加入数据：</h4><div class="code-wrapper"><pre><code class="hljs go">c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">3</span>)<span class="hljs-comment">// 初始化</span>c &lt;- <span class="hljs-number">1</span><span class="hljs-comment">// 写入一个数据</span>c &lt;- <span class="hljs-number">5</span> &lt;&lt; <span class="hljs-number">2</span><span class="hljs-comment">// 写入一个数据（表达式 5 &lt;&lt; 2）</span>fmt.Println(<span class="hljs-built_in">len</span>(c), <span class="hljs-built_in">cap</span>(c))<span class="hljs-comment">// 2 3</span>c &lt;- <span class="hljs-number">-1</span></code></pre></div><p>边写边读的场合，写入数据而超过最大容量时，那个写入会阻塞，直到有数据取出。</p><p>没有协程读取数据的场合，给管道写入数据超过那个最大容量时，就会报错</p><h4 id="取出数据">取出数据：</h4><div class="code-wrapper"><pre><code class="hljs go">n := &lt;-c<span class="hljs-comment">// 取出一个数据</span>fmt.Println(n, &lt;-c)<span class="hljs-comment">// 1 20</span>&lt;-c<span class="hljs-comment">// 仅取出数据而不接收</span>fmt.Println(<span class="hljs-built_in">len</span>(c), <span class="hljs-built_in">cap</span>(c))<span class="hljs-comment">// 0 3</span></code></pre></div><p>在没有协程的情况下，向空管道索取数据会报错（deadlock）</p><h4 id="关闭-channel">关闭 channel：</h4><p>使用内置函数 close 以关闭 channel。关闭后，该 channel不再接收数据，但仍能取出数据</p><div class="code-wrapper"><pre><code class="hljs go">c3 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">3</span>)c3 &lt;- <span class="hljs-number">1</span><span class="hljs-built_in">close</span>(c3)<span class="hljs-comment">// 关闭了 channel</span>&lt;-c3<span class="hljs-comment">// 仍能取出数据</span>c3 &lt;- <span class="hljs-number">1</span><span class="hljs-comment">// 此处会报错，因为管道已经关闭 ☆</span></code></pre></div><h4 id="遍历-channel">遍历 channel：</h4><p>channel 支持 for-range 遍历。那个遍历时没有下标。</p><p>在 channel 未关闭前进行遍历，遍历到最后会阻塞，直到 channel关闭时才完成遍历。没有协程的场合，遍历一个未关闭的 channel时会报错（deadlock）</p><div class="code-wrapper"><pre><code class="hljs go">c4 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">cap</span>(c); i++ &#123;        c &lt;- i    &#125;<span class="hljs-built_in">close</span>(c)&#125;(c4)<span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> c4 &#123;    fmt.Print(v, <span class="hljs-string">&quot; &quot;</span>)&#125;</code></pre></div><h4 id="注意事项-1">注意事项</h4><ul><li><p>默认情况下，channel 是双向管道。但也能声明为 只读/只写的形式。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ca <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> <span class="hljs-comment">// 可读可写</span><span class="hljs-keyword">var</span> cw <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span><span class="hljs-comment">// 只写</span><span class="hljs-keyword">var</span> cr &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span><span class="hljs-comment">// 只读</span></code></pre></div><p>只读/只写 的管道仍是 chan 类型，只读/只写 只表示一种状态。</p><p>在函数的参数声明中，将 chan 声明为只读/只写，既能避免误操作，也能提升效率。</p></li><li><p>使用 select 可以解决从管道取数据的阻塞问题</p><div class="code-wrapper"><pre><code class="hljs go">cv := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)cm := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)...run := <span class="hljs-literal">true</span><span class="hljs-keyword">for</span> run &#123;    <span class="hljs-keyword">select</span> &#123;    <span class="hljs-keyword">case</span> v := &lt;-cv:<span class="hljs-comment">// 尝试从 cv 取出数据。未能取出则向后进行</span>        fmt.Println(v)    <span class="hljs-keyword">case</span> v := &lt;-cm:<span class="hljs-comment">// 尝试从 cm 取出数据。未能取出则向后进行</span>        fmt.Println(v)    <span class="hljs-keyword">default</span>:        run = <span class="hljs-literal">false</span>    &#125;&#125;</code></pre></div></li></ul>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Go&gt;7 文件操作</title>
    <link href="/2022/06/22/Go/7%20%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/06/22/Go/7%20%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="文件操作">7 文件操作</h1><p>文件是……是什么大家都懂的吧。</p><p>在程序中，以流的形式对文件来进行操作</p><p>流：数据在文件和程序间经历的路径</p><p>输入流：数据从数据源（文件）到程序（内存）的路径</p><p>输出流：数据从程序（内存）到数据源（文件）的路径</p><h2 id="打开关闭文件">7.1 打开、关闭文件</h2><p>在 os 包中，封装了所有文件相关的操作。</p><p>os 包的结构体 File 代表一个打开的文件对象</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> file *os.File<span class="hljs-comment">/* 打开文件 */</span><span class="hljs-keyword">if</span> f, err := os.Open(<span class="hljs-string">&quot;D:/1.txt&quot;</span>); err == <span class="hljs-literal">nil</span> &#123;<span class="hljs-comment">// [1]</span>    fmt.Println(<span class="hljs-string">&quot;打开成功\t&quot;</span>, f)    file = f&#125; <span class="hljs-keyword">else</span> &#123;    fmt.Println(<span class="hljs-string">&quot;打开失败\t&quot;</span>, err)&#125;<span class="hljs-comment">/* 关闭文件 */</span><span class="hljs-keyword">if</span> err := file.Close(); err == <span class="hljs-literal">nil</span> &#123;<span class="hljs-comment">// [2]</span>    fmt.Println(<span class="hljs-string">&quot;关闭文件&quot;</span>)&#125; <span class="hljs-keyword">else</span> &#123;    fmt.Println(<span class="hljs-string">&quot;关闭失败\t&quot;</span>, err)&#125;</code></pre></div><h4 id="常用函数">常用函数</h4><blockquote><p>以下函数存在于 os 包</p></blockquote><p><strong>打开文件</strong></p><ul><li><p><code>func Open(name string) (*File, error)</code>：打开文件</p><p>打开一个文件用于读取。成功时，返回一个文件指针</p></li><li><p><code>OpenFile(name string, flag int, perm FileMode) (file *File, err error)</code></p><p>使用指定的选项打开文件。其中 flag 是文件打开模式（可组合使用），perm为权限控制</p><p>flag 有以下选择：</p><ul><li>os.O_RDONLY：以只读模式打开文件</li><li>os.O_WRONLY：以只写方式打开文件</li><li>os.O_RDWR：读写模式打开文件</li><li>os.O_APPEND：以追加模式打开文件</li><li>os.O_CREATE：文件不存在时，会创建该文件</li><li>os.O_EXCL：和 os.O_CREATE 配合使用。要求文件必须不存在</li><li>os.O_SYNC：打开文件用于同步 I/O</li><li>os.O_TRUNC：打开时清空文件</li></ul><p>一定要慎重选择 flag 哟~</p><p>另外，perm 权限控制在 Windows 系统下无效。仅 Linux系统有效。</p></li></ul><p><strong>文件状态</strong></p><ul><li><p><code>Stat(name string) (fi FileInfo, err error)</code>：返回文件状态</p><p>err 为 nil 时，说明文件或文件夹存在。os.IsNotExist(err) 返回 true时，说明文件不存在。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">if</span> _, err := os.Stat(<span class="hljs-string">`d:\1.txt`</span>); err == <span class="hljs-literal">nil</span> &#123;    fmt.Println(<span class="hljs-string">&quot;文件存在&quot;</span>)&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> os.IsNotExist(err) &#123;    fmt.Println(<span class="hljs-string">&quot;文件不存在&quot;</span>)&#125; <span class="hljs-keyword">else</span> &#123;    fmt.Println(<span class="hljs-string">`优质答案：&quot;我不知道&quot;`</span>)&#125;</code></pre></div></li></ul><p><strong>关闭文件</strong></p><ul><li><p><code>func (f *File) Close() error</code>：关闭文件</p><p><strong>注意：</strong>当函数退出时，要及时关闭File，否则会有内存泄漏</p><p>可以使用 defer 进行延迟关闭</p></li></ul><h2 id="读写文件">7.2 读、写文件</h2><h4 id="读文件">读文件</h4><p><strong>读取文件内容（带缓冲区）：</strong></p><blockquote><p>需要导入 bufio 包。该包下有一个 Reader 结构体</p></blockquote><div class="code-wrapper"><pre><code class="hljs go">file, _ := os.Open(<span class="hljs-string">&quot;d:\\1.txt&quot;</span>)reader := bufio.NewReader(file)<span class="hljs-comment">// [1]</span><span class="hljs-keyword">for</span> &#123;    str, err := reader.ReadString(<span class="hljs-string">&#x27;\n&#x27;</span>)<span class="hljs-comment">// [2]</span>    fmt.Print(str)    <span class="hljs-keyword">if</span> err == io.EOF &#123;<span class="hljs-comment">// [3]</span>        <span class="hljs-keyword">break</span>    &#125;&#125;file.Close()</code></pre></div><ol type="1"><li>创建一个 *Reader，其缓冲区默认为 4096</li><li>直到遇到指定字符前，读取字符</li><li>EOF 是文件结束标记。err == EOF 时表明文件已经结束</li></ol><p><strong>读取文件内容（一次性读完）：</strong></p><blockquote><p>需要导入 ioutil 包。</p></blockquote><div class="code-wrapper"><pre><code class="hljs go">str, err := ioutil.ReadFile(<span class="hljs-string">&quot;D:\\1.txt&quot;</span>)<span class="hljs-comment">// [1]</span><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;    fmt.Println(<span class="hljs-type">string</span>(str))&#125; <span class="hljs-keyword">else</span> &#123;    fmt.Println(err)&#125;</code></pre></div><ol type="1"><li><p><code>ReadFile(filename string) (byte[], error)</code></p><p>读取文件全部内容，返回字节数组</p><p>这个方法不需要额外对 File 进行打开或关闭</p><p><strong>注意：</strong>该方法仅适用于较小文件</p></li></ol><h4 id="写文件">写文件</h4><p><strong>写入文件内容（带缓冲区）：</strong></p><blockquote><p>需要导入 bufio 包。</p></blockquote><div class="code-wrapper"><pre><code class="hljs go">f, _ := os.OpenFile(<span class="hljs-string">&quot;D:\\1.txt&quot;</span>, os.O_APPEND|os.O_RDWR|os.O_CREATE, <span class="hljs-number">0</span>)writer := bufio.NewWriter(f)<span class="hljs-comment">// [1]</span>writer.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;\n★&quot;</span>))<span class="hljs-comment">// [2]</span>writer.Flush()<span class="hljs-comment">// [3]</span>f.Close()</code></pre></div><ol type="1"><li>创建一个 *Writer</li><li>写入字符。此时，字符存在于缓存，还未真正写入文件</li><li>将缓存内容写入文件</li></ol><p><strong>写入文件内容（一次性写入）：</strong></p><blockquote><p>需要导入 ioutil 包。</p></blockquote><div class="code-wrapper"><pre><code class="hljs go">err := ioutil.WriteFile(<span class="hljs-string">&quot;D:\\1.txt&quot;</span>, []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;刻晴\n刻晴\n刻晴\n&quot;</span>), <span class="hljs-number">0666</span>)<span class="hljs-comment">// [1]</span><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;    fmt.Println(err)&#125;</code></pre></div><ol type="1"><li><p><code>WriteFile(filename string, data []byte, perm FileMode) error</code></p><p>向文件写入指定全部内容。</p><p>文件存在时，删除原本内容。不存在时，创建该文件。</p></li></ol><h2 id="命令行参数">7.3 命令行参数</h2><h4 id="os.args-获取命令行参数">os.Args 获取命令行参数</h4><p>os.Args 是一个 string 的切片，其存放所有的命令行参数</p><div class="code-wrapper"><pre><code class="hljs cmd">******&gt; test.exe ☆ <span class="hljs-number">123</span></code></pre></div><p>上述指令的命令行参数分别是</p><div class="code-wrapper"><pre><code class="hljs go">fmt.Println(os.Args[<span class="hljs-number">0</span>])<span class="hljs-comment">// ******\test.exe</span>fmt.Println(os.Args[<span class="hljs-number">1</span>])<span class="hljs-comment">// ☆</span>fmt.Println(os.Args[<span class="hljs-number">2</span>])<span class="hljs-comment">// 123</span></code></pre></div><p>第一个参数是文件名（*是我省略的部分），之后以空格为间隔区分其他参数</p><h4 id="flag-包解析命令行参数">flag 包解析命令行参数</h4><p>os.Args必须严格按照输入顺序解析命令行参数。解析参数不方便，也不便于指定参数。</p><div class="code-wrapper"><pre><code class="hljs cmd">******&gt; test.exe -c ☆ -d <span class="hljs-number">123</span></code></pre></div><p>上述指令的命令行参数分别是</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span><span class="hljs-keyword">var</span> lack <span class="hljs-type">string</span><span class="hljs-comment">/* 进行注册 */</span>flag.IntVar(&amp;i, <span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-number">-1</span>, <span class="hljs-string">&quot;命令行参数 -d，该项输入值是 123，默认值是 -1&quot;</span>)flag.StringVar(&amp;s, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;--&quot;</span>, <span class="hljs-string">&quot;命令行参数 -c，该项输入值是 ☆，默认值是 --&quot;</span>)flag.StringVar(&amp;lack, <span class="hljs-string">&quot;l&quot;</span>, <span class="hljs-string">&quot;--&quot;</span>, <span class="hljs-string">&quot;命令行参数 -l，该项没有输入值，默认值是 --&quot;</span>)fmt.Println(i)    <span class="hljs-comment">// -1</span>fmt.Println(s)    <span class="hljs-comment">// --</span>fmt.Println(lack) <span class="hljs-comment">// --</span>i = <span class="hljs-number">-1000</span>s = <span class="hljs-string">&quot;s&quot;</span>lack = <span class="hljs-string">&quot;lack&quot;</span>flag.Parse()fmt.Println(i)    <span class="hljs-comment">// 123</span>fmt.Println(s)    <span class="hljs-comment">// ☆</span>fmt.Println(lack) <span class="hljs-comment">// lack</span></code></pre></div><ul><li><p><code>StringVar(p *string, name string, value string, usage string)</code></p><p>用指定的 名称 name、默认值 value、使用信息 usage 注册一个 string类型的 flag，将其值保存到 p 指向的变量。</p><p>在注册时，即向 p 中填充默认值。之后调用 Parse方法时，再将解析到的参数填入</p><p><code>IntVar(p *int, name string, value int, usage string)</code></p><p>注册一个 int类型的 flag，将其值保存到 p 指向的变量。</p></li><li><p><code>Parse()</code>：转换</p><p>从 os.Args[1:] 中解析注册的 flag。未解析到时，不进行任何赋值</p><p>该函数建议在上述注册函数注册完成后，对变量进行调用前调用</p></li></ul><h2 id="json">7.4 JSON</h2><p>JSON（JavaScript Object Notation）是一种轻量级数据交换格式。</p><p>JSON 易于阅读和编写，也易于机器解析和生成</p><p>JSON 自 2001 年起推广使用，目前已成为主流的数据格式。</p><p>JSON易于机器解析和生成，并能有效地提升网络传输效率。通常程序在网络传输时会先将数据序列化为JSON 字符串。接收方得到 JSON字符串时，再将其反序列化恢复为原先数据。该方式已然成为各个语言的标准。</p><pre><code class=" mermaid">graph LRa(Golang) --序列化--&gt; b(JSON 字符串) --网络传输--&gt; c(程序) --反序列化--&gt; d(其他语言)</code></pre><p>在 JS 语言中，一切都是对象。任何数据都能通过 JSON 来表示。</p><p>JSON 是用键值对来保存数据的方式。键名在前，值在后，内容用引号<code>" "</code> 包裹。键值间以冒号 <code>:</code>间隔。多个值时用方括号 <code>[ ]</code> 包裹。不同项间以逗号<code>,</code> 间隔。</p><p>比如：</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Heruin&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">6</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;address&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;H.M.J&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;I.M&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span></code></pre></div><h4 id="json-序列化">JSON 序列化</h4><p>JSON 序列化是指将具有 key-value结构的数据类型（如结构体、切片、map）序列化。</p><p>在 json 包下提供了序列化方法</p><ul><li><p><code>Marshal(v interface) ([]byte, error)</code>：将给定接口序列化。</p><p>要注意结构体中字段的访问权限（首字母大写）</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> A <span class="hljs-keyword">struct</span> &#123;Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;A_Name&quot;`</span>Age  <span class="hljs-type">int</span>add  <span class="hljs-type">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-comment">/* 结构体的序列化 */</span>a := A&#123;<span class="hljs-string">&quot;Heruin&quot;</span>, <span class="hljs-number">6</span>, <span class="hljs-string">&quot;H.M.J&quot;</span>&#125;s, _ := json.Marshal(a)fmt.Println(<span class="hljs-type">string</span>(s))<span class="hljs-comment">// &#123;&quot;A_Name&quot;:&quot;Heruin&quot;,&quot;Age&quot;:6&#125;</span>        <span class="hljs-comment">/* 切片的序列化 */</span>b := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;☆&quot;</span>, <span class="hljs-string">&quot;★&quot;</span>&#125;s, _ = json.Marshal(b)fmt.Println(<span class="hljs-type">string</span>(s))<span class="hljs-comment">// [&quot;☆&quot;,&quot;★&quot;]</span>        <span class="hljs-comment">/* map的序列化 */</span>    c := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-number">0</span>: <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&quot;C&quot;</span>&#125;s, _ = json.Marshal(c)fmt.Println(<span class="hljs-type">string</span>(s))<span class="hljs-comment">// &#123;&quot;0&quot;:&quot;A&quot;,&quot;1&quot;:&quot;B&quot;,&quot;2&quot;:&quot;C&quot;&#125;</span>        <span class="hljs-comment">/* 对基本数据类型序列化 */</span>d := <span class="hljs-number">1000</span>s, _ = json.Marshal(d)fmt.Println(<span class="hljs-type">string</span>(s))<span class="hljs-comment">// 1000</span>&#125;</code></pre></div></li></ul><h4 id="json-反序列化">JSON 反序列化</h4><p>JSON 序列化是指将 JSON 字符串转换成指定的数据类型</p><p>在 json 包下提供了反序列化方法</p><ul><li><p><code>Unmarshal(str []byte, v *interface) error</code>：将字符串反序列化，结果放在v 指示的变量中</p><p>反序列化时，应确保序列化前后的类型一致</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> A <span class="hljs-keyword">struct</span> &#123;Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;A_Name&quot;`</span>Age  <span class="hljs-type">int</span>add  <span class="hljs-type">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;s1 := <span class="hljs-string">`&#123;&quot;A_Name&quot;:&quot;Heruin&quot;,&quot;Age&quot;:6&#125;`</span><span class="hljs-keyword">var</span> a Ajson.Unmarshal([]<span class="hljs-type">byte</span>(s1), &amp;a)<span class="hljs-comment">// 除了 add 字段外，值等于前面的 a</span>s2 := <span class="hljs-string">`[&quot;☆&quot;,&quot;★&quot;]`</span><span class="hljs-keyword">var</span> b []<span class="hljs-type">string</span>json.Unmarshal([]<span class="hljs-type">byte</span>(s2), &amp;b)<span class="hljs-comment">// 值等于前面的 b</span>s3 := <span class="hljs-string">`&#123;&quot;0&quot;:&quot;A&quot;,&quot;1&quot;:&quot;B&quot;,&quot;2&quot;:&quot;C&quot;&#125;`</span><span class="hljs-keyword">var</span> c <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>json.Unmarshal([]<span class="hljs-type">byte</span>(s3), &amp;c)<span class="hljs-comment">// 值等于前面的 c</span>s4 := <span class="hljs-string">`1000`</span><span class="hljs-keyword">var</span> d <span class="hljs-type">int</span>json.Unmarshal([]<span class="hljs-type">byte</span>(s4), &amp;d)<span class="hljs-comment">// 值等于前面的 d</span>&#125;</code></pre></div></li></ul>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Go&gt;6 项目：家庭收支记账软件</title>
    <link href="/2022/06/20/Go/6%20%E9%A1%B9%E7%9B%AE%EF%BC%9A%E5%AE%B6%E5%BA%AD%E6%94%B6%E6%94%AF%E8%AE%B0%E8%B4%A6%E8%BD%AF%E4%BB%B6/"/>
    <url>/2022/06/20/Go/6%20%E9%A1%B9%E7%9B%AE%EF%BC%9A%E5%AE%B6%E5%BA%AD%E6%94%B6%E6%94%AF%E8%AE%B0%E8%B4%A6%E8%BD%AF%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="项目家庭收支记账软件">6 项目：家庭收支记账软件</h1><h2 id="项目1家庭收支记账软件">项目1：家庭收支记账软件</h2><h4 id="需求分析">需求分析</h4><p>实现基于文本界面的家庭收支记账软件</p><p>该软件能记录家庭收入、支出，并能打印收支明细表</p><h4 id="项目设计">项目设计</h4><pre><code class=" mermaid">graph TDA(登录菜单)--&gt;Aa&#123;密码&#125;.-&gt;AAa--正确--&gt;B(管理菜单)B--&gt;B1[1 查看账本]B--&gt;B2[2 添加条目]B--&gt;B3[3 删除条目]B--&gt;B4[4 恢复条目]B--&gt;B9[9 登出]--&gt;AB1--&gt;B11[全部]B2--&gt;B21[进账]B2--&gt;B22[出账]</code></pre><h2 id="附录">附录</h2><h3 id="家庭收支记账软件">家庭收支记账软件</h3><p><strong>main</strong></p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (menu <span class="hljs-string">&quot;go_code/family_balance/menu&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;menu.Menu0()&#125;</code></pre></div><p><strong>data</strong></p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> data<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;strconv&quot;</span>)<span class="hljs-keyword">type</span> Ele <span class="hljs-keyword">struct</span> &#123;Year    <span class="hljs-type">int</span>Month   <span class="hljs-type">int</span>Date    <span class="hljs-type">int</span>Item    <span class="hljs-type">string</span>Amount  <span class="hljs-type">int</span>Abandon <span class="hljs-type">bool</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *Ele)</span></span> String() <span class="hljs-type">string</span> &#123;res := strconv.Itoa(e.Year) + <span class="hljs-string">&quot;.&quot;</span> + strconv.Itoa(e.Month) + <span class="hljs-string">&quot;.&quot;</span> + strconv.Itoa(e.Date)<span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(res) &lt; <span class="hljs-number">10</span> &#123;res += <span class="hljs-string">&quot; &quot;</span>&#125;res += <span class="hljs-string">&quot;\t&quot;</span> + strconv.Itoa(e.Amount)res += <span class="hljs-string">&quot;\t&quot;</span> + e.Item<span class="hljs-keyword">return</span> res&#125;</code></pre></div><p><strong>menu</strong></p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> menu<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;errors&quot;</span><span class="hljs-string">&quot;fmt&quot;</span>data <span class="hljs-string">&quot;go_code/family_balance/data&quot;</span>)<span class="hljs-keyword">var</span> (skipMenu <span class="hljs-type">bool</span>pw       <span class="hljs-type">string</span>datas    []data.EledateL    <span class="hljs-type">int</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;skipMenu = <span class="hljs-literal">false</span>pw = <span class="hljs-string">&quot;000000&quot;</span>datas = <span class="hljs-built_in">make</span>([]data.Ele, <span class="hljs-number">0</span>)dateL = <span class="hljs-number">0</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Menu0</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> &#123;fmt.Println(<span class="hljs-string">`—————————————家庭收支记账软件—————————————`</span>)fmt.Println(<span class="hljs-string">&quot;\t\t1 登 录&quot;</span>)fmt.Println(<span class="hljs-string">&quot;\t\t9 退 出&quot;</span>)fmt.Print(<span class="hljs-string">&quot;请选择：&quot;</span>)i := <span class="hljs-number">0</span><span class="hljs-keyword">if</span> _, e := fmt.Scan(&amp;i); e != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;输入有误&quot;</span>)<span class="hljs-keyword">continue</span>&#125;<span class="hljs-keyword">switch</span> i &#123;<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<span class="hljs-keyword">if</span> login() &#123;menu()&#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(<span class="hljs-string">&quot;密码错误&quot;</span>)&#125;<span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:<span class="hljs-keyword">return</span><span class="hljs-keyword">default</span>:fmt.Println(<span class="hljs-string">`输入错误`</span>)&#125;fmt.Println(<span class="hljs-string">&quot;\n——————————————————————————&quot;</span>)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">login</span><span class="hljs-params">()</span></span> <span class="hljs-type">bool</span> &#123;fmt.Println(<span class="hljs-string">`——————————————登 录——————————————`</span>)fmt.Print(<span class="hljs-string">`请输入密码：`</span>)word := <span class="hljs-string">&quot;&quot;</span>fmt.Scan(&amp;word)<span class="hljs-keyword">return</span> word == pw&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">showMenu</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">if</span> skipMenu &#123;skipMenu = <span class="hljs-literal">false</span><span class="hljs-keyword">return</span>&#125;fmt.Println(<span class="hljs-string">`—————————————欢迎回来—————————————`</span>)fmt.Println(<span class="hljs-string">&quot;\t\t1 查看账本&quot;</span>)fmt.Println(<span class="hljs-string">&quot;\t\t2 添加条目&quot;</span>)fmt.Println(<span class="hljs-string">&quot;\t\t3 删除条目&quot;</span>)fmt.Println(<span class="hljs-string">&quot;\t\t9 退出&quot;</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">menu</span><span class="hljs-params">()</span></span> &#123;n := <span class="hljs-number">0</span><span class="hljs-keyword">for</span> &#123;showMenu()fmt.Print(<span class="hljs-string">&quot;请选择：&quot;</span>)fmt.Scan(&amp;n)<span class="hljs-keyword">switch</span> n &#123;<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:fmt.Println(<span class="hljs-string">&quot;==============查看账目==============&quot;</span>)fmt.Println(<span class="hljs-string">&quot;\n余额：&quot;</span>, showAll())<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:fmt.Println(<span class="hljs-string">&quot;==============添加条目==============&quot;</span>)add()<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:fmt.Println(<span class="hljs-string">&quot;==============删除条目==============&quot;</span>)del()<span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:update()<span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:<span class="hljs-keyword">return</span><span class="hljs-keyword">default</span>:&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">showAll</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">if</span> dateL &lt;= <span class="hljs-number">0</span> &#123;fmt.Println(<span class="hljs-string">&quot;当前没有账目&quot;</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&#125;count := <span class="hljs-number">0</span>fmt.Println(<span class="hljs-string">&quot;序号&quot;</span>, <span class="hljs-string">&quot;\t日期      \t数额\t项目&quot;</span>)<span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> datas &#123;<span class="hljs-keyword">if</span> v.Abandon &#123;<span class="hljs-keyword">continue</span>&#125;count += v.Amountfmt.Println(i, <span class="hljs-string">&quot;\t&quot;</span>+v.String())&#125;<span class="hljs-keyword">return</span> count&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span> &#123;w := <span class="hljs-string">&quot; &quot;</span>b := <span class="hljs-literal">false</span>e := data.Ele&#123;Abandon: <span class="hljs-literal">false</span>&#125;<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">if</span> <span class="hljs-built_in">recover</span>() != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;输入有误&quot;</span>)&#125;&#125;()fmt.Println(<span class="hljs-string">`支出（I）/收入（O）：`</span>)fmt.Scan(&amp;w)<span class="hljs-keyword">if</span> w == <span class="hljs-string">&quot;i&quot;</span> || w == <span class="hljs-string">&quot;I&quot;</span> &#123;b = <span class="hljs-literal">true</span>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> w == <span class="hljs-string">&quot;O&quot;</span> || w == <span class="hljs-string">&quot;o&quot;</span> &#123;b = <span class="hljs-literal">false</span>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">panic</span>(errors.New(<span class="hljs-string">&quot;&quot;</span>))&#125;fmt.Print(<span class="hljs-string">&quot;\n输入日期（yyyy mm dd）：&quot;</span>)fmt.Scan(&amp;e.Year, &amp;e.Month, &amp;e.Date)<span class="hljs-keyword">if</span> b &#123;e.Item = <span class="hljs-string">&quot;收入&quot;</span>&#125; <span class="hljs-keyword">else</span> &#123;fmt.Print(<span class="hljs-string">&quot;\n输入用途：&quot;</span>)fmt.Scan(&amp;e.Item)&#125;fmt.Print(<span class="hljs-string">&quot;\n输入数额：&quot;</span>)fmt.Scan(&amp;e.Amount)<span class="hljs-keyword">if</span> !b &#123;e.Amount = -e.Amount&#125;datas = <span class="hljs-built_in">append</span>(datas, e)fmt.Println(<span class="hljs-string">&quot;\n添加成功！&quot;</span>)dateL++fmt.Print(<span class="hljs-string">&quot;继续吗？（Y/N）：&quot;</span>)fmt.Scan(&amp;w)<span class="hljs-keyword">if</span> w == <span class="hljs-string">&quot;y&quot;</span> || w == <span class="hljs-string">&quot;Y&quot;</span> &#123;add()&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">del</span><span class="hljs-params">()</span></span> &#123;index := <span class="hljs-number">-1</span><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">if</span> <span class="hljs-built_in">recover</span>() != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;输入有误&quot;</span>)&#125;&#125;()showAll()fmt.Print(<span class="hljs-string">&quot;请输入要删除的条目序号：&quot;</span>)fmt.Scan(&amp;index)<span class="hljs-keyword">if</span> !datas[index].Abandon &#123;dateL--datas[index].Abandon = <span class="hljs-literal">true</span>fmt.Println(<span class="hljs-string">&quot;成功&quot;</span>)&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">panic</span>(errors.New(<span class="hljs-string">&quot;&quot;</span>))&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">update</span><span class="hljs-params">()</span></span> &#123;index := <span class="hljs-number">-1</span><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">if</span> <span class="hljs-built_in">recover</span>() != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;输入有误&quot;</span>)&#125;&#125;()showAll()fmt.Print(<span class="hljs-string">&quot;请输入要更新的条目序号：&quot;</span>)fmt.Scan(&amp;index)<span class="hljs-keyword">if</span> datas[index].Abandon &#123;datas[index].Abandon = <span class="hljs-literal">false</span>fmt.Println(<span class="hljs-string">&quot;该条目已恢复&quot;</span>)dateL++<span class="hljs-keyword">return</span>&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>笔记</tag>
      
      <tag>程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Go&gt;5 Go 面向 “对象” 编程</title>
    <link href="/2022/06/19/Go/5%20Go%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/06/19/Go/5%20Go%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="go-面向-对象-编程">5 Go 面向 “对象” 编程</h1><p>Go也支持面向对象编程（OOP），但并不是纯粹的面向对象语言。准确地讲，<strong>Go语言支持面向对象编程特性</strong></p><p>Go 语言没有类（class）。Go语言的结构体（struct）与其他编程语言的类有同等地位。可以认为 Go语言是通过 struct 来实现 OOP 特性的</p><p>Go 面向对象编程非常简洁，其去掉了 OOP语言的继承、方法重载、构造函数、析构函数、隐藏的 this 指针等。Go语言仍有 OOP 的继承、封装、多态的特性。但实现方式不同于其他 OOP语言。</p><p>Go 语言的 OOP很优雅，其本身就是语言类型系统的一部分，通过接口关联。耦合度低，也十分灵活。Go语言中，面向接口编程是非常重要的特性</p><p>面向对象编程的步骤：声明（定义）结构体、编写结构体字段、编写结构体方法</p><h2 id="结构体">5.1 结构体</h2><p>将一类事物的特性提取出来，形成新的数据类型，就是一个结构体。通过这个结构体，可以创建多个变量。</p><h4 id="定义结构体">定义结构体</h4><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Example <span class="hljs-keyword">struct</span> &#123;    A_Str <span class="hljs-type">string</span>    A_Int <span class="hljs-type">int</span>&#125;</code></pre></div><p>结构体名、字段名的首字母大写时，该结构体、字段可以在其他包使用，否则只能在本包使用</p><h4 id="声明结构体变量">声明结构体变量</h4><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> e Examplee2 := Example&#123;<span class="hljs-string">&quot;e2 AStr&quot;</span>, <span class="hljs-number">2</span>&#125;<span class="hljs-comment">// 此时字段初始化列表要么为空，要么全部初始化</span>e3 := Example&#123;    A_Str: <span class="hljs-string">&quot;e3 AStr&quot;</span>,&#125; ep := <span class="hljs-built_in">new</span>(Example)<span class="hljs-comment">// 此时 ep 是一个指针</span></code></pre></div><p>结构体是 <strong>值类型</strong>，其赋值方式是<strong>值拷贝</strong>。</p><p>结构体是 <b><font color="#aF0000">值类型</font></b>，其赋值方式是<b><font color="#aF0000">值拷贝</font></b>。</p><p><font color="#AF0000">结构体是</font><b><font color="#FF0000">值类型</font></b>，<font color="#AF0000">其赋值方式是</FONT> <b><font color="#FF0000">值拷贝</font></b>。</p><h3 id="字段">5.1.1 字段</h3><p>字段（属性，field）是结构体的一个组成部分。可以是基本数据类型，数组，也能是引用类型。字段的声明方法与变量相同。</p><p>创建结构体变量后，没有给字段赋值时，字段对应一个零值。</p><p>不同结构体变量的字段是互相独立，互不影响的。一个结构体变量字段的更改不会影响其他结构体变量</p><p>访问字段：<code>结构体变量名.字段名</code></p><div class="code-wrapper"><pre><code class="hljs go">e.A_Int = <span class="hljs-number">50</span>(*ep).A_Int = <span class="hljs-number">100</span>ep.A_Int = <span class="hljs-number">-1</span><span class="hljs-comment">// 该写法是上面写法的简化</span></code></pre></div><blockquote><p><code>指针名.字段名</code> 的写法等同于<code>(*指针名).字段名</code></p></blockquote><h4 id="使用细节">使用细节</h4><ul><li><p>结构体的所有字段在内存中是连续分布的</p></li><li><p>结构体是用户单独定义的类型。与其他类型进行强制转换时，需要有完全相同的字段（包括字段名、字段个数、字段类型、顺序）</p></li><li><p>对结构体进行 type 重定义，Go语言会认为是新的数据类型。但是可以进行强制转换</p></li><li><p>在结构体的每个字段上，可以写一个 tag。该 tag可以通过反射机制获取。</p><p>常见场景：序列化、反序列化</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Examp <span class="hljs-keyword">struct</span> &#123;    Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><span class="hljs-comment">// json:&quot;name&quot; 就是 tag</span>&#125;</code></pre></div></li></ul><h2 id="方法">5.2 方法</h2><p>在某些情况下，需要声明（定义）方法。</p><p>方法与函数不同。Go 中的方法与指定的数据类型绑定。</p><p>不仅是 struct，只要是自定义类型，都可以有方法。</p><h4 id="方法的声明">方法的声明</h4><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> A <span class="hljs-keyword">struct</span> &#123;<span class="hljs-comment">// 一个自定义类型 A</span>    str <span class="hljs-type">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a A)</span></span> act() &#123;<span class="hljs-comment">// 绑定类型 A 的一个方法</span>    fmt.Println(a.str)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    s := A&#123;<span class="hljs-string">&quot;★&quot;</span>&#125;    s.act()<span class="hljs-comment">// 调用方法</span>&#125;</code></pre></div><h4 id="使用细节-1">使用细节</h4><ul><li><p>方法必须被指定的数据类型的对象调用。不能直接调用，也不能被其他数据类型调用</p></li><li><p>方法名前的括号中是该方法的接收者。这个概念类似于 Java的隐式参数。</p><p>方法调用时，将调用该方法的变量作为实参传递给方法作为接收者。</p></li><li><p>如果接收者是值类型，则接收者是值拷贝。否则是引用传递。</p><p>那结构体是值类型嘛，你懂的。如果希望修改结构体变量的值，可以通过指针方式</p><p>和函数不同，<strong>不论指针还是变量，都能直接调用方法</strong>。但接收者的类型只取决于声明方法时接收者的类型。</p></li><li><p>方法的访问范围控制与函数相同：首字母大写时才能在其他包访问</p></li><li><p>如果一个变量实现了 <code>String() string</code> 方法，则fmt.Print 会默认调用该方法进行输出</p></li></ul><h4 id="工厂模式">工厂模式</h4><p>Golang 的结构体没有构造函数，通常使用工厂模式解决这个问题</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ast <span class="hljs-keyword">struct</span> &#123;<span class="hljs-comment">// 一个自定义类型 ast</span>    str <span class="hljs-type">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetA</span><span class="hljs-params">(str <span class="hljs-type">string</span>)</span></span> *ast &#123;<span class="hljs-comment">// 相当于构造器</span>    <span class="hljs-keyword">return</span> &amp;a&#123;str&#125;&#125;fonc (a *ast) GetAStr() <span class="hljs-type">string</span> &#123;<span class="hljs-comment">// getter</span>    <span class="hljs-keyword">return</span> a.str&#125;</code></pre></div><h2 id="接口">5.3 接口</h2><p>interface类型可以定义一组方法，这些方法不需要实现。某个自定义类型需要使用时，再实现这些方法。接口体现了程序设计的<strong>多态</strong> 和 <strong>高内聚低耦合</strong> 的思想。</p><p>在 Go 语言中，<strong>interface不能包含任何变量</strong>，其方法都是没有实现的方法</p><p>在 Go 语言中，接口不需要显式的实现。只要一个变量实现了接口中的<strong>所有</strong> 方法，那么该变量就实现这个接口。</p><h4 id="声明定义接口">声明/定义接口</h4><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> I <span class="hljs-keyword">interface</span>&#123;<span class="hljs-comment">// 接口</span>    method() <span class="hljs-type">int</span><span class="hljs-comment">// 一个未实现的方法</span>&#125;<span class="hljs-keyword">type</span> C <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 不需要显式地实现接口</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c C)</span></span> method() <span class="hljs-type">int</span> &#123;<span class="hljs-comment">// 实现接口方法</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> i I = A&#123;&#125;fmt.Println(i.act())&#125;</code></pre></div><h4 id="注意事项">注意事项</h4><ul><li><p>接口不能创建实例，但可以指向一个实现了该接口的变量</p></li><li><p>接口的所有方法都没有实现</p></li><li><p>在 Go语言中，一个自定义类型实现了某个接口的所有方法，就认为该类型实现了该接口</p><p>只有实现了一个接口，才能将其赋给该接口类型</p><p><strong>通过指针类型实现方法时，只能把指针赋给接口</strong></p></li><li><p>只要是自定义数据类型就能实现接口，而不仅仅是结构体</p></li><li><p>一个自定义类型可以实现多个接口</p></li><li><p>在 Go 语言中，接口不能拥有任何变量，但可以继承别的接口。</p><p>继承别的接口时，接口中不能包含同名方法。否则，会导致重定义</p></li><li><p>interface 类型是一个指针，其零值为 nil</p></li><li><p>空接口没有任何方法，所以所有类型都实现了空接口</p></li></ul><h2 id="面向对象">5.4 面向对象</h2><p>面向对象编程的三大特性：封装、继承、多态</p><h3 id="封装">5.4.1 封装</h3><p>把抽象出的字段和对字段的操作封装在一起。数据被保护在内部，程序的其他包只有通过授权的操作（方法）才能对字段进行访问。</p><p>封装的好处：</p><ul><li>隐藏实现的细节</li><li>对数据进行验证，保证安全合理</li></ul><p>实现封装的方法：</p><ul><li><p>对结构体的属性进行封装</p><p>将结构体、字段的首字母小写</p></li><li><p>通过方法，包实现封装</p><p>提供一个工厂模式的函数，首字母大写，类似于构造函数</p><p>提供首字母大写的 Get 和 Set 方法，用以获取属性值或为属性赋值</p></li></ul><p>在 Go 语言中并不特别强调封装。</p><h3 id="继承">5.4.2 继承</h3><p>继承能解决代码复用的问题，让编程更靠近人类思维</p><p>当多个结构体存在相同的字段和方法时，可以从这些结构体中抽象出结构体，在该结构体中定义这些相同的属性和方法。其他结构体不需要重新定义字段和方法，只需要嵌套一个匿名结构体即可。</p><p>在 Go中，如果一个结构体嵌套了另一结构体，则该结构体能访问匿名结构体的字段和方法，从而实现了继承特性。</p><p>继承的好处：</p><ul><li>提高代码复用性</li><li>提高代码维护性、可扩展性</li></ul><h4 id="语法">语法</h4><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Father <span class="hljs-keyword">struct</span> &#123;    str <span class="hljs-type">string</span>&#125;<span class="hljs-keyword">type</span> Son <span class="hljs-keyword">struct</span> &#123;    Father<span class="hljs-comment">// 嵌套匿名结构体</span>&#125;</code></pre></div><p>嵌入了匿名结构体后，使用方式会发生变化</p><div class="code-wrapper"><pre><code class="hljs go">s := Son&#123;&#125;fmt.Println(s.Father.str)<span class="hljs-comment">// 使用匿名构造体的字段</span>fmt.Println(s.str)<span class="hljs-comment">// 访问匿名结构体字段可以简化</span></code></pre></div><h4 id="注意事项-1">注意事项</h4><ul><li><p>结构体能使用嵌套匿名结构体的所有字段和方法</p></li><li><p>访问匿名结构体字段可以简化。</p><p>直接通过字段构造体对象访问字段时，编译器会先查看结构体本身是否有该字段。</p><p>如果没有，会进而对内嵌匿名结构体进行查找。都找不到时会报错。</p><p>结构体嵌入多个匿名结构体，且当前嵌套层级的匿名结构体拥有相同字段或方法时，必须指定匿名结构体的名字，以消除二义性。否则报错</p></li><li><p>一个结构体嵌套了一个有名结构体时，这种模式就是<strong>组合</strong>。组合关系中，访问组合结构体字段时必须带上该有名结构体的名字</p></li><li><p>嵌套匿名结构体后，创建构造体实例时，也能直接指定那些匿名构造体字段的值</p></li><li><p>继承与接口的区别</p><ul><li><p><strong>继承</strong>：继承其他结构体后，自动获得其所有字段和方法，并可以直接使用</p><p>继承的价值在于解决代码的复用性和可维护性</p></li><li><p><strong>接口</strong>：希望扩展功能，又不想破坏继承关系时，就可以去实现接口。接口是对继承的补充</p><p>接口的价值在于设计号各种规范，让其他自定义类型实现这些方法。接口在一定程度上实现了代码解耦</p></li></ul></li></ul><h3 id="多态">5.4.3 多态</h3><p>多态：变量（实例）具有多种形态。</p><p>在 Go语言中，多态特征是通过接口实现的。通过统一的接口调用不同的实现，此时接口就呈现不同的形态。</p><h4 id="类型断言">类型断言</h4><p>由于接口是一般类型，不知道具体类型。要转成具体类型时，需要类型断言</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> I <span class="hljs-keyword">interface</span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> i I = <span class="hljs-number">10</span><span class="hljs-keyword">var</span> t <span class="hljs-type">int</span>    <span class="hljs-comment">/* t = i */</span><span class="hljs-comment">// 不允许这样赋值</span>    t = i.(T)<span class="hljs-comment">// 进行类型断言。此时如果类型不匹配，会导致 panic</span>&#125;</code></pre></div><p>进行类型断言时，如果实际类型不匹配，会报panic。应该确保指向的就是断言类型</p><p>为避免上述情况，在类型断言时，应该带上检测机制：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> i I = <span class="hljs-number">10</span><span class="hljs-keyword">if</span> t, done := i.(<span class="hljs-type">int</span>); done &#123;    fmt.Println(t)&#125; <span class="hljs-keyword">else</span> &#123;    fmt.Println(<span class="hljs-string">&quot;Failed&quot;</span>)&#125;</code></pre></div><p>或者也可以这样：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> i I = <span class="hljs-number">10</span><span class="hljs-keyword">if</span> t := i.(<span class="hljs-keyword">type</span>); t == <span class="hljs-type">int</span> &#123;    fmt.Println(<span class="hljs-string">&quot;i == int&quot;</span>)&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> t == <span class="hljs-type">float32</span> &#123;    fmt.Println(<span class="hljs-string">&quot;i == float&quot;</span>)&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;C++&gt;8 I/O 流</title>
    <link href="/2022/06/18/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/8%20IO%20%E6%B5%81/"/>
    <url>/2022/06/18/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/8%20IO%20%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="io-流">8 I/O 流</h1><blockquote><p>C++ 中没有输入/输出语句，但有一个面向对象的输入/输出软件包，即 I/O流类库。</p><p>流是 I/O流类库的核心概念。一般意义上说，凡是数据从一处传输到另一处都是流的操作。</p></blockquote><h4 id="c-流类库关系图">C++ 流类库关系图：</h4><pre><code class=" mermaid">graph TDa(ios) --&gt; b(istream)c --&gt; e(ofstream)a --&gt; c(ostream) --&gt; o(iostream)b --&gt; ob --&gt; d(ifstream)o --&gt; m(fstream)</code></pre><p>图中箭头表示继承关系。从 ios 派生 istream 和 ostream时，均使用了虚继承</p><p>istream类提供了流的大部分输入操作，对系统预定义的所有输入流重载提取运算符<code>&gt;&gt;</code></p><p>ostream 类对系统预定义的所有输出流重载插入运算符<code>&lt;&lt;</code></p><p>C++ 的 iostream 类库提供了数百种 I/O 功能。iostream类库接口部分包含在几个头文件中：</p><ul><li><p>iostream：包含操作所有输入/输出流所需的基本信息。大多数 C++程序都应该包含该文件。</p><p>该文件有 4 个标准流对象，提供了格式化和无格式化的 I/O 功能</p></li><li><p>iomanip：包含格式化 I/O的带参数流操作符，可用于指定数据输入/输出的格式</p></li><li><p>fstream：包含处理文件的有关信息，提供建立文件、读/写文件的各种操作接口</p></li></ul><h2 id="标准流对象">8.1 标准流对象</h2><p>C++ 在头文件 iostream 中定义了 4个标准流对象：cin（标准输入流）、cout（标准输出流）、cerr（非缓冲错误输出流）、clog（缓冲错误输出流）</p><ul><li><p>cin：与标准输入设备（键盘）相关联，用于读取数据，可以被重定向</p></li><li><p>cout：与标准输出设备（屏幕）相关联，用于输出数据，可以被重定向</p></li><li><p>cerr：与标准错误信息输出设备（屏幕）相关联（非缓冲），用于输出出错信息，不能重定向</p></li><li><p>clog：与标准错误信息输出设备（缓冲）相关联，用于输出出错信息，不能重定向</p><p>其与 cerr 的区别是 cerr 不需要缓存区，直接向显示器输出信息。</p></li></ul><p>程序中可以直接对上述 4 个预定义的标准流进行操作，而无需事先进行“打开” 操作，也无需在事后进行“关闭”。系统已经预先为每个程序都隐含了对他们的打开和关闭操作。</p><h4 id="错误状态字">错误状态字</h4><p>C++ 在 ios 类中定义了相关的错误状态字来反映流的状态。</p><p>状态字的每一位对应流的一种错误状态，用一个对应的标识常量标记</p><table><tr align="center"><th>标识常量</th><th>值</th><th>含义</th></tr><tr><td align="center">goodbit</td><td align="center">0x00</td><td align="left">流状态正常</td></tr><tr><td align="center">eofbit</td><td align="center">0x01</td><td align="left">文件结束符</td></tr><tr><td align="center">failbit</td><td align="center">0x02</td><td align="left">I/O 操作失败，数据未丢失，可以恢复</td></tr><tr><td align="center">badbit</td><td align="center">0x04</td><td align="left">非法操作，数据丢失，无法恢复</td></tr></table><h4 id="常用函数">常用函数：</h4><ul><li><p><code>FILE* freopen(const char* path, const char* mode, FILE* stream)</code></p><p>将 stream 按照 mode 指定的模式重定向到 path 指向的文件。mode 可以是w（写）或 r（读）</p><p>重定向发生错误时，将关闭原本的 stream，并返回 NULL</p></li><li><p><code>int eof() const</code></p><p>返回 eofbit 的值。当文本文件结束时，在输入流中会自动设置 eofbit</p><p>抵达结尾时，该值为 1，否则为 0</p><p>在标准输入流 cin 中，按下 ctrl + Z 组合键表示输入流的结束</p></li><li><p><code>int fail() const</code></p><p>返回 failbit 状态，以判断流操作是否失败</p></li><li><p><code>int good() const</code></p><p><code>int operator void*()</code></p><p>返回 goodbit 状态，以判断流操作是否正常。</p><p>当 eofbit、failbit、badbit 都未被置位时，返回 1，否则返回 0</p></li><li><p><code>int bad() const</code></p><p><code>int operator void!()</code></p><p>返回 badbit 状态，以判断流操作是否失败</p><p>当 eofbit、failbit、badbit 都未被置位时，返回 0，否则返回 1</p></li><li><p><code>int rdstate() const</code></p><p>返回流的当前状态</p></li><li><p><code>void clean(int nState = 0)</code></p><p>更改当前错误状态字</p></li></ul><h2 id="控制-io-格式">8.2 控制 I/O 格式</h2><p>不同的应用会对数据输入/输出的格式提出不同的要求。可以在使用 cout输出时控制格式。</p><h3 id="流操作符">8.2.1 流操作符</h3><p>为方便使用，C++中对所有的基本数据类型均设置了默认的数据输入/数据输出格式。</p><h4 id="默认的输出输入格式">默认的输出/输入格式：</h4><table><tr align="center"><th>I/O 的数据类型</th><th>默认输入格式</th><th>默认输出格式</th></tr><tr><td>short、int、long</td><td>与整型常数相同</td><td>一般整数形式，负数前带有负号</td></tr><tr><td>float、double、long double</td><td>与浮点数相同</td><td>浮点或指数格式。取决于哪个较短</td></tr><tr><td>char</td><td>第一个非空白字符</td><td>单个字符（无引号）</td></tr><tr><td>char*</td><td>从第一个空白字符起，到下一个空白字符结束</td><td>字符序列（无引号）</td></tr><tr><td>void*</td><td>无前缀的十六进制数</td><td>无前缀的十六进制数</td></tr><tr><td>Bool</td><td>true 或 1 识别为 true<br/>false 或 0 识别为 false</td><td>1 或 0</td></tr></table><p>C++ 在 iostream中提供了一些常用的无参数的流操作符（也称格式控制符）</p><p>流操作符可以直接用在 <code>&gt;&gt;</code> 或 <code>&lt;&lt;</code>后，使用便捷。</p><h4 id="常用的格式控制符">常用的格式控制符：</h4><p>使用以下格式控制符时要包含头文件 iostream</p><table><tr align="center"><th>流操作符</th><th>作用</th><th>输入/输出</th></tr><tr align="center"><td>endl</td><td align="left">输出一个换行符，并清空流</td><td>O</td></tr><tr align="center"><td>ends</td><td align="left">输出字符串结束，并清空流</td><td>O</td></tr><tr align="center"><td>flush</td><td align="left">清空流缓冲区</td><td>O</td></tr><tr align="center"><td>dec</td><td align="left">以十进制形式输入/输出整数（默认设置）</td><td>I/O</td></tr><tr align="center"><td>hex</td><td align="left">以十六进制形式输入/输出整数</td><td>I/O</td></tr><tr align="center"><td>ost</td><td align="left">以八进制形式输入/输出整数</td><td>I/O</td></tr><tr align="center"><td>ws</td><td align="left">提取空白字符</td><td>O</td></tr></table><h4 id="常用的格式控制流操作符">常用的格式控制流操作符：</h4><p>使用以下格式控制符时要包含头文件 iomanip</p><table><tr align="center"><th>流操作符</th><th>作用</th></tr><tr><td align="center">fixed</td><td>以普通小数形式输出浮点数</td></tr><tr><td align="center">scientific</td><td>以科学计数法形式输出浮点数</td></tr><tr><td align="center">left</td><td>左对齐。即宽度不足时将字符添加到右边</td></tr><tr><td align="center">right</td><td>右对齐。即宽度不足时将字符添加到在边（默认）</td></tr><tr><td align="center">setbase(int b)</td><td>设置输出时的进制。b 可以是 8、10、16</td></tr><tr><td align="center">setw(int w)</td><td>仅一次有效：设置输出宽度为 w 字符，或输入时读入 w 个字符。</td></tr><tr><td align="center">setfill(int c)</td><td>输出指定宽度时，不足宽度的场合以 c 字符填充（默认以空格填充）</td></tr><tr><td align="center">setprecision(int n)</td><td>设置输出浮点数的精度为 n。<br/> 非 fixed、scientific 方式的场合，n为有效数字最多的位数。超过时四舍五入或变为科学计数法并保留最多 n 位<br/>fixed、scientific 方式的场合，n 是小数点后保留的位数</td></tr><tr><td align="center">setiosflags(fmtflags f)</td><td>通用操作符。将格式标志 f 对应的格式标志位置置为 1</td></tr><tr><td align="center">resetiosflags(fmtflags f)</td><td>通用操作符。将格式标志 f 对应的格式标志位置置为 0（清除）</td></tr><tr><td align="center">boolapha</td><td>把 true 和 false 输出为字符串</td></tr><tr><td align="center">noboolapha</td><td>把 true 和 false 输出为 1 和 0（默认）</td></tr><tr><td align="center">showbase</td><td>输出表示数值进制的前缀</td></tr><tr><td align="center">noshowbase</td><td>不输出表示数值进制的前缀（默认）</td></tr><tr><td align="center">showpoint</td><td>总是输出小数点</td></tr><tr><td align="center">noshowpoint</td><td>小数存在时才输出小数点（默认）</td></tr><tr><td align="center">showpos</td><td>在非负值中显示 +</td></tr><tr><td align="center">noshowpos</td><td>在非负值中不显示 +（默认）</td></tr><tr><td align="center">skipws</td><td>输入时跳过空白字符（默认）</td></tr><tr><td align="center">noskipws</td><td>输入时不跳过空白字符（默认）</td></tr><tr><td align="center">uppercase</td><td>十六进制数中使用 A ~ E<br/> 若输出前缀，则前缀输出 0X、0B<br/>科学计数法中输出 E</td></tr><tr><td align="center">nouppercase</td><td>十六进制数中使用 a ~ e<br/> 若输出前缀，则前缀输出 0x、0b<br/>科学计数法中输出 e（默认）</td></tr><tr><td align="center">internal</td><td>数值的符号（正负号）在指定宽度内左对齐，数值右对齐，中间由填充字符填充</td></tr></table><p>以下是一个使用示范：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iomanip&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    cout &lt;&lt; uppercase &lt;&lt; showbase &lt;&lt; <span class="hljs-built_in">setbase</span>(<span class="hljs-number">8</span>);    cout &lt;&lt; <span class="hljs-number">100</span> &lt;&lt; endl;<span class="hljs-comment">// 输出 0X64</span>&#125;</code></pre></div><h3 id="标志字">8.2.2 标志字</h3><p>为满足不同用户对数据输入/输出 格式的要求，C++ 提供了通过setiosflags()设置标志字进行格式控制的方式。函数的参数为流的格式标志位</p><p>标志字是一个 long型的数据，由若干系统定义的格式控制标志位组合而成</p><h4 id="常见标志">常见标志</h4><table><tr align="center"><th>标志常量名</th><th>值</th><th>含义</th><th>输入/输出</th></tr><tr align="center"><td>ios::skipws</td><td>0x0001</td><td align="left">跳过输入中的空白</td><td>I</td></tr><tr align="center"><td>ios::left</td><td>0x0002</td><td align="left">按输出域左对齐，用填充字符填充右边</td><td>O</td></tr><tr align="center"><td>ios::right</td><td>0x0004</td><td align="left">按输出域右对齐，用填充字符填充左边（默认）</td><td>O</td></tr><tr align="center"><td>ios::internal</td><td>0x0008</td><td align="left">在符号位或基数指示符后填入字符</td><td>O</td></tr><tr align="center"><td>ios::dec</td><td>0x0010</td><td align="left">转换为十进制基数格式（默认）</td><td>I/O</td></tr><tr align="center"><td>ios::oct</td><td>0x0020</td><td align="left">转换为八进制基数格式</td><td>I/O</td></tr><tr align="center"><td>ios::hex</td><td>0x0040</td><td align="left">转换为十六进制基数格式</td><td>I/O</td></tr><tr align="center"><td>ios::showbase</td><td>0x0080</td><td align="left">在输出中显示基数指示符</td><td>O</td></tr><tr align="center"><td>ios::showpoint</td><td>0x0100</td><td align="left">输出浮点数时必须带小数点和尾部的 0</td><td>O</td></tr><tr align="center"><td>ios::uppercase</td><td>0x0200</td><td align="left">以大写字母表示十六进制数，科学计数法使用 E</td><td>O</td></tr><tr align="center"><td>ios::showpos</td><td>0x0400</td><td align="left">正数前加 + 符号</td><td>O</td></tr><tr align="center"><td>ios::scientific</td><td>0x0800</td><td align="left">以科学计数法表示浮点数</td><td>O</td></tr><tr align="center"><td>ios::fixed</td><td>0x1000</td><td align="left">定点形式表示浮点数</td><td>O</td></tr><tr align="center"><td>ios::unitbuf</td><td>0x2000</td><td align="left">插入操作后立即刷新流</td><td>O</td></tr></table><p>当要设置多个标志时，使用 | 运算符连接</p><p>流格式标志的每一位表示一种格式，标志位间有相互制约关系。设置了某个标志，又要设置与其矛盾的标志时，应使用函数resetiosflags() 清除原先的标志</p><p>为便于清除同类互斥位，ios 定义了几个公有静态符号常量：</p><Table><tr><td>ios::basefield</td><td>值为 dec|oct|hex</td></tr><tr><td>ios::adjustifield</td><td>值为 left|right|internal</td></tr><tr><td>ios::floatfield</td><td>值为 scientific|fixed</td></tr></table><h2 id="cincout-常用函数">8.3 cin/cout 常用函数</h2><h4 id="cin">cin</h4><ul><li><p><code>long flags(long lFlags)</code>：用传入关键字替换原先标志字。返回那个原来的标志字</p><p><code>long flags()</code>：仅返回那个原来的标志字</p><p><code>long setf(long lFlags)</code>：用传入关键字置位原先标志字。返回那个原来的标志字</p><p><code>long setf(long lFlags, long lMask)</code>：将关键字指定标志位清零，再置位关键字</p><p><code>long unsetf(long lMask)</code>：将关键字指定标志位清零</p><blockquote><p>这些函数和流操作符 setiosflags、resetiosflags 作用相同</p></blockquote></li><li><p><code>int width(int nw)</code>：设置输出宽度，返回旧输出宽度</p><p>该函数没有持续性。输出一项数据后输出宽度恢复默认值</p><p><code>int width() const</code>：返回输出宽度</p><blockquote><p>这些函数和流操作符 setw 作用相同</p></blockquote></li><li><p><code>char fill(char cFill)</code>：设置填充字符，返回旧填充字符</p><p><code>char fill() const</code>：返回填充字符</p><blockquote><p>这些函数和流操作符 setfill 作用相同</p></blockquote></li><li><p><code>int percision(int np)</code>：设置数据显示精度，返回旧显示精度</p><p><code>int percision() const</code>：返回显示精度</p><blockquote><p>这些函数和流操作符 setpercision 作用相同</p></blockquote></li></ul><p>ostream 中还有一些输出流通用的成员函数：</p><ul><li><code>ostream&amp; put(char)</code>：向流中插入字符</li><li><code>ostream&amp; write(const char* pch, int nCount)</code>：向流中插入pch 指向的长度为 nCount 的序列</li></ul><h4 id="cout">cout</h4><ul><li><p><code>int get()</code>：从输入流中读取一个字符。</p><p>遇到结束符时，返回值是系统常量 EOF</p></li><li><p><code>istream&amp; getline(char* buf, int bufSize)</code>：从输入流读取字符到缓冲区buf</p><p>读取到 <code>\n</code> 为止。一次最多读取 bufSize - 1个字符。函数会在数据结尾自动添加 <code>\0</code></p><p><code>istream&amp; getline(char* buf, int bufSize, char delim)</code>：从输入流读取字符到缓冲区buf</p><p>读取到 delim 为止。一次最多读取 bufSize - 1个字符。函数会在数据结尾自动添加 <code>\0</code></p></li><li><p><code>bool eof()</code>：判断是否输入流已结束</p></li><li><p><code>istream&amp; ignore(int n = 1, int delim = EOF)</code>：直到遇到delim 前，跳过流中的 n 个字符</p></li><li><p><code>int peek()</code>：返回流中的当前字符，但并不取出该字符</p></li></ul><h2 id="文件操作">8.4 文件操作</h2><p>文本类型分为两种：</p><ul><li>文本文件：以文本的 ASCII码 形式储存在计算机中</li><li>二进制文件：以文本的 二进制 形式储存在计算机中</li></ul><p>操作文件的三大类（需包含头文件 fstream）：</p><ul><li>ofstream：写操作</li><li>ifstream：读操作</li><li>fstream：读写操作</li></ul><p>在程序中，要使用一个文件，必须包含 3个步骤：打开文件、操作文件、关闭文件</p><h3 id="打开和关闭文件">8.4.1 打开和关闭文件</h3><p>对文件进行读写操作前，要先打开文件。打开文件有两个目的：</p><ul><li><p>建立关联。通过指定文件名，建立起文件与文件流对象的关联。以后进行操作时，可以通过与其相关的流对象来进行</p></li><li><p>说明文件的使用方式和文件格式。</p><p>使用方式有：只读、只写、既读又写、在末尾追加</p><p>文件格式是：文本方式、二进制方式</p></li></ul><h4 id="打开文件的方式">打开文件的方式</h4><ul><li><p>先建立流对象，再调用 open 函数</p><div class="code-wrapper"><pre><code class="hljs c++">ofstream ofs;<span class="hljs-comment">// 流类名 对象名;</span>ofs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;D:\1.txt&quot;</span>, ios::out | ios::app);    <span class="hljs-comment">// 对象名.open(文件名, 模式);</span></code></pre></div><p><strong>流类</strong>：ifstream（读）、ofstream（写）、fstream（读/写）</p><p><strong>文件名</strong>：用字符串标识的外部文件。可以是完整路径，也可以是相对路径</p><p><strong>模式</strong>：是类 ios中定义的打开方式常量，用来表示文件打开方式</p></li><li><p>使用流类自带的构造函数，在构造流对象时即连接外部文件</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">ofstream <span class="hljs-title">ofs</span><span class="hljs-params">(<span class="hljs-string">&quot;D:\1.txt&quot;</span>, ios::out | ios::app)</span></span>;</code></pre></div><p>可以用文件名是否为 true 以判断是否打开成功</p><div class="code-wrapper"><pre><code class="hljs c++">cout &lt;&lt; (ofs ? <span class="hljs-string">&quot;打开成功&quot;</span> : <span class="hljs-string">&quot;打开失败&quot;</span>) &lt;&lt; endl;</code></pre></div></li></ul><h4 id="文件打开模式标记">文件打开模式标记</h4><table><tr align="center"><th>模式标记</th><th>适用对象</th><th>作用</th></tr><tr align="center"><td>ios::in</td><td>ifstream<br/>fstream</td><td align="left">以读方式打开文件。<br/>如果文件不存在，则打开出错</td></tr><tr align="center"><td>ios::out</td><td>ofstream<br/>fstream</td><td align="left">以写方式打开文件。<br/>如果文件不存在，则创建该文件。否则在打开时清除原先内容</td></tr><tr align="center"><td>ios::app</td><td>ofstream</td><td align="left">以追加方式打开文件，用于在文件尾部添加数据。<br/>如果文件不存在，则新建该文件</td></tr><tr align="center"><td>ios::ate</td><td>ofstream</td><td align="left">打开一个已有文件，文件指针指向末尾<br/>如果文件不存在，则打开出错</td></tr><tr align="center"><td>ios::trunc</td><td>ofstream</td><td align="left">删除文件现有内容。单独使用时等同于 ios::out</td></tr><tr align="center"><td>ios::binary</td><td>ofstream<br/>ifstream<br/>fstream</td><td align="left">以二进制方式打开文件<br/>若不指定此模式，则以默认的文本方式打开文件</td></tr></table><p>标记可以组合使用。组合时，使用 <code>|</code> 符号分隔。如：</p><p><code>ios::in | ios::out</code>：此时既可以读也可以写，且打开文件时原有内容保持不变</p><h4 id="关闭文件">关闭文件</h4><p>发出关闭文件指令后，系统会将缓存区数据完整写入文件，并添加文件结束标记，切断流对象与外部文件的连接。</p><p>使用 fstream 的成员函数 close 关闭文件</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">ofstream <span class="hljs-title">ofs</span><span class="hljs-params">(<span class="hljs-string">&quot;D:\1.txt&quot;</span>, ios::out | ios::app)</span></span>;...ofs.<span class="hljs-built_in">close</span>();<span class="hljs-comment">// 关闭了文件</span></code></pre></div><h3 id="读写文件">8.4.2 读写文件</h3><p>每个文件都有一个结束标识。对于文本文件来说，C++ 在 iostream中定义了一个标识文件结束的标识常量 EOF，其值为 <code>0x1A</code>的字符。关闭文件流时，该字符被自动加入文件尾部。</p><p>在键盘操作时，按下 ctrl + Z 组合键即可在标准输入流 cin中输入文件结束符</p><h4 id="写文件">写文件</h4><div class="code-wrapper"><pre><code class="hljs c++">ofstream ofs;<span class="hljs-comment">// [2] 创建流对象</span>ofs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;D:/1.txt&quot;</span>);<span class="hljs-comment">// [3] 打开文件</span>ofs &lt;&lt; <span class="hljs-string">&quot;OFS&quot;</span>;<span class="hljs-comment">// [4] 写入数据</span>ofs.<span class="hljs-built_in">close</span>();<span class="hljs-comment">// [5] 关闭文件</span></code></pre></div><ol type="1"><li><p>包含头文件：<code>#include&lt;fstream&gt;</code></p></li><li><p>创建流对象：<code>ofstream ofs;</code></p></li><li><p>打开文件：<code>ofs.open("文件路径", 打开方式);</code></p></li><li><p>写数据：<code>ofs &lt;&lt; "写入的数据";</code></p><p>也能使用 <code>put(char c)</code> 一次只放入一个字节</p></li><li><p>关闭文件：<code>ofs.close();</code></p></li></ol><h4 id="读文件">读文件</h4><div class="code-wrapper"><pre><code class="hljs c++">ifstream ifs;<span class="hljs-comment">// [2] 创建流对象</span>ifs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;D:/1.txt&quot;</span>, ios::in);<span class="hljs-comment">// [3] 打开文件</span><span class="hljs-keyword">if</span> (!ifs.<span class="hljs-built_in">is_open</span>()) <span class="hljs-keyword">return</span>;<span class="hljs-type">char</span> cs[<span class="hljs-number">1024</span>];<span class="hljs-comment">// [4] 读取文件</span><span class="hljs-keyword">while</span> (ifs &gt;&gt; cs) cout &lt;&lt; cs &lt;&lt; endl;ifs.<span class="hljs-built_in">close</span>();<span class="hljs-comment">// [5] 关闭文件</span></code></pre></div><ol start="3" type="1"><li><p>打开文件</p><p>其中 <code>ifs.is_open()</code> 用于判断是否打开文件。成功的场合返回true</p><p>判断文件是否为空的方法：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">char</span> c;ifs &gt;&gt; c;<span class="hljs-comment">// 读取一个字符</span><span class="hljs-keyword">if</span> (ifs.<span class="hljs-built_in">eof</span>()) cout &lt;&lt; <span class="hljs-string">&quot;文件为空&quot;</span> &lt;&lt; endl;<span class="hljs-comment">// 遇到标识符 EOF 则文件为空</span></code></pre></div></li><li><p>读取文件。读取文件有 4 种方法：</p><ul><li><p>按数组长度读取至数组</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">char</span> cs[<span class="hljs-number">1024</span>];<span class="hljs-keyword">while</span> (ifs &gt;&gt; cs) cout &lt;&lt; cs &lt;&lt; endl;</code></pre></div><p>其中 <code>ifs &gt;&gt; cs</code> 如果读取到文件末尾，则返回false</p></li><li><p>按行读取至数组：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">char</span> cs[<span class="hljs-number">1024</span>];<span class="hljs-keyword">while</span> (ifs.<span class="hljs-built_in">getline</span>(cs, <span class="hljs-built_in">sizeof</span>(cs))) cout &lt;&lt; cs &lt;&lt; endl;</code></pre></div><p>其中 <code>ifs.getline(char*, int)</code> 第一个形参是一个<code>char*</code>，第二个形参是最大长度。该方法会把读取到的字符写入<code>char*</code></p></li><li><p>按行读取至字符串：</p><div class="code-wrapper"><pre><code class="hljs c++">string str;<span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(ifs, str)) cout &lt;&lt; str &lt;&lt; endl;</code></pre></div></li><li><p>按字符读取（不推荐使用）：</p><p>使用 <code>get()</code> 方法一次读取一个字节，或者<code>get(char&amp; c)</code> 读取字节并让 c 引用</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">char</span> c;<span class="hljs-keyword">while</span> ((c = ifs.<span class="hljs-built_in">get</span>()) != EOF) cout &lt;&lt; c;</code></pre></div></li></ul></li></ol><h3 id="二进制文件">8.4.3 二进制文件</h3><p>二进制文件也被称为 类型文件。</p><p>二进制文件以基本数据类型的二进制形式存放。其数据存储格式与内存一致，且长度仅与数据类型有关。二进制数据流不会对写入读出的数据做格式转换，便于高速处理数据。</p><h4 id="二进制文件与文本文件的区别">二进制文件与文本文件的区别</h4><ul><li><p>文本文件兼容性强。但其存储信息时需要人为添加分隔符，占用空间大。读取时需要在内存、外存间进行格式转换，也不便于对数据进行随机访问。</p></li><li><p>二进制文件以二进制形式存储数据，便于对数据进行随机访问，读写速度快。但兼容性差。</p></li><li><p>在 Windows 中，以文本方式读取文件，系统会将所有 <code>\r\n</code>转换成 <code>\n</code>。即如果存在连续字节<code>0x0D0A</code>，系统会将其转换为 <code>0x0A</code></p><p>同样的，写文件时，会将 <code>\n</code> 转换为 <code>\r\n</code></p><p>因此，使用文本方式打开二进制文件进行读写，其结果可能与原先存在出入。所以使用二进制方法打开文件总是更为安全。</p></li></ul><h4 id="读写二进制文件">读写二进制文件</h4><p>二进制文件打开方式要指定为 <code>ios::binary</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ele</span> &#123;<span class="hljs-comment">// 随便写的一个类</span><span class="hljs-keyword">public</span>:<span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">write_met</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-function">ofstream <span class="hljs-title">ofs</span><span class="hljs-params">(<span class="hljs-string">&quot;D:/1.txt&quot;</span>, ios::out | ios::binary)</span></span>;<span class="hljs-comment">//[2] 创建输出流对象</span>Ele e = <span class="hljs-built_in">Ele</span>();e.n = <span class="hljs-number">100</span>;ofs.<span class="hljs-built_in">write</span>((<span class="hljs-type">char</span>*)&amp;e, <span class="hljs-built_in">sizeof</span>(e));<span class="hljs-comment">//[3] 写入文件</span>ofs.<span class="hljs-built_in">close</span>();&#125;<span class="hljs-function">Ele* <span class="hljs-title">read_met</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-function">ifstream <span class="hljs-title">ifs</span><span class="hljs-params">(<span class="hljs-string">&quot;D:/1.txt&quot;</span>, ios::in | ios::binary)</span></span>;<span class="hljs-comment">//[4] 创建输入流对象</span><span class="hljs-keyword">if</span> (!ifs.<span class="hljs-built_in">is_open</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;Ele e;<span class="hljs-comment">//[5] 读取文件</span>ifs.<span class="hljs-built_in">read</span>((<span class="hljs-type">char</span>*)&amp;e, <span class="hljs-built_in">sizeof</span>(e));<span class="hljs-keyword">return</span> &amp;e;&#125;</code></pre></div><ol start="3" type="1"><li><p>写入文件</p><p><code>ofs.write(const char*, int)</code>：需求一个对象的 char*类型的指针，因此要进行强制转型</p><p><code>ifs.read(const char*, int)</code>：同理</p><p>使用这些方法进行读写时，不需要额外插入分隔符。它们本身都要求指定读写长度</p></li><li><p>能使用 <code>int gcount()</code> 成员函数得到读取的字节数</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> num = ifs.<span class="hljs-built_in">gcount</span>();<span class="hljs-comment">// 上一次读取的字节数</span></code></pre></div></li></ol><h3 id="随机访问文件">8.4.4 随机访问文件</h3><p>如果一个文件只能进行顺序存取操作，则称为顺序文件。键盘、显示器、磁带就是典型的顺序文件设备。</p><p>能在文件任意位置进行存取操作的，称为随机访问文件。</p><p>C++ 中，每个流都有一个<strong>流指针</strong>，其由系统控制，随着流的各种操作在字节流中移动。</p><p>文件打开后，系统会自动生成一个流指针，指向文件开头（以 ios::ate形式打开时，指向结尾）。文件的 读/写 操作从指针位置开始。每次 读/写操作后，指针会移动到下一个 读/写 分量的起始位置。</p><p>顺序访问方式下，流指针自动移动，无需人为改变。也能通过函数改变指针位置，实现随机访问。</p><p><strong>istream：</strong></p><ul><li><p><code>istream&amp; seekg(long offset, ios::seek_dir dir)</code>：让文件读指针向指定位置移动</p><p>其中 <code>ios::seek_dir</code> 是 ios中定义的一个枚举类型，值是：</p><ul><li><code>ios::beg</code>：流的开始位置。此时 offset 需是非负整数</li><li><code>ios::cur</code>：表示流的当前位置。此时 offset为负表示向前移动</li><li><code>ios::end</code>：；流的结束位置。此时 offset 需是非正整数</li></ul><p><code>istream&amp; seekg(long pos)</code>：设置文件读指针的位置</p><p>等价于 <code>seekg(pos, ios::beg)</code></p></li><li><p><code>long tellg()</code>：返回读指针的当前位置</p></li></ul><p><strong>ostream：</strong></p><ul><li><p><code>ostream&amp; seekp(long offset, ios::seek_dir dir)</code>：让文件写指针向指定位置移动</p><p><code>ostream&amp; seekp(long pos)</code>：设置文件写指针的位置</p></li><li><p><code>long tellp()</code>：返回写指针的当前位置</p></li></ul><p>在 fstream 中，读指针与写指针是同一指针。对其调用上述 读/写函数是等价的</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Go&gt;4 数组、切片和 map</title>
    <link href="/2022/06/11/Go/4%20%E6%95%B0%E7%BB%84%E3%80%81%E5%88%87%E7%89%87%E5%92%8C%20map/"/>
    <url>/2022/06/11/Go/4%20%E6%95%B0%E7%BB%84%E3%80%81%E5%88%87%E7%89%87%E5%92%8C%20map/</url>
    
    <content type="html"><![CDATA[<h1 id="数组切片和-map">4 数组、切片和 map</h1><h2 id="数组">4.1 数组</h2><p>数组可以存放多个同一类型的数据。数组也是一种数据类型。</p><p>在 Go中，数组也是值类型。<strong>默认情况下为值拷贝，新旧数组互不影响</strong></p><p>数组在内存中是一段连续的空间。数组名指向该数组空间的首地址，也是数组第一个元素的地址。</p><p>数组各个元素的地址间隔依据数组类型决定。</p><p>Go中不允许可变大小的数组，也不允许使用变量作为数组大小。如有需求，请使用切片</p><p><strong>数组的定义：</strong></p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> array [<span class="hljs-number">10</span>]<span class="hljs-type">int</span><span class="hljs-comment">// 数组元素为零值</span><span class="hljs-keyword">var</span> array1 [<span class="hljs-number">3</span>]<span class="hljs-type">int</span> = [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<span class="hljs-comment">// 声明时即初始化</span><span class="hljs-keyword">var</span> array2 = [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<span class="hljs-comment">// 类型推导</span><span class="hljs-keyword">var</span> array3 = [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<span class="hljs-comment">// 数组大小推导</span><span class="hljs-keyword">var</span> array4 = [<span class="hljs-number">4</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>: <span class="hljs-number">1</span>, <span class="hljs-number">0</span>: <span class="hljs-number">2</span>, <span class="hljs-number">3</span>: <span class="hljs-number">3</span>, <span class="hljs-number">2</span>: <span class="hljs-number">4</span>&#125;<span class="hljs-comment">// 指定那些下标元素</span><span class="hljs-keyword">var</span> array5 = [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>: <span class="hljs-number">1</span>, <span class="hljs-number">0</span>: <span class="hljs-number">2</span>, <span class="hljs-number">3</span>: <span class="hljs-number">3</span>, <span class="hljs-number">7</span>: <span class="hljs-number">4</span>&#125;<span class="hljs-comment">// 此时类型为 int[8]</span></code></pre></div><p><strong>访问数组元素：</strong></p><div class="code-wrapper"><pre><code class="hljs go">数组名[下标]</code></pre></div><h2 id="切片">4.2 切片</h2><p>slice 切片是 Go 中特有的数据类型。切片的使用类似数组</p><p>切片是数组的引用，因此切片是引用类型。进行值传递时，遵守引用传递机制</p><p>切片的长度可变，因此切片是可以动态变化的数组</p><h4 id="切片的定义">切片的定义：</h4><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s []<span class="hljs-type">int</span><span class="hljs-comment">// 声明一个切片</span>s1 := array4[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]<span class="hljs-comment">// 该切片引用数组 array4 [1,3) 范围的数据</span>s2 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">4</span>, <span class="hljs-number">10</span>)<span class="hljs-comment">// 使用 make 函数获得 长度4 容量10 的切片</span>s3 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>)<span class="hljs-comment">// 该切片容量、长度都是 5</span>s4 := array4[<span class="hljs-number">2</span>:]<span class="hljs-comment">// 相当于 array4[2:len(array4)]</span>s5 := array4[:<span class="hljs-number">4</span>]<span class="hljs-comment">// 相当于 array4[0:4]</span>s6 := array4[:]<span class="hljs-comment">// 相当于 array4[0:len(array4)]</span></code></pre></div><p>切片声明后还不能使用，因为其为空。必须让其引用数组，或使用 make方法产生切片空间后才能使用。</p><p>切片可以继续切片</p><h4 id="切片常用函数">切片常用函数：</h4><ul><li><p><code>len(v) int</code>：返回切片的长度（包含的元素数量）</p></li><li><p><code>cap(v) int</code>：返回切片的容量（能包含的最大元素数量）</p></li><li><p><code>make(Type, IntegerType) Type</code>：分配并初始化一个指定长度的切片</p><p><code>make(Type, IntegerType, IntegerType) Type</code>：返回一个指定长度、容量的切片</p><p>通过 make 方式创建的切片，其对应数组由 make函数底层维护，对外不可见。</p></li><li><p><code>append(slice []Type, ele Type...) slice</code>：对切片进行动态追加。</p><p>容量不足的场合会扩容。返回追加完毕后的新的切片</p><p>Go 底层会创建新的数组，并将原有元素以 <strong>值拷贝</strong>方式拷贝到新的数组。之后，返回一个引用新数组的新切片</p><p>也就是说，切片进行 append 后，新的切片会失去对原有数组的引用</p><p>也能追加一个切片：</p><div class="code-wrapper"><pre><code class="hljs go">s = <span class="hljs-built_in">append</span>(s, s...)<span class="hljs-comment">// 表示将 s 的全部元素追加到 s 后</span></code></pre></div></li><li><p><code>copy(s []Type, o []Type)</code>：将 o的数据拷贝（值拷贝）到 s。</p><p>期间，s 的容量不变。s 容量更大时，多余位置保留原样。s容量更小时，其余元素不保存。</p></li></ul><h4 id="string-与-slice-的关系">string 与 slice 的关系</h4><p>因为 string 底层是 byte 数组，因此 string 也能进行切片处理</p><p>字符串是不可变的。不能通过下标直接改变 string的字符。可以通过切片实现修改需求</p><p>想要改变字符串时，先将字符串转换成 []byte 或[]rune。修改后重新转换成字符串：</p><div class="code-wrapper"><pre><code class="hljs go">str := <span class="hljs-string">&quot;刻晴刻晴刻晴刻晴&quot;</span>s := []<span class="hljs-type">rune</span>(str)[<span class="hljs-number">6</span>:]s = <span class="hljs-built_in">append</span>(s, []<span class="hljs-type">rune</span>(<span class="hljs-string">&quot;晴~~&quot;</span>)...)s[<span class="hljs-number">3</span>] = <span class="hljs-string">&#x27;★&#x27;</span>str = <span class="hljs-type">string</span>(s)<span class="hljs-comment">// 刻晴晴★~</span></code></pre></div><h2 id="map">4.3 map</h2><p>map（映射）是 key-value 数据结构，又称字段或关联数组</p><p>key 可以是 slice、map、function 外的类型（这些类型不能使用 ==判断）。通常使用 int 或 string 做 key</p><h4 id="map-的定义">map 的定义：</h4><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> <span class="hljs-comment">// key 是 string，value 是 int</span>m2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>, <span class="hljs-number">10</span>)m3 := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>&#123;    <span class="hljs-number">0</span>: <span class="hljs-string">&quot;刻晴&quot;</span>,    <span class="hljs-number">1</span>: <span class="hljs-string">&quot;胡桃&quot;</span>,    <span class="hljs-number">2</span>: <span class="hljs-string">&quot;甘雨&quot;</span>,&#125;</code></pre></div><p>map 的声明时不分配内存，需要 make 后才能使用</p><h4 id="map-的-crud">map 的 CRUD：</h4><div class="code-wrapper"><pre><code class="hljs go">m[<span class="hljs-string">&quot;刻晴&quot;</span>] = <span class="hljs-number">100</span><span class="hljs-comment">// 增加、修改 k-v</span><span class="hljs-built_in">delete</span>(m, <span class="hljs-string">&quot;刻晴&quot;</span>)<span class="hljs-comment">// 按照 key 删除 k-v</span>val, find := m[<span class="hljs-string">&quot;甘雨&quot;</span>]<span class="hljs-comment">// val 为查找到的值，find 为是否找到</span><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m &#123;<span class="hljs-comment">// 使用 for-range 进行遍历</span>    fmt.Println(k, <span class="hljs-string">&quot; - &quot;</span>, v)&#125;</code></pre></div><p>map 的 key 不能重复，value 可以重复。其 key - value 是无序存放的</p><p>要将 map 的 key 排序，只有先将所有 key 取出，再将取出的 key排序，最后按照顺序取出那些值</p><h4 id="使用细节">使用细节</h4><ul><li>map 是引用类型，遵守引用传递的机制</li><li>map 的容量达到后，会自动扩容</li><li>map 的 value 也常用 struct 类型，更适合管理复杂数据</li></ul>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Go&gt;3 函数、包和错误处理</title>
    <link href="/2022/06/08/Go/3%20%E5%87%BD%E6%95%B0%E3%80%81%E5%8C%85%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
    <url>/2022/06/08/Go/3%20%E5%87%BD%E6%95%B0%E3%80%81%E5%8C%85%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="函数包和错误处理">3 函数、包和错误处理</h1><h2 id="包">3.1 包</h2><p>go 以包的形式管理文件和项目目录结构。Go中的每个文件都属于一个包。</p><h4 id="包的作用">包的作用：</h4><ul><li>区分相同名字的函数、变量等标识符</li><li>程序文件繁多时，可以很好地管理项目</li><li>控制函数、变量等访问范围（作用域）</li></ul><h4 id="语法">语法：</h4><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> 包名<span class="hljs-comment">// 文件打包</span><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;包的路径&quot;</span><span class="hljs-comment">// 引入包</span></code></pre></div><h4 id="使用细节">使用细节：</h4><ul><li><p>文件打包时，让该包对应文件夹名。包名与文件夹名一致，且为小写字母</p></li><li><p>当文件要使用其他包的函数或变量时，要先引入对应的包</p><p>一次性引入多个包时，也能这样做</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;包名1&quot;</span>    <span class="hljs-string">&quot;包名2&quot;</span>)</code></pre></div></li><li><p>package 指令必须存在于文件第一行，之后才是 import 命令</p></li><li><p>import 包时，编译器自动从 $GOPATH 的 src目录下开始引入。</p></li><li><p>访问其他包的函数、变量时，语法是：<code>包名.标识符</code></p></li><li><p>如果包名较长，也能为其取别名。但取别名后，原本的包名就不再使用了</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">import</span> 别名 <span class="hljs-string">&quot;包名&quot;</span></code></pre></div></li><li><p>在同一包下，不能有相同的函数名。否则会导致重复定义</p></li><li><p>main 包是唯一的。如果要编译成一个可执行文件，就需要将该包声明为main。</p><div class="code-wrapper"><pre><code class="hljs cmd">*****&gt;go build [-o bin/my.exe] ****/****/****/main</code></pre></div><p><code>[ ]</code>中是可选内容。加入的场合，在那个指定位置生成指定名称的可执行文件。否则在$GOPATH 目录下生成默认名称的可执行文件。</p></li></ul><h2 id="函数">3.2 函数</h2><p>为完成某一功能的程序指令的集合，称为函数。程序不能没有函数，就像西方不能失去耶路撒冷。</p><p>在 Go 中，函数分为：自定义函数、系统函数</p><h4 id="基本语法">基本语法：</h4><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> 函数名 <span class="hljs-params">(形参列表)</span></span> (返回值列表) &#123;    执行语句    <span class="hljs-keyword">return</span> 返回值列表&#125;</code></pre></div><p>可以没有返回值。这个场合，也能没有 return 语句</p><p>只有一个返回值（且未命名）时，那个返回值列表的括号也能省略</p><h4 id="注意事项">注意事项：</h4><ul><li><p>接收函数返回值时，如果希望忽略某个返回值，可以使用 <code>_</code>接收那个希望忽略的值</p></li><li><p>参数列表和返回值列表的数据类型可以是值类型，也能是引用类型</p></li><li><p>函数命名遵循标识符命名规范。</p></li><li><p>函数中的变量是局部的，函数外不生效</p></li><li><p>基本数据类型与数组的传参方法默认是值传递。在函数内修改不会影响原来的值</p><p>可以传入变量的地址，并在函数内以指针形式操作变量。这样从效果上看类似引用传递</p><p>不管值传递还是引用传递，传递给函数的都是变量的副本。但值传递传递值的拷贝，引用传递传递那个地址的拷贝。</p></li><li><p><strong>Go 函数不支持重载</strong></p></li><li><p><strong>Go 中的函数也是一种数据类型。</strong></p><p>可以把函数赋值给一个变量。这样，该变量就是一个函数类型的变量了。</p><p>Go 中函数是数据类型，因此也能作为形参，并调用</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a := actfmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, a)<span class="hljs-comment">// func(int, int) int</span>fmt.Println(met(act))<span class="hljs-comment">// 6</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">act</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> a + b&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">met</span><span class="hljs-params">(f <span class="hljs-keyword">func</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> f(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)&#125;</code></pre></div></li><li><p>为简化数据类型定义，Go 支持自定义数据类型。语法如下：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> 自定义数据类型 数据类型</code></pre></div><p>可以理解为给数据类型起了一个别名</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> myfunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span><span class="hljs-comment">// 此时 myfunc 等价于 func(int, int) int</span><span class="hljs-keyword">var</span> a myfunc = actfmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, a)<span class="hljs-comment">// main.myfunc</span></code></pre></div><p>虽然起了别名，但 Go 认为是两个不同类型</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> myInt <span class="hljs-type">int</span><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span> = <span class="hljs-number">1000</span><span class="hljs-keyword">var</span> n myInt = <span class="hljs-number">10</span>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, i)fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, n)<span class="hljs-comment">/* n = i */</span><span class="hljs-comment">// 无法这样赋值，因为 Go 认为 myInt 不是 int</span>n = myInt(i)<span class="hljs-comment">// 需要进行类型转换</span></code></pre></div></li><li><p>支持对函数返回值命名</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">act</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">int</span>, sum <span class="hljs-type">int</span>, sub <span class="hljs-type">int</span>) &#123;sum = a + bsub = a - b    <span class="hljs-keyword">if</span> (sum &gt; <span class="hljs-number">20</span>) &#123;        <span class="hljs-keyword">return</span>    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fmt.Println(act(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>))<span class="hljs-comment">// 1 1 1</span>fmt.Println(act(<span class="hljs-number">100</span>, <span class="hljs-number">1</span>))<span class="hljs-comment">// 0 101 99</span>&#125;</code></pre></div><p>对返回值命名时，那些命名的返回值后方的所有返回值也要一并命名。</p><p>只要有对返回值的命名，就能使用单独的 return语句。届时将所有命名的返回值返回，未命名的返回值返回那个类型的零值</p><p>即使对返回值进行了命名，也能指定返回值。指定返回值时必须指定全部返回值</p></li><li><p>Go 支持可变参数</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">met</span><span class="hljs-params">(args ...<span class="hljs-type">int</span>)</span></span> (sum <span class="hljs-type">int</span>) &#123;<span class="hljs-keyword">for</span> _, value := <span class="hljs-keyword">range</span> args &#123;sum += value&#125;<span class="hljs-keyword">return</span> sum&#125;</code></pre></div><p>args 本质是一个 slice 切片。通过 args[index] 访问各个值</p></li><li><p>函数内部声明 / 定义的变量称为<strong>局部变量</strong>。其作用域仅限于函数内部。如果变量在代码块中，其作用域即限于该代码块。</p><p>函数外部声明 / 定义的变量称为<strong>全局变量</strong>。作用域在整个包都有效。那个首字母大写的场合，其作用域在整个程序中有效。</p></li></ul><h3 id="init-函数">3.2.1 init 函数</h3><p>每个源文件都能包含一个 init 函数。该函数会在 main 函数执行前，被 Go调用。</p><p>通常可以在 init 函数中完成初始化工作。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;    ...&#125;</code></pre></div><h4 id="注意事项-1">注意事项：</h4><ul><li><p>如果一个文件包含 全局变量定义、init 函数 和 main函数，其执行流程是：</p><p>全局变量定义 -&gt; init 函数 -&gt; main 函数</p></li><li><p>init 函数最主要的作用是进行初始化工作</p></li><li><p>引入文件也有 init 函数时，执行流程如下：</p><p>被引入的全局变量定义 -&gt; 被引入的 init 函数 -&gt; 全局变量定义-&gt; init 函数 -&gt; main 函数</p></li></ul><h3 id="匿名函数">3.2.2 匿名函数</h3><p>Go支持匿名函数。如果我们希望某个函数只使用一次，可以使用匿名函数。</p><p>匿名函数也能多次调用。</p><h4 id="使用方式">使用方式：</h4><ul><li><p>将匿名函数赋给变量。通过变量来调用</p><div class="code-wrapper"><pre><code class="hljs go">f := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n1 <span class="hljs-type">int</span>, n2 <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;     <span class="hljs-keyword">return</span> n1 + n2 &#125;i := f(<span class="hljs-number">4</span>, <span class="hljs-number">100</span>)</code></pre></div></li><li><p>定义匿名函数时直接调用</p><div class="code-wrapper"><pre><code class="hljs go">i := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n1 <span class="hljs-type">int</span>, n2 <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">return</span> n1 + n2&#125;(<span class="hljs-number">4</span>, <span class="hljs-number">7</span>)</code></pre></div><p>这个调用可以理解成 <code>i := f(4, 100)</code> 中的 <code>f</code>标识符直接替换为函数对象。</p><p>因为没有命名，所以只能调用一次</p></li><li><p>将匿名函数赋给全局变量，则其成为全局匿名函数</p></li></ul><h3 id="闭包">3.2.3 闭包</h3><p>闭包就是一个函数和其相关的引用环境组成的整体（实体）</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">act</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;i := <span class="hljs-number">0</span><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a <span class="hljs-type">int</span>)</span></span> (ret <span class="hljs-type">int</span>) &#123;ret = ii += a<span class="hljs-keyword">return</span>&#125;&#125;</code></pre></div><p>上述函数返回一个匿名函数，该匿名函数用到函数外的 i。</p><p>该匿名函数与 i 是一个整体，即构成一个闭包。</p><p>反复调用闭包对象时，i 只初始化一次，故而每次调用都会造成累计：</p><div class="code-wrapper"><pre><code class="hljs go">f := act()fmt.Println(f(<span class="hljs-number">100</span>))<span class="hljs-comment">// 0</span>fmt.Println(f(<span class="hljs-number">100</span>))<span class="hljs-comment">// 100</span>fmt.Println(f(<span class="hljs-number">100</span>))<span class="hljs-comment">// 200</span>fmt.Println(act()(<span class="hljs-number">100</span>))<span class="hljs-comment">// 0</span>fmt.Println(act()(<span class="hljs-number">100</span>))<span class="hljs-comment">// 0</span>fmt.Println(act()(<span class="hljs-number">100</span>))<span class="hljs-comment">// 0</span></code></pre></div><h3 id="defer-关键字">3.2.4 defer 关键字</h3><p>在函数中，程序员经常需要创建资源（如：数据库连接、文件句柄、锁等），为在函数执行完毕后，及时释放资源，Go的设计者提供 defer（延时机制）</p><div class="code-wrapper"><pre><code class="hljs go">f := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a <span class="hljs-type">int</span>)</span></span> &#123;    <span class="hljs-keyword">defer</span> fmt.Println(a, <span class="hljs-string">&quot;(defer1)&quot;</span>)    a += <span class="hljs-number">10</span>    <span class="hljs-keyword">defer</span> fmt.Println(a, <span class="hljs-string">&quot;(defer2)&quot;</span>)    a *= <span class="hljs-number">10</span>    fmt.Println(a)&#125;f(<span class="hljs-number">0</span>)</code></pre></div><blockquote><p>此时，系统依次输出 100 、10(defer2)、0(defer1)</p></blockquote><h4 id="注意事项-2">注意事项：</h4><ul><li><p>执行函数时，如果遇到 defer语句，系统不会执行该语句，而是会将其压入栈中。</p><p>函数执行结束后，再从该栈中依次取出语句（先入后出）并执行。</p></li><li><p>让 defer 语句入栈时，也会将相关数值一并拷贝入栈</p></li><li><p>defer 最主要的价值是，函数执行完毕后，可以及时释放资源</p></li></ul><h2 id="常用函数">3.3 常用函数</h2><h3 id="字符串函数">3.3.1 字符串函数</h3><ul><li><p><code>len(v) int</code>：返回传入的 v 的长度。</p><p>传入字符串时，返回那个字节数量。传入数组时，返回那个元素数量</p><p>传入数组指针时，返回 *v 元素数量。传入切片、映射时，返回元素数量</p><p>传入通道时，返回通道缓存中队列未读取的元素数量</p></li><li><p><code>r := []rune(string)</code>：将字符串转为 rune 切片</p><p>这样，能解决中文字符乱码问题</p><p><code>b := []byte(string)</code>：将字符转为 byte 切片</p><p><code>string([]rune) string</code>：将 rune 切片转为字符串</p><p><code>string([]byte) string</code>：将 byte 切片转为字符串</p></li></ul><p><strong>以下函数被包含在 strconv 包内：</strong></p><ul><li><p><code>strconv.Atoi(string)(int, error)</code>：将字符串转成整数</p><p><code>strconv.Itoa(int) string</code>：将字符串转成整数</p></li><li><p><code>strconv.FormatInt(int, int) string</code>：将指定 int转为指定进制的字符串</p><p>第二个参数可以是 2、8、16</p></li></ul><p><strong>以下函数被包含在 strings 包内：</strong></p><ul><li><p><code>strings.Contains(string, string) bool</code>：查找子串是否在指定字符串中</p></li><li><p><code>strings.Count(string, string) int</code>：统计字符串中有多少指定的子串</p></li><li><p><code>strings.EqualFold(string, string) bool</code>：不区分大小写地比较字符串是否相等</p></li><li><p><code>strings.Index(string, string) int</code>：返回子串第一次出现的index 值。没有则返回 -1</p><p><code>strings.LastIndex(string, string) int</code>：返回子串最后一次出现的index 值</p></li><li><p><code>strings.Replace(string, string, string, int) string</code>：将指定子串替换为另一个子串</p><p>可以指定要替换的数量。-1 的场合全部替换</p><p><strong>所有的替换的场合，原字符串不变，返回那个替换后的新字符串</strong></p></li><li><p><code>strings.ToLower(string) string</code>：转为全部小写英文字母</p><p><code>strings.ToUpper(string) string</code>：转为全部大写英文字母</p></li><li><p><code>strings.Split(string, string) string[]</code>：按照指定字符对字符串进行分割</p></li><li><p><code>strings.TrimSpace(string) string</code>：去掉字符串前后的空格</p><p><code>strings.Trim(string, string) string</code>：去掉字符串前后的所有的指定字符</p><p>那些指定字符指的是第二个字符串参数中，包含的任意字符</p><div class="code-wrapper"><pre><code class="hljs go">fmt.Print(strings.Trim(<span class="hljs-string">&quot;1321oAo12&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>))<span class="hljs-comment">// 输出 oAo</span></code></pre></div><p><code>strings.TrimLeft(string, string) string</code>：仅去掉字符串左边的指定字符</p><p><code>strings.TrimRight(string, string) string</code></p></li><li><p><code>strings.HasPrefix(string, string) bool</code>：字符串是否以某子串开头</p><p><code>strings.HasSuffix(string, string) bool</code>：字符串是否以某子串结尾</p></li></ul><h3 id="时间和日期函数">3.3.2 时间和日期函数</h3><p><strong>以下函数被包含在 time 包内：</strong></p><ul><li><p><code>time.Time</code>：Time 类型。代表时间</p><p><code>time.Now() Time</code>：获取一个当前时间的 Time 对象</p></li><li><p>获取 Time 对象的某项时间参数</p><div class="code-wrapper"><pre><code class="hljs go">t := time.Now()</code></pre></div><p><code>t.Day() int</code>：获取日数</p><p><code>t.Month() time.Month</code>：获取月份。利用类型转换才能得到 int类型的月份</p><p><code>t.Year() int</code>：获取年份</p><p><code>t.Hour() int</code>、<code>t.Minute() int</code>、<code>t.Second() int</code>：获取时、分、秒</p><p><code>t.Format(string) string</code>：按照字符串格式将格式化该时间。那个格式字符串各项可以自由组合，<strong>但时间是固定的，不能变更。即必须是：2006年 01 月 02 日 15 时 04 分 05 秒</strong></p><div class="code-wrapper"><pre><code class="hljs go">s := t.Format(<span class="hljs-string">&quot;2006/01/02 15:04:05&quot;</span>)<span class="hljs-comment">// 格式字符串必须是该时间</span>s2 := t.Format(<span class="hljs-string">&quot;2006-01-02&quot;</span>)s3 := t.Format(<span class="hljs-string">&quot;15:04:05&quot;</span>)</code></pre></div><blockquote><p>这个时间据说是开发者夹带私货。会开发的就是任性哦~</p></blockquote><p><code>t.Unix() int</code>：获取指定时间戳</p><p><code>t.UnixNano() int64</code>：获取指定纳秒时间戳</p></li><li><p><code>time.Hour</code>：时间常量，代表 1 小时。</p><p>要获取 10 小时可以使用<code>10 * time.Hour</code>。可以使用加法、减法。但不能使用除法</p><p><code>time.Minute</code>、<code>time.Second</code>：分钟、秒</p><p><code>time.Millisecond</code>：毫秒。1000 毫秒 == 1 秒</p><p><code>time.Microsecond</code>：微秒。1000 微秒 == 1 毫秒</p><p><code>time.Nanosecond</code>：纳秒。1000 纳秒 == 1 微秒</p><p>以上这些时间常量的类型是 time.Duration</p></li><li><p><code>time.sleep(time.Duration)</code>：休眠指定时间</p></li></ul><h2 id="内置函数">3.4 内置函数</h2><p>Go的设计者为了编程方便，提供了一些函数。这些函数能直接使用。即为内置函数。</p><ul><li><p><code>len(v) int</code>：返回传入的 v 的长度。取决于 v 的类型</p><p><code>cap(v) int</code>：返回 v 的容量。取决于 v 的类型</p></li><li><p><code>new(Type) *Type</code>：使用 new来分配内存。返回值为一个指向该类型新分配的零值的指针</p></li><li><p><code>make(Type, IntegerType) Type</code>：分配并初始化一个类型为切片、映射或通道的对象</p></li><li><p><code>recover() error</code>：捕获一个异常</p></li></ul><p><font color="#FF0000" size="6">☆</font></p><h2 id="错误处理">3.5 错误处理</h2><p>在默认情况下，程序发生错误（panic）后就会退出（崩溃）</p><p>如果希望发生错误后，可以捕获错误并进行处理，使程序得以继续执行，还能进行提示，就需要错误处理</p><p>Go 语言追求简洁优雅。Go 通过 defer、panic、recover 进行错误处理：</p><p>Go 可以抛出 panic 异常，并在 defer 中通过 recover捕获该异常，然后进行处理</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;    err := <span class="hljs-built_in">recover</span>()    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;        fmt.Println(<span class="hljs-string">&quot;Error -&quot;</span>, err)    &#125;&#125;()i := <span class="hljs-number">10</span>n := <span class="hljs-number">0</span>fmt.Println(i / n)<span class="hljs-comment">// 这里出现一处除以 0 的错误</span></code></pre></div><blockquote><p>以上代码输出：Error -runtime error: integer divide by zero</p></blockquote><p>加入错误处理后，程序不会轻易崩溃。如果加入预警代码，就能增强代码健壮性</p><h4 id="自定义错误">自定义错误：</h4><p>Go 语言支持自定义错误。</p><ul><li><code>errors.New(string) error</code>：传入错误说明，返回一个 error对象</li><li><code>panic(interface&#123;&#125;)</code>：输出错误信息，并退出程序</li></ul><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;    fmt.Println(<span class="hljs-built_in">recover</span>(), <span class="hljs-string">&quot;!!!&quot;</span>)&#125;()<span class="hljs-built_in">panic</span>(errors.New(<span class="hljs-string">&quot;???&quot;</span>))</code></pre></div><blockquote><p>输出：??? !!!</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Go&gt;2 程序流程控制</title>
    <link href="/2022/06/07/Go/2%20%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <url>/2022/06/07/Go/2%20%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="程序流程控制">2 程序流程控制</h1><h2 id="运算符">2.1 运算符</h2><p>运算符是一种特殊的符号，用以表示数据运算、赋值、比较等</p><p>主要有 6 类：</p><ul><li>算术运算符：++、--、+、-、*、/</li><li>赋值运算符：=、+=、-=、&amp;=、|=、^=、!=</li><li>比较运算符 / 关系运算符：&gt;、&lt;、&lt;=、&gt;=、==、!=</li><li>逻辑运算符：&amp;&amp;、||</li><li>位运算符：&gt;&gt;、&lt;&lt;、&gt;&gt;&gt;、&amp;、^、!、|</li><li>其他运算符：取址符 <code>&amp;</code>、指针符 <code>*</code></li></ul><p><strong>特别地</strong>：Go 中的 <code>++</code>、<code>--</code>都只能独立使用，且只能出现在变量后侧：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span> = <span class="hljs-number">10</span>i++<span class="hljs-comment">/* --i */</span><span class="hljs-comment">// 错误用法</span><span class="hljs-comment">/* var n int = i++ */</span><span class="hljs-comment">// 错误用法</span></code></pre></div><p>另外，Go 语言<strong>明确不支持三元运算符</strong></p><h2 id="键盘输入屏幕输出">2.2 键盘输入、屏幕输出</h2><p>这两个功能包含在 fmt 包中。</p><p>导入 fmt 包：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span></code></pre></div><h4 id="屏幕输出">屏幕输出：</h4><ul><li><p><code>fmt.Print(a... interface&#123;&#125;)</code>：输出该语句</p><p><code>fmt.Println(a... interface&#123;&#125;)</code>：输出该语句，之后换行</p><p><code>fmt.Printf(format string, a... interface&#123;&#125;)</code>：格式化输出语句</p></li></ul><h4 id="键盘输入">键盘输入：</h4><ul><li><p><code>fmt.Scanln(a... interface&#123;&#125;)</code>：获取输入，保存到传入参数中。直到换行时才停止扫描</p><p><code>fmt.Scanf(format string, a... interface&#123;&#125;)</code>：根据指定格式，将成功读取的空白分割的值保存到传入参数中</p></li></ul><h2 id="程序流程控制-1">2.3 程序流程控制</h2><p>程序流程控制主要分为三种</p><ul><li>顺序控制</li><li>分支控制</li><li>循环控制</li></ul><h3 id="顺序控制">2.3.1 顺序控制</h3><blockquote><p>程序从上到下逐行执行，中间没有任何判断和跳转（默认的控制顺序）</p></blockquote><pre><code class=" mermaid">graph LRA(A语句)--&gt;B(B语句)--&gt;C(C语句)--&gt;D(D语句)--&gt;E(...)</code></pre><h3 id="分支控制">2.3.2 分支控制</h3><h4 id="单分支控制">单分支控制：</h4><p>当条件满足时，执行表达式。</p><pre><code class=" mermaid">graph LRA(if 语句)--&gt; B&#123;条件表达式&#125;B --true--&gt; C(执行语句块)C --&gt; D(继续)B --false----&gt; D</code></pre><p><strong>注意：</strong>在 Go中，条件表达式不能加括号，且结构体即使只有一句也必须加上大括号</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">if</span> i := <span class="hljs-number">5</span>; i &lt; <span class="hljs-number">10</span> &#123;    i++&#125;</code></pre></div><h4 id="双分支控制">双分支控制：</h4><p>当条件满足时，执行表达式。否则执行另一表达式</p><pre><code class=" mermaid">graph LRA(if...else 语句)--&gt; B&#123;条件表达式&#125;B --true--&gt; C(执行语句块1)C --&gt; D(继续)B --false--&gt; F(执行语句块2)F --&gt; D</code></pre><p><strong>注意：</strong>在 Go 中，不能让 else 语句另起一行</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">10</span> &#123;    i++&#125; <span class="hljs-keyword">else</span> &#123;    i--&#125;</code></pre></div><h4 id="多分支控制">多分支控制：</h4><p>有条件满足时，执行该表达式。否则执行 else 语句或直接继续</p><pre><code class=" mermaid">graph LRA(if...else if  语句)--&gt; B&#123;条件1&#125;B --true--&gt; C(执行语句块1)C --&gt; D(继续)B --false--&gt; F&#123;条件2&#125;F --true--&gt; G(执行语句块2)G --&gt; DF --false--&gt; H&#123;条件3&#125;H --true--&gt; I(执行语句块3)I --&gt; DH --false--&gt; J(else 语句块)J --&gt; D</code></pre><p>其中，else 语句块不是必须的。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">10</span> &#123;    i++&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">20</span> &#123;    i--&#125; <span class="hljs-keyword">else</span> &#123;    i = <span class="hljs-number">0</span>&#125;</code></pre></div><h4 id="switch-分支结构">switch 分支结构：</h4><p>switch 语句用于基于不同条件执行不同动作。</p><p>每个 case 分支都是唯一的，从上到下逐一测试，直到匹配为止。</p><pre><code class=" mermaid">graph LRA(switch  语句)--&gt; B&#123;表达式 a&#125;B --&gt;b1[a == 表达式 1]--true--&gt; C(语句块1)b1 --false--&gt;b2[a == 表达式 2]--true--&gt; D(语句块2)b2 --false--&gt;b3[a == 表达式 3]--true--&gt; E(语句块3)b3--false--&gt; F(default语句块)C --&gt; G(继续)D --&gt; GE --&gt; GF --&gt; GC -.fallthrough.-&gt; DD -.fallthrough.-&gt; EE -.fallthrough.-&gt; F</code></pre><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span>fmt.Scanln(&amp;i)<span class="hljs-keyword">switch</span> i &#123;    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-number">3</span>:    fmt.Println(<span class="hljs-string">&quot;喵喵喵&quot;</span>)    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:    fmt.Println(<span class="hljs-string">&quot;汪汪汪&quot;</span>)    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:    fmt.Println(<span class="hljs-string">&quot;嗷嗷嗷&quot;</span>)    <span class="hljs-keyword">default</span>:    fmt.Println(<span class="hljs-string">&quot;滋滋滋&quot;</span>)&#125;</code></pre></div><p><strong>注意事项：</strong></p><ul><li><p>case 后可以是一个表达式（常量、变量、有返回值的函数）</p></li><li><p>case 后各个表达式数据类型需和 switch 表达式数据类型一致</p></li><li><p>case 后可以有多个表达式，以 <code>,</code> 分隔</p></li><li><p>case 后的表达式若是常量值，则要求不能重复</p></li><li><p>case 后不需要加 break，default 语句可以省略</p></li><li><p>switch 后面可以不带表达式，此时 case表达式数据类型是布尔值。类似于多个 if...else 分支使用</p></li><li><p>（不推荐）switch 后可以直接声明 / 定义一个变量，并以<code>;</code> 结束</p></li><li><p>在 case 语句块添加 fallthrough，则会穿透执行下一个 case语句块</p></li><li><p>type switch 可以用于判断某个 interface 的变量类型</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> i := x.(<span class="hljs-keyword">type</span>) &#123;    <span class="hljs-keyword">case</span> <span class="hljs-type">int</span>:    fmt.Println(<span class="hljs-string">&quot;是 int 类型&quot;</span>)    <span class="hljs-keyword">case</span> <span class="hljs-type">bool</span>:    fmt.Println(<span class="hljs-string">&quot;是 bool 类型&quot;</span>)&#125;</code></pre></div></li><li><p>在 case 语句块添加 fallthrough，则会穿透执行下一个 case语句块</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> i := <span class="hljs-number">2</span>; i &#123;<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:    <span class="hljs-keyword">fallthrough</span><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:&#125;</code></pre></div><p>fallthrough 必须出现在 case 块的最后，且该 case 块不能是最后一个 case块</p><p><strong>不允许在 type switch 中使用 fallthrough</strong></p></li></ul><h3 id="循环控制">2.3.3 循环控制</h3><p>基本语法：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">for</span> 循环变量初始化; 循环条件; 循环变量迭代 &#123;    循环操作&#125;</code></pre></div><pre><code class=" mermaid">graph LRA(for 循环语句) --&gt; F[循环变量初始化] --&gt; B&#123;循环条件&#125; --false--&gt; D(继续)B --true--&gt; C(循环操作)  --&gt; E[循环变量迭代]  --&gt; B</code></pre><p>for循环四个要素：循环变量初始化、循环的条件、循环的操作、循环变量迭代</p><p>所有循环开始前仅一次进行初始化。直到循环条件变为 false前，执行循环操作。每轮循环结束后，进行循环变量迭代。</p><p>可以把 变量初始化 和 循环变量迭代写在其他位置。循环条件为空时，默认无限循环</p><h4 id="for-range">for-range</h4><p>Golang 提供 for-range 方式，以便于遍历字符串和数组</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> str <span class="hljs-type">string</span> = <span class="hljs-string">&quot;辟邪剑法&quot;</span><span class="hljs-keyword">for</span> index, val := <span class="hljs-keyword">range</span> str &#123;<span class="hljs-comment">// index 即下标，val 即值。使用 _ 忽略其中的一个</span>    fmt.Printf(<span class="hljs-string">&quot;%d\t%c\n&quot;</span>, index, val)&#125;</code></pre></div><p>汉字占 3 字节。传统方法遍历字符串时，可能产生乱码。但 for-range方式遍历时不会出错。</p><h4 id="while-和-do...while">while 和 do...while</h4><p>Go 语言中没有 while 和 do...while 语法。通过 for循环来模拟实现其效果。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">/* 模拟 while */</span><span class="hljs-keyword">for</span> &#123;    <span class="hljs-keyword">if</span> (循环条件表达式) &#123;        <span class="hljs-keyword">break</span>;    &#125;    循环操作    循环变量迭代&#125;<span class="hljs-comment">/* 模拟 do...while */</span><span class="hljs-keyword">for</span> &#123;    循环操作    循环变量迭代    <span class="hljs-keyword">if</span> (循环条件表达式) &#123;        <span class="hljs-keyword">break</span>;    &#125;&#125;</code></pre></div><h2 id="跳转控制语句">2.4 跳转控制语句</h2><h4 id="break">break</h4><blockquote><p>用于中止一个语句块的执行。用于中断当前 for 循环或跳出 switch 语句</p></blockquote><pre><code class=" mermaid">graph LRA(for 语句) --初始化--&gt; B&#123;循环条件&#125; --false--&gt; D(继续)B --true--&gt; c1(语句1) --&gt; c2(语句2) --&gt; c3(语句3) --&gt; E[循环变量迭代] --&gt; Bc1 --break--&gt; D</code></pre><ul><li><p>break 默认会跳出最近的循环</p></li><li><p>break语句出现在多层嵌套语句块中时，能通过标签指明要中止哪一层语句块</p><div class="code-wrapper"><pre><code class="hljs go">lable1:<span class="hljs-comment">// 标签</span><span class="hljs-keyword">for</span> &#123;    <span class="hljs-keyword">for</span> &#123;        fmt.Print(<span class="hljs-string">&quot;免疫 &quot;</span>)        i++        <span class="hljs-keyword">if</span> i &gt;= <span class="hljs-number">100</span> &#123;            <span class="hljs-keyword">break</span> lable1        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> i%<span class="hljs-number">10</span> == <span class="hljs-number">0</span> &#123;            <span class="hljs-keyword">break</span>        &#125;    &#125;    fmt.Println()&#125;</code></pre></div></li></ul><h4 id="continue">continue</h4><blockquote><p>在循环中出现。用于结束本次循环，继续下一次循环</p></blockquote><pre><code class=" mermaid">graph LRA(for 语句) --初始化--&gt; B&#123;循环条件&#125; --false--&gt; D(继续)B --true--&gt; c1(语句1) --&gt; c2(语句2) --&gt; c3(语句3) --&gt; E[循环变量迭代] --&gt; Bc1 --continue--&gt; E</code></pre><ul><li>continue 默认会跳过最近的循环</li><li>continue语句出现在多层嵌套语句块中时，能通过标签指明要跳过哪一层循环</li></ul><h4 id="goto">goto</h4><blockquote><p>可以无条件地转移到程序中指定的行</p></blockquote><ul><li>goto语句通常与条件语句配合使用，以实现条件转移，跳出循环体等功能。</li><li>一般不建议使用 goto 语句，以免造成流程混乱</li></ul><h4 id="return">return</h4><blockquote><p>用于方法或函数中。表示跳出所在的方法或函数</p></blockquote><pre><code class=" mermaid">graph LR    A(调用方法A) --&gt; B(语句a)    subgraph 方法AB --&gt; C(语句b) --&gt; D(语句c) --&gt; E(语句d)    endE --执行完毕--&gt; F(继续)C --return--&gt; F</code></pre><p>如若写在主方法，会直接跳出程序</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Go&gt;目录</title>
    <link href="/2022/06/06/Go/0%20%E7%9B%AE%E5%BD%95/"/>
    <url>/2022/06/06/Go/0%20%E7%9B%AE%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="目录">目录</h1><h2 id="go-基础知识">1 <ahref="../../../../../2022/06/05/Go/1%20Go%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">Go基础知识</a></h2><ul><li><h3 id="go-执行流程">1.1 <ahref="../../../../../2022/06/05/Go/1%20Go%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#1-1-Go-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B">Go执行流程</a></h3></li><li><h3 id="go-开发注意事项">1.2 <ahref="../../../../../2022/06/05/Go/1%20Go%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#1-2-Go-%E5%BC%80%E5%8F%91%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">Go开发注意事项</a></h3></li><li><h3 id="注释">1.3 <ahref="../../../../../2022/06/05/Go/1%20Go%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#1-3-%E6%B3%A8%E9%87%8A">注释</a></h3></li><li><h3 id="变量">1.4 <ahref="../../../../../2022/06/05/Go/1%20Go%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#1-4-%E5%8F%98%E9%87%8F">变量</a></h3><ul><li><h4 id="常量">1.4.1 <ahref="../../../../../2022/06/05/Go/1%20Go%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#1-4-1-常量">常量</a></h4></li></ul></li><li><h3 id="数据类型">1.5 <ahref="../../../../../2022/06/05/Go/1%20Go%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#1-5-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a></h3><ul><li><h4 id="整数类型">1.5.1 <ahref="../../../../../2022/06/05/Go/1%20Go%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#1-5-1-%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B">整数类型</a></h4></li><li><h4 id="浮点类型">1.5.2 <ahref="../../../../../2022/06/05/Go/1%20Go%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#1-5-2-%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B">浮点类型</a></h4></li><li><h4 id="字符类型">1.5.3 <ahref="../../../../../2022/06/05/Go/1%20Go%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#1-5-3-%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B">字符类型</a></h4></li><li><h4 id="布尔类型">1.5.4 <ahref="../../../../../2022/06/05/Go/1%20Go%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#1-5-4-%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B">布尔类型</a></h4></li><li><h4 id="字符串类型">1.5.5 <ahref="../../../../../2022/06/05/Go/1%20Go%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#1-5-5-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B">字符串类型</a></h4></li><li><h4 id="基本数据类型的转换">1.5.6 <ahref="../../../../../2022/06/05/Go/1%20Go%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#1-5-6-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2">基本数据类型的转换</a></h4></li><li><h4 id="基本数据类型与-string-的转换">1.5.7 <ahref="../../../../../2022/06/05/Go/1%20Go%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#1-5-7-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E-string-%E7%9A%84%E8%BD%AC%E6%8D%A2">基本数据类型与string 的转换</a></h4></li></ul></li><li><h3 id="值类型和引用类型">1.6 <ahref="../../../../../2022/06/05/Go/1%20Go%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#1-6-%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B">值类型和引用类型</a></h3><ul><li><h4 id="指针">1.6.1 <ahref="../../../../../2022/06/05/Go/1%20Go%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#1-6-1-%E6%8C%87%E9%92%88">指针</a></h4></li></ul></li><li><h3 id="标识符">1.7 <ahref="../../../../../2022/06/05/Go/1%20Go%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#1-7-%E6%A0%87%E8%AF%86%E7%AC%A6">标识符</a></h3></li></ul><hr /><h2 id="程序流程控制">2 <ahref="../../../../../2022/06/07/Go/2%20%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/">程序流程控制</a></h2><ul><li><h3 id="运算符">2.1 <ahref="../../../../../2022/06/07/Go/2%20%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/#2-1-%E8%BF%90%E7%AE%97%E7%AC%A6">运算符</a></h3></li><li><h3 id="键盘输入屏幕输出">2.2 <ahref="../../../../../2022/06/07/Go/2%20%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/#2-2-%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E3%80%81%E5%B1%8F%E5%B9%95%E8%BE%93%E5%87%BA">键盘输入、屏幕输出</a></h3></li><li><h3 id="程序流程控制-1">2.3 <ahref="../../../../../2022/06/07/Go/2%20%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/#2-3-%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6">程序流程控制</a></h3><ul><li><h4 id="顺序控制">2.3.1 <ahref="../../../../../2022/06/07/Go/2%20%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/#2-3-1-%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6">顺序控制</a></h4></li><li><h4 id="分支控制">2.3.2 <ahref="../../../../../2022/06/07/Go/2%20%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/#2-3-2-%E5%88%86%E6%94%AF%E6%8E%A7%E5%88%B6">分支控制</a></h4></li><li><h4 id="循环控制">2.3.3 <ahref="../../../../../2022/06/07/Go/2%20%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/#2-3-3-%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6">循环控制</a></h4></li></ul></li><li><h3 id="跳转控制语句">2.4 <ahref="../../../../../2022/06/07/Go/2%20%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/#2-4-%E8%B7%B3%E8%BD%AC%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5">跳转控制语句</a></h3></li></ul><hr /><h2 id="函数包和错误处理">3 <ahref="../../../../../2022/06/08/Go/3%20%E5%87%BD%E6%95%B0%E3%80%81%E5%8C%85%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/">函数、包和错误处理</a></h2><ul><li><h3 id="包">3.1 <ahref="../../../../../2022/06/08/Go/3%20%E5%87%BD%E6%95%B0%E3%80%81%E5%8C%85%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/#3-1-%E5%8C%85">包</a></h3></li><li><h3 id="函数">3.2 <ahref="../../../../../2022/06/08/Go/3%20%E5%87%BD%E6%95%B0%E3%80%81%E5%8C%85%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/#3-2-%E5%87%BD%E6%95%B0">函数</a></h3><ul><li><h4 id="init-函数">3.2.1 <ahref="../../../../../2022/06/08/Go/3%20%E5%87%BD%E6%95%B0%E3%80%81%E5%8C%85%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/#3-2-1-init-%E5%87%BD%E6%95%B0">init函数</a></h4></li><li><h4 id="匿名函数">3.2.2 <ahref="../../../../../2022/06/08/Go/3%20%E5%87%BD%E6%95%B0%E3%80%81%E5%8C%85%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/#3-2-2-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0">匿名函数</a></h4></li><li><h4 id="闭包">3.2.3 <ahref="../../../../../2022/06/08/Go/3%20%E5%87%BD%E6%95%B0%E3%80%81%E5%8C%85%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/#3-2-3-%E9%97%AD%E5%8C%85">闭包</a></h4></li><li><h4 id="defer-关键字">3.2.4 <ahref="../../../../../2022/06/08/Go/3%20%E5%87%BD%E6%95%B0%E3%80%81%E5%8C%85%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/#3-2-4-defer-%E5%85%B3%E9%94%AE%E5%AD%97">defer关键字</a></h4></li></ul></li><li><h3 id="常用函数">3.3 <ahref="../../../../../2022/06/08/Go/3%20%E5%87%BD%E6%95%B0%E3%80%81%E5%8C%85%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/#3-3-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0">常用函数</a></h3><ul><li><h4 id="字符串函数">3.3.1 <ahref="../../../../../2022/06/08/Go/3%20%E5%87%BD%E6%95%B0%E3%80%81%E5%8C%85%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/#3-3-1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0">字符串函数</a></h4></li><li><h4 id="时间和日期函数">3.3.2 <ahref="../../../../../2022/06/08/Go/3%20%E5%87%BD%E6%95%B0%E3%80%81%E5%8C%85%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/#3-3-2-%E6%97%B6%E9%97%B4%E5%92%8C%E6%97%A5%E6%9C%9F%E5%87%BD%E6%95%B0">时间和日期函数</a></h4></li></ul></li><li><h3 id="内置函数">3.4 <ahref="../../../../../2022/06/08/Go/3%20%E5%87%BD%E6%95%B0%E3%80%81%E5%8C%85%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/#3-4-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0">内置函数</a></h3></li><li><h3 id="错误处理">3.5 <ahref="../../../../../2022/06/08/Go/3%20%E5%87%BD%E6%95%B0%E3%80%81%E5%8C%85%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/#3-5-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">错误处理</a></h3></li></ul><hr /><h2 id="数组切片和-map">4 <ahref="../../../../../2022/06/11/Go/4%20数组、切片和%20map/">数组、切片和map</a></h2><ul><li><h3 id="数组">4.1 <ahref="../../../../../2022/06/11/Go/4%20数组、切片和%20map/#4-1-数组">数组</a></h3></li><li><h3 id="切片">4.2 <ahref="../../../../../2022/06/11/Go/4%20数组、切片和%20map/#4-2-切片">切片</a></h3></li><li><h3 id="map">4.3 <ahref="../../../../../2022/06/11/Go/4%20数组、切片和%20map/#4-3-map">map</a></h3></li></ul><hr /><h2 id="go-面向-对象-编程">5 <ahref="../../../../../2022/06/19/Go/5%20Go%20面向对象编程/">Go 面向“对象” 编程</a></h2><ul><li><h3 id="结构体">5.1 <ahref="../../../../../2022/06/19/Go/5%20Go%20面向对象编程/#5-1-结构体">结构体</a></h3><ul><li><h4 id="字段">5.1.1 <ahref="../../../../../2022/06/19/Go/5%20Go%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/#5-1-1-%E5%AD%97%E6%AE%B5">字段</a></h4></li></ul></li><li><h3 id="方法">5.2 <ahref="../../../../../2022/06/19/Go/5%20Go%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/#5-2-%E6%96%B9%E6%B3%95">方法</a></h3></li><li><h3 id="接口">5.3 <ahref="../../../../../2022/06/19/Go/5%20Go%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/#5-3-%E6%8E%A5%E5%8F%A3">接口</a></h3></li><li><h3 id="面向对象">5.4 <ahref="../../../../../2022/06/19/Go/5%20Go%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/#5-4-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">面向对象</a></h3><ul><li><h4 id="封装">5.4.1 <ahref="../../../../../2022/06/19/Go/5%20Go%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/#5-4-1-%E5%B0%81%E8%A3%85">封装</a></h4></li><li><h4 id="继承">5.4.2 <ahref="../../../../../2022/06/19/Go/5%20Go%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/#5-4-2-%E7%BB%A7%E6%89%BF">继承</a></h4></li><li><h4 id="多态">5.4.3 <ahref="../../../../../2022/06/19/Go/5%20Go%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/#5-4-3-%E5%A4%9A%E6%80%81">多态</a></h4></li></ul></li></ul><hr /><h2 id="项目家庭收支记账软件">6 <ahref="../../../../../2022/06/20/Go/6%20项目：家庭收支记账软件">项目：家庭收支记账软件</a></h2><ul><li><h3 id="项目1家庭收支记账软件">项目1：家庭收支记账软件</h3></li><li><h3 id="附录">附录：</h3><ul><li><h4 id="家庭收支记账软件"><ahref="../../../../../2022/06/20/Go/6%20项目：家庭收支记账软件/#%E5%AE%B6%E5%BA%AD%E6%94%B6%E6%94%AF%E8%AE%B0%E8%B4%A6%E8%BD%AF%E4%BB%B6">家庭收支记账软件</a></h4></li></ul></li></ul><hr /><h2 id="文件操作">7 <ahref="../../../../../2022/06/22/Go/7%20文件操作">文件操作</a></h2><ul><li><h3 id="打开关闭文件">7.1 <ahref="../../../../../2022/06/22/Go/7%20文件操作/#7-1-打开、关闭文件">打开、关闭文件</a></h3></li><li><h3 id="读写文件">7.2 <ahref="../../../../../2022/06/22/Go/7%20文件操作/#7-2-读、写文件">读、写文件</a></h3></li><li><h3 id="命令行参数">7.3 <ahref="../../../../../2022/06/22/Go/7%20文件操作/#7-3-命令行参数">命令行参数</a></h3></li><li><h3 id="json">7.4 <ahref="../../../../../2022/06/22/Go/7%20文件操作/#7-4-JSON">JSON</a></h3></li></ul><hr /><h2 id="goroutine-和-channel">8 <ahref="../../../../../2022/07/01/Go/8%20goroutine%20和%20channel">goroutine和 channel</a></h2><ul><li><h3 id="单元测试">8.1 <ahref="../../../../../2022/07/01/Go/8%20goroutine%20和%20channel/#8-1-单元测试">单元测试</a></h3></li><li><h3 id="goroutine-协程">8.2 <ahref="../../../../../2022/07/01/Go/8%20goroutine%20和%20channel/#8-2-goroutine-协程">goroutine协程</a></h3></li><li><h3 id="channel-管道">8.3 <ahref="../../../../../2022/07/01/Go/8%20goroutine%20和%20channel/#8-3-channel-管道">channel管道</a></h3><ul><li><h4 id="线程加锁">8.3.1 <ahref="../../../../../2022/07/01/Go/8%20goroutine%20和%20channel/#8-3-1-线程加锁">线程加锁</a></h4></li><li><h4 id="channel-的使用">8.3.2 <ahref="../../../../../2022/07/01/Go/8%20goroutine%20和%20channel/#8-3-2-channel-的使用">channel的使用</a></h4></li></ul></li></ul><hr /><h2 id="反射网络编程">9 反射、网络编程</h2><ul><li><h3 id="反射">9.1 反射</h3></li><li><h3 id="网络编程">9.2 网络编程</h3><ul><li><h4 id="服务端">9.2.1 服务端</h4></li><li><h4 id="客户端">9.2.2 客户端</h4></li></ul></li></ul><hr />]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>笔记</tag>
      
      <tag>目录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Go&gt;1 Go 基础知识</title>
    <link href="/2022/06/05/Go/1%20Go%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/06/05/Go/1%20Go%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="go-基础知识">1 Go 基础知识</h1><blockquote><p>Google 为什么要创造 Go 语言：</p><ul><li>计算机硬件技术更新频繁，性能提高很快。但目前主流编程语言发展明显落后于硬件，不能合理利用多核多CPU 的优势来提示软件系统性能</li><li>软件系统复杂度越来越高，维护成本也越来越高。目前缺乏一个足够简洁高效的编程语言</li><li>c / c++程序运行速度虽然很快，但编译速度很慢。同时存在内存泄漏等一系列困扰。</li></ul><p><a href="https://golang.org/#">Golang 官网</a></p><p><a href="https://golang.org/pkg">Golang 标准库 API文档</a>，或者也可以试试 <ahref="studygolang.com/pkgdoc">这个网址</a></p></blockquote><h4 id="go-语言发展史">Go 语言发展史：</h4><ul><li>2007 年，Google 开始设计一门全新的语言，这是 Go 语言的原型</li><li>2009 年 11 月 10 日，Google 将 Go语言以开放源代码的方式向全球发布</li><li>2015 年 8 月 19 日，Go 1.5 版发布。本次更新中 “移除了最后残余的 c代码”</li><li>2017 年 2 月 17 日，Go 语言 Go 1.8 版发布</li><li>2017 年 8 月 24 日，Go 语言 Go 1.9 版发布</li><li>2018 年 2 月 16 日，Go 语言 Go 1.10 版发布</li><li>目前的最新版本是 Go 1.18</li></ul><h4 id="go-语言的特点">Go 语言的特点：</h4><p>Go语言既能到达静态编译语言的安全和性能，又达到了动态语言开发维护的高效率。</p><ul><li>Go 从 c语言中继承了很多概念，包括表达式语法，控制结构。基础数据模型。调用参数传值，指针等。也保留了和c 语言一样的编译执行方式和弱化的指针。</li><li>引入包的概念，用于组织程序结构。Go语言的每一个文件都要归属于一个包，而不能单独存在。</li><li>垃圾回收机制，内存自动回收，不需要开发人员管理</li><li><strong>天然并发：</strong><ul><li>从语言层面支持并发，实现简单。</li><li>goroutine，轻量级线程。可以实现大并发处理，高效利用多核</li><li>基于 CPS 并发模型（Communicating Sequential Processes）实现</li></ul></li><li>吸收了管道通信机制，形成 Go 语言特有的管道channel。通过管道可以实现不同的 goroutine 之间的相互通信</li><li>函数可以返回多个值</li><li>新的创新：如切片 slice、延时执行 defer 等</li></ul><h2 id="go-执行流程">1.1 Go 执行流程</h2><blockquote><p>通过编译器，将 Go 源文件编译成机器能识别的二进制码文件的过程称为<strong>编译</strong>。</p><p>在文件目录下使用 go build指令以编译文件。此时，可以指定生成的文件名</p></blockquote><ul><li><p>先编译，再执行（<code>[ ]</code> 内的内容能省略）</p><div class="code-wrapper"><pre><code class="hljs cmd">******&gt;go build [-o 可执行文件名] 源文件名******&gt;可执行文件名</code></pre></div><pre><code class=" mermaid">graph LRA(.go 文件)--go build 编译--&gt;B(可执行文件)--运行--&gt;C(结果)</code></pre></li><li><p>直接对源码执行 go run 命令</p><div class="code-wrapper"><pre><code class="hljs cmd">******&gt;go run 源文件名</code></pre></div><pre><code class=" mermaid">graph LRA(.go 文件)--go run 编译运行一步--&gt;C(结果)</code></pre></li></ul><p>两种执行方式的区别：</p><ol type="1"><li><p>编译可执行文件后，将该文件放到没有 Go开发环境的设备上仍能运行</p><p>使用 go run 运行文件则需要 Go 开发环境</p></li><li><p>编译时，编译器会将程序运行依赖的库文件包含在可执行文件中。因此，可执行文件占用空间较大。</p></li></ol><h2 id="go-开发注意事项">1.2 Go 开发注意事项</h2><ol type="1"><li><p>Go 源文件以 .go 为扩展名</p></li><li><p>Go 应用程序的执行入口是 main() 方法</p></li><li><p>Go 语言严格区分大小写</p></li><li><p>Go 方法由一条条语句构成，每个语句后可以不加分号（Go语言会在每行后自动添加）</p></li><li><p>Go 编译器是逐行翻译的。因此，不能将多条语句写在同一行</p></li><li><p><strong>Go 语言定义的变量或 import的包如果没有用到，就不能编译通过</strong></p></li><li><p>可以使用 gofmt 指令来对代码进行整理</p><div class="code-wrapper"><pre><code class="hljs cmd">******&gt;gofmt -w 源文件名</code></pre></div></li></ol><h2 id="注释">1.3 注释</h2><p>用于注解说明解释程序的文字就是注释。注释提高了代码阅读性。被注释的文字不会被Go 编译器执行。</p><p>Go 语言中注释有两种形式：单行注释和多行注释</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 单行注释</span><span class="hljs-comment">/* 多行</span><span class="hljs-comment">注释 */</span></code></pre></div><p>注释不能嵌套注释。Go 官方推荐使用单行注释来注释整个方法和语句</p><h2 id="变量">1.4 变量</h2><p>变量是程序的基本组成单位，相当于内存中一个数据存储空间的表示。该存储区域有自己的名称（变量名）和类型（数据类型）</p><p><strong>Go 语言中变量的声明有以下形式：</strong></p><ul><li><p>指定变量类型。声明后不赋值的场合，使用默认值</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span><span class="hljs-comment">// var 变量名 数据类型</span>i = <span class="hljs-number">100</span><span class="hljs-comment">// 赋值</span></code></pre></div></li><li><p>根据赋值自行判断数据类型（类型推导）</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> i = <span class="hljs-number">10</span><span class="hljs-comment">// var 变量名 = 值</span></code></pre></div></li><li><p>省略 <code>var</code>，使用 <code>:=</code></p><div class="code-wrapper"><pre><code class="hljs go">i := <span class="hljs-number">20</span><span class="hljs-comment">// 变量名 := 值</span></code></pre></div></li><li><p>一次性声明多个变量</p><div class="code-wrapper"><pre><code class="hljs go">v1, v2, v3 := <span class="hljs-number">100</span>, <span class="hljs-string">&quot;Go&quot;</span>, <span class="hljs-number">3.2</span></code></pre></div></li></ul><p>在函数体外声明的变量称为<strong>全局变量</strong>：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> n1 = <span class="hljs-number">100</span><span class="hljs-comment">// 全局变量</span><span class="hljs-keyword">var</span> (n2 = <span class="hljs-number">200</span><span class="hljs-comment">// 另一种全局变量的声明方式</span>    n3 = <span class="hljs-number">300</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    ...&#125;</code></pre></div><p><strong>使用细节：</strong></p><ul><li><p><strong>不能使用 <code>:=</code> 方式声明全局变量</strong></p><p>因为 <code>:=</code> 等同于一个 变量声明 +赋值语句。在函数体外可以声明变量，但不能执行语句（也就不能执行赋值语句）</p></li><li><p>全局变量即使没有使用过，也能编译通过</p></li></ul><h3 id="常量">1.4.1 常量</h3><p>常量是变量的一种。使用 const 而非 var 修饰的变量称为常量。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">const</span> ci <span class="hljs-type">int</span> = <span class="hljs-number">100</span><span class="hljs-keyword">const</span> c2 = <span class="hljs-number">1000</span><span class="hljs-comment">// 也能直接省略那个类型名</span><span class="hljs-keyword">const</span> c3 = ci - <span class="hljs-number">5</span></code></pre></div><p>在函数体外声明的常量称为全局常量</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (i = <span class="hljs-number">100</span>    ui <span class="hljs-type">uint64</span> = <span class="hljs-number">9</span>)</code></pre></div><p><strong>使用细节：</strong></p><ul><li><p>常量必须在声明时即赋值</p></li><li><p>常量赋值后不能更改。</p></li><li><p><strong>常量只能修饰 bool、数值类型、string类型。</strong></p></li><li><p>常量即使没有使用过，也能编译通过</p></li><li><p>常量必须在编译阶段确定数值。可以使用表达式对常量赋值，但表达式中<strong>不能含有任何变量</strong></p></li><li><p>可以使用 iota 对常量进行序号赋值</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (    o0      = <span class="hljs-number">100</span><span class="hljs-comment">// 100</span>    o1, o11 = <span class="hljs-literal">iota</span>, <span class="hljs-literal">iota</span><span class="hljs-comment">// 1 1</span>    o2      = <span class="hljs-literal">iota</span><span class="hljs-comment">// 2</span>    o3<span class="hljs-comment">// 3</span>)</code></pre></div><p>届时，iota 项及其之后未赋值的项的值，等于其声明位置的编号（从 0开始计数）的值</p><p>iota 只能对常量声明块中的常量进行赋值</p></li><li><p>在 Go语言中，不要求常量首字母大写。首字母的大小写是决定标识符的访问范围。</p></li></ul><h2 id="数据类型">1.5 数据类型</h2><p>每一种数据都定义了明确的数据类型，在内存中分配了不同大小的空间</p><p><strong>- 基本数据类型</strong></p><ul><li>数值型<ul><li>整数类型（int, int8, int16, int32, int64, uint, uint8, uint16,uint32, uint64, rune, byte）</li><li>浮点类型（float32, float64）</li></ul></li><li>字符型（没有专门的字符型，使用 byte 保存单个字符）</li><li>布尔型（bool）</li><li>字符串（string）</li></ul><p><strong>- 派生 / 复杂数据类型</strong></p><ul><li>指针（Pointer）</li><li>数组</li><li>结构体（struct）</li><li>管道（Channel）</li><li>函数</li><li>切片（slice）</li><li>接口（interface）</li><li>map</li></ul><h3 id="整数类型">1.5.1 整数类型</h3><blockquote><p>用于存放一个整数数值</p></blockquote><p>uint 为无符号整数，int 为有符号整数。</p><p>数字为占用空间大小。int8 占用 1 字节，int16 占用 2字节，以此类推。</p><p>表数范围由其符号有无及占用空间决定。int8 表数范围是 [-128,127]，int32 表数范围是 [-2<sup>31</sup>, 2<sup>31</sup> - 1]，uint8表数范围是 [0, 255]</p><p>rune 等价于 int32，其可以表示一个 Unicode 码</p><p>byte 等价于 uint8。存储字符时，选用 byte</p><p>整数类型的默认值（零值）是 <code>0</code></p><h4 id="使用细节">使用细节</h4><ol type="1"><li>Go 各整数分为有符号和无符号。Go 中的 int、uint的大小和操作系统有关。</li><li>Go 的整型默认声明为 int 型</li><li>使用 <code>unsafe.Sizeof(n)</code>函数，以查看变量占用空间的大小（字节）</li><li>使用整型变量时，应在保证程序正确运行的情况下，尽量使用占用空间小的数据类型</li></ol><h3 id="浮点类型">1.5.2 浮点类型</h3><blockquote><p>用于存放一个小数数值</p></blockquote><p>数字为精度大小。float32 为单精度（32 位，占用 4 字节），float64为双精度（64 位，占用 8 字节）</p><p>浮点类型的默认值（零值）是 <code>0</code></p><h4 id="使用细节-1">使用细节</h4><ol type="1"><li>Go 的浮点型默认声明为 float64 类型</li><li>浮点数在计算机中的存放方式：浮点数 = 符号位 + 指数位 + 尾数位</li><li>尾数部分可能丢失，就会造成精度丢失。</li></ol><h3 id="字符类型">1.5.3 字符类型</h3><p>Go 没有专门的字符型，使用 byte 保存单个字符。Go的字符串是由字节连接起来的。</p><p>字符常量是单引号 <code>‘ ’</code> 包括的单个字符。Go运行使用转义字符</p><h4 id="使用细节-2">使用细节</h4><ol type="1"><li><p>如果字符在 ASCII 表中，可以直接保存到 byte（或者 rune）</p></li><li><p>如果字符码值大于 255，可以使用 int 保存</p></li><li><p>Go 中，字符的本质是一个整数。直接输出时，输出该字符的 UTF-8码值</p><p>要按照字符方法输出时，应该使用格式化输出<code>fmt.Printf()</code></p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span> = <span class="hljs-string">&#x27;★&#x27;</span>fmt.Printf(<span class="hljs-string">&quot;%c&quot;</span>, i)</code></pre></div></li><li><p>Go 语言的字符使用 UTF-8 编码。</p></li><li><p>字符类型可以进行运算，因为其相当于一个整数。</p></li></ol><h3 id="布尔类型">1.5.4 布尔类型</h3><p>布尔类型用于表示真或假。布尔类型只允许取 true 或 false</p><p>bool 类型占 1 字节。其适用于逻辑运算，一般用于程序流程控制</p><p>布尔类型的默认值（零值）是 <code>false</code></p><h3 id="字符串类型">1.5.5 字符串类型</h3><p>Go 语言将字符串也视为基本数据类型</p><p>字符串就是一串固定长度的字符连接起来的字符序列。Go的字符串由单个字节连接</p><p>字符串的默认值（零值）是空串 <code>“”</code></p><p>字符串有 2 种表示形式</p><ul><li><p>双引号包含字符串。此时会识别转义字符</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> str1 = <span class="hljs-string">&quot;放牛的&quot;</span></code></pre></div></li><li><p>反引号包含字符串。此时将以字符串的原生形式输出，包含换行和特殊字符。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> str2 = <span class="hljs-string">`矮堇瓜`</span></code></pre></div><p>这样能实现防止攻击、输出原代码等效果</p></li></ul><h4 id="使用细节-3">使用细节</h4><ol type="1"><li><p>Go 使用 UTF-8 编码标识 Unicode 文本，这样 Go 统一使用 UTF-8编码，再也不会发生乱码问题。</p></li><li><p>字符串一旦赋值即不能更改。<strong>在 Go中，字符串是不可变的</strong></p></li><li><p>当 <code>+</code> 运算符两侧都是字符串时，Go会将其解析为字符串拼接</p><p>一次拼接太长时，能分行编写，但需要把那个 <code>+</code>运算符留在行尾</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;马冬什么？\n&quot;</span> + <span class="hljs-string">&quot;马冬梅！\n&quot;</span> +<span class="hljs-string">&quot;马什么梅啊？\n&quot;</span> + <span class="hljs-string">&quot;马冬梅啊！\n&quot;</span> +<span class="hljs-string">&quot;什么冬梅啊？\n&quot;</span> + <span class="hljs-string">&quot;行，大爷你坐这吧\n&quot;</span> + <span class="hljs-string">&quot;好嘞&quot;</span></code></pre></div><p>这是因为 Go 会自动为每行代码添加 <code>;</code>。看到有<code>+</code>，他就懂了！</p></li></ol><h3 id="基本数据类型的转换">1.5.6 基本数据类型的转换</h3><p>Go 中的基本数据类型<strong>不能自动转换</strong>，不同变量间赋值时需要显式转换</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> d <span class="hljs-type">float64</span> = <span class="hljs-number">10</span><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span> = <span class="hljs-type">int</span>(d)<span class="hljs-comment">// 数据类型(变量)</span></code></pre></div><h4 id="使用细节-4">使用细节</h4><ol type="1"><li><p>数据类型既可以从小到大转换，也能从大到小转换</p></li><li><p>被转换的是变量存储的数值。变量本身没有变化</p></li><li><p>从大到小转换时，可能产生数据溢出</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> n <span class="hljs-type">int32</span> = <span class="hljs-number">12</span><span class="hljs-keyword">var</span> i <span class="hljs-type">int8</span> = <span class="hljs-type">int8</span>(n) + <span class="hljs-number">127</span><span class="hljs-comment">// 相当于 int8(n + 127) 结果会溢出</span><span class="hljs-comment">/* var i2 int8 = int8(n) + 128 */</span><span class="hljs-comment">// 编译错误，因为检测到 128 超出范围</span></code></pre></div></li></ol><h3 id="基本数据类型与-string-的转换">1.5.7 基本数据类型与 string的转换</h3><p>基本数据类型转成 string：</p><ul><li><p>使用 <code>fmt.Sprintf("%参数", 表达式)</code></p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> n = <span class="hljs-number">100</span><span class="hljs-keyword">var</span> c <span class="hljs-type">rune</span> = <span class="hljs-string">&#x27;★&#x27;</span>str := fmt.Sprintf(<span class="hljs-string">&quot;%c刻晴%c%v%c&quot;</span>, c, c, n, c)<span class="hljs-comment">// ★刻晴★100★</span></code></pre></div></li><li><p>使用 strconv 包的函数</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> n <span class="hljs-type">int</span> = <span class="hljs-number">100</span>str := strconv.FormatInt(<span class="hljs-type">int64</span>(n), <span class="hljs-number">2</span>)<span class="hljs-comment">// 转化为 2 进制 1100100</span>str2 := strconv.Itoa(n)</code></pre></div></li></ul><p>string 转成基本数据类型：</p><ul><li><p>使用 strconv 包的函数</p><div class="code-wrapper"><pre><code class="hljs go">str := <span class="hljs-string">&quot;100&quot;</span><span class="hljs-keyword">var</span> n <span class="hljs-type">int64</span>n, _ = strconv.ParseInt(str, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>)<span class="hljs-comment">// 该函数有多个返回值，_ 即忽略第二个</span></code></pre></div><p>此时，要确保那个 string可以转化成有效数据。不能转换时，那个返回值是默认值</p></li></ul><h2 id="值类型和引用类型">1.6 值类型和引用类型</h2><ul><li><p>值类型：包括基本数据类型、数组、struct 结构体。</p><p>对于值类型，其变量直接存储值，内存通常在栈中分配</p></li><li><p>引用类型：包括指针、slice 切片、map、管道 chan、interface 等</p><p>引用类型变量存储一个地址，该地址指向的空间真正的存储数据。内存通常在堆上分配。</p><p>当没有任何变量引用该地址时，该地址对应的数据空间成为垃圾，由 GC回收</p></li></ul><h3 id="指针">1.6.1 指针</h3><p>值类型都有对应的指针类型。</p><ul><li>声明指针：<code>指针变量名 *数据类型</code></li><li>记录地址：<code>指针变量名 = &amp;变量名</code></li><li>使用指针：<code>*指针变量名</code></li></ul><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span> = <span class="hljs-number">10</span>;<span class="hljs-keyword">var</span> pointer *<span class="hljs-type">int</span> = &amp;i<span class="hljs-comment">// 指针</span>fmt.Println(pointer)<span class="hljs-comment">// 输出一个地址</span>fmt.Println(*pointer)<span class="hljs-comment">// 输出 10</span></code></pre></div><h2 id="标识符">1.7 标识符</h2><p>Go对各种变量、方法等命名时使用的字符序列称为标识符。凡能自己起名字的地方都叫标识符</p><h4 id="命名规则">命名规则：</h4><ul><li>标识符由 26 个大小写英文字母、数字、下划线组成</li><li>数字不能作为标识符开头</li><li>Go 中严格区分大小写</li><li>标识符不能包含空格</li><li>下划线 <code>_</code> 在 Go 中是一个特殊的标识符，称为<strong>空标识符</strong>。它可以代表其他任何标识符，但其对应的值会被忽略（如，忽略一个返回值）。空标识符只能作为占位符使用，而不能作为标识符使用。</li><li>不能以系统保留关键字作为标识符，如 break、if 等</li><li><strong>如果变量、函数、常量名首字母大写，则其可以跨包访问。否则仅限于本包访问</strong></li></ul><h4 id="命名规范">命名规范：</h4><ul><li>命名包名时：保持 package名字与目录名保持一致，并使包名简短、有意义，且不和标准库冲突。</li><li>命名变量、函数、常量时，采用驼峰法命名（即：单词字母小写，第二个单词起首字母大写）</li></ul><h4 id="go-的保留关键字和预定义标识符">Go的保留关键字和预定义标识符：</h4><p>Go 为了简化代码编译过程中对代码的解析，其保留关键字只有 25 个：</p><table><tr><td>break</td><td>default</td><td>func</td><td>interface</td><td>select</td></tr><tr><td>case</td><td>defer</td><td>go</td><td>map</td><td>struct</td></tr><tr><td>chan</td><td>else</td><td>goto</td><td>package</td><td>switch</td></tr><tr><td>const</td><td>fallthrough</td><td>if</td><td>range</td><td>type</td></tr><tr><td>continue</td><td>for</td><td>import</td><td>return</td><td>var</td></tr></table><p>其还提供了 36 个预定义标识符，包括基础数据类型和系统内嵌函数：</p><table><tr><td>append</td><td>bool</td><td>byte</td><td>cap</td><td>close</td><td>complex</td></tr><tr><td>complex64</td><td>complex128</td><td>uint16</td><td>copy</td><td>flase</td><td>float32</td></tr><tr><td>float64</td><td>imag</td><td>int</td><td>int8</td><td>int16</td><td>int32</td></tr><tr><td>uint32</td><td>int64</td><td>iota</td><td>len</td><td>make</td><td>new</td></tr><tr><td>nil</td><td>panic</td><td>uint64</td><td>print</td><td>println</td><td>real</td></tr><tr><td>recover</td><td>string</td><td>true</td><td>uint</td><td>uint8</td><td>uintprt</td></tr></table>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt;26 算法入门</title>
    <link href="/2022/06/03/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/26%20%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"/>
    <url>/2022/06/03/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/26%20%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="算法初级">26 算法初级</h1><h2 id="算法的执行时间">26.1 算法的执行时间</h2><blockquote><p>度量一个算法执行时间的方法：</p><ul><li><p>事后统计方法</p><p>该方法可行，但需要实际运行该程序，并且结果受环境因素影响。</p></li><li><p>事前估算方法</p><p>通过分析算法的时间复杂度来判断哪个算法更优</p></li></ul></blockquote><h4 id="时间频度">时间频度</h4><p>算法花费的时间与算法中语句的执行次数成正相关。算法中语句执行次数越多，其花费时间也就越多。</p><p>一个算法中的语句执行次数称为 时间频度（语句频度），记为 T(n)</p><p>举例说明（计算 1 - 100 内所有整数之和）：</p><ul><li><p>方法一：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;    result += i;&#125;</code></pre></div><p>该方法执行了 100 次计算，因此其时间复杂度 T(n) = n</p></li><li><p>方法二：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span> result;result = (<span class="hljs-number">1</span> + n) * (n / <span class="hljs-number">2</span>);</code></pre></div><p>该方法执行了 1 次计算，因此其时间复杂度 T(n) = 1</p></li></ul><h3 id="时间复杂度">26.1.1 时间复杂度</h3><p>一般情况下，算法中的基本操作语句的重复执行次数是问题规模 n的某个函数，用 T(n) 表示。</p><p>若有某个辅助函数 f(n)，使得当 n 趋近于无穷大时，T(n) / f(n)的极限值为不等于零的常数，则称 f(n) 为 T(n) 的同量级函数。记作：T(n) =O(f(n))。</p><p>称 O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。</p><p>如：T(3n<sup>2</sup>+2n-1) 的时间复杂度为 O(n<sup>2</sup>)</p><p><strong>常见的时间复杂度（从小到大排列）：</strong></p><ul><li>常数阶 O(1)</li><li>对数阶 O(㏒<sub>k</sub>n)</li><li>线性阶 O(n)</li><li>线性对数阶 O(n㏒<sub>k</sub>n)</li><li>平方阶 O(n<sup>2</sup>)</li><li>立方阶 O(n<sup>3</sup>)</li><li>k 次方阶 O(n<sup>k</sup>)</li><li>指数阶 O(2<sup>n</sup>)</li></ul><p><strong>计算时间复杂度的方法：</strong></p><ol type="1"><li>用常数 1 代替运行时间中的加法常数</li><li>修改后的运行次数函数中，只保留最高阶项</li><li>去除最高阶项的系数</li></ol><p><strong>平均时间复杂度、最坏时间复杂度：</strong></p><ul><li><p>平均时间复杂度：指所有可能的输入实例以等概率出现的情况下，该算法的运行时间</p></li><li><p>最坏时间复杂度：最坏情况下的时间复杂度。</p><p>一般讨论时间复杂度都是讨论最坏时间复杂度。原因是：最坏时间复杂度是算法在任何输入实例上运行时间的界限。这就保证了算法运行时间不会比最坏情况更长。</p><p>最坏时间复杂度和平均时间复杂度也许不一致。这和具体算法有关。</p></li></ul><h4 id="算法的空间复杂度">算法的空间复杂度</h4><p>类似于时间复杂度的讨论，一个算法的空间复杂度定义为该算法所耗费的存储空间。它也是问题规模n 的函数。</p><p>空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与问题规模n 相关。</p><p>在做算法分析时，<strong>主要讨论的是时间复杂度</strong>。从用户体验上看，更看重程序执行的速度。一些缓存产品和算法本质是用空间换时间。</p><h2 id="常用的算法">26.2 常用的算法</h2><h3 id="二分查找算法">26.2.1 二分查找算法</h3><p>二分查找只适用于从有序数列中进行查找。其运行时间为O(㏒<sub>2</sub>n)</p><p><strong><em>——二分查找，见 <ahref="../../../../../../2021/11/27/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/5%20%E6%95%B0%E7%BB%84%E3%80%81%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/#5-3-2-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">[5.3.2二分查找]</a></em></strong></p><h4id="一个用到二分查找算法的典型题目">一个用到二分查找算法的典型题目</h4><blockquote><p><strong><ahref="https://leetcode.cn/problems/koko-eating-bananas/">爱吃香蕉的珂珂</a></strong></p><p>珂珂喜欢吃香蕉。这里有 n 堆香蕉，第 i 堆中有 piles[i]根香蕉。警卫已经离开了，将在 h 小时后回来。</p><p>珂珂可以决定她吃香蕉的速度 k（单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 k根。如果这堆香蕉少于 k根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。</p><p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p><p>返回她可以在 h 小时内吃掉所有香蕉的最小速度 k（k 为整数）。</p></blockquote><p><strong>题解：</strong></p><p>注意到，随着 k 的增加，吃光香蕉的用时 t 随之减少。取食数量 k与进食总时间 t 呈线性相关。</p><p>因此，可以使用二分查找算法，找出 t == h 时，k 的最小取值</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minEatingSpeed</span><span class="hljs-params">(<span class="hljs-type">int</span>[] piles, <span class="hljs-type">int</span> h)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// k 可能取到的最大值。该值等于：香蕉堆中香蕉数量的最大值</span>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// k 可能取到的最小值。该值等于：香蕉总数 / 规定时间</span>        <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// 香蕉总数</span>        <span class="hljs-comment">/* 进行一次遍历，完成对 max、min、sum 的初始化 */</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : piles) &#123;            sum += n;            <span class="hljs-keyword">if</span> (max &lt; n) max = n;        &#125;        <span class="hljs-comment">/* 由于每堆香蕉至少需要 1 小时，当 piles.length == h 时，k 是那个香蕉堆最大值 */</span>        <span class="hljs-keyword">if</span> (piles.length == h) <span class="hljs-keyword">return</span> max;        min = (sum + h - <span class="hljs-number">1</span>) / h;<span class="hljs-comment">// 这里是 int 除法的向上取整</span>                <span class="hljs-comment">/* 二分查找，如果在 p 情况下超时（吃不完香蕉），说明 k &gt; p</span><span class="hljs-comment">        如果在 p 情况下提前吃完，说明 k &lt; p </span><span class="hljs-comment">        如果恰好吃完，由于要求返回那个最小 k 值，我们仍要在 &lt; p 的范围内查找 */</span>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> min;        <span class="hljs-keyword">while</span> (max &gt;= min) &#123;            p = (max + min) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span> (check(piles, p) &lt;= h) max = p - <span class="hljs-number">1</span>;            <span class="hljs-type">else</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> p + <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> min;    &#125;        <span class="hljs-comment">/* 计算在吃 n 根的情况下，需要用时多久吃完 */</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span>[] piles, <span class="hljs-type">int</span> n)</span> &#123;        <span class="hljs-type">long</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : piles) &#123;            ret += (i + n - <span class="hljs-number">1</span>) / n;        &#125;        <span class="hljs-keyword">return</span> ret;    &#125;&#125;</code></pre></div><h3 id="分治算法">26.2.2 分治算法</h3><p>分治算法是一种重要算法。其核心思想是 <strong>分而治之</strong>。</p><p>将一个复杂问题分为多个子问题，再将子问题分为更小的子问题。直到那些子问题都能简单地直接得解，原问题的解即子问题解的组合。</p><p>该算法也是很多高效算法的基础，如排序算法（快速排序、归并排序），傅立叶变换（快速傅立叶变换）等。</p><h3 id="动态规划">26.2.3 动态规划</h3><p>动态规划的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解</p><p>与分治法不同的是，适用于动态规划求解的问题，其分解得到的子问题往往不是互相独立的。下一子阶段的求解往往是建立在上一子阶段解的基础上的。</p><h4 id="一个用到动态规划的典型题目">一个用到动态规划的典型题目：</h4><blockquote><p><strong><ahref="https://leetcode.cn/contest/weekly-contest-298/problems/selling-pieces-of-wood/">卖木块</a></strong></p><p>给你两个整数 <code>m</code> 和 <code>n</code>，分别表示一块矩形木块的高和宽。同时给你一个二维整数数组<code>prices</code> ，其中 <code>prices[i] = [hi, wi, pricei]</code>表示你可以以 <code>pricei</code> 元的价格卖一块高为 <code>hi</code> 宽为<code>wi</code> 的矩形木块。</p><p>每一次操作中，你必须按下述方式之一执行切割操作，以得到两块更小的矩形木块：</p><ul><li>沿垂直方向按高度 <strong>完全</strong> 切割木块，或</li><li>沿水平方向按宽度 <strong>完全</strong> 切割木块</li></ul><p>在将一块木块切成若干小木块后，你可以根据 <code>prices</code>卖木块。你可以卖多块同样尺寸的木块。你不需要将所有小木块都卖出去。你<strong>不能</strong> 旋转切好后木块的高和宽。</p><p>请你返回切割一块大小为 <code>m x n</code> 的木块后，能得到的<strong>最多</strong> 钱数。</p><p>注意你可以切割木块任意次。</p></blockquote><p><strong>题解：</strong></p><p>我们可以模拟切分木块的过程，从而得到答案。</p><p>对于任意木块 m × n，我们可以将其切开。此时该木块的价值 V等于两个子木块的价值和。具体来说：</p><ul><li>沿横向切开时，木块价值 V(m, n) = V(i, n) + V(m - i, n)</li><li>沿纵向切开时，木块价值 V(m, n) = V(m, i) + V(m, n - i)</li><li>也可以选择不切开，此时木块价值为 prices(m, n)</li></ul><p>一块木块的价值是上述三种情况中的最大值。</p><p>我们可以维护一个数组，从最小木块开始统计那些木块的价值。直到统计到最大木块时，那个值即是答案。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">sellingWood</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] prices)</span> &#123;        <span class="hljs-comment">/* 将那些不分割的情况记录 */</span>        <span class="hljs-type">long</span>[][] val = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] ints : prices) val[ints[<span class="hljs-number">0</span>]][ints[<span class="hljs-number">1</span>]] = ints[<span class="hljs-number">2</span>];                <span class="hljs-comment">/* 最小的高度开始，统计木块价值 */</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;            <span class="hljs-comment">/* 从最小的宽度开始，统计木块的价值 */</span>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;                <span class="hljs-comment">/* 在该高度纵切 */</span>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; k &lt;= j - k; k++) &#123;                    <span class="hljs-type">long</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> val[i][k] + val[i][j - k];                    <span class="hljs-keyword">if</span> (temp &gt; val[i][j]) val[i][j] = temp;                &#125;                <span class="hljs-comment">/* 在该宽度横切 */</span>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; u &lt;= i - u; u++) &#123;                    <span class="hljs-type">long</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> val[i - u][j] + val[u][j];                    <span class="hljs-keyword">if</span> (temp &gt; val[i][j]) val[i][j] = temp;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> val[m][n];    &#125;&#125;</code></pre></div><h3 id="kmp-算法">26.2.4 KMP 算法</h3><p>KMP（Knuth-Morris-Pratt，字符串查找算法），该算法以提出该算法的三人姓名命名，是一个解决查找模式字符串 在 文本中 出现位置的经典算法。</p><p>KMP 算法利用前面判断过的信息，通过一个 next数组（部分搜索池），保存模式串中，前后最长公共子序列的长度。每次回溯时，通过next 数组找到前面匹配过的位置，省去了大量计算时间。</p><p>在 KMP算法里，源串指针永远不会向前回溯，而对象串指针在当前位置匹配成功时后移，匹配失败时前移。</p><h4 id="kmp-算法步骤">KMP 算法步骤</h4><p>假定我们的对象串是 <code>String tar = "ABCDABD"</code></p><p>去匹配源串 <code>String ori = "ABCDABCDABCDABDADD"</code></p><ol type="1"><li><p>根据对象串，初始化一个部分匹配池。该池中的第 i位代表匹配进行到此处时，已匹配过的部分与对象串进行自匹配的结果。</p><table><tr><th><p>搜索词</p></th><td><p>A</p></td><td><p>B</p></td><td><p>C</p></td><td><p>D</p></td><td><p>A</p></td><td><p>B</p></td><td><p>D</p></td></tr><tr><th><p>部分匹配值</p></th><td><p>-1</p></td><td><p>0</p></td><td><p>0</p></td><td><p>0</p></td><td><p>0</p></td><td><p>1</p></td><td><p>1</p></td></tr></table></li><li><p>让源串指针和对象串指针指向各自开头。尝试匹配那些指针指向的字符。</p></li><li><p>出现字符匹配时，向后移动源串指针和对象串指针，继续下一步匹配。</p><p>出现不匹配时，把对象指针移动到部分匹配池指示的位置，继续尝试匹配。</p><p>第一个字符都不匹配时，向后移动源串指针，对象串会从头开始匹配。</p></li><li><p>对象串指针指向对象串末尾时，即匹配成功。源串指针指向源串末尾时，即匹配失败。</p></li></ol><h4 id="实现-kmp-算法">实现 KMP 算法</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">KMP</span><span class="hljs-params">(String ori, String tar)</span> &#123;    <span class="hljs-keyword">if</span> (tar == <span class="hljs-literal">null</span> || ori == <span class="hljs-literal">null</span> || tar.length() &gt; ori.length()) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    <span class="hljs-type">char</span>[] ts = tar.toCharArray();        <span class="hljs-comment">// 对象字符串</span>    <span class="hljs-type">char</span>[] os = ori.toCharArray();        <span class="hljs-comment">// 源字符串</span>    <span class="hljs-comment">/* 初始化部分匹配池 */</span>    <span class="hljs-type">int</span>[] list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[ts.length];    list[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, k = -<span class="hljs-number">1</span>; j &lt; list.length-<span class="hljs-number">1</span>; ) &#123;        <span class="hljs-keyword">if</span> (k == -<span class="hljs-number">1</span> || ts[j] == ts[k]) list[++j] = list[++k] + <span class="hljs-number">1</span>;        <span class="hljs-type">else</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> list[k];    &#125;    <span class="hljs-comment">/* 源串指针 op、对象串指针 tp */</span>    <span class="hljs-type">int</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, tp = <span class="hljs-number">0</span>;    <span class="hljs-comment">/* 开始匹配 */</span>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;        <span class="hljs-comment">/* 对象串指针指向对象串末尾时，即匹配成功 */</span>        <span class="hljs-keyword">if</span> (tp &gt;= ts.length) <span class="hljs-keyword">return</span> op - ts.length;        <span class="hljs-comment">/* 源串指针指向源串末尾时，即匹配失败 */</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op &gt;= os.length) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        <span class="hljs-comment">/* 匹配时，后移源串指针和对象串指针，继续匹配。</span><span class="hljs-comment">                出现不匹配时，把对象指针移动到部分匹配池指示的位置，并继续匹配。 */</span>        <span class="hljs-keyword">while</span> (tp &gt;= <span class="hljs-number">0</span> &amp;&amp; ts[tp] != os[op]) tp = list[tp];        tp++;        op++;    &#125;&#125;</code></pre></div><h3 id="贪心算法">26.2.5 贪心算法</h3><p>贪心算法（贪婪算法）是指在对问题进行求解时，在每一步选择中都采取最好或最优的选择。从而希望结果是最好或最优的算法。</p><p>贪婪算法得到的结果不一定是最优结果，但都是相对接近最优的结果。</p><p><strong><em>——一个贪心算法的例子，见本章附录：<ahref="../../../../../../2022/06/03/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/26%20%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/#%E9%AA%91%E5%A3%AB%E5%91%A8%E6%B8%B8%E9%97%AE%E9%A2%98">[骑士周游问题]</a></em></strong></p><h3 id="普里姆算法">26.2.6 普里姆算法</h3><p>最小生成树问题（MST，Minimum Cost SpanningTree）：给定一个带权的无向连通图，如何选取一棵生成树，时树上所有边的权总和最小。</p><p>要解决最小生成树问题，可以采取<strong>普里姆算法（Prim）</strong></p><h4 id="普里姆算法步骤">普里姆算法步骤：</h4><p>示范一个联通网图的格式。后面算法中的 <code>int[][] map</code>都是该格式的联通网：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;,        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;,        &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>&#125;,        &#123;<span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>&#125;,        &#123;<span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>&#125;&#125;;<span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> map.length;</code></pre></div><p>网点编号为 [0, n)，n 为网点数量。<code>map[a][b]</code> 是网点 a与网点 b 间路径的权（0 为不连通）</p><pre><code class=" mermaid">graph LRA((0))--1---B((1))A--2---C((2))B--3---CA--4---D((3))--6---CA--5---E((4))--7---D</code></pre><ol type="1"><li>从任意顶点 i（0 &lt;= i &lt;n）起构造最小生成树。将该顶点标记为已访问</li><li>如果联通网图中存在剩余顶点，则记录那些与已访问顶点相连的边中，权值最小的边（避免产生回路），并将该顶点加入已访问集合。</li><li>联通网图中没有未访问节点时，即所有顶点都被联通</li></ol><h4 id="实现普里姆算法">实现普里姆算法</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] prim(<span class="hljs-type">int</span>[][] map) &#123;    <span class="hljs-comment">/* 初始化 */</span>    Set&lt;Integer&gt; visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<span class="hljs-comment">// 已访问集合</span>    Set&lt;Integer&gt; remain = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<span class="hljs-comment">// 待访问集合</span>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> map.length;<span class="hljs-comment">// 网点数量</span>    <span class="hljs-type">int</span>[][] ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<span class="hljs-comment">// 极小联通子图</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) remain.add(i);    visited.add(<span class="hljs-number">0</span>);        <span class="hljs-comment">/* 记录待访问集合与已访问集合的节点间，权值最小的边，并将该节点加入已访问集合 */</span>    <span class="hljs-keyword">while</span> (!remain.isEmpty()) &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">point</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (Integer i : visited) &#123;            <span class="hljs-keyword">for</span> (Integer j : remain) &#123;                <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> map[i][j];                <span class="hljs-keyword">if</span> (current != <span class="hljs-number">0</span> &amp;&amp; (min == <span class="hljs-number">0</span> || current &lt; min)) &#123;                    min = current;                    point = j;                &#125;            &#125;        &#125;        visited.add(point);        remain.remove((Integer) point);        ret[y][x] = min;        ret[x][y] = min;    &#125;    <span class="hljs-keyword">return</span> ret;&#125;</code></pre></div><h3 id="克鲁斯卡尔算法">26.2.7 克鲁斯卡尔算法</h3><p>解决最小生成树问题的另一种方法是<strong>克鲁斯卡尔算法（Kruskal）</strong></p><h4 id="克鲁斯卡尔算法步骤">克鲁斯卡尔算法步骤</h4><ol type="1"><li>构建一个只含 n 个节点的森林。</li><li>依照权值从小到大，从联通网中选择边加入森林（避免产生回路）。</li><li>直到森林变成一棵树为止，就完成了最小生成树</li></ol><h4 id="实现克鲁斯卡尔算法">实现克鲁斯卡尔算法</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] kruskal(<span class="hljs-type">int</span>[][] map) &#123;    <span class="hljs-comment">/* 节点类（局部内部类） */</span>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;        <span class="hljs-type">Node</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        Node <span class="hljs-title function_">getSuper</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> prev.getSuper();        &#125;    &#125;    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> map.length;        <span class="hljs-comment">/* 构建一个只含 n 个节点的森林 */</span>    Node[] nodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[n];    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) nodes[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();    <span class="hljs-type">int</span>[][] ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];        <span class="hljs-comment">/* 将所有边进行初始化。将这些边加入一个优先级队列，以便从小到大取出</span><span class="hljs-comment">    对于其中每一项 i 都有：i[0] 为权值，i[1]、i[2] 为该边连接的两个节点 */</span>    PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(Comparator.comparing(o -&gt; o[<span class="hljs-number">0</span>]));    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> map[i][j];            <span class="hljs-keyword">if</span> (temp != <span class="hljs-number">0</span>) pq.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;temp, i, j&#125;);        &#125;    &#125;        <span class="hljs-comment">/* 依照权值从小到大，从联通网中选择边加入森林</span><span class="hljs-comment">    取出边时，通过比较两个顶点的顶级父节点是否相同，可以判断两顶点是否已经联通 */</span>    <span class="hljs-keyword">while</span> (!pq.isEmpty()) &#123;        <span class="hljs-type">int</span>[] temp = pq.poll();        <span class="hljs-type">Node</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> nodes[temp[<span class="hljs-number">1</span>]].getSuper();        <span class="hljs-type">Node</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> nodes[temp[<span class="hljs-number">2</span>]].getSuper();        <span class="hljs-keyword">if</span> (a != b) &#123;            b.prev = a;            ret[temp[<span class="hljs-number">1</span>]][temp[<span class="hljs-number">2</span>]] = temp[<span class="hljs-number">0</span>];            ret[temp[<span class="hljs-number">2</span>]][temp[<span class="hljs-number">1</span>]] = temp[<span class="hljs-number">0</span>];        &#125;    &#125;    <span class="hljs-keyword">return</span> ret;&#125;</code></pre></div><h3 id="迪杰斯特拉算法">26.2.8 迪杰斯特拉算法</h3><p>要计算一个连通图内，某一节点到图中另一节点的最短路径，可以采用<strong>迪杰斯特拉算法（Dijkstra）</strong></p><p>该算法是典型最短路径算法，采用广度优先搜索，以起始点为中心向外层层扩展，直到终点为止</p><h4 id="迪杰斯特拉算法步骤">迪杰斯特拉算法步骤</h4><ol type="1"><li><p>设置出发点 v、顶点集合 V、距离集合 D。其中 v 为起始点，V包含起始点外所有顶点，D[i] 表示 v 到 V[i] 的距离</p></li><li><p>找到 D[] 中的最小值 D[n] 和其对应的顶点 V[n]。此时D[n] 即为顶点V[n] 到 v 的最小距离。</p></li><li><p>将 V[n] 设置为当前出发点，从 V 中移除 V[n]。</p><p>对 D 进行更新。D[i] 变成 (原本数值) 和 (当前顶点 v 与 V[i] 距离 +D[n]) 的较小一方数值</p><p>从 D 中移除 D[n]</p></li><li><p>重复 2 -3，直到当前顶点变为终点。此时的行进距离即为最短路径</p></li></ol><h4 id="迪杰斯特拉算法实现">迪杰斯特拉算法实现</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] map, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;    <span class="hljs-keyword">if</span> (start == end) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">/* 将顶点和边放入优先级队列，以便后续取出最短距离</span><span class="hljs-comment">    对于其中任意元素 n 有：n[1] 为节点，n[0] 为 n[1] 与起始节点的最短距离 */</span>    PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(Comparator.comparing(o-&gt;o[<span class="hljs-number">0</span>]));    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> map.length;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        <span class="hljs-keyword">if</span> (i == start) <span class="hljs-keyword">continue</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> map[start][i];        pq.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;temp == <span class="hljs-number">0</span> ? Integer.MAX_VALUE : temp, i&#125;);    &#125;        <span class="hljs-comment">/* 取出那个最短路径和对应节点，对剩余元素进行更新 */</span>    <span class="hljs-keyword">while</span> (!pq.isEmpty()) &#123;        <span class="hljs-type">int</span>[] temp = pq.poll();        <span class="hljs-keyword">if</span> (temp[<span class="hljs-number">1</span>] == end) <span class="hljs-keyword">return</span> temp[<span class="hljs-number">0</span>];        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (temp[<span class="hljs-number">1</span>] == Integer.MAX_VALUE) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] flush : pq) &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">dir</span> <span class="hljs-operator">=</span> map[flush[<span class="hljs-number">1</span>]][temp[<span class="hljs-number">1</span>]];            <span class="hljs-keyword">if</span> (dir != <span class="hljs-number">0</span> &amp;&amp; flush[<span class="hljs-number">0</span>] &gt; dir + temp[<span class="hljs-number">0</span>]) flush[<span class="hljs-number">0</span>] = dir + temp[<span class="hljs-number">0</span>];        &#125;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre></div><h3 id="弗洛伊德算法">26.2.9 弗洛伊德算法</h3><p>另一种最短路径算法是 <strong>弗洛伊德算法（Floyd）</strong></p><p><strong><del>I count weights!</del></strong></p><p>迪杰斯特拉算法用于计算图中 <strong>某一顶点</strong>到其他顶点的最短路径。</p><p>弗洛伊德算法用于计算图中 <strong>各个顶点</strong>之间的最短路径。</p><h4 id="弗洛伊德算法步骤">弗洛伊德算法步骤</h4><ol type="1"><li><p>对于任意顶点 a、b ，取任意中继节点 k，则 a、b 间最短路径 D(a,b)是 [a、b 直接路径距离] 与 [D(a,k) + D(b,k)] 间的较小方数值</p></li><li><p>对于上面的 D(a,k) 和 D(b,k)，是以相同方式获得</p></li><li><p>要计算图中每个节点的最短路径，势必要用每个顶点（作为中继节点）对图进行更新。</p><p>用每个顶点进行更新时，对其他所有边进行更新。</p></li></ol><h4 id="实现弗洛伊德算法">实现弗洛伊德算法</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] floyd(<span class="hljs-type">int</span>[][] map) &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> map.length;    <span class="hljs-type">int</span>[][] ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) ret[i] = Arrays.copyOf(map[i], n);<span class="hljs-comment">/* 让每个节点做中继节点 */</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;                <span class="hljs-comment">/* 取出节点 a */</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) &#123;            <span class="hljs-comment">/* a 不能是中继节点，而且必须与中继节点相连</span><span class="hljs-comment">            此处，由于 i == j 时 map[i][j] == 0，所以省略了 i == j 的判断 */</span>            <span class="hljs-type">int</span> part1;            <span class="hljs-keyword">if</span> ((part1 = ret[i][j]) == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;                        <span class="hljs-comment">/* 取出节点 b */</span>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; j; k++) &#123;                <span class="hljs-comment">/* 对 b 的判断与对 a 的相同，即：不是中继节点，且与中继节点相连  */</span>                <span class="hljs-type">int</span> part2;                <span class="hljs-keyword">if</span> ((part2 = ret[i][k]) == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;                <span class="hljs-type">int</span> <span class="hljs-variable">edge</span> <span class="hljs-operator">=</span> ret[k][j];<span class="hljs-comment">// a、b 的直接路径距离</span>                part2 += part1;<span class="hljs-comment">// 通过中继节点的路径距离</span>                                <span class="hljs-comment">/* 如有必要，进行更新 */</span>                <span class="hljs-keyword">if</span> (edge == <span class="hljs-number">0</span> || edge &gt; part2) &#123;                    ret[k][j] = part2;                    ret[j][k] = part2;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> ret;&#125;</code></pre></div><h2 id="附录">附录</h2><h3 id="骑士周游问题">骑士周游问题</h3><p>将一枚骑士棋子放在国际象棋棋盘上。使骑士按照行棋规则移动，要求每个方格只能进入一次，最终走遍棋盘上所有方格。</p><p>穷举法效率较低，可以利用贪心算法进行优化。</p><p>每次行棋前，计算那些目标点位上包含的行棋方法的数量。行棋时，从最低数量的点位开始尝试。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Chess</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[][] chess = <span class="hljs-literal">null</span>;<span class="hljs-comment">// 棋盘。chess[y][x] == 0 表示该格未被走过，否则是已被走过</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[][] inner = <span class="hljs-literal">null</span>;<span class="hljs-comment">// 数据棋盘。inner[y][x] 是 (x, y) 该格能通向几个未被走过的格子</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">goal</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<span class="hljs-comment">// 本局游戏中，需要走过多少格子</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Comparator&lt;<span class="hljs-type">int</span>[]&gt; c = Comparator.comparing(o-&gt;inner[o[<span class="hljs-number">1</span>]][o[<span class="hljs-number">0</span>]]);    <span class="hljs-comment">// 比较器，期待传入的是数组形式的点位：int[] o</span>    <span class="hljs-comment">// 其中 o.length == 2，o[0] 为横坐标 x，o[1] 为纵坐标 y</span>    <span class="hljs-comment">// 该比较器比较该 o 点位的 inner 值，即 inner[o[1]][o[0]]</span>    <span class="hljs-comment">/* 进行一次马踏棋盘游戏 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">chess</span><span class="hljs-params">(<span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;        <span class="hljs-comment">/* 对初始的参数进行检查 */</span>        <span class="hljs-keyword">if</span> (width &lt; <span class="hljs-number">4</span> || width &gt; <span class="hljs-number">53</span> || height &lt; <span class="hljs-number">4</span> || height &gt; <span class="hljs-number">53</span> || x &lt; <span class="hljs-number">0</span> || x &gt; width || y &lt; <span class="hljs-number">0</span> || y &gt; height)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Illegal Chess Game&quot;</span>);        <span class="hljs-comment">/* 初始化参数 */</span>        goal = width * height;        chess = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[height][width];        inner = initialInner(width, height);        <span class="hljs-comment">/* 进行游戏。成功时输出棋盘，否则提示失败 */</span>        System.out.println(act(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;x, y&#125;, <span class="hljs-number">1</span>) ? deepToString(chess) : <span class="hljs-string">&quot;失败&quot;</span>);    &#125;    <span class="hljs-comment">/* 把棋子移动到该格。</span><span class="hljs-comment">        该格的坐标是 (p[0], p[1])，这是棋子走的第 step 步 */</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">act</span><span class="hljs-params">(<span class="hljs-type">int</span>[] p, <span class="hljs-type">int</span> step)</span> &#123;        <span class="hljs-comment">/* 把当前格子标记为已走过 */</span>        chess[p[<span class="hljs-number">1</span>]][p[<span class="hljs-number">0</span>]] = step;        <span class="hljs-comment">/* 如果走过了所有格子，则游戏结束 */</span>        <span class="hljs-keyword">if</span> (step &gt;= goal) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        step++;        <span class="hljs-comment">/* 查看有哪些能走的格子，将其放入一个优先级队列 */</span>        <span class="hljs-type">int</span>[][] aims = aims(p[<span class="hljs-number">0</span>], p[<span class="hljs-number">1</span>]);        Queue&lt;<span class="hljs-type">int</span>[]&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(c);    <span class="hljs-comment">// 这个比较器是前面定义的，比较 inner 值的那个比较器</span>        Stack&lt;<span class="hljs-type">int</span>[]&gt; s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] i : aims) &#123;            <span class="hljs-comment">/* 点位合法时，让那个 inner 值减少（因为当前格子不能走了），并让其入列 */</span>            <span class="hljs-keyword">if</span> (check(i)) &#123;                inner[i[<span class="hljs-number">1</span>]][i[<span class="hljs-number">0</span>]]--;                s.push(i);                q.add(i);            &#125;        &#125;        <span class="hljs-comment">/* 从 inner 较小的点位开始，试着向目标格移动棋子 */</span>        <span class="hljs-keyword">while</span> (!q.isEmpty()) <span class="hljs-keyword">if</span> (act(q.poll(), step)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-comment">/* 进行到这里说明没有有效走法，我们将该格子重新标记为未走过，并返回上一格 */</span>        chess[p[<span class="hljs-number">1</span>]][p[<span class="hljs-number">0</span>]] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] i : s) inner[i[<span class="hljs-number">1</span>]][i[<span class="hljs-number">0</span>]]++;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-comment">/* 初始化那个数据棋盘。该方法仅在进入游戏时调用一次 */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] initialInner(<span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height) &#123;        <span class="hljs-type">int</span>[][] inner = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[height][width];        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; height; i++) &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">red</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;            <span class="hljs-type">int</span> <span class="hljs-variable">div</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span> || i == height - <span class="hljs-number">2</span>) red = <span class="hljs-number">2</span>;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> || i == height - <span class="hljs-number">1</span>) div = <span class="hljs-number">1</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; width; j++) &#123;                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> red;                <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> div;                <span class="hljs-keyword">if</span> (j == <span class="hljs-number">1</span> || j == width - <span class="hljs-number">2</span>) r += <span class="hljs-number">2</span>;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span> || j == width - <span class="hljs-number">1</span>) d += <span class="hljs-number">1</span>;                inner[i][j] = (<span class="hljs-number">8</span> - r) &gt;&gt; (d);            &#125;        &#125;        <span class="hljs-keyword">return</span> inner;    &#125;    <span class="hljs-comment">/* 返回从 (x, y) 点位能到达的所有点位构成的数组，但不保证数组中每个点位都有效 */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] aims(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;        <span class="hljs-type">int</span>[][] ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">8</span>][<span class="hljs-number">2</span>];        <span class="hljs-type">boolean</span> <span class="hljs-variable">rx</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;        <span class="hljs-type">boolean</span> <span class="hljs-variable">ry</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">8</span>; j++) &#123;            ret[j][<span class="hljs-number">0</span>] = x + (rx ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>) * ((j + <span class="hljs-number">4</span>) / <span class="hljs-number">4</span>);            ret[j][<span class="hljs-number">1</span>] = y + (ry ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>) * ((<span class="hljs-number">11</span> - j) / <span class="hljs-number">4</span>);            <span class="hljs-keyword">if</span> (ry = !ry) rx = !rx;        &#125;        <span class="hljs-keyword">return</span> ret;    &#125;    <span class="hljs-comment">/* 检查该点位是否有效 */</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span>[] i)</span> &#123;        <span class="hljs-keyword">if</span> (i[<span class="hljs-number">0</span>] &lt; <span class="hljs-number">0</span> || i[<span class="hljs-number">1</span>] &lt; <span class="hljs-number">0</span> || i[<span class="hljs-number">1</span>] &gt;= inner.length || i[<span class="hljs-number">0</span>] &gt;= inner[i[<span class="hljs-number">1</span>]].length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> chess[i[<span class="hljs-number">1</span>]][i[<span class="hljs-number">0</span>]] == <span class="hljs-number">0</span>;    &#125;<span class="hljs-comment">/* 输出一个棋盘的信息 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">deepToString</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] array)</span> &#123;        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] ints : array) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : ints) sb.append(i).append(<span class="hljs-string">&quot;\t&quot;</span>);            sb.append(<span class="hljs-string">&quot;\n&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> sb.toString();    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>程序</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt;14 树</title>
    <link href="/2022/06/02/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/14%20%E6%A0%91/"/>
    <url>/2022/06/02/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/14%20%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="树">14 树</h1><h4 id="什么是树">什么是树？</h4><table><tr align="center"><td></td><td><b>结构严格派</b><br/><font color="#FF4000">唯一父节点和复数子节点</font></td><td><b>结构中立派</b><br/>有前驱和后继关系就行</td><td><b>结构自由派</b><br/>能存放内容就行</td></tr><tr align="center"><td><b>类型严格派</b><br/><font color="#FF4000">是一种数据结构</font></td><td>二叉树是树</td><td>链表也是树</td><td>栈也是树</td></tr><tr align="center"><td><b>类型中立派</b><br/>和编程有关就行</td><td>包也是树</td><td>语句肯定是树</td><td>标识符都是树</td></tr><tr align="center"><td><b>类型自由派</b><br/>和程序员有关就行</td><td>wifi 当然是树</td><td>衣服拉链也是树</td><td>馄饨也是树！</td></tr></table><h2 id="二叉树">14.1 二叉树：</h2><p><img src="/img/Java_InputImage/树结构图_14.1.png" /></p><p><em>（树结构图_14.1）</em></p><ul><li><p><strong>二叉树：</strong>树有多种。每个节点最多只能有 2个子节点的一种树的形式称为二叉树</p><p>二叉树的子节点分为<font color="#FF0000"><strong>左节点</strong></font > 和<font color="#5070FF"><strong>右节点</strong></font>。</p></li><li><p><strong>满二叉树：</strong>二叉树的 所有叶节点 都在最后一层，且节点总数是 2<sup>n</sup> - 1</p></li><li><p><strong>完全二叉树：</strong>二叉树的 所有叶节点 都在 最后一层 和倒数第二层，且最后一层的叶节点在左侧连续、倒数第二层的叶节点在右侧连续</p></li></ul><h4 id="二叉树的遍历">二叉树的遍历：</h4><ul><li><p><strong>前序遍历：</strong>先输出<font color="#EF9F00">父节点</font>，再遍历<font color="#FF3030">左子树</font>和<font color="#5070FF">右子树</font>。</p><p>自根节点起。先输出当前节点。再递归前序遍历左节点。那之后，递归前序遍历右节点。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<span class="hljs-comment">// 节点类</span>    <span class="hljs-type">int</span> val;    Node left;    Node right;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">traverse</span><span class="hljs-params">(Node root)</span> &#123;    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();    traverse(root, sb);    <span class="hljs-keyword">return</span> sb.toString();&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">traverse</span><span class="hljs-params">(Node root, StringBuilder sb)</span> &#123;    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;    sb.append(root.val).append(<span class="hljs-string">&quot; &quot;</span>);<span class="hljs-comment">// 先输出父节点</span>    traverse(root.left, sb);<span class="hljs-comment">// 再遍历左子树</span>    traverse(root.right, sb);<span class="hljs-comment">// 再遍历右子树</span>&#125;</code></pre></div></li><li><p><strong>中序遍历：</strong>先遍历<font color="#FF3030">左子树</font>，再输出<font color="#EF9F00">父节点</font>，再遍历<font color="#5070FF">右子树</font>。</p></li><li><p><strong>后序遍历：</strong>先遍历<font color="#FF3030">左子树</font>，再遍历<font color="#5070FF">右子树</font>，再输出<font color="#EF9F00">父节点</font>。</p></li></ul><h3 id="顺序存储二叉树">14.1.1 顺序存储二叉树</h3><p>从数据存储来看，数组与树可以相互转换。数组可以转换成树，树也能转换成数组。</p><p>顺序存储二叉树通常只考虑完全二叉树。将数组转换成树后，将可以进行前序、中序、后序遍历。</p><p><strong>顺序存储二叉树的例子：</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span>[] array = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;;</code></pre></div><p>该 array 的顺序存储二叉树为：</p><pre><code class=" mermaid">graph TDA(0)---B(1)---C(3)A---a(2)---aa(5)B---D(4)a---ab(6)C---E(7)C---F(8)D---G(9)D---H(10)</code></pre><h4 id="顺序存储二叉树的转换">顺序存储二叉树的转换：</h4><ul><li><p>数组下标为 0 的元素放在根节点。</p></li><li><p>对于数组下标为 n 的元素，其左子节点的数组下标为 2 × n +1、右子节点的数组下标为 2 × n + 2、父节点的数组下标为 (n - 1) / 2</p><p>可以发现，所有左节点都是奇数下标，右节点都是偶数下标</p></li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">toTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span> &#123;    <span class="hljs-type">Node</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(array[<span class="hljs-number">0</span>]);    List&lt;Node&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Node&gt;();    list.add(root);<span class="hljs-comment">// 数组下标为 0 的元素放在根节点。</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; array.length; i++) &#123;<span class="hljs-comment">// 按照前述方法，创建每个元素节点，并放在对应父节点下</span>        <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(array[i]);        list.add(temp);        <span class="hljs-type">Node</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> list.get((i - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) parent.right = temp;        <span class="hljs-keyword">else</span> parent.left = temp;    &#125;    <span class="hljs-keyword">return</span> root;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> val;    <span class="hljs-keyword">public</span> Node left;    <span class="hljs-keyword">public</span> Node right;        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;        <span class="hljs-built_in">this</span>.val = val;    &#125;&#125;</code></pre></div><p>以上是一种显式的转换。也可以直接将数组视为抽象的顺序存储二叉树。</p><p>如：堆。<strong><em>——见 <ahref="../../../../../../2021/11/27/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/5%20%E6%95%B0%E7%BB%84%E3%80%81%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/#5-4-8-%E5%A0%86%E6%8E%92%E5%BA%8F">[5.4.8堆排序]</a></em></strong></p><h3 id="线索化二叉树">14.1.2 线索化二叉树</h3><p>含有 n 各节点的二叉链表中，有 n + 1个空指针域。利用这些空指针域，存放指向节点在某种遍历次序下的前驱和后继节点的指针，这种附加的指针称为<strong>线索</strong>。加上了线索的二叉链表称为<strong>线索链表</strong>，相应二叉树称为<strong>线索二叉树</strong>。</p><p>线索二叉树可分为：前序线索二叉树、中序线索二叉树、后续线索二叉树。</p><p>线索化二叉树后，那些左节点和右节点既可能指向自身的子树，也可能指向自身的 前驱 / 后继节点。因此，需要添加一组标记，以记录线索的种类。</p><p>这个遍历的场合，不能再使用递归方式遍历，而是改为线性方式遍历即可。</p><h3 id="赫夫曼树">14.1.3 赫夫曼树</h3><p>给定 n 个权值作为 n个叶节点，构造一棵二叉树。若该树的带权路径长度（WPL）最小，则称其为<strong>最优二叉树</strong>（赫夫曼树、哈夫曼树、霍夫曼树）</p><ul><li><p>节点的带权路径长度：该节点的权 × 节点路径长度</p></li><li><p>树的带权路径长度：所有的叶结点的带权路径长度之和</p><p>赫夫曼树中，一定是权值较大的节点距离根更近。</p></li></ul><p><strong>赫夫曼树的例子：</strong></p><pre><code class=" mermaid">graph TDA(NaN)---B(NaN)---C(14)B---b(NaN)---c(5)b---D(NaN)---E(1)D---F(2)A---a(NaN)---aa(16)a---ab(20)</code></pre><h4 id="生成赫夫曼树">生成赫夫曼树：</h4><ol type="1"><li>对数据进行排序。每个数据都可以创建一个节点</li><li>取出权值最小的两颗二叉树，合并为一棵新的二叉树。该二叉树权值是两棵子树的权值之和</li><li>将数据再次排序，重复合并步骤，直至剩余唯一的树，即为赫夫曼树</li></ol><h4 id="赫夫曼编码">赫夫曼编码：</h4><blockquote><p>赫夫曼编码是一种编码方式，是一种程序算法。赫夫曼编码是赫夫曼树在电讯通信中的经典应用之一。</p><p>赫夫曼编码广泛应用于数据文件压缩，其压缩率在 20% ~ 90% 间</p><p>赫夫曼编码是可变字长编码的一种。是老赫在 1952 年提出的编码方法，称为“最佳编码”</p><p>赫夫曼编码是无损处理方案。由于赫夫曼编码是按字节处理数据，因此可以处理所有文件</p></blockquote><p>编码方式有三种：</p><ul><li><p><strong>定长编码：</strong></p><p>如 ASCII 码，其每个字符占用长度为固定 8 字节</p></li><li><p><strong>变长编码：</strong></p><p>对字符进行统计，按照各个字符出现的次数进行编码。出现次数越多，编码越小。</p><p>字符的编码不能是其他字符编码的前缀，这样的编码叫做前缀编码（消除二义性）。</p></li><li><p><strong>赫夫曼编码：</strong></p><p>按照字符的出现次数，构建赫夫曼树。之后，按照赫夫曼树结构，给字符规定编码。向左的路径记为0，向右记为 1。</p><p>这样得到的编码，一定是前缀编码。因为那些字符节点都是叶节点。赫夫曼行啊赫夫曼！</p><p>之后，用规定的编码将指定字符串转化为字节数组。最后，传递字符数组即可。</p></li></ul><h5 id="实现赫夫曼编码">实现赫夫曼编码：</h5><p><strong><em>——见本章附录：<a href="#f1-实现赫夫曼编码解码">F1实现赫夫曼编码/解码</a></em></strong></p><p><strong>注意事项：</strong></p><ul><li>压缩已经过压缩处理的文件，那个压缩率会变低</li><li>如果一个文件中重复的数据很少，压缩效果也会不明显</li></ul><h3 id="二叉排序树">14.1.4 二叉排序树</h3><p>二叉排序树（BST，Binary SortTree）：对于任何一个非叶节点，其左节点小于等于当前节点，右节点大于等于当前节点</p><p><strong>二叉排序树的例子：</strong></p><pre><code class=" mermaid">graph TDA(10)---B(8)B---D(4)---c(2)---d(1)D---b(6)B---E(9)A---C(15)---e(12)C---ee(23)</code></pre><p><strong>二叉排序树删除节点：</strong></p><ul><li><p>删除叶节点的场合，将那个父节点的对应连接置空即可。</p></li><li><p>删除有唯一子节点的节点场合，让那个父节点的对应连接改为指向子树即可。</p></li><li><p>删除有两个子节点的节点的场合，将该节点置为正无穷或负无穷。</p><p>之后维护该二叉排序树，直到该节点成为叶节点时，删除该节点即可。</p></li></ul><h4 id="平衡二叉树">14.1.4.1 平衡二叉树</h4><blockquote><p>二叉排序树可能形成一些奇怪的形状（如左子树全部为空），这样就不能发挥树形结构的比较优势。</p></blockquote><p>平衡二叉树（AVL树）：也叫平衡二叉搜索树。非空时，其任意节点左右两个子树的高度差不超过1，且左右子树也都是平衡二叉树。</p><p>平衡二叉树的实现方法有：红黑树、AVL、替罪羊树、Treap、伸展树等</p><h5 id="平衡二叉树的左旋转">平衡二叉树的左旋转：</h5><ul><li>创建一个新节点。该节点的值等于根节点值</li><li>使该新节点的左子树指向当前根节点的左子树。使该节点的右子树指向当前根节点右子树的左子树</li><li>使当前根节点的右子树的左子树指向该新节点</li><li>使当前根节点的右子树成为新的根节点。旧的根节点被废弃</li></ul><p>简单的说，就是让根节点的右子树指向右子树的左子树。而右子树的左子树指向根节点。</p><p>合理性在于，根节点（root）的右子树（right）上的所有值都大于 root；而right 的所有左子树的值，以及 root 所有左子树的值也一定小于 right 值</p><h5 id="平衡二叉树的右旋转">平衡二叉树的右旋转：</h5><p>还不是一样？</p><h5 id="平衡二叉树的双旋转">平衡二叉树的双旋转：</h5><p>符合进行右旋转的条件（右子树高度 &gt; 左子树高度 +1）时，如果那个左子树的右子树高度高于其左子树高度，需要先对左子树进行左旋转。以此类推。</p><h5 id="实现平衡二叉树">实现平衡二叉树：</h5><p><strong><em>——见本章附录：<a href="#f2-实现平衡二叉树">F2实现平衡二叉树</a></em></strong></p><h3 id="线段树">14.1.5 线段树</h3><p>线段树（SegmentTree）是一棵二叉树。其每个节点表示一个闭区间，父节点的区间内包含所有子节点的区间。</p><ul><li><p>对于每个非叶节点，将其区间平均划分成两个子区间。左节点指向其中较小区间，右节点指向那个较大区间</p><p>换言之，对于非叶节点 [L, R]，其左子节点是 [L, (L + R) /2]，右子节点是 [((L + R) / 2) + 1, R]</p></li><li><p>对于每个叶节点，其区间仅包含一个元素。即，其区间的左界等于右界。</p></li></ul><p><strong>线段树的例子：</strong></p><p>在区间 [1, 9] 中，记录 [2, 9] 的样子</p><pre><code class=" mermaid">graph TBRoot(&amp;#91&amp;#49,9&amp;#93)Root---L(&amp;#91&amp;#49,5&amp;#93)style R fill: #BFFFFCRoot---R(&amp;#91&amp;#54,9&amp;#93)L---LL(&amp;#91&amp;#49,3&amp;#93)style LR fill: #BFFFFCL---LR(&amp;#91&amp;#52,5&amp;#93)R---RL(&amp;#91&amp;#54,7&amp;#93)R---RR(&amp;#91&amp;#56,9&amp;#93)LL---LLL(&amp;#91&amp;#49,2&amp;#93)style LLR fill: #BFFFFCLL---LLR(&amp;#91&amp;#51,3&amp;#93)LR---LRL(&amp;#91&amp;#52,4&amp;#93)LR---LRR(&amp;#91&amp;#53,5&amp;#93)RL---RLL(&amp;#91&amp;#54,6&amp;#93)RL---RLR(&amp;#91&amp;#55,7&amp;#93)RR---RRL(&amp;#91&amp;#56,8&amp;#93)RR---RRR(&amp;#91&amp;#57,9&amp;#93)LLL---LLLL(&amp;#91&amp;#49,1&amp;#93)style LLLR fill: #BFFFFCLLL---LLLR(&amp;#91&amp;#50,2&amp;#93)</code></pre><p>线段树是近似的完全二叉树。有时，线段树的节点是随着线段树的更新逐渐建立的，此时线段树不处于完全二叉树的状态。</p><p><strong>线段树的更新：</strong></p><p>标记区间时，按照 <strong>广度优先搜索</strong>的思想，从根节点开始遍历区间。</p><p><strong><em>——广度优先搜索，见本章 <a href="#广度优先搜索-bfs">14.3.2广度优先搜索 BFS</a></em></strong></p><p>比如，添加区间 [START, END] 时：</p><ul><li><p>如果一个节点的区间内所有元素都被标记，则标记这个节点</p><p>对于区间 [L, R]，如果 L &gt;= STRAT 且 R &lt;=END，则标记该节点</p></li><li><p>如果一个节点的区间内部分元素被标记，则继续遍历其左右节点</p><p>对于区间 [L, R]，MID = (L + R) / 2</p><p>如果 MID &gt;= L，则需要遍历其左节点。如果 MID &lt;R，则需要遍历其右节点</p></li></ul><p>标记节点时，只需在该节点添加懒标记，而不必对所有子节点进行标记。</p><p><strong>懒标记：</strong></p><p>使用懒标记，可以只更新到满足条件的区间，而不必对所有子区间一一更新。此后再次遍历到该节点时，再对懒标记进行下推</p><p>上述例子中，记录区间 [2, 7] 时，仅更新了 [2, 2]、[3, 3]、[4, 5]、[6,9] 这些节点。</p><p>以节点 [6, 9]为例，该区间上被添加了懒标记，代表该区间及所有子区间都被记录了一次。下次遍历到这个节点时，懒标记被下推给子节点[6, 7]、[8, 9]</p><p><strong>线段树的查询：</strong></p><p>一个区间的元素和，等于 <em>其子区间各自元素和</em> 的合计值</p><p>一个区间中的最大值，等于 <em>其子区间各自最大值</em> 中的较大值</p><h2 id="多路查找树">14.2 多路查找树</h2><blockquote><p>二叉树虽然效率较高，但需要加载到内存中。节点过多时就可能出现问题。</p><p>如：需要进行多次 I / O操作，导致构建速度慢；造成二叉树高度很大，降低操作速度。</p></blockquote><p>每个节点可以拥有更多数据项和更多子节点的树，就是多叉树（multiwaytree）。</p><p>多叉树通过重新组织节点，能减少树的高度，能对二叉树进行优化。</p><h4 id="名词解释">名词解释：</h4><ul><li>节点的度：节点的子节点数量</li><li>树的度 / 阶：树中所有节点的度的最大值</li></ul><h3 id="树-1">14.2.1 2-3 树</h3><p>2-3 树是最简单的 B 树结构。其具有如下特点：</p><ul><li><p>所有叶节点都在同一层。节点包含不超过 2 个值。</p></li><li><p>有两个子节点的节点叫<strong>二节点</strong>。二节点要么没有子节点，要么有两个子节点。</p><p>有三个子节点的节点叫<strong>三节点</strong>。三节点要么没有子节点，要么有三个子节点。</p></li><li><p>2-3 树是由 二节点 和 三节点构成的树。其节点仍遵循二叉排序树的规则。</p><p>对于二节点：其左子树的值需小于当前节点、右子树的值需大于当前节点</p><p>对于三节点：其左子树的值小于当前节点的最小值，中子树的值需介于当前节点的两个值之间，右子树的值大于当前节点的最大值</p></li></ul><p><strong>2-3 树的例子：</strong></p><pre><code class=" mermaid">graph TDA(10)---B(6)B---D(1, 3)B---E(7)A---C(15, 20)C---F(11, 12)C---G(19)C---H(22, 32)</code></pre><h4 id="构建-2-3-树">构建 2-3 树：</h4><ul><li><p>插入节点时，如果不能满足条件，即需要拆分。</p><p>拆分时先拆上层。上层满时，才拆本层。拆分后仍要满足规则</p></li></ul><h4 id="树-2">2-3-4 树：</h4><p>还不是一样？</p><h3 id="b-树">14.2.2 B 树</h3><p>B 树（b-tree，balance tree）。2-3 树与 2-3-4 树都是 B 树的种类。</p><pre><code class=" mermaid">graph TDROOT(30, 60&lt;br/&gt;P1 - P2 - P3)ROOT---R1(10, 20&lt;br/&gt;P1 - P2 - P3)ROOT---R2(40, 50&lt;br/&gt;. - P2 - P3)ROOT---R3(70, 80&lt;br/&gt;P1 - P2 - P3)R1---R11(3, 6)R1---R12(12, 13)R1---R13(23, 24)R2---R21( )R2---R22(41, 48)R2---R23(55, 57)R3---R31(61, 62)R3---R32(73, 74)R3---R33(84, 86)</code></pre><p>B 树具有如下特点：</p><ul><li><p>树树我啊，所有叶节点都在同一层呢。</p></li><li><p>搜索时，从根节点起，对当前节点内的关键字（有序）进行二分查找。</p><p>命中则结束。否则，进入那个对应范围的子节点。那个命中可能发生在叶节点，也可能在非叶节点。</p><p>如果当前节点为空，则表示没有找到。</p></li><li><p>B树的关键字集合分布在整棵树中，非叶节点和叶节点都存放数据</p></li><li><p>B 树的搜索性能等价于在关键字全集内进行二分查找</p></li></ul><h4 id="b-树-1">B+ 树：</h4><p>B+ 树是 B 树的变体。</p><p>使用链表存储数据时，查找数据缓慢。因此将链表数据分为若干段，将每段的索引节点保存为树。</p><pre><code class=" mermaid">graph TDROOT(0, 32, 61&lt;br/&gt;A - B - C)ROOT---R1(0, 12, 23&lt;br/&gt;A - B - C)ROOT---R2(32, 40, 52&lt;br/&gt;A - B - C)ROOT---R3(61, 73, 84&lt;br/&gt;A - B - C)R1---R11(0&lt;br/&gt;4&lt;br/&gt;9)R1---R12(12&lt;br/&gt;13&lt;br/&gt;17)R1---R13(23&lt;br/&gt;24&lt;br/&gt;25)R2---R21(32&lt;br/&gt;38&lt;br/&gt;39)R2---R22(40&lt;br/&gt;41&lt;br/&gt;48)R2---R23(52&lt;br/&gt;55&lt;br/&gt;57)R3---R31(61&lt;br/&gt;62&lt;br/&gt;66)R3---R32(73&lt;br/&gt;74&lt;br/&gt;79)R3---R33(84&lt;br/&gt;86&lt;br/&gt;87)subgraph 数据链表R11R12R13R21R22R23R31R32R33end</code></pre><p>B+ 树具有如下特点：</p><ul><li><p>B+ 树的关键字都出现在叶节点的链表中，链表中数据是有序的。</p><p>非叶节点只相当于叶节点的索引（稀疏索引），叶节点相当于是存储数据的数据层（稠密索引）。</p></li><li><p>B+ 树的命中只可能发生在叶节点。</p></li><li><p>B+ 树的搜索性能也等价于在关键字全集内进行二分查找</p></li><li><p>B+ 树更适合文件索引系统</p></li></ul><h4 id="b-树-2">B* 树：</h4><p>B* 树是 B+ 树的变体，其在非根、非叶节点间加入了兄弟指针。</p><pre><code class=" mermaid">graph TDROOT(0, 32, 61&lt;br/&gt;A - B - C)ROOT---R1(0, 12, 23&lt;br/&gt;A - B - C)ROOT---R2(32, 40, 52&lt;br/&gt;A - B - C)ROOT---R3(61, 73, 84&lt;br/&gt;A - B - C)R1---R11(0&lt;br/&gt;4&lt;br/&gt;9)R1---R12(12&lt;br/&gt;13&lt;br/&gt;17)R1---R13(23&lt;br/&gt;24&lt;br/&gt;25)R2---R21(32&lt;br/&gt;38&lt;br/&gt;39)R2---R22(40&lt;br/&gt;41&lt;br/&gt;48)R2---R23(52&lt;br/&gt;55&lt;br/&gt;57)R3---R31(61&lt;br/&gt;62&lt;br/&gt;66)R3---R32(73&lt;br/&gt;74&lt;br/&gt;79)R3---R33(84&lt;br/&gt;86&lt;br/&gt;87)subgraph 数据链表R11R12R13R21R22R23R31R32R33endsubgraph 索引相连R1R2R3end</code></pre><p>B* 树具有以下特点：</p><ul><li>B* 树定义了非叶子节点关键字个数至少为 (2 / 3) *M。其块的最低使用率为 2 / 3，而 B+ 树最低使用率为 1 / 2</li><li>B* 树分配新节点的概率更低，空间使用率更高</li></ul><h3 id="前缀树">14.2.3 前缀树</h3><p>前缀树（字典树、单词查找树、键树），是一种多路查找树。利用元素的公共前缀来减少查询时间。</p><p>下面是一个存储了数个单词（a、act、art、cat、can、cant、roin）的前缀树：</p><pre><code class=" mermaid">graph TBR[ ]style a fill: #C0F0E0R --- a((a))R --- c[c]R --- r[r]a --- ac[c]a --- ar[r]style act fill: #C0F0E0ac --- act((t))style art fill: #C0F0E0ar --- art((t))c --- ca[a]style cat fill: #C0F0E0ca --- cat((t))style can fill: #C0F0E0ca --- can((n))style cant fill: #C0F0E0can --- cant((t))r --- ro[o]ro --- roi[i]style roin fill: #C0F0E0roi --- roin((n))</code></pre><p>前缀树具有如下特点：</p><ul><li><p>根节点不包含字符，除根节点外每一个节点包含一个字符。</p></li><li><p>节点的路径即为一条存储字符串。特别的，根节点表示空字符串</p><p>每个节点持有一个计数器，计算该节点处存储的字符串数量。</p></li><li><p>所有的子节点都与父节点具有相同前缀。</p></li><li><p>在前缀树中，查询字符串的时间复杂度为 O(L)，其中 L为字符串长度</p></li></ul><p><strong>实现前缀树：</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TrimTree</span> &#123;    <span class="hljs-comment">/* 节点类 */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;        Map&lt;Character, Node&gt; next = <span class="hljs-literal">null</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        Node() &#123;            <span class="hljs-built_in">this</span>.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();            <span class="hljs-built_in">this</span>.count = <span class="hljs-number">0</span>;        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-type">Node</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">// 根节点</span>    <span class="hljs-comment">/* 构造器 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TrimTree</span><span class="hljs-params">(String... strings)</span> &#123;        <span class="hljs-built_in">this</span>.root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();        <span class="hljs-keyword">for</span> (String s : strings) add(s);    &#125;    <span class="hljs-comment">/* 添加字符串 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(String s)</span> &#123;        <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> root;        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray()) &#123;            <span class="hljs-keyword">if</span> (!p.next.containsKey(c)) p.next.put(c, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>());            p = p.next.get(c);        &#125;        p.count++;    &#125;    <span class="hljs-comment">/* 查找字符串 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String s)</span> &#123;        <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> root;        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray()) &#123;            <span class="hljs-keyword">if</span> (!p.next.containsKey(c)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;            p = p.next.get(c);        &#125;        <span class="hljs-keyword">return</span> p.count;    &#125;&#125;</code></pre></div><h2 id="图">14.3 图</h2><blockquote><p>线性表局限于一个直接前驱和一个直接后继的关系。</p><p>树可能有数个直接后继，但只能有一个直接前驱（父节点）</p><p>当需要表示多对多关系时，就需要 <strong>图</strong></p></blockquote><p>图是一种数据结构。每个节点可以有零个或多个相邻元素。</p><p>两个节点间的连接称为 <strong>边（edge）</strong>，节点也被称为<strong>顶点（vertex）</strong></p><p>图的分类：</p><ul><li>按照 顶点间的连接有无方向 分为：有向图、无向图</li><li>按照 是否带权 分为：带权图（网）、非带权图</li><li>按照 表示方式分为：二维数组表示（邻接矩阵）、链表表示（邻接表）</li></ul><h4 id="图的表示方式">图的表示方式：</h4><p>一组连接的节点：</p><pre><code class=" mermaid">graph TDA(1)---B(0)A---C(2)B---CB---D(3)B---E(4)</code></pre><p><strong>邻接矩阵：</strong></p><div class="code-wrapper"><pre><code class="hljs -">   0  1  2  3  40 ┌0, 1, 1, 1, 1┐1 |1, 0, 1, 0, 0|2 |1, 1, 0, 0, 0|3 |1, 0, 0, 0, 0|4 └1, 0, 0, 0, 0┘</code></pre></div><p>其中，(0, 1) == 1 表示 节点 0 与 节点 1 相连</p><p>邻接矩阵为每个顶点都分配了 n 个边的空间。这样，造成了空间的损失</p><p><strong>邻接表：</strong></p><div class="code-wrapper"><pre><code class="hljs -">0 [1]→[2]→[3]→[4]→1 [0]→[2]→2 [0]→[1]→3 [0]→4 [0]→</code></pre></div><p>邻接表为每个节点创建一个链表，链表中是与其相连的节点。邻接表由 数组 +链表 组成</p><p>邻接表只关心存在的边，不关心不存在的边，因此没有空间浪费</p><h3 id="深度优先搜索-dfs">14.3.1 深度优先搜索 DFS</h3><p>深度优先搜索（Depth FirstSearch），其策略是优先纵向挖掘深入，而不是对一个节点的所有节点先进行横向访问。</p><p>从初始访问节点出发，首先访问其第一个相邻节点。之后，从那个访问节点出发，递归访问第一个相邻节点。直到一个节点的路径完全访问结束后，才访问第二个节点。</p><h4 id="步骤">步骤：</h4><ul><li>访问初始节点 s，标记其为已访问</li><li>从 s 的第一个相邻节点起，以递归方式对其进行深度优先搜索。</li><li>当前节点没有可访问的相邻节点时，就完成了对一条路径访问。此时才返回上一级，继续搜索下一节点。</li></ul><h3 id="广度优先搜索-bfs">14.3.2 广度优先搜索 BFS</h3><p>广度优先搜索（Broad FirstSearch），其策略是优先横向访问所有相邻节点，而不是对一条路径进行纵向挖掘。</p><p>从初始访问节点出发，记录所有相邻节点。之后，访问先前记录节点，并记录所有相邻节点。直到没有能访问的节点为止，就完成了对所有连接节点的搜索。</p><h4 id="步骤-1">步骤：</h4><ul><li>记录初始节点 s</li><li>访问上一次记录的节点，将其标记为已访问。将那些节点的所有可访问的相邻节点记录。</li><li>重复上一步，直到没有可访问的节点时，就完成了对所有连接节点的访问。</li></ul><h2 id="附录">附录</h2><h3 id="f1-实现赫夫曼编码解码">F1 实现赫夫曼编码/解码</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/* 压缩数据包 */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataBox</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] data;<span class="hljs-comment">// 压缩信息主体</span>    <span class="hljs-keyword">public</span> Map&lt;Byte, String&gt; key;<span class="hljs-comment">// 赫夫曼表</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> step;<span class="hljs-comment">// 补位数</span>&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Huff</span> &#123;    <span class="hljs-comment">/* 将数据压缩，返回一个压缩包 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DataBox <span class="hljs-title function_">huff</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] data)</span> &#123;        <span class="hljs-type">DataBox</span> <span class="hljs-variable">dataBox</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataBox</span>();        dataBox.key = getHuffMap(data);<span class="hljs-comment">// 在压缩包内记录编码表</span>        dataBox.data = toHuff(data, dataBox);<span class="hljs-comment">// 在压缩包内记录压缩后数据，也会记录补位数</span>        <span class="hljs-keyword">return</span> dataBox;    &#125;    <span class="hljs-comment">/* 根据要压缩的数据，计算那个赫夫曼表 */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Byte, String&gt; <span class="hljs-title function_">getHuffMap</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] val)</span> &#123;        <span class="hljs-keyword">if</span> (val == <span class="hljs-literal">null</span> || val.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();        Map&lt;Byte, Node&gt; huff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-type">byte</span> c : val) &#123;<span class="hljs-comment">// 记录每个字符出现的次数</span>            <span class="hljs-keyword">if</span> (huff.containsKey(c)) huff.get(c).times++;            <span class="hljs-keyword">else</span> huff.put(c, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(c, <span class="hljs-number">1</span>));        &#125;        PriorityQueue&lt;Node&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(huff.values());        <span class="hljs-keyword">while</span> (pq.size() &gt; <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">// 生成赫夫曼树</span>            <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(pq.remove(), pq.remove());            pq.add(temp);        &#125;        Map&lt;Byte, String&gt; ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();        update(ret, pq.remove(), <span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">// 根据那个赫夫曼树，生成赫夫曼编码</span>        <span class="hljs-keyword">if</span> (ret.size() == <span class="hljs-number">1</span>) ret.put(val[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;0&quot;</span>);<span class="hljs-comment">// 特别地，只有唯一字符从场合这样处理</span>        <span class="hljs-keyword">return</span> ret;    &#125;    <span class="hljs-comment">/* 根据赫夫曼表，将数据压缩 */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] toHuff(<span class="hljs-type">byte</span>[] val, DataBox d) &#123;        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();        <span class="hljs-keyword">for</span> (<span class="hljs-type">byte</span> c : val) &#123;<span class="hljs-comment">// 得到压缩后的 bit 字符串</span>            sb.append(d.key.get(c));        &#125;        <span class="hljs-type">byte</span>[] ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[(sb.length() + <span class="hljs-number">7</span>) / <span class="hljs-number">8</span>];<span class="hljs-comment">// 压缩后的数据放在 byte 数组中</span>        d.step = sb.length() % <span class="hljs-number">8</span>;<span class="hljs-comment">// 记录那个补位数</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ret.length; i ++) &#123;            <span class="hljs-keyword">if</span> (i &gt;= ret.length - <span class="hljs-number">1</span> &amp;&amp; d.step != <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// 最后一位可能有补位。那个场合，让有效数字在最左侧</span>                ret[i] = (<span class="hljs-type">byte</span>) (Integer.parseInt(sb.substring(<span class="hljs-number">8</span> * i), <span class="hljs-number">2</span>) &lt;&lt; (<span class="hljs-number">8</span> - d.step));            &#125; <span class="hljs-keyword">else</span> ret[i] = (<span class="hljs-type">byte</span>) Integer.parseInt(sb.substring(<span class="hljs-number">8</span> * i, <span class="hljs-number">8</span> * i + <span class="hljs-number">8</span>), <span class="hljs-number">2</span>);        &#125;        <span class="hljs-keyword">return</span> ret;    &#125;    <span class="hljs-comment">/* 该方法能遍历赫夫曼树，以获取赫夫曼表 */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Map&lt;Byte, String&gt; ss, Node root, String s)</span> &#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.right == <span class="hljs-literal">null</span> &amp;&amp; root.left == <span class="hljs-literal">null</span>) &#123;            ss.put(root.val, s);<span class="hljs-comment">// 是叶节点的场合，记录这个编码值</span>        &#125;        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) update(ss, root.left, s + <span class="hljs-string">&quot;0&quot;</span>);<span class="hljs-comment">// 向左路径记为 0</span>        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>) update(ss, root.right, s + <span class="hljs-string">&quot;1&quot;</span>);<span class="hljs-comment">// 向右路径记为 1</span>    &#125;        <span class="hljs-comment">/* 解压压缩包 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] antiHuff(DataBox d) &#123;        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; d.data.length; i++) &#123;<span class="hljs-comment">// 获取那个压缩数据的编码</span>            <span class="hljs-type">String</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;            <span class="hljs-keyword">if</span> (i &gt;= d.data.length - <span class="hljs-number">1</span> &amp;&amp; d.step != <span class="hljs-number">0</span>) sb.append((temp = Integer.toBinaryString(d.data[i] | <span class="hljs-number">256</span>)), temp.length() - <span class="hljs-number">8</span>, temp.length() - <span class="hljs-number">8</span> + d.step);<span class="hljs-comment">// 遍历到最后，要处理那个补位</span>            <span class="hljs-keyword">else</span> sb.append((temp = Integer.toBinaryString(d.data[i] | <span class="hljs-number">256</span>)).substring(temp.length() - <span class="hljs-number">8</span>));        &#125;        Map&lt;String, Byte&gt; anti = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();        <span class="hljs-keyword">for</span> (Byte aByte : d.key.keySet()) &#123;<span class="hljs-comment">// 将编码表转化为解码表</span>            anti.put(d.key.get(aByte), aByte);        &#125;        List&lt;Byte&gt; ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; sb.length(); i++) &#123;<span class="hljs-comment">// 按照解码表，把压缩编码转化为未解压编码</span>            s.append(sb.charAt(i));            <span class="hljs-keyword">if</span> (anti.containsKey(s.toString())) &#123;                ret.add(anti.get(s.toString()));                s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();            &#125;        &#125;        <span class="hljs-type">byte</span>[] bt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[ret.size()];<span class="hljs-comment">// 将 Byte 数组转化为 byte 数组</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; bt.length; i++) &#123;            bt[i] = ret.get(i);        &#125;        <span class="hljs-keyword">return</span> bt;    &#125;<span class="hljs-comment">/* 节点类，是构建赫夫曼树时用到的类 */</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Node&gt; &#123;        <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span> val;<span class="hljs-comment">// 代表的 byte 值</span>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> times;<span class="hljs-comment">// 出现的次数</span>        <span class="hljs-keyword">public</span> Node left;        <span class="hljs-keyword">public</span> Node right;        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(Node l, Node r)</span> &#123;            <span class="hljs-built_in">this</span>.left = l;            <span class="hljs-built_in">this</span>.right = r;            <span class="hljs-built_in">this</span>.times = l.times + r.times;        &#125;        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">byte</span> val, <span class="hljs-type">int</span> pow)</span> &#123;            <span class="hljs-built_in">this</span>.val = val;            <span class="hljs-built_in">this</span>.times = pow;        &#125;        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">byte</span> val)</span> &#123;            <span class="hljs-built_in">this</span>.val = val;            <span class="hljs-built_in">this</span>.times = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Node o)</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.times - o.times;        &#125;    &#125;&#125;</code></pre></div><h3 id="f2-实现平衡二叉树">F2 实现平衡二叉树</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AVL</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-type">Node</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">// 根节点</span>        <span class="hljs-comment">/* 添加一个值（添加一个节点）</span><span class="hljs-comment">    val：要添加的值 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;        <span class="hljs-type">Node</span> <span class="hljs-variable">toAdd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(val);        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) root = toAdd;        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-type">Node</span> <span class="hljs-variable">par</span> <span class="hljs-operator">=</span> root;            <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> root;            <span class="hljs-keyword">while</span> (temp != <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">// 确定其插入位置</span>                par = temp;                <span class="hljs-keyword">if</span> (val &gt; temp.val) &#123;                    temp = temp.right;                    toAdd.way = <span class="hljs-literal">true</span>;                &#125; <span class="hljs-keyword">else</span> &#123;                    temp = temp.left;                    toAdd.way = <span class="hljs-literal">false</span>;                &#125;            &#125;            <span class="hljs-keyword">if</span> (toAdd.way) &#123;<span class="hljs-comment">// 将其插入到指定位置</span>                par.right = toAdd;                par.right.parent = par;            &#125; <span class="hljs-keyword">else</span> &#123;                par.left = toAdd;                par.left.parent = par;            &#125;            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<span class="hljs-comment">// 维护该平衡二叉树</span>                par = toAVL(par);                <span class="hljs-keyword">if</span> (par.parent == <span class="hljs-literal">null</span>) &#123;                    root = par;                    <span class="hljs-keyword">break</span>;                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">if</span> (par.way) par.parent.right = par;                    <span class="hljs-keyword">else</span> par.parent.left = par;                    par = par.parent;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-comment">/* 维护平衡二叉树</span><span class="hljs-comment">    root: 待检查节点 */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">toAVL</span><span class="hljs-params">(Node root)</span> &#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">gap</span> <span class="hljs-operator">=</span> root.rightHeight() - root.leftHeight();        <span class="hljs-keyword">if</span> (Math.abs(gap) &gt; <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">// |gap| &gt; 1 时，需要旋转</span>            <span class="hljs-keyword">if</span> (gap &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// gap &gt; 0 需要左旋，否则右旋</span>                <span class="hljs-keyword">if</span> (root.right.leftHeight() &gt; root.right.rightHeight()) root.right = roll(root.right, <span class="hljs-literal">true</span>);                <span class="hljs-keyword">return</span> roll(root, <span class="hljs-literal">false</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">if</span> (root.left.rightHeight() &gt; root.left.leftHeight()) root.left = roll(root.left, <span class="hljs-literal">false</span>);                <span class="hljs-keyword">return</span> roll(root, <span class="hljs-literal">true</span>);            &#125;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> root;    &#125;    <span class="hljs-comment">/* 对该节点进行旋转。</span><span class="hljs-comment">    root：待旋转节点</span><span class="hljs-comment">    dirR：true 的场合右旋，否则左旋 */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">roll</span><span class="hljs-params">(Node root, <span class="hljs-type">boolean</span> dirR)</span> &#123;        <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">if</span> (dirR) &#123;            temp = root.left;            root.left = temp.right;            <span class="hljs-keyword">if</span> (temp.right != <span class="hljs-literal">null</span>) &#123;                temp.right.way = <span class="hljs-literal">false</span>;                temp.right.parent = root;            &#125;            temp.right = root;        &#125; <span class="hljs-keyword">else</span> &#123;            temp = root.right;            root.right = temp.left;            <span class="hljs-keyword">if</span> (temp.left != <span class="hljs-literal">null</span>) &#123;                temp.left.way = <span class="hljs-literal">true</span>;                temp.left.parent = root;            &#125;            temp.left = root;        &#125;        temp.way = root.way;        temp.parent = root.parent;        root.way = dirR;        root.parent = temp;        <span class="hljs-keyword">return</span> temp;    &#125;        <span class="hljs-comment">/* 一个展示树的方法。供 debug 用 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(Node root)</span> &#123;        LinkedList&lt;Node&gt; a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();        LinkedList&lt;Node&gt; b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();        a.add(root);        <span class="hljs-keyword">while</span> (!a.isEmpty()) &#123;            <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> a.removeFirst();            System.out.print(temp.val + <span class="hljs-string">&quot; &quot;</span>);            <span class="hljs-keyword">if</span> (temp.left != <span class="hljs-literal">null</span>) b.add(temp.left);            <span class="hljs-keyword">if</span> (temp.right != <span class="hljs-literal">null</span>) b.add(temp.right);            <span class="hljs-keyword">if</span> (a.isEmpty()) &#123;                System.out.println();                a = b;                b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();            &#125;        &#125;        System.out.println(<span class="hljs-string">&quot;共 &quot;</span> + count(root) + <span class="hljs-string">&quot; 个节点&quot;</span>);    &#125;        <span class="hljs-comment">/* 一个清点树中节点的方法 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">count</span><span class="hljs-params">(Node root)</span> &#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + count(root.left) + count(root.right);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> val;<span class="hljs-comment">// 值</span>        <span class="hljs-keyword">public</span> Node left;<span class="hljs-comment">// 左节点</span>        <span class="hljs-keyword">public</span> Node right;<span class="hljs-comment">// 右节点</span>        <span class="hljs-keyword">public</span> Node parent;<span class="hljs-comment">// 父节点</span>        <span class="hljs-type">boolean</span> <span class="hljs-variable">way</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;        <span class="hljs-comment">// false：该节点是左节点；true：是右节点</span>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;            <span class="hljs-built_in">this</span>.val = val;        &#125;        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">leftHeight</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">// 左子树高度</span>            <span class="hljs-keyword">return</span> (left == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : left.height());        &#125;        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rightHeight</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">// 右子树高度</span>            <span class="hljs-keyword">return</span> (right == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : right.height());        &#125;        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">height</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">// 该节点树高度</span>            <span class="hljs-keyword">return</span> Math.max(leftHeight(), rightHeight()) + <span class="hljs-number">1</span>;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt;13 Java 数据结构</title>
    <link href="/2022/05/29/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/13%20Java%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2022/05/29/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/13%20Java%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="java-数据结构">13 Java 数据结构</h1><blockquote><p>数据结构分为两种：线性结构、非线性结构</p></blockquote><p><strong>线性结构：</strong></p><ul><li><p>最常用的数据结构。数据元素间存在一对一线性关系。</p></li><li><p>线性结构有 2 种不同的存储结构：顺序储存结构，链式储存结构</p><p>顺序存储结构中元素存储在连续的内存空间中。</p><p>链式储存结构中元素储存在非连续的空间中，元素节点中存放数据元素及相邻元素的地址信息</p></li><li><p>常见的线性结构有：数组、队列、链表、栈等</p></li></ul><p><strong>非线性结构：</strong></p><ul><li>非线性结构包括：二维数组、多维数组、广义表、树结构、图结构</li></ul><h2 id="集合的框架体系">13.1 集合的框架体系</h2><blockquote><p>Java提供了一系列集合容器，以方便程序员动态保存元素。并提供了一系列方便的操作对象的方法。</p><p>Java 集合主要分为两组：单列集合（Collection）、双列集合（Map）</p></blockquote><p><img src="/img/Java_InputImage/集合体系图_13.1.png" /></p><p><em>（集合体系图_13.1）</em></p><ul><li><p><strong>Collection接口</strong>（单列集合）：可以存放多个元素。每个元素可以是 Object</p><p>Collection 接口有两个重要子接口：List（有序集合）和Set（无序集合）</p></li><li><p><strong>Map接口</strong>（双列集合）：用于保存具有映射关系的数据：key -value（双列元素）</p><p>key 和 value 可以是任何类型的引用数据类型。其中 key 不能重复，value可以重复</p><p>key 和 value 存在单一对应关系。通过特定的 key 一定能找到指定的value</p></li></ul><h2 id="单列集合接口-collection">13.2 单列集合接口 Collection</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Collection</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Lterable</span>&lt;E&gt;</code></pre></div><blockquote><p>Collection 实现子类可以存放多个元素。每个元素可以是 Object</p><p>有些 Collection 实现子类能存放重复的元素，有些不能</p><p>有些 Collection 实现子类是有序的（List） ，有些不是（Set）</p><p>Collection 接口没有直接的实现子类，都是通过其子接口实现的</p></blockquote><h3 id="常用方法">常用方法：</h3><ul><li><p><code>add</code>：添加单个元素</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">ArrayList</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();list.add(<span class="hljs-string">&quot;哈哈啊&quot;</span>);list.add(<span class="hljs-number">10</span>);<span class="hljs-comment">// 相当于List.add(new Integer(10));</span>list.add(<span class="hljs-literal">true</span>);<span class="hljs-comment">// 同上</span></code></pre></div></li><li><p><code>remove</code>：删除单个元素</p><div class="code-wrapper"><pre><code class="hljs java">list.remove(<span class="hljs-number">0</span>)<span class="hljs-comment">// 删除编号 0 的元素。上例中会删除 &quot;哈哈啊&quot;</span>list.remove((Integer)<span class="hljs-number">10</span>);<span class="hljs-comment">// 删除上例的 10 要这样写</span></code></pre></div></li><li><p><code>contains</code>：检查元素是否存在</p></li><li><p><code>size</code>：获取元素个数</p></li><li><p><code>isEmpty</code>：判断是否为空</p></li><li><p><code>clear</code>：清空</p></li><li><p><code>addAll</code>：添加多个元素</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">ArrayList</span> <span class="hljs-variable">list2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();list2.add(<span class="hljs-number">111</span>);list2.add(<span class="hljs-string">&quot;idea&quot;</span>);list.addAll(list2);<span class="hljs-comment">// 这里可以输入所有实现了 Collection 接口的集合</span></code></pre></div></li><li><p><code>containsAll</code>：检查多个元素是否存在</p><div class="code-wrapper"><pre><code class="hljs java">list.contaionsAll(list2);<span class="hljs-comment">// 同上，放一个实现了 Collection 接口的集合</span></code></pre></div></li><li><p><code>removeAll</code>：删除多个元素</p><div class="code-wrapper"><pre><code class="hljs java">list.removeAll(list2);<span class="hljs-comment">// 同上</span></code></pre></div></li><li><p><code>Iterator iterator()</code>：返回指向集合开始位置的迭代器</p></li></ul><h3 id="迭代器-iterator">13.2.1 迭代器 Iterator</h3><blockquote><p>Iterator 对象称为迭代器，主要用于遍历 Collection 集合中的元素。</p><p>Collection 继承的 Iterable 接口中，提供了 <code>iterator()</code>方法，会返回一个新的迭代器。</p><p>Iterator 对象仅用于遍历集合，本身不存放元素</p><p>IDEA 中，迭代器 while 循环的模板快捷键：<code>itit</code></p></blockquote><p><strong>常用方法：</strong></p><ul><li><code>boolean hasNext()</code>：该方法判断是否有下一个元素。</li><li><code>T next()</code>：该方法会将指针下移，然后返回下移后的位置上的元素</li></ul><p><strong>用迭代器遍历元素：</strong></p><div class="code-wrapper"><pre><code class="hljs java">Collection&lt;Object&gt; c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();Iterator&lt;Object&gt; iterator = c.iterator();<span class="hljs-comment">// [1]</span><span class="hljs-keyword">while</span> (iterator.hasNext())&#123;<span class="hljs-comment">// [2]</span><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> iterator.next();<span class="hljs-comment">// [3]</span>System.out.println(obj);&#125;</code></pre></div><ol type="1"><li><p>获取迭代器</p></li><li><p>判断有无下一元素</p></li><li><p>将迭代器后移，并返回那个后移位置上的元素</p><p>while 循环结束后，指针指向最后元素的位置。再次 <code>next()</code>会报错。如果需要再使用，需要重置迭代器。</p><div class="code-wrapper"><pre><code class="hljs java">iterator = list.iterator();<span class="hljs-comment">// 重置了迭代器</span></code></pre></div></li></ol><p><strong>for each（增强 for 循环）：</strong></p><blockquote><p>for each 的语法与 for 循环相似，但是可以遍历 Collection 和 数组中的元素</p><p>IDEA 中，增强 for 循环的模板快捷键：<code>I</code></p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (Object o : list)&#123;...&#125;</code></pre></div><ul><li>for each 可在 Collection 集合中使用。</li><li>for each 的底层在本质上也是<code>Iterator</code>。可以理解为简化版本的迭代器遍历。</li></ul><h2 id="有序集合接口-list">13.3 有序集合接口 List</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">List</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Collection</span>&lt;E&gt;</code></pre></div><blockquote><p>List 是 Collection 接口的子类接口</p><p>List 是有序（添加顺序和取出顺序一致）的，可重复的</p><p>List 中的每个元素都有其对应的顺序索引（从 0 开始编号）</p></blockquote><h3 id="常用方法-1">常用方法：</h3><ul><li><p><code>add(int, obj)</code>：在 int 位置插入 obj 元素。返回true</p><p><code>add(obj)</code>：在末尾插入 obj。返回 true</p><div class="code-wrapper"><pre><code class="hljs java">list.add(<span class="hljs-number">111</span>);list.add(<span class="hljs-number">0</span>, <span class="hljs-number">110</span>);<span class="hljs-comment">// 在第 1 个位置插入数字 110</span></code></pre></div><p><code>addElement(obj)</code>：在末尾插入obj。无返回值。你说要这方法有啥用？名字还长一截</p></li><li><p><code>addAll(int, collection)</code>：在 int 位置插入 collection中的所有元素</p></li><li><p><code>get(int)</code>：返回 int 位置的元素</p></li><li><p><code>indexOf(obj)</code>：返回 obj 首次出现时的位置</p></li><li><p><code>lastIndexOf(obj)</code>：返回 obj最后一次出现时的位置</p></li><li><p><code>remove(int)</code>：移除 int位置的元素，并返回那个被移除的元素</p></li><li><p><code>set(int, obj)</code>：设置 int 位置的元素为obj。相当于替换。返回那个被替换元素的下标</p><p><code>setElement(obj, int)</code>：设置 int 位置的元素为obj。无返回值</p></li><li><p><code>subList(int1, int2)</code>：返回 [int1, int2)范围的元素构成的子集合</p></li></ul><h3 id="可变数组-arraylist">13.3.1 可变数组 ArrayList</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractList</span>&lt;E&gt;     <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</code></pre></div><blockquote><p>ArrayList 是 List 的实现子类。其底层由数组来实现存储。</p><p>ArrayList 可以存放 null</p></blockquote><h4 id="arraylist-的源码">ArrayList 的源码：</h4><ol type="1"><li><p>ArrayList 中维护了一个 Object 类型的数组elementData。该数组就是用来存放元素的数组</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> Object[] elementData;</code></pre></div></li><li><p>创建 ArrayList 对象时，如果使用无参构造器，则 elementData[]初始容量为 0</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> &#123;    <span class="hljs-built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;</code></pre></div></li><li><p>如果使用指定大小构造器，则初始容量为指定大小。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;    <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">/* 这个场合，与默认构造器的不同之处在于</span><span class="hljs-comment">扩容时，该 0 容量变为 1，而默认构造器会变为 10 */</span>        <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(...);    &#125;&#125;</code></pre></div></li><li><p>扩容的场合：</p><p>如果是 <strong>无参构造器生成的初始 0 长度的elementData</strong>，则将其容量置为 10。</p><p>否则容量扩容为 1.5 倍。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/* 扩容方法，传入的参数 minCapacity 是容器现有元素数量 + 1 的值</span><span class="hljs-comment">如果是无参构造器生成的默认数组，此时传入固定值 10 */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;    <span class="hljs-comment">/* 计算新的容量（旧容量的 1.5 倍）</span><span class="hljs-comment">    此处 &gt;&gt; 为位运算符，等同于 newC = oldC + oldC / 2; */</span>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);    <span class="hljs-comment">/* 这里如果原容量是特殊值（1 或 0），容量会变为那个 minCapacity 的值 */</span>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)        newCapacity = minCapacity;    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)        newCapacity = hugeCapacity(minCapacity);    elementData = Arrays.copyOf(elementData, newCapacity);&#125;</code></pre></div></li></ol><h3 id="可变数组-vector">13.3.2 可变数组 Vector</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span>&lt;E&gt;    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractList</span>&lt;E&gt;    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</code></pre></div><blockquote><p>Vector 是 List 的实现子类。其底层由数组来实现存储</p><p>Vector 与 ArrayList 基本等同。ArrayList 效率更高，Vector线程安全。</p><p>在开发中，需要考虑线程安全时，建议使用 Vector ，而非 ArrayList。</p></blockquote><h4 id="vector-的源码">Vector 的源码：</h4><ol type="1"><li><p>底层维护了一个 Object 类型的数组 elementData。用以存放元素</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object[] elementData;</code></pre></div></li><li><p>使用无参构造器创建对象时，默认大小是 10</p><p>使用有参构造器的场合，默认是那个指定大小（initialCapaticy）</p><p>也能在构造器中指定那个扩容的增长速度（capacityIncrement）</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Vector</span><span class="hljs-params">()</span> &#123;    <span class="hljs-built_in">this</span>(<span class="hljs-number">10</span>);&#125;<span class="hljs-keyword">public</span> <span class="hljs-title function_">Vector</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;    <span class="hljs-built_in">this</span>(initialCapacity, <span class="hljs-number">0</span>);&#125;<span class="hljs-keyword">public</span> <span class="hljs-title function_">Vector</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">int</span> capacityIncrement)</span> &#123;    <span class="hljs-built_in">super</span>();    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(...);    <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];    <span class="hljs-built_in">this</span>.capacityIncrement = capacityIncrement;&#125;</code></pre></div></li><li><p>扩容的场合，容量变成 2 倍</p><p>使用有参构造器改变了 capacityIncrement 的场合，增量是那个指定数值</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;    <span class="hljs-comment">/* 计算新的容量（按照指定的增速扩容）</span><span class="hljs-comment">    那个指定无效或未指定时，容量变为 2 倍 */</span>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + ((capacityIncrement &gt; <span class="hljs-number">0</span>) ?                                     capacityIncrement : oldCapacity);    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)        newCapacity = minCapacity;    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)        newCapacity = hugeCapacity(minCapacity);    elementData = Arrays.copyOf(elementData, newCapacity);&#125;</code></pre></div></li></ol><h3 id="链表-linkedlist">13.3.3 链表 LinkedList</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span>&lt;E&gt;    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSequentialList</span>&lt;E&gt;    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</code></pre></div><blockquote><p>LinkedList 是 List 的实现子类，底层以链表形式存储元素。</p><p>链表是一种<strong>非线性结构</strong>：其以节点方式存储，节点间在内存上的位置不连续。</p><p>链表是有序的列表。单向链表每个节点包含 data 域和 next 域。那些 next域指向下一节点的位置。</p><p>双向链表在单向链表的基础上，每个节点加入 prev区域以指示其前方节点。这样，就能实现双向查找。双向链表可以不依靠辅助节点而实现自我删除。</p><p>LinkedList 底层实现了 双向链表 和 双端队列 特点。</p><p>LinkedList 可以添加null，可添加重复元素。但没有实现同步，因此线程不安全。</p></blockquote><p><img src="/img/Java_InputImage/链表图_13.3.3.png" /></p><h4 id="常用方法-2">常用方法：</h4><ul><li><p><code>void addLast(E e)</code>：尾插一个新的元素</p><p>LinkedList 的 add 方法即调用该方法</p></li><li><p><code>void addFirst(E e)</code>：头插一个新的元素</p></li><li><p><code>E removeLast()</code>：移除并返回尾部元素。为空时报错</p><p><code>E poll()</code>：移除并返回尾部元素。为空时返回 null</p><p><code>E removeFirst()</code>：移除并返回头部元素。为空时报错</p></li><li><p><code>E getLast()</code>：仅返回尾部元素。为空时报错</p><p><code>E peek()</code>：返回尾部元素。为空时返回 null</p><p><code>E element()</code>：返回头部元素。为空时返回 null</p><p><code>E getFirst()</code></p></li></ul><h4 id="linkedlist-的源码">LinkedList 的源码</h4><ol type="1"><li><p>LinkedList 只有默认构造器和一个拷贝构造器</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedList</span><span class="hljs-params">()</span> &#123;&#125;<span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;    <span class="hljs-built_in">this</span>();    addAll(c);&#125;</code></pre></div></li><li><p>LinkedList 底层维护了一个 双向链表</p><p>两个属性 first、last 分别指向 首节点 和 尾节点</p><p>每个节点（Node 对象），里面又维护了 prev、next、item 属性。</p><p>其中通过 prev 指向前一个节点，通过 next指向后一个节点。最终实现双向链表。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> Node&lt;E&gt; first;<span class="hljs-keyword">transient</span> Node&lt;E&gt; last;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;    E item;    Node&lt;E&gt; next;    Node&lt;E&gt; prev;    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;        <span class="hljs-built_in">this</span>.item = element;        <span class="hljs-built_in">this</span>.next = next;        <span class="hljs-built_in">this</span>.prev = prev;    &#125;&#125;</code></pre></div></li><li><p>LinkedList 不需要扩容。其增删元素时只要改变节点的指向即可。</p><p>也因此，其添加、删除元素效率比数组更高</p></li></ol><h4 id="arraylist-和-linkedlist-的比较">ArrayList 和 LinkedList的比较：</h4><table><thead><tr class="header"><th></th><th>底层结构</th><th>增删效率</th><th>改查效率</th></tr></thead><tbody><tr class="odd"><td>ArrayList</td><td>可变数组</td><td>低（数组扩容）</td><td>高</td></tr><tr class="even"><td><code>LinkedList</code></td><td>双向链表</td><td>高（链表追加）</td><td>低</td></tr></tbody></table><p>应该根据实际情况来选择使用的集合：</p><ul><li><p>如果改查操作多，选择 ArrayList。一般来说，在程序中，80% - 90%都是查询。大部分情况下，选择 ArrayList。</p></li><li><p>如果增删操作多，选择 LinkedList</p></li></ul><h3 id="稀疏数组">13.3.4 稀疏数组</h3><blockquote><p>二维数组的很多值是默认值0，因此记录了很多没有意义的数据。因此，可以使用稀疏数组。</p></blockquote><p>稀疏数组的处理方法：</p><ol type="1"><li>记录数组共有几行几列，有多少个不同的值</li><li>把具有不同值的元素的行列及值记录在一个小规模数组中，从而缩小程序规模</li></ol><p><strong>二维数组转换为稀疏数组：</strong></p><p>下面用 ArrayList 模拟一个稀疏数组。</p><p>二维数组：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] map = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ,<span class="hljs-number">0</span> , <span class="hljs-number">0</span>&#125;,              &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;,              &#123;<span class="hljs-number">15</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;,              &#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;,              &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;,              &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,              &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;&#125;;</code></pre></div><p>遍历原始的二维数组，得到有效数据的个数sum，并将二维数组的有效数据存入稀疏数组</p><div class="code-wrapper"><pre><code class="hljs java">List&lt;<span class="hljs-type">int</span>[]&gt; sparseArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();sparseArray.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;map.length, map[<span class="hljs-number">0</span>].length, <span class="hljs-number">0</span>&#125;);<span class="hljs-comment">//</span><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; y &lt; map.length; y++) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; x &lt; map[<span class="hljs-number">0</span>].length; x++) &#123;        <span class="hljs-keyword">if</span> (map[y][x] != <span class="hljs-number">0</span>) &#123;            sparseArray.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;y, x, map[y][x]&#125;);            sparseArray.get(<span class="hljs-number">0</span>)[<span class="hljs-number">2</span>]++;        &#125;    &#125;&#125;</code></pre></div><p><strong>稀疏数组转化为二维数组：</strong></p><p>读取稀疏数组的每一行，按照其第一行数据，创建原始的二维数组。</p><p>读取后几行数据，将值赋给二维数组</p><h3 id="栈-stack">13.3.5 栈 Stack</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Vector</span>&lt;E&gt;</code></pre></div><blockquote><p>Stack 是 Vector 的子类。以数组模拟了栈的数据结构。</p><p>栈是一个先入后出的有序列表。其元素之插入删除只能在该线性表的同一端进行。</p><p>其允许增删的一端称为栈顶，另一端即为栈底。</p><p>最先放入的元素位于栈底，最后放入的元素位于栈顶。</p><p>放入元素称为入栈（push），取出元素称为出栈（pop）</p></blockquote><p><img src="/img/Java_InputImage/栈图_13.3.5.png" /></p><p><strong>栈的应用场景：</strong></p><ul><li>子程序的调用</li><li>处理递归调用</li><li>表达式的转换与求值</li><li>二叉树的遍历</li><li>图形的深度优先搜索法</li></ul><h4 id="常用方法-3">常用方法：</h4><ul><li><p><code>E push(E item)</code>：将元素 item 压入栈。返回值是 item自己</p></li><li><p><code>E pop()</code>：让栈顶元素出栈</p></li><li><p><code>E peek()</code>：仅获取栈顶元素</p></li><li><p><code>int search(Object o)</code>：查找该元素最后出现的位置。</p><p>栈底为 1，栈顶为 size()，不存在返回 -1</p></li></ul><h4 id="栈模拟计算器">13.3.5.1 栈模拟计算器</h4><blockquote><p>使用栈结构完成对计算器的实现</p></blockquote><p>要进行计算，需要获得表达式。</p><p>表达式分为三种：</p><ul><li><p><strong>中缀表达式：</strong></p><p>中缀表达式即生活中常见的运算表达式。比如：(3 + 4) * 5 - 6</p><p>中缀表达式是人最熟悉的。但是对于计算机来说却不好操作。因此，计算时常将其转化为其他表达式进行操作。</p></li><li><p><strong>前缀表达式：</strong></p><p>前缀表达式（波兰表达式）是一种没有括号的表达式。其将运算符写在前面，操作数写在后面</p><blockquote><p>(3 + 4) * 5 - 6 的前缀表达式为： + 3 * 4 - 5 6</p><p>(1 + 2) * (3 + 4) 的前缀表达式为：* + 1 2 + 3 4</p></blockquote><p>前缀表达式的计算机求值：</p><ul><li>从<b style="color:#FF3080">右</b>向<b style="color:#00C0AF">左</b>扫描表达式</li><li>将数字压入堆栈</li><li>遇到运算符的场合，对数字栈顶元素与次顶元素进行计算，并把那个结果入栈</li><li>重复该操作，最终数字栈的唯一剩余数字即为运算结果</li></ul></li><li><p><strong>后缀表达式：</strong></p><p>后缀表达式（逆波兰表达式）与前缀表达式相似。但其运算符位于操作数之后</p><blockquote><p>(3 + 4) * 5 - 6 的后缀表达式为： 3 4 + 5 * 6 -</p><p>(1 + 2) * (3 + 4) 的后缀表达式为：1 2 + 3 4 + *</p></blockquote><p>后缀表达式的计算机求值：</p><ul><li>从<b style="color:#00C0AF">左</b>向<b style="color:#FF3080">右</b>扫描表达式</li><li>将数字压入堆栈</li><li>遇到运算符的场合，对数字栈顶元素与次顶元素进行计算，并把那个结果入栈</li><li>重复该操作，最终数字栈的唯一剩余数字即为运算结果</li></ul></li></ul><p>对于人类来说，中缀表达式最为熟悉。但对于计算机来说，前缀、后缀表达式更容易识别。</p><p>我们可以将中缀表达式转化为后缀表达式，再进行运算。</p><p><strong>中缀表达式转换为后缀表达式：</strong></p><ol type="1"><li><p>初始化两个栈：运算符栈 operator_stack、表达式栈formula_stack</p></li><li><p>从左到右扫描中缀表达式</p></li><li><p>遇到操作数时，将其压入表达式栈 formula_stack</p></li><li><p>遇到运算符时，比较其与 operator_stack 栈顶运算符的优先级。</p><ul><li>operator_stack 为空，或栈顶为 <code>(</code>的场合，让运算符入栈</li><li>优先级高于栈顶运算符的场合，让其入栈</li><li>优先级低于或等于栈顶运算符的场合，将那个堆顶运算符弹出并压入formula_stack。之后，重复该步骤。</li></ul></li><li><p>遇到括号时：</p><ul><li>遇到 <code>(</code> 时，压入 operator_stack</li><li>遇到 <code>)</code> 时，直到遇到 <code>(</code> 前，依次弹出operator_stack 堆顶的运算符，并压入formula_stack。之后将这一对括号丢弃。</li></ul></li><li><p>到达表达式最右边时，依次弹出 operator_stack 堆顶的运算符，压入formula_stack。</p></li><li><p>此时，formula_stack 即为后缀表达式。</p><p>使用 Java 的 toArray方法将其转为数组。或将其依次弹出，并逆序输出。</p></li></ol><p><strong>计算器的实现：</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;Character, Integer&gt; priority = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();    <span class="hljs-keyword">static</span> &#123;        priority.put(<span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-number">1</span>);        priority.put(<span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-number">1</span>);        priority.put(<span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-number">2</span>);        priority.put(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">2</span>);        priority.put(<span class="hljs-string">&#x27;×&#x27;</span>, <span class="hljs-number">2</span>);        priority.put(<span class="hljs-string">&#x27;÷&#x27;</span>, <span class="hljs-number">2</span>);        priority.put(<span class="hljs-string">&#x27;(&#x27;</span>, -<span class="hljs-number">100</span>);        priority.put(<span class="hljs-string">&#x27;)&#x27;</span>, -<span class="hljs-number">10</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calculate</span><span class="hljs-params">(String formula)</span> &#123;        String[] ss = formula.split(<span class="hljs-string">&quot; &quot;</span>);        Stack&lt;String&gt; operator_stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();        Stack&lt;String&gt; formula_stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();        <span class="hljs-keyword">for</span> (String s : ss) &#123;            <span class="hljs-keyword">if</span> (s.matches(<span class="hljs-string">&quot;\\d+([.]\\d+)?&quot;</span>)) &#123;                formula_stack.push(s);                <span class="hljs-keyword">continue</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (operator_stack.empty() || s.equals(<span class="hljs-string">&quot;(&quot;</span>)) &#123;                operator_stack.push(s);                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-type">String</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> operator_stack.peek();            <span class="hljs-keyword">while</span> (priority.get(s.charAt(<span class="hljs-number">0</span>)) &lt;= priority.get(temp.charAt(<span class="hljs-number">0</span>))) &#123;                formula_stack.push(operator_stack.pop());                <span class="hljs-keyword">if</span> (operator_stack.empty()) <span class="hljs-keyword">break</span>;                temp = operator_stack.peek();            &#125;            <span class="hljs-keyword">if</span> (s.equals(<span class="hljs-string">&quot;)&quot;</span>)) &#123;                operator_stack.pop();            &#125; <span class="hljs-keyword">else</span> operator_stack.push(s);        &#125;        <span class="hljs-keyword">while</span> (!operator_stack.empty()) &#123;            formula_stack.push(operator_stack.pop());        &#125;        <span class="hljs-keyword">return</span> anti_Poland(String.join(<span class="hljs-string">&quot; &quot;</span>, formula_stack.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;&#125;)));    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">anti_Poland</span><span class="hljs-params">(String formula)</span> &#123;        String[] ss = formula.split(<span class="hljs-string">&quot; &quot;</span>);        Stack&lt;Double&gt; ns = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();        <span class="hljs-keyword">for</span> (String s : ss) &#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-type">double</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> Double.parseDouble(s);                ns.push(num);            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                <span class="hljs-keyword">switch</span> (s) &#123;                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:                        ns.push(ns.pop() + ns.pop());                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;×&quot;</span>:                        ns.push(ns.pop() * ns.pop());                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;÷&quot;</span>:                        ns.push(<span class="hljs-number">1</span> / ns.pop() * ns.pop());                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:                        ns.push(-ns.pop() + ns.pop());                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">default</span>:                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Illegal operator&quot;</span>);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> ns.pop();    &#125;&#125;</code></pre></div><h3 id="跳表-skiplist">13.3.6 跳表 SkipList</h3><p>跳表是一种特殊的链表。普通的链表虽然添加、删除节点的速度很快（O(1)），但是要查找节点却很慢（O(n)）。跳表是一个多层次的链表，其在链表的基础上增加了多级索引，实现了O(㏒n) 的查找速度。</p><p><img src="/img/Java_InputImage/13_3_6 跳表图.jpg"/></p><p><em>（13_3_6 跳表图）</em></p><p>跳表将原本数据层的数据按照一定间隔抽取节点形成索引层，之后再从索引层抽取节点形成第二级索引，以此类推形成多层索引。</p><p>跳表的查询速度得到了优化，但占用空间更大。本质上是一种空间换时间的做法。</p><p><strong>查询</strong></p><p>从最稀疏的索引层（最上层）开始，确定那个待查找数据所在的范围，逐层向下并确定范围，直至数据层。</p><p><strong>增删</strong></p><p>删除元素时，如果那个元素是索引元素，那些索引也会被删除。同时，如果只向数据层中增加元素，可能使索引间隔过大，从而降低查找效率。如果在增加元素时还能保持索引数量的动态平衡，就能防止跳表退化，保持跳表效率。</p><p>跳表给出的解决方案是：在增加元素时产生一个随机值，让这个随机值决定该新节点是否成为索引节点，以及成为几级索引节点。</p><p><strong>实现跳表</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Skiplist</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> level;<span class="hljs-comment">// 该跳表的合计层数，包括数据层和索引层</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Random seed;<span class="hljs-comment">// 随机数种子</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node root;<span class="hljs-comment">// 链表开头</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node end;<span class="hljs-comment">// 链表结尾</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<span class="hljs-comment">// 链表节点类</span>        <span class="hljs-type">int</span> val;<span class="hljs-comment">// 值</span>        <span class="hljs-type">int</span> count;<span class="hljs-comment">// 储存的值的数量</span>        Node[] next;<span class="hljs-comment">// 指向的下一节点</span>        Node[] prev;<span class="hljs-comment">// 指向的上一节点</span>        <span class="hljs-comment">// 需要指出的是：next 和 prev 的长度指示了节点所在的最高层级</span>        <span class="hljs-comment">// 长度为 1 时仅处在数据层，2 时也位于一级索引，以此类推</span>        <span class="hljs-comment">// 也就是说，next 和 prev 里，下标 0 的位置位于数据层，1 位于一级索引层</span>        <span class="hljs-comment">/* 三个参数是：值 val，节点的层级 rand，节点储存值的数量 count */</span>        Node(<span class="hljs-type">int</span> val, <span class="hljs-type">int</span> rand, <span class="hljs-type">int</span> count) &#123;            <span class="hljs-built_in">this</span>.val = val;            <span class="hljs-built_in">this</span>.count = count;            next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[rand];            prev = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[rand];        &#125;    &#125;    <span class="hljs-comment">/* 构造器 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Skiplist</span><span class="hljs-params">()</span> &#123;        <span class="hljs-built_in">this</span>(<span class="hljs-number">4</span>);    &#125;    <span class="hljs-comment">/* 有参构造器。输入的值是索引层数量。该值至少应为 1 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Skiplist</span><span class="hljs-params">(<span class="hljs-type">int</span> level)</span> &#123;        <span class="hljs-keyword">if</span> (level &lt; <span class="hljs-number">1</span> || level &gt; <span class="hljs-number">30</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(level == <span class="hljs-number">0</span> ?                    <span class="hljs-string">&quot;Why not choose a LinkedList?&quot;</span> :                    <span class="hljs-string">&quot;SkipList level out of range: given &quot;</span> + level + <span class="hljs-string">&quot; out of range [1, 30]&quot;</span>);        <span class="hljs-built_in">this</span>.level = level + <span class="hljs-number">1</span>;        <span class="hljs-built_in">this</span>.seed = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>(System.currentTimeMillis());        root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Integer.MIN_VALUE, <span class="hljs-built_in">this</span>.level, <span class="hljs-number">0</span>);        end = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Integer.MAX_VALUE, <span class="hljs-built_in">this</span>.level, <span class="hljs-number">0</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; n &lt; <span class="hljs-built_in">this</span>.level; n++) &#123;            root.next[n] = end;            end.prev[n] = root;        &#125;    &#125;    <span class="hljs-comment">/* 查询一个值是否存在 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span> target)</span> &#123;        <span class="hljs-type">Node</span> <span class="hljs-variable">find</span> <span class="hljs-operator">=</span> position(target);        <span class="hljs-keyword">return</span> find.val == target &amp;&amp; find.count &gt; <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">/* 搜索一个值的位置。不存在时会返回数据层中前一个节点的位置 */</span>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">position</span><span class="hljs-params">(<span class="hljs-type">int</span> target)</span> &#123;        <span class="hljs-type">Node</span> <span class="hljs-variable">see</span> <span class="hljs-operator">=</span> root;        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;            <span class="hljs-keyword">if</span> (see.val == target) <span class="hljs-keyword">return</span> see;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> see.next.length - <span class="hljs-number">1</span>; ; n--) &#123;                <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> see;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (see.next[n].val &lt;= target) &#123;                    see = see.next[n];                    <span class="hljs-keyword">break</span>;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-comment">/* 添加一个值 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;        <span class="hljs-type">Node</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> position(num);        <span class="hljs-keyword">if</span> (pos.val == num) &#123;<span class="hljs-comment">// 如果这个节点已经建立，就仅使该节点计数增加</span>            pos.count++;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-type">int</span> <span class="hljs-variable">rand</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> + level - Integer.toBinaryString(seed.nextInt(<span class="hljs-number">1</span> &lt;&lt; level)).length();        <span class="hljs-comment">// level 的值等于总层数。seed 是一个随机数种子，nextInt(int n) 方法返回 [0, n) 的数值</span>        <span class="hljs-comment">// Integer.toBinaryString(int n) 方法是将一个数字转化成二进制表示的字符串</span>        <span class="hljs-comment">// seed.nextInt(1 &lt;&lt; level) 保证了返回值的二进制长度在 [1, level] 之间，并且概率合意</span>        <span class="hljs-type">Node</span> <span class="hljs-variable">add</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(num, rand, <span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; t &lt; rand; ) &#123;<span class="hljs-comment">// 将新节点添加到链表中。</span>            <span class="hljs-keyword">for</span> (; t &lt; pos.next.length &amp;&amp; t &lt; rand; t++) &#123;                <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> pos.next[t];                add.next[t] = next;                next.prev[t] = add;                pos.next[t] = add;                add.prev[t] = pos;            &#125;            pos = pos.prev[pos.prev.length - <span class="hljs-number">1</span>];        &#125;    &#125;    <span class="hljs-comment">/* 删除节点（的值） */</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">erase</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;        <span class="hljs-type">Node</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> position(num);        <span class="hljs-keyword">if</span> (pos.val == num &amp;&amp; pos.count &gt; <span class="hljs-number">0</span>) &#123;            pos.count--;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;</code></pre></div><h2 id="队列接口-queue">13.4 队列接口 Queue</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Queue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Collection</span>&lt;E&gt;</code></pre></div><blockquote><p>Queue 是 Collection 的子接口</p><p>Queue的实现子类都是队列式集合。队列是一个有序列表，可以用数组或链表来实现</p><p>队列遵循先入先出的原则。队列中元素是以添加顺序取出的。</p><p>向队列中增加元素称为<strong>入列</strong>（push），取出元素称为<strong>出列</strong>（pop）</p></blockquote><p><img src="/img/Java_InputImage/队列图_13.4.png" /></p><h3 id="常用方法-4">常用方法：</h3><ul><li><p><code>add(E e)</code>：添加元素。队列满的场合抛出异常</p><p><code>put(E e)</code>：添加元素。队列满的场合可能阻塞</p><p><code>boolean offer(E e)</code>：添加元素。队列满的场合返回false</p></li><li><p><code>E remove()</code>：移除并返回队列头部元素。队列空的场合抛出异常</p><p><code>E poll()</code>：移除并返回队列头部元素</p><p><code>E take()</code>：移除并返回队列头部元素。队列空的场合可能阻塞</p></li><li><p><code>E peek()</code>：仅返回队列头部元素。为空时返回 null</p><p><code>E element()</code>：仅返回队列头部元素。为空时抛出异常</p></li></ul><h3 id="优先级队列-priorityqueue">13.4.1 优先级队列 PriorityQueue</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityQueue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;E&gt;    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable</code></pre></div><blockquote><p>PriorityQueue 是一个无界优先级队列。底层以数组储存元素。</p><p>无界队列：即没有范围限制的队列。</p><p>PriorityQueue 不允许 null 元素，也不允许不可比较的元素。</p><p>PriorityQueue中的元素以自然顺序，或传入的比较器决定的顺序排序。其中的最小元素位于队头，最大元素位于队尾。</p><p>以迭代器遍历时，会按照原本的放入顺序获取元素。PriorityQueue的源码：</p></blockquote><ol type="1"><li><p>底层维护了一个 Object 类型的数组 queue。用以存放元素</p><p>另维护了一个比较器 comparator，用以比较元素</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> Object[] queue;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Comparator&lt;? <span class="hljs-built_in">super</span> E&gt; comparator;</code></pre></div></li><li><p>默认构造器初始容量为 11，比较器为 null</p><p>也能指定初始容量，或传入比较器</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">PriorityQueue</span><span class="hljs-params">()</span> &#123;    <span class="hljs-built_in">this</span>(DEFAULT_INITIAL_CAPACITY, <span class="hljs-literal">null</span>);&#125;<span class="hljs-keyword">public</span> <span class="hljs-title function_">PriorityQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;    <span class="hljs-built_in">this</span>(initialCapacity, <span class="hljs-literal">null</span>);&#125;<span class="hljs-keyword">public</span> <span class="hljs-title function_">PriorityQueue</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-built_in">super</span> E&gt; comparator)</span> &#123;    <span class="hljs-built_in">this</span>(DEFAULT_INITIAL_CAPACITY, comparator);&#125;<span class="hljs-keyword">public</span> <span class="hljs-title function_">PriorityQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity,</span><span class="hljs-params">                     Comparator&lt;? <span class="hljs-built_in">super</span> E&gt; comparator)</span> &#123;    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">1</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();    <span class="hljs-built_in">this</span>.queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];    <span class="hljs-built_in">this</span>.comparator = comparator;&#125;</code></pre></div></li><li><p>放入时依靠比较器 comparator 进行排序。</p><p>那个比较器为 null的场合，每次放入元素会按元素自身的自然顺序进行排序。</p><p>不能排序的场合会抛出异常。</p></li><li><p>扩容时，容量小于 64 的场合容量变为 2 倍 + 2。否则那个容量变为 1.5倍</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> queue.length;        <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + ((oldCapacity &lt; <span class="hljs-number">64</span>) ?                                         (oldCapacity + <span class="hljs-number">2</span>) :                                         (oldCapacity &gt;&gt; <span class="hljs-number">1</span>));        <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)            newCapacity = hugeCapacity(minCapacity);        queue = Arrays.copyOf(queue, newCapacity);    &#125;</code></pre></div></li></ol><h3 id="阻塞队列接口-blockingqueue">13.4.2 阻塞队列接口BlockingQueue</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BlockingQueue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Queue</span>&lt;E&gt;</code></pre></div><blockquote><p>BlockingQueue 是一个接口，其实现子类都是阻塞队列。</p><p>阻塞队列：</p><ul><li>元素入列时，那个队列已满的场合，会进行等待。直到有元素出列后，元素数量未超过队列总数时，解除阻塞状态，进而继续入列。</li><li>元素出列时，如果队列为空，则会进行等待。直到有元素入列时，解除阻塞状态，进而继续出列。</li><li>阻塞队列能防止容器溢出。只要是阻塞队列，就是线程安全的队列。</li><li>阻塞队列不接受 null 元素</li></ul><p>BlockingQueue 的常用实现子类有：</p><ul><li>ArrayBlockingQueue：底层以数组存放元素的有界阻塞队列</li><li>LinkedBlockingQueue：底层以链表存放元素的可选边界的阻塞队列</li><li>PriorityBlockingQueue：无界阻塞队列，与 PriorityQueue排序方式相同</li></ul></blockquote><h4 id="常用方法-5">常用方法：</h4><p>实际上，其常用方法能分为几类：</p><table><tr><td></td><th>抛出异常</th><th>特殊值</th><th>阻塞</th><th>等待</th></tr><tr><th>插入</th><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e, time, unit)</td></tr><tr><th>删除</th><td>remove()</td><td>poll()</td><td>take()</td><td>take(time, unit)</td></tr><tr><th>查找</th><td>element()</td><td>peek()</td><td>-</td><td>-</td></tr></table><h2 id="双列集合接口-map">13.5 双列集合接口 Map</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Map</span>&lt;K,V&gt;</code></pre></div><p><strong>以下关于 Map 接口的描述，适用于 JDK 8 的环境</strong></p><blockquote><p>Map 与 Collection 并列存在，用于保存具有映射关系的数据：key -value（双列元素）</p><p>Map 的 key 和 value 可以是任何类型的引用数据类型，也能存入 null。</p><p>Map 的 key 不允许重复，value 可以重复。key 和 value存在单一对应关系。通过特定的 key 一定能找到指定的 value。</p><p>一组 k - v 会被封装到一个 Entry 对象中。Entry 是一个内部接口。Map的实现子类中都包含一个实现这个接口的内部类。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Entry</span>&lt;K,V&gt; &#123;K <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span>;V <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span>;    ...&#125;</code></pre></div><p>如果添加相同的 key，会覆盖原先的 key -value。等同于修改（key不会替换，value 会被替换）</p></blockquote><h4 id="常用方法-6">常用方法：</h4><ul><li><p><code>put()</code>：添加。已存在的场合，实行替换。（key不替换，value 替换）</p></li><li><p><code>remove()</code>：根据键删除映射关系</p></li><li><p><code>get()</code>：根据键获取值</p></li><li><p><code>size()</code>：元素个数</p></li><li><p><code>isEmpty()</code>：判断个数是否为 0</p></li><li><p><code>clear()</code>：清空</p></li><li><p><code>containsKey()</code>：查找键是否存在</p></li><li><p><code>Set&lt;K&gt; keySet()</code>：获取所有 键 构成的集合</p><p><code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>：获取所有Entry 构成的集合</p><p><code>Collection&lt;V&gt; values()</code>：获取所有 值构成的集合</p></li></ul><h4 id="map-接口遍历元素">Map 接口遍历元素：</h4><ul><li><p><strong>方法一</strong>：利用 <code>Set&lt;K&gt; keySet()</code>方法</p><p>先得到所有 keys，再遍历 keys，根据每个 key 获得 value：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Set</span> <span class="hljs-variable">keyset</span> <span class="hljs-operator">=</span> map.keySet();<span class="hljs-keyword">for</span> (Object o : keyset) &#123;System.out.println(o + <span class="hljs-string">&quot; = &quot;</span> + map.get(o));&#125;</code></pre></div></li><li><p><strong>方法二</strong>：利用 <code>Set&lt;V&gt; values()</code>方法</p><p>直接把所有 values 取出，之后遍历 values</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Collection</span> <span class="hljs-variable">values</span> <span class="hljs-operator">=</span> map.values();<span class="hljs-keyword">for</span> (Object value : values) &#123;System.out.println(value);&#125;</code></pre></div></li><li><p><strong>方法三</strong>：利用<code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code> 方法</p><p>通过获取 entrySet 来获取 k - v</p><div class="code-wrapper"><pre><code class="hljs java">Set&lt;Map.Entry&gt; entrySet = map.entrySet();<span class="hljs-keyword">for</span> (Map.Entry e : entrySet) &#123;System.out.println(e.getKey() + <span class="hljs-string">&quot; - &quot;</span> + e.getValue());&#125;</code></pre></div></li></ul><h3 id="散列表-hashmap">13.5.1 散列表 HashMap</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashMap</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractMap</span>&lt;K,V&gt;    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable</code></pre></div><blockquote><p>HashMap 是 Map 接口使用频率最高的实现类。是根据关键码值（keyvalue）而进行直接访问的数据结构。通过将关键码值映射到表中一个位置来访问记录，以加快查找速度。</p><p>那个映射函数叫做散列函数，存放记录的数组叫做散列表（哈希表）</p><p>HashMap 是以 k - v 对得到方式来存储数据。一组数据会被封装到一个 Node对象中。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123; <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash; <span class="hljs-keyword">final</span> K key; V value; Node&lt;K,V&gt; next; ...&#125;</code></pre></div><p>JDK 7 前，HashMap 底层是 数组 + 链表。JDK 8 后，底层是 数组 + 链表 +红黑树。HashMap 不保证映射的顺序。</p><p>HashMap 没有实现同步（没有 synchronized），是线程不安全的</p></blockquote><h4 id="hashmap-的源码">HashMap 的源码：</h4><ol type="1"><li><p>HashMap 底层维护了 Node 类型的数组 table。默认为 null</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;</code></pre></div><p>另外，还有集合values、keySet、enrtySet。这些集合能帮助程序员进行遍历</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> Set&lt;K&gt;keySet;<span class="hljs-keyword">transient</span> Collection&lt;V&gt;values;<span class="hljs-keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt;entrySet;</code></pre></div></li><li><p>创建对象时，默认构造器将加载因子（loadfactor）初始化为 0.75。</p><p>也能指定那些初始容量和加载因子。</p><p>默认构造器第一次添加元素的场合，table 扩容为 16，临界值为 16 * 0.75 =12。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">DEFAULT_LOAD_FACTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75f</span>;<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAXIMUM_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">()</span> &#123;    <span class="hljs-built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;<span class="hljs-comment">// 这个默认构造的场合，其他参数都是默认值</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;    <span class="hljs-built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;<span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor)</span> &#123;    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(...);    <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)        initialCapacity = MAXIMUM_CAPACITY;    <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(...);    <span class="hljs-built_in">this</span>.loadFactor = loadFactor;    <span class="hljs-built_in">this</span>.threshold = tableSizeFor(initialCapacity);&#125;</code></pre></div></li><li><p>添加时容量不够的场合，需要扩容。</p><p>默认构造器第一次添加元素的场合，table 扩容为 16，临界值为 16 * 0.75 =12。</p><p>扩容的场合，容量变为 2 倍。临界值相应变化。</p><p>临界值不会超过那个指定的 MAXIMUM_CAPACITY（1 &lt;&lt; 30），否则变成Integer.MAX_VALUE。</p><p>JDK 8 中，如果一条链表的元素个数超过 TREEIFY_THRESHOLD（默认是8），并且 <code>table</code> 的大小 &gt;= MIN_TREEIFY_CAPACITY（默认64），会进行树化。</p><p>剪枝：红黑树的元素减少到一定程度，会被重新转化为 链表</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAXIMUM_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>;<span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;    Node&lt;K,V&gt;[] oldTab = table;<span class="hljs-comment">// &lt;- 旧的数据数组 table</span>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCap</span> <span class="hljs-operator">=</span> (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<span class="hljs-comment">// &lt;- 旧的 table 的容量</span>    <span class="hljs-type">int</span> <span class="hljs-variable">oldThr</span> <span class="hljs-operator">=</span> threshold;<span class="hljs-comment">// &lt;- 旧的临界值</span>    <span class="hljs-type">int</span> newCap, newThr = <span class="hljs-number">0</span>;<span class="hljs-comment">// &lt;- 新的容量、临界值</span>        <span class="hljs-comment">/* 旧的数组不为空时，</span><span class="hljs-comment">    如果容量已达指定的 MAXIMUM_CAPACITY，则不扩容</span><span class="hljs-comment">    否则扩容为 2 倍容量，临界值也变为 2 倍 */</span>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;        newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;            threshold = Integer.MAX_VALUE;            <span class="hljs-keyword">return</span> oldTab;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">/* 旧的数组为空，但临界值已被指定（原因是：指定构造器传入初始容量为 0） */</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>)        newCap = oldThr;    <span class="hljs-comment">/* 旧的数组为空，临界值为 0（原因是：使用默认构造器）</span><span class="hljs-comment">    默认构造器初始化容量为 16，默认临界因子为 0.75f */</span>    <span class="hljs-keyword">else</span> &#123;        newCap = DEFAULT_INITIAL_CAPACITY;        newThr = (<span class="hljs-type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);    &#125;        <span class="hljs-comment">/* 到这里，newThr（新临界值）为 0 的原因可能是：</span><span class="hljs-comment">    1. 旧容量小于那个最小容量（16）</span><span class="hljs-comment">    2. 扩容后容量大于那个最大容量</span><span class="hljs-comment">    3. 旧的临界值为 0 或 Integer.MIN_VALUE</span><span class="hljs-comment">    4. 构造器传入初始容量为 0 */</span>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">/* 按照 新容量 * 临界因子 的方法计算临界值。临界值不会超过一个指定的最大值 */</span>        <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>)newCap * loadFactor;        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-type">float</span>)MAXIMUM_CAPACITY ?                  (<span class="hljs-type">int</span>)ft : Integer.MAX_VALUE);    &#125;    threshold = newThr;        <span class="hljs-comment">/* 确定了容量和临界值，下面把旧数组元素移至新数组。</span><span class="hljs-comment">    那个移动的场合，会以新容量重新计算所有元素的下标位置 */</span>    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[newCap];    table = newTab;    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;            Node&lt;K,V&gt; e;            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;                oldTab[j] = <span class="hljs-literal">null</span>;                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>)                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, newTab, j, oldCap);                <span class="hljs-keyword">else</span> &#123;                    Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;                    Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;                    Node&lt;K,V&gt; next;                    <span class="hljs-keyword">do</span> &#123;                        next = e.next;                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)                                loHead = e;                            <span class="hljs-keyword">else</span>                                loTail.next = e;                            loTail = e;                        &#125;                        <span class="hljs-keyword">else</span> &#123;                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)                                hiHead = e;                            <span class="hljs-keyword">else</span>                                hiTail.next = e;                            hiTail = e;                        &#125;                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;                        loTail.next = <span class="hljs-literal">null</span>;                        newTab[j] = loHead;                    &#125;                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;                        hiTail.next = <span class="hljs-literal">null</span>;                        newTab[j + oldCap] = hiHead;                    &#125;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> newTab;&#125;</code></pre></div></li><li><p>添加 k - v 时，通过 key 的哈希值得到其在 table的索引，判断索引位置是否被占用。</p><p>未占用的场合，直接添加。</p><p>占用的场合，判断其 key 是否相等。相等的场合，替换 value。否则，按照树 或 链表 的方式处理。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);&#125;<span class="hljs-comment">/* 会先对放入元素的哈希值进行一次计算，得到一个数字：hash */</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> key.hashCode();    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>));<span class="hljs-comment">// 位运算符：&gt;&gt;&gt; 无符号右移</span>&#125;<span class="hljs-comment">/* put 方法会调用该 putVal 方法。</span><span class="hljs-comment">那些传入值是：hash、key、value、false、true */</span><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent, <span class="hljs-type">boolean</span> evict)</span> &#123;    Node&lt;K,V&gt;[] tab = table; <span class="hljs-comment">// &lt;- 是那个存放数据的 table 数组</span>    <span class="hljs-type">int</span> n;<span class="hljs-comment">// &lt;- 是 table.length</span>        <span class="hljs-comment">/* 如果原先的 table 为空，则对其重新分配空间 */</span>    <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>) &#123;        tab = resize();        n = tab.length;    &#125;        <span class="hljs-comment">/* 用方才计算的 hash 数，得到要放入元素的下标值 i</span><span class="hljs-comment">    n - 1 是数据数组的最大下标，(n - 1) &amp; hash 必定不大于 n - 1 */</span>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> (n - <span class="hljs-number">1</span>) &amp; hash;<span class="hljs-comment">// 位运算符：&amp; 按位与</span>    Node&lt;K,V&gt; p = tab[i];<span class="hljs-comment">// 得到 table 中，位于那个插入位置的元素</span>            <span class="hljs-comment">/* 倘若该位置为空，则直接放入 */</span>    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span>) &#123;        tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);    &#125;    <span class="hljs-comment">/* 该位置不为空，意味着可能添加了重复元素 */</span>    <span class="hljs-keyword">else</span> &#123;        Node&lt;K,V&gt; e; <span class="hljs-comment">// &lt;- 被发现重复的那个 Node。无重复时结果为 null。这个 Node 的 value 会被替换。</span>        <span class="hljs-type">K</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> p.key;<span class="hljs-comment">// &lt;- 当前取出进行比较的 key 值</span>                <span class="hljs-comment">/* 为了验证其是否重复，这里要进行如下比较：</span><span class="hljs-comment">        1. 比较两者的 hash 数。不同的场合是不同元素</span><span class="hljs-comment">        2. 使用 == 和 equals 两种方法比较 key。不同的场合是不同元素 </span><span class="hljs-comment">        如果是相同元素，则该节点的值会被替换 */</span>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp; (k  == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k)))) &#123;            e = p;        &#125;                <span class="hljs-comment">/* 此处节点结构是 树 的场合，还需遍历比较树的每个节点 */</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);                <span class="hljs-comment">/* 此处节点结构是 链表 的场合，还需遍历比较每个链表节点 */</span>        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;                e = p.next;                <span class="hljs-comment">/* e == null 意味着遍历结束，全部不同。这样，在此处添加那个新的 Node */</span>                <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>) &#123;                    p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span>                        treeifyBin(tab, hash);                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-comment">/* 故技重施，如果发现相同，则替换那个新元素 */</span>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k)))) &#123;                    <span class="hljs-keyword">break</span>;                &#125;                p = e;            &#125;        &#125;                <span class="hljs-comment">/* 经历上述比较后，e != null 意味着有元素要被替换了 */</span>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;            <span class="hljs-comment">/* 传入的参数 onluIfAbsent == false，所以此处一定是 true */</span>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)                e.value = value;            afterNodeAccess(e);<span class="hljs-comment">// &lt;- HashMap 中，该方法为空实现。</span>            <span class="hljs-keyword">return</span> oldValue;        &#125;    &#125;    ++modCount;        <span class="hljs-comment">/* 如果到达这里，说明添加了元素（而非替换），要查看大小是否超过临界值 */</span>    <span class="hljs-keyword">if</span> (++size &gt; threshold)        resize();    afterNodeInsertion(evict);<span class="hljs-comment">// &lt;- HashMap 中，该方法为空实现。</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;&#125;<span class="hljs-comment">/* 上面提到的一些空实现的方法 */</span><span class="hljs-keyword">void</span> <span class="hljs-title function_">afterNodeAccess</span><span class="hljs-params">(Node&lt;K,V&gt; p)</span> &#123; &#125;<span class="hljs-keyword">void</span> <span class="hljs-title function_">afterNodeInsertion</span><span class="hljs-params">(<span class="hljs-type">boolean</span> evict)</span> &#123; &#125;<span class="hljs-keyword">void</span> <span class="hljs-title function_">afterNodeRemoval</span><span class="hljs-params">(Node&lt;K,V&gt; p)</span> &#123; &#125;</code></pre></div></li></ol><h3 id="散列表-hashtable">13.5.2 散列表 Hashtable</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hashtable</span>&lt;K,V&gt;    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Dictionary</span>&lt;K,V&gt;    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>&lt;K,V&gt;, Cloneable, java.io.Serializable</code></pre></div><blockquote><p>Hashtable 和 HashMap 基本一致，但Hashtable 是线程安全的。但也因为如此，Hashtable 的效率低下。</p></blockquote><h4 id="hashtable-与-hashmap-的比较">Hashtable 与 HashMap 的比较：</h4><table><thead><tr class="header"><th></th><th>版本</th><th>线程安全（同步）</th><th>效率</th><th>是否允许 null值</th></tr></thead><tbody><tr class="odd"><td>Hashtable</td><td>1.0</td><td>安全</td><td>较低</td><td>不允许</td></tr><tr class="even"><td>HashMap</td><td>1.2</td><td>不安全</td><td>高</td><td>允许</td></tr></tbody></table><ul><li><p>Hashtable 底层也是有数组，默认构造器的初始容量为 11。临界值是 11* 0.75 = 8。</p></li><li><p>扩容大致如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> (oldCapacity &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<span class="hljs-comment">//即，原容量 * 2 + 1</span></code></pre></div></li><li><p>Hashtable 不会树化</p></li></ul><h3 id="红黑树-treemap">13.5.3 红黑树 TreeMap</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeMap</span>&lt;K,V&gt;    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractMap</span>&lt;K,V&gt;    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NavigableMap</span>&lt;K,V&gt;, Cloneable, java.io.Serializable</code></pre></div><blockquote><p>TreeMap 实现了 Map 接口。底层使用 红黑树 存储数据。</p><p>相较数组（访问快，检索、插入慢）和链表（插入快，检索、访问慢），树形数据结构（如二叉排序树）在保证数据检索速度的同时，也能保证数据插入、删除、修改的速度</p></blockquote><p><strong><em>——见 <ahref="../../../../../../2022/06/02/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/14%20%E6%A0%91/#14-1-4-1-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91">[14.1.4.1平衡二叉树]</a></em></strong></p><h4 id="treemap-的源码">TreeMap 的源码：</h4><ol type="1"><li><p>TreeMap 底层维护了一个二叉树，以及一个比较器</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Comparator&lt;? <span class="hljs-built_in">super</span> K&gt; comparator;<span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Entry&lt;K,V&gt; root;</code></pre></div></li><li><p>创建对象时，能采用无参构造，也能指定比较器完成构造</p><p>那个无参构造的场合，比较器为空。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">TreeMap</span><span class="hljs-params">()</span> &#123;    comparator = <span class="hljs-literal">null</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-title function_">TreeMap</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-built_in">super</span> K&gt; comparator)</span> &#123;    <span class="hljs-built_in">this</span>.comparator = comparator;&#125;</code></pre></div><p>比较器如果为空，则要求传入的 key 必须是 Comparable接口的实现子类，否则无法进行比较。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Object k1, Object k2)</span> &#123;    <span class="hljs-keyword">return</span> comparator==<span class="hljs-literal">null</span> ? ((Comparable&lt;? <span class="hljs-built_in">super</span> K&gt;)k1).compareTo((K)k2)        : comparator.compare((K)k1, (K)k2);&#125;</code></pre></div></li><li><p>添加时，通过比较器确定那个添加位置。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;    Entry&lt;K,V&gt; t = root;<span class="hljs-comment">// &lt;- 树的根节点</span>        <span class="hljs-comment">/* 二叉树为空的场合，创建根节点，将数据放入 */</span>    <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123;        compare(key, key);        root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>&lt;&gt;(key, value, <span class="hljs-literal">null</span>);        size = <span class="hljs-number">1</span>;        modCount++;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;        <span class="hljs-type">int</span> cmp;<span class="hljs-comment">// &lt;- 临时值，存放比较结果</span>    Entry&lt;K,V&gt; parent;<span class="hljs-comment">// &lt;- 临时值，存放父节点</span>    Comparator&lt;? <span class="hljs-built_in">super</span> K&gt; cpr = comparator;<span class="hljs-comment">// &lt;- 比较器</span>        <span class="hljs-comment">/* 有比较器的场合，按照这个方法进行比较 */</span>    <span class="hljs-keyword">if</span> (cpr != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">do</span> &#123;            parent = t;            cmp = cpr.compare(key, t.key);            <span class="hljs-keyword">if</span> (cmp &lt; <span class="hljs-number">0</span>)                t = t.left;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmp &gt; <span class="hljs-number">0</span>)                t = t.right;            <span class="hljs-keyword">else</span>                <span class="hljs-keyword">return</span> t.setValue(value);        &#125; <span class="hljs-keyword">while</span> (t != <span class="hljs-literal">null</span>);    &#125;        <span class="hljs-comment">/* 比较器为空的场合，按照这个方法进行比较 */</span>    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();        &#125;        Comparable&lt;? <span class="hljs-built_in">super</span> K&gt; k = (Comparable&lt;? <span class="hljs-built_in">super</span> K&gt;) key;        <span class="hljs-keyword">do</span> &#123;            parent = t;            cmp = k.compareTo(t.key);            <span class="hljs-keyword">if</span> (cmp &lt; <span class="hljs-number">0</span>)                t = t.left;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmp &gt; <span class="hljs-number">0</span>)                t = t.right;            <span class="hljs-keyword">else</span>                <span class="hljs-keyword">return</span> t.setValue(value);        &#125; <span class="hljs-keyword">while</span> (t != <span class="hljs-literal">null</span>);    &#125;        <span class="hljs-comment">/* 将数据节点放到正确的路径下 */</span>    Entry&lt;K,V&gt; e = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>&lt;&gt;(key, value, parent);    <span class="hljs-keyword">if</span> (cmp &lt; <span class="hljs-number">0</span>)        parent.left = e;    <span class="hljs-keyword">else</span>        parent.right = e;        <span class="hljs-comment">/* 此处会试着将该树转换成完全二叉树 */</span>    fixAfterInsertion(e);    size++;    modCount++;    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;&#125;</code></pre></div></li><li><p>添加的最后，会试着将该树转换成完全二叉树</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fixAfterInsertion</span><span class="hljs-params">(Entry&lt;K,V&gt; x)</span> &#123;    x.color = RED;    <span class="hljs-keyword">while</span> (x != <span class="hljs-literal">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;        <span class="hljs-keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));            <span class="hljs-keyword">if</span> (colorOf(y) == RED) &#123;                setColor(parentOf(x), BLACK);                setColor(y, BLACK);                setColor(parentOf(parentOf(x)), RED);                x = parentOf(parentOf(x));            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">if</span> (x == rightOf(parentOf(x))) &#123;                    x = parentOf(x);                    rotateLeft(x);                &#125;                setColor(parentOf(x), BLACK);                setColor(parentOf(parentOf(x)), RED);                rotateRight(parentOf(parentOf(x)));            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));            <span class="hljs-keyword">if</span> (colorOf(y) == RED) &#123;                setColor(parentOf(x), BLACK);                setColor(y, BLACK);                setColor(parentOf(parentOf(x)), RED);                x = parentOf(parentOf(x));            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">if</span> (x == leftOf(parentOf(x))) &#123;                    x = parentOf(x);                    rotateRight(x);                &#125;                setColor(parentOf(x), BLACK);                setColor(parentOf(parentOf(x)), RED);                rotateLeft(parentOf(parentOf(x)));            &#125;        &#125;    &#125;    root.color = BLACK;&#125;</code></pre></div></li></ol><h3 id="properties">13.5.4 Properties</h3><blockquote><p>Properties 继承自 Hashtable 并实现了 Map接口。也使用键值对的方式保存数据</p><p>Properties 使用特点与 Hashtable 相似</p><p>Properties 还可以用于 xxx.properties 文件中，加载数据到 Properties对象，进行读取和修改</p><p>xxx.properties 文件常作为配置文件</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Properties</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Hashtable</span>&lt;Object,Object&gt;</code></pre></div><p><strong><em>——关于这些，详见 <ahref="../../../../../../2022/01/06/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/17%20IO%E6%B5%81/">[17IO流 ]</a></em></strong></p><ul><li><p><code>String getProperty(String key)</code> ：输入一个 String类型的 key，返回一个 String 的 value</p><p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getProperty</span><span class="hljs-params">(String key)</span> &#123;<span class="hljs-type">Object</span> <span class="hljs-variable">oval</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.get(key);<span class="hljs-type">String</span> <span class="hljs-variable">sval</span> <span class="hljs-operator">=</span> (oval <span class="hljs-keyword">instanceof</span> String) ? (String)oval : <span class="hljs-literal">null</span>;<span class="hljs-keyword">return</span> ((sval == <span class="hljs-literal">null</span>) &amp;&amp; (defaults != <span class="hljs-literal">null</span>)) ? defaults.getProperty(key) : sval;&#125;</code></pre></div></p></li></ul><h2 id="无序集合接口-set">13.6 无序集合接口 Set</h2><blockquote><p>Set 是 Collection 接口的子类接口。</p><p>Set接口的特点是无序（添加和取出顺序不一致，其取出顺序由某个算法决定），没有索引</p><p>不允许重复元素。故而，最多包含一个 null</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Set</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Collection</span>&lt;E&gt;</code></pre></div><h3 id="hashset">13.6.1 HashSet</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashSet</span>&lt;E&gt;    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSet</span>&lt;E&gt;    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable</code></pre></div><blockquote><p>HashSet 实现了 Set 接口。底层实际上使用 HashMap 来存储数据。<del>身在Collection 心在 Map</del></p><p>HashSet 是无序的。其实际顺序取决于计算得到的 hash 值</p></blockquote><h4 id="hashset-的源码">HashSet 的源码</h4><ol type="1"><li><p>HashSet 底层是 HashMap。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> HashMap&lt;E,Object&gt; map;</code></pre></div></li><li><p>实例化也和 HashMap 相同</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashSet</span><span class="hljs-params">()</span> &#123;    map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();&#125;<span class="hljs-keyword">public</span> <span class="hljs-title function_">HashSet</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;    map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(initialCapacity);&#125;<span class="hljs-keyword">public</span> <span class="hljs-title function_">HashSet</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor)</span> &#123;    map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(initialCapacity, loadFactor);&#125;</code></pre></div></li><li><p>添加一个元素时调用 HashMap 的方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;    <span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-literal">null</span>;&#125;</code></pre></div></li></ol><h3 id="linkedhashset">13.6.2 LinkedHashSet</h3><blockquote><p>LinkedHashSet 是 HashSet 的子类</p><p>LinkedHashSet 底层是一个 LinkedHashMap，维护了一个数组 +双向链表。<del>有其父必有其子</del></p><p>LinkedHashSet 根据元素的 hashCode值来决定元素的存储位置。同时，使用链表维护元素的次序。这使得元素看起来是以插入顺序保存的，并得以按照放入顺序取出</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;E&gt;    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HashSet</span>&lt;E&gt;    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable</code></pre></div><h4 id="linkedhashset-的源码">LinkedHashSet 的源码：</h4><ol type="1"><li><p>在类 HashSet中，存在一个默认访问范围的构造器。该构造器不同于其他构造器，会让实例维护一个LinkedHashMap</p><div class="code-wrapper"><pre><code class="hljs java">HashSet(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor, <span class="hljs-type">boolean</span> dummy) &#123;    map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;(initialCapacity, loadFactor);&#125;</code></pre></div><p>LinkedHashSet 的构造器即调用了该父类构造器</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedHashSet</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor)</span> &#123;    <span class="hljs-built_in">super</span>(initialCapacity, loadFactor, <span class="hljs-literal">true</span>);&#125;<span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedHashSet</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;    <span class="hljs-built_in">super</span>(initialCapacity, <span class="hljs-number">.75f</span>, <span class="hljs-literal">true</span>);&#125;<span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedHashSet</span><span class="hljs-params">()</span> &#123;    <span class="hljs-built_in">super</span>(<span class="hljs-number">16</span>, <span class="hljs-number">.75f</span>, <span class="hljs-literal">true</span>);&#125;</code></pre></div></li></ol><h3 id="treeset">13.6.3 TreeSet</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeSet</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSet</span>&lt;E&gt;    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NavigableSet</span>&lt;E&gt;, Cloneable, java.io.Serializable</code></pre></div><blockquote><p>TreeSet 实现了 Set 接口，其底层是一个 TreeMap。<del>好家伙，原来 Set全家都是卧底</del></p><p>调用无参构造器创建 TreeSet时，默认是无序排列。也能在构造时传入一个比较器。有比较器的场合，比较器返回0 时，不发生替换</p><p>不传入比较器的场合，使用的是传入对象自带的比较器。所以，这个场合，传入的key 对象必须是 Comparable 接口的实现子类</p></blockquote><h2 id="集合的选择">13.7 集合的选择</h2><p>在开发中，选择什么集合实现类，主要取决于业务操作特点，然后根据集合实现类特性进行分析选择。</p><p>判断存储的类型（一组对象 [单列]，或一组键值对 [双列]） -一组对象：Collection 接口 - 允许重复：List -增删多：<code>LinkedList</code> （双向链表） - 改查多：ArrayList（<code>Object[]</code> 数组） - 不允许重复：Set - 无序：HashSet （数组+ 链表 + 红黑树，底层是 HashMap） - 排序：<code>TreeSet</code> -顺序一致：LinkedHashSet （数组 + 双向链表，底层是<code>LinkedHashMap</code>） - 一组键值对：Map - 键无序：HashMap （数组+ 链表 + 红黑树 [ JDK 8 以后 ] ） - 键排序：<code>TreeMap</code> -键顺序一致：<code>LinkedHashMap</code> （底层是 HashMap） -读取文件：Properties</p><h2 id="工具类-collections">13.8 工具类 Collections</h2><blockquote><p>Collections 工具类是一个操作 Set、List、Map 等集合的工具类</p><p>其中提供了一系列静态方法，对集合元素进行 排序、查询和修改等操作</p></blockquote><h4 id="常用方法-7">常用方法：</h4><p><strong>排序：</strong></p><ul><li><code>reverse(List)</code>：反转 List 中元素的排序</li><li><code>shuffle(List)</code>：对 <code>List</code>中元素进行随机排序</li><li><code>sort(List)</code>：根据元素的自然顺序对指定 List集合元素升序排列</li><li><code>reverse(List, Comparator)</code>：根据指定 Comparator 对 List排序</li><li><code>swap(List, int, int)</code>：将两处元素位置互换</li></ul><p><strong>查找、替换：</strong></p><ul><li><p><code>Object max(Collection)</code>：根据元素的自然排序，返回集合中最大的元素</p></li><li><p><code>Object max(Collection, Comparator)</code>：根据比较器，返回最大元素</p></li><li><p><code>Object min(Collection)</code>：根据元素的自然排序，返回最小元素</p></li><li><p><code>Object min(Collection, Comparator)</code>：根据比较器，返回最小元素</p></li><li><p><code>int frequency(Collection, Object)</code>：返回集合中指定元素的出现次数</p></li><li><p><code>void copy(List dest, List src)</code>：将 src 的内容复制到dest 中</p><p>这个场合，要保证 dest 的大小不小于 src。所以，可能需要先给 dest赋值</p></li><li><p><code>boolean replaceAll(List list, Object oldVal, Object newVal)</code>：用newVal 替换所有 oldVal 值</p></li></ul><h2 id="junit">13.9 JUnit</h2><blockquote><p>一个类有多个功能代码需要测试，为了测试，就要写入 <code>main</code>方法中</p><p>如果有多个功能代码测试，需要反复撤销，过程繁琐</p></blockquote><blockquote><p>JUnit 是一个 Java 语言单元测试框架</p><p>多数 Java 开发环境都已集成了 JUnit 作为单元测试工具</p><p><ahref="https://www.bilibili.com/video/BV1fh411y7R8?p=566&amp;t=259.3"title="看这个吧">使用方法</a></p><p>……总的来讲，方法就是加入 <code>@Test</code>，然后<code>alt + enter</code> 引入 JUnit 5，最后运行</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;C++&gt;13 项目：机房预约系统</title>
    <link href="/2022/05/24/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/13%20%E9%A1%B9%E7%9B%AE%EF%BC%9A%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/05/24/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/13%20%E9%A1%B9%E7%9B%AE%EF%BC%9A%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="项目机房预约系统">13 项目：机房预约系统</h1><h2 id="项目需求">13.1 项目需求</h2><blockquote><p>有数个规格不同的机房，现开发一套预约系统，以解决使用冲突</p><p>三种身份代表：学生（申请使用）、教师（审核预约）、管理员（创建学生、教师账号）</p><p>机房共有三间：1号机房（20人）、2号机房（50人）、3号机房（100人）</p><p>管理员：申请的订单每周由管理员手动清空</p><p>学生：可以预约未来一周内的机房使用，日期为周一至周五，可选时段为上午或下午</p><p>教师：审核预约，选择通过或不通过</p></blockquote><p><strong>菜单：</strong></p><ul><li>学生（学号、姓名、登陆密码）<ul><li>申请预约</li><li>查看自身预约</li><li>查看所有预约</li><li>取消预约（成功的预约或审核中的预约）</li><li>注销登录（二次确认）</li></ul></li><li>老师（职工号、姓名、登陆密码）<ul><li>查看所有预约</li><li>审核预约</li><li>注销登录（二次确认）</li></ul></li><li>管理员（管理员编号、登陆密码）<ul><li>添加账号</li><li>查看账号</li><li>修改账号</li><li>查看机房</li><li>清空预约记录</li><li>注销登录（二次确认）</li></ul></li><li>退出</li></ul><p><strong>账号：</strong></p><ul><li>账号类（ID、姓名、密码、标识符）<ul><li>管理员（ID 为 000000，标识符）</li><li>教师（ID 为 1000XX，标识符）</li><li>学生（ID 为 3000XX，标识符）</li></ul></li></ul><p><strong>机房：</strong></p><ul><li>机房类（容量，预约记录）</li></ul><h2 id="附录">附录</h2><h3 id="机房预约系统">机房预约系统</h3><blockquote><p>执行以下代码</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;menu.h&quot;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">menu0</span>();&#125;</code></pre></div></blockquote><h4 id="头文件">1 2头文件：</h4><p><strong>room.h</strong></p><blockquote><p>包含机房类。还声明了一个预定信息类。</p><p>这两个类的实现都在：<strong>room.cpp</strong></p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;person.h&quot;</span></span><span class="hljs-keyword">class</span> <span class="hljs-title class_">List</span>;<span class="hljs-comment">// 预定信息类</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Room</span> &#123;<span class="hljs-comment">// 机房类</span><span class="hljs-keyword">public</span>:<span class="hljs-built_in">Room</span>(<span class="hljs-type">int</span> seats);<span class="hljs-comment">// 构造器，初始指定那个座位数</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">add_request</span><span class="hljs-params">(List* list)</span></span>;<span class="hljs-comment">// 添加预定</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">confirm_request</span><span class="hljs-params">(vector&lt;List*&gt;::const_iterator r, <span class="hljs-type">bool</span> passed, Teacher* t, <span class="hljs-type">bool</span> link = <span class="hljs-literal">false</span>)</span></span>;    <span class="hljs-comment">// 完成预定</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 清空信息</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showAllTBD</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 显示全部 待审核预定 的信息</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showAllD</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 显示全部 已审核预定 的信息</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSeat</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 返回那个座位数</span><span class="hljs-function">string <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 返回机房名称</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cancel</span><span class="hljs-params">(vector&lt;List*&gt;::const_iterator tar)</span></span>;    <span class="hljs-comment">// 取消一个 待审核预定</span><span class="hljs-type">static</span> vector&lt;Room*&gt;* rooms;<span class="hljs-comment">// 机房集。静态容器，包含全部机房</span>vector&lt;List*&gt; tbd;<span class="hljs-comment">// 待审核集。该容器包含全部 待审核预定</span>vector&lt;List*&gt; confirmed;<span class="hljs-comment">// 已审核集。该容器包含全部 已审核预定</span><span class="hljs-keyword">private</span>:<span class="hljs-type">int</span> seats;<span class="hljs-comment">// 座位数</span>string name;<span class="hljs-comment">// 机房名</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> m_name_count;<span class="hljs-comment">// 静态变量。初始化时自动分配机房名称</span>&#125;;</code></pre></div><p><strong>person.h</strong></p><blockquote><p>包含所有账号类，以及预定信息类</p><p>账号类：Person（信息账号类）、Student（学生账号类）、Teacher（教师账号类）、Manager（管理员账号类）</p><p>账号类的实现在：<strong>person.cpp</strong></p><p>预定信息类的实现在：<strong>room.cpp</strong></p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-keyword">class</span> <span class="hljs-title class_">List</span>;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Room</span>;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<span class="hljs-comment">// 信息账号类。该类是所有账号类的父类</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getID</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 获取账号 ID</span><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">getSign</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 获取账号标记（教师为 T，学生为 S，管理员为 M，信息为 W）</span><span class="hljs-function">string <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(string name)</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setID</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setPW</span><span class="hljs-params">(string ne)</span></span>;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkPW</span><span class="hljs-params">(string pw)</span></span>;<span class="hljs-comment">// 检查密码是否正确</span><span class="hljs-function">string <span class="hljs-title">print</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 返回该账号的信息构成的字符串</span><span class="hljs-type">static</span> Person* reject_has_existed;<span class="hljs-comment">// 一个静态的实例。当提交的预定与当前已审核的预定冲突时，用该实例进行标记</span><span class="hljs-keyword">protected</span>:<span class="hljs-built_in">Person</span>();<span class="hljs-comment">// 构造器。不允许实例化该类对象</span><span class="hljs-built_in">Person</span>(string name, <span class="hljs-type">int</span> id);string name;<span class="hljs-comment">// 姓名</span><span class="hljs-type">int</span> id = <span class="hljs-number">-1</span>;<span class="hljs-comment">// ID</span><span class="hljs-type">char</span> sign = <span class="hljs-string">&#x27;P&#x27;</span>;<span class="hljs-comment">// 账号标记（教师为 T，学生为 S，管理员为 M，信息为 W）</span>string password;<span class="hljs-comment">// 密码</span>&#125;;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Manager</span>: <span class="hljs-keyword">public</span> Person &#123;<span class="hljs-comment">// 管理员类</span><span class="hljs-keyword">public</span>:<span class="hljs-built_in">Manager</span>(string name, string pw);<span class="hljs-function"><span class="hljs-type">static</span> Manager* <span class="hljs-title">getManager</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 静态方法。返回唯一的管理员账号实例。</span><span class="hljs-function">Person* <span class="hljs-title">createAccount</span><span class="hljs-params">(<span class="hljs-type">char</span> identity, string name, string pw)</span></span>;    <span class="hljs-comment">// 创建账号</span><span class="hljs-keyword">private</span>:<span class="hljs-type">static</span> Manager* ss;<span class="hljs-comment">// 静态实例。管理员账号是唯一的，就是这个实例</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> m_id_count;&#125;;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> : <span class="hljs-keyword">public</span> Person &#123;<span class="hljs-comment">// 学生类</span><span class="hljs-keyword">public</span>:<span class="hljs-built_in">Student</span>(string name, string pw);<span class="hljs-function"><span class="hljs-type">static</span> vector&lt;Student*&gt;* <span class="hljs-title">all</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 静态方法。返回包含全部学生实例的容器</span><span class="hljs-function">List* <span class="hljs-title">order</span><span class="hljs-params">(<span class="hljs-type">int</span> date, <span class="hljs-type">bool</span> time)</span></span>;<span class="hljs-comment">// 返回一个新的预约</span><span class="hljs-function"><span class="hljs-type">static</span> Student* <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span></span>;<span class="hljs-comment">// 静态方法。按 ID 查找学生</span><span class="hljs-function"><span class="hljs-type">static</span> Student* <span class="hljs-title">find</span><span class="hljs-params">(string name)</span></span>;<span class="hljs-comment">// 静态方法。按姓名查找学生</span><span class="hljs-keyword">private</span>:<span class="hljs-type">static</span> vector&lt;Student*&gt;* ss;<span class="hljs-comment">// 学生集。静态容器。是包含全部学生实例的容器</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> m_id_count;<span class="hljs-comment">// 实例化学生类时自动分配 ID</span>&#125;;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> : <span class="hljs-keyword">public</span> Person &#123;<span class="hljs-comment">// 教师类</span><span class="hljs-keyword">public</span>:<span class="hljs-built_in">Teacher</span>(string name, string pw);<span class="hljs-function"><span class="hljs-type">static</span> vector&lt;Teacher*&gt;* <span class="hljs-title">all</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 静态方法。返回包含全部教师实例的容器</span><span class="hljs-function">List* <span class="hljs-title">confirm</span><span class="hljs-params">(List* l, <span class="hljs-type">bool</span> b)</span></span>;<span class="hljs-comment">// 返回一个经过审核的预约</span><span class="hljs-function"><span class="hljs-type">static</span> Teacher* <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span></span>;<span class="hljs-function"><span class="hljs-type">static</span> Teacher* <span class="hljs-title">find</span><span class="hljs-params">(string name)</span></span>;<span class="hljs-keyword">private</span>:<span class="hljs-type">static</span> vector&lt;Teacher*&gt;* ss;<span class="hljs-comment">// 教师集。静态容器。是包含全部教师实例的容器</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> m_id_count;&#125;;<span class="hljs-keyword">class</span> <span class="hljs-title class_">List</span> &#123;<span class="hljs-comment">// 预约信息类</span><span class="hljs-keyword">public</span>:Person* requester;<span class="hljs-comment">// 此处一般是一个 Student*，表示预约人的信息</span>Person* confirmer;<span class="hljs-comment">// 此处可能是一个 Teacher*，也可能是一个 Person*</span>    <span class="hljs-comment">// Teacher* 的场合，表示审核人的信息</span>    <span class="hljs-comment">// Person* 的场合，表示那个错误的原因</span><span class="hljs-type">int</span> state;<span class="hljs-comment">// 审核状态：0待审核、1通过、-1拒绝</span><span class="hljs-type">int</span> date;<span class="hljs-comment">// 日期，范围是 1 - 7（周一 ~ 周日）</span><span class="hljs-type">bool</span> time;<span class="hljs-comment">// 时段：true 上午、false 下午</span>Room* room;<span class="hljs-comment">// 机房</span><span class="hljs-built_in">List</span>(<span class="hljs-type">int</span> date, <span class="hljs-type">bool</span> time, Student* s);<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">confirm</span><span class="hljs-params">(<span class="hljs-type">bool</span> pass, Person* t)</span></span>;<span class="hljs-comment">// 更新审核状态</span><span class="hljs-function">string <span class="hljs-title">print</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 返回预约信息构成的字符串</span>&#125;;</code></pre></div><p><strong>menu.h</strong></p><blockquote><p>菜单。程序的主干。</p><p>执行 <code>menu0()</code> 以进入机房预约系统</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;room.h&quot;</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testing_initial</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 测试初始化。这个方法初始化了数个账号及机房，以供测试之用</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">menu0</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 程序的主入口</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_menu0</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 显示 一级菜单</span><span class="hljs-function">Person* <span class="hljs-title">log_in</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>;<span class="hljs-comment">// 尝试登录。返回将要登录的账号信息</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">menu_stu</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 学生菜单入口</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_menu_stu</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 显示 学生菜单</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">menu_tea</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 教师菜单入口</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_menu_tea</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 显示 教师菜单</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">menu_man</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 管理员菜单入口</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_menu_man</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 显示 管理员菜单</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">log_out</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 登出的二次确认</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stu_order</span><span class="hljs-params">(Student* student)</span></span>;<span class="hljs-comment">// 预约机房</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">check_order</span><span class="hljs-params">(Student* student)</span></span>;<span class="hljs-comment">// 查看该账号的所有预约</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">check_all</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 查看所有预约</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">check_all_tbd</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 查看所有 未审核的预约</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">check_all_confirmed</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 查看所有 审核通过的预约（不包含被拒绝的预约）</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cancel</span><span class="hljs-params">(Student* student)</span></span>;<span class="hljs-comment">// 取消一条 未审核的预约</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">confirm</span><span class="hljs-params">(Teacher* t)</span></span>;<span class="hljs-comment">// 审核预约</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">confirm_it</span><span class="hljs-params">(<span class="hljs-type">int</span> num, <span class="hljs-type">bool</span> passed, Teacher* t)</span></span>;<span class="hljs-comment">// 审核预约的执行程序</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_account</span><span class="hljs-params">(Manager* m)</span></span>;<span class="hljs-comment">// 添加账号</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_accounts</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 展示全部账号</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change_account</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 修改一个账号的信息</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_rooms</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 展示全部机房</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear_history</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 清空预约记录</span></code></pre></div><h4 id="源文件">2 源文件：</h4><p><strong>room.cpp</strong></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;room.h&quot;</span></span>Room::<span class="hljs-built_in">Room</span>(<span class="hljs-type">int</span> seats) &#123;<span class="hljs-keyword">this</span>-&gt;seats = seats;<span class="hljs-keyword">this</span>-&gt;name = <span class="hljs-string">&quot;机房&quot;</span> + <span class="hljs-built_in">to_string</span>(++m_name_count);        <span class="hljs-comment">/* 实例化时，自动将自身放入 Room::rooms 房间集 */</span>rooms-&gt;<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">this</span>);&#125;;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Room::add_request</span><span class="hljs-params">(List* list)</span> </span>&#123;list-&gt;room = <span class="hljs-keyword">this</span>;        <span class="hljs-comment">/* 同一账号不能重复添加内容完全相同的请求 */</span><span class="hljs-keyword">for</span> (vector&lt;List*&gt;::const_iterator i = <span class="hljs-keyword">this</span>-&gt;tbd.<span class="hljs-built_in">begin</span>(); i != <span class="hljs-keyword">this</span>-&gt;tbd.<span class="hljs-built_in">end</span>(); i++) &#123;List* temp = *i;<span class="hljs-keyword">if</span> (temp-&gt;requester == list-&gt;requester &amp;&amp; temp-&gt;date == list-&gt;date &amp;&amp; temp-&gt;time == list-&gt;time) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;&#125;        <span class="hljs-comment">/* 如果指定机房在指定时段已被占用，直接拒绝该请求 */</span><span class="hljs-keyword">for</span> (vector&lt;List*&gt;::const_iterator i = <span class="hljs-keyword">this</span>-&gt;confirmed.<span class="hljs-built_in">begin</span>(); i != <span class="hljs-keyword">this</span>-&gt;confirmed.<span class="hljs-built_in">end</span>(); i++) &#123;List* temp = *i;<span class="hljs-keyword">if</span> (temp-&gt;state &gt; <span class="hljs-number">0</span> &amp;&amp; temp-&gt;date == list-&gt;date &amp;&amp; temp-&gt;time == list-&gt;time) &#123;            <span class="hljs-comment">/* 向该请求添加错误信息 */</span>list-&gt;<span class="hljs-built_in">confirm</span>(<span class="hljs-literal">false</span>, Person::reject_has_existed);confirmed.<span class="hljs-built_in">push_back</span>(list);<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;&#125;        <span class="hljs-comment">/* 检查通过后，将该请求放入 待审核集 */</span><span class="hljs-keyword">this</span>-&gt;tbd.<span class="hljs-built_in">push_back</span>(list);<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Room::confirm_request</span><span class="hljs-params">(vector&lt;List*&gt;::const_iterator r, <span class="hljs-type">bool</span> passed, Teacher* t，<span class="hljs-type">bool</span> link)</span></span>&#123;    <span class="hljs-comment">/* 这是正在审核的预约对象 */</span>List* list = *r;    <span class="hljs-comment">/* 如果审核结果是通过，那么有必要同时拒绝所有其他相同时间的未审核预定 */</span><span class="hljs-keyword">if</span> (passed) link = <span class="hljs-literal">true</span>;    <span class="hljs-comment">/* 从 未审核集 中移除该预约 */</span>tbd.<span class="hljs-built_in">erase</span>(r);        <span class="hljs-comment">/* 在 已审核集 中进行搜索。时间安排如有冲突则直接拒绝 */</span><span class="hljs-keyword">for</span> (vector&lt;List*&gt;::const_iterator i = confirmed.<span class="hljs-built_in">begin</span>(); i != confirmed.<span class="hljs-built_in">end</span>(); i++) &#123;List* temp = *i;<span class="hljs-keyword">if</span> (temp-&gt;state &gt; <span class="hljs-number">0</span> &amp;&amp; temp-&gt;date == list-&gt;date &amp;&amp; temp-&gt;time == list-&gt;time) &#123;            <span class="hljs-comment">/* 向该请求添加错误信息 */</span>list-&gt;<span class="hljs-built_in">confirm</span>(<span class="hljs-literal">false</span>, Person::reject_has_existed);confirmed.<span class="hljs-built_in">push_back</span>(list);<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;&#125;        <span class="hljs-comment">/* 更新该预约的审核状态 */</span>list-&gt;<span class="hljs-built_in">confirm</span>(passed, t);        <span class="hljs-comment">/* 认为需要拒绝其他请求时，递归调用此方法，直至拒绝了全部请求 */</span><span class="hljs-keyword">if</span> (link) &#123;<span class="hljs-keyword">for</span> (vector&lt;List*&gt;::const_iterator i = tbd.<span class="hljs-built_in">begin</span>(); i != tbd.<span class="hljs-built_in">end</span>(); i++) &#123;List* temp = *i;<span class="hljs-keyword">if</span> (temp-&gt;date == list-&gt;date &amp;&amp; temp-&gt;time == list-&gt;time) &#123;<span class="hljs-built_in">confirm_request</span>(i, <span class="hljs-literal">false</span>, t, <span class="hljs-literal">true</span>);<span class="hljs-keyword">break</span>;&#125;&#125;&#125;        <span class="hljs-comment">/* 不需要拒绝其他请求时，将该预约添加到 已审核集。 */</span><span class="hljs-keyword">this</span>-&gt;confirmed.<span class="hljs-built_in">push_back</span>(list);<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;;<span class="hljs-comment">/* 清空该机房所有预定记录 */</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Room::clear</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">for</span> (vector&lt;List*&gt;::const_iterator i = confirmed.<span class="hljs-built_in">begin</span>(); i != confirmed.<span class="hljs-built_in">end</span>(); i++) &#123;<span class="hljs-keyword">delete</span>* i;&#125;confirmed.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span> (vector&lt;List*&gt;::const_iterator i = tbd.<span class="hljs-built_in">begin</span>(); i != tbd.<span class="hljs-built_in">end</span>(); i++) &#123;<span class="hljs-keyword">delete</span>* i;&#125;tbd.<span class="hljs-built_in">clear</span>();    tbd.<span class="hljs-built_in">swap</span>(confirm);&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Room::showAllTBD</span><span class="hljs-params">()</span></span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;机房：&quot;</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;待确认申请如下：&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;申请人ID\t姓名\t日期\t时段\t申请状态\t审核ID\t审核姓名&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">for</span> (vector&lt;List*&gt;::const_iterator i = tbd.<span class="hljs-built_in">begin</span>(); i != tbd.<span class="hljs-built_in">end</span>(); i++) &#123;List* temp = *i;cout &lt;&lt; temp-&gt;<span class="hljs-built_in">print</span>() &lt;&lt; endl;&#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Room::showAllD</span><span class="hljs-params">()</span></span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;机房：&quot;</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;已完成申请如下：&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;申请人ID\t姓名\t日期\t时段\t申请状态\t审核ID\t审核姓名&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">for</span> (vector&lt;List*&gt;::const_iterator i = confirmed.<span class="hljs-built_in">begin</span>(); i != confirmed.<span class="hljs-built_in">end</span>(); i++) &#123;List* temp = *i;cout &lt;&lt; temp-&gt;<span class="hljs-built_in">print</span>() &lt;&lt; endl;&#125;&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Room::getSeat</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;seats;&#125;;<span class="hljs-function">string <span class="hljs-title">Room::getName</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;name;&#125;;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Room::cancel</span><span class="hljs-params">(vector&lt;List*&gt;::const_iterator tar)</span> </span>&#123;<span class="hljs-keyword">this</span>-&gt;tbd.<span class="hljs-built_in">erase</span>(tar);<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;;List::<span class="hljs-built_in">List</span>(<span class="hljs-type">int</span> date, <span class="hljs-type">bool</span> time, Student* s) &#123;<span class="hljs-keyword">this</span>-&gt;date = date;<span class="hljs-keyword">this</span>-&gt;time = time;<span class="hljs-keyword">this</span>-&gt;requester = s;<span class="hljs-keyword">this</span>-&gt;state = <span class="hljs-number">0</span>;<span class="hljs-keyword">this</span>-&gt;confirmer = <span class="hljs-literal">NULL</span>;<span class="hljs-keyword">this</span>-&gt;room = <span class="hljs-literal">NULL</span>;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">List::confirm</span><span class="hljs-params">(<span class="hljs-type">bool</span> pass, Person* t)</span> </span>&#123;<span class="hljs-keyword">this</span>-&gt;confirmer = t;<span class="hljs-keyword">if</span> (pass) <span class="hljs-keyword">this</span>-&gt;state = <span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">this</span>-&gt;state = <span class="hljs-number">-1</span>;&#125;;<span class="hljs-function">string <span class="hljs-title">List::print</span><span class="hljs-params">()</span> </span>&#123;string ret = requester-&gt;<span class="hljs-built_in">print</span>() + <span class="hljs-string">&quot;\t周&quot;</span> + <span class="hljs-built_in">to_string</span>(date) + <span class="hljs-string">&quot;\t&quot;</span> + (time ? <span class="hljs-string">&quot;上午&quot;</span> : <span class="hljs-string">&quot;下午&quot;</span>) + <span class="hljs-string">&quot;\t&quot;</span>;<span class="hljs-keyword">if</span> (state == <span class="hljs-number">0</span>) &#123;ret += <span class="hljs-string">&quot;审核中&quot;</span>;&#125;<span class="hljs-keyword">else</span> &#123;ret += (state &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;通过&quot;</span> : <span class="hljs-string">&quot;拒绝&quot;</span>);ret += <span class="hljs-string">&quot;\t&quot;</span> + confirmer-&gt;<span class="hljs-built_in">print</span>();&#125;<span class="hljs-keyword">return</span> ret;&#125;;<span class="hljs-type">int</span> Room::m_name_count = <span class="hljs-number">0</span>;vector&lt;Room*&gt;* Room::rooms = <span class="hljs-keyword">new</span> vector&lt;Room*&gt;;</code></pre></div><p><strong>person.cpp</strong></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;person.h&quot;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Person::getID</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> id;&#125;<span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">Person::getSign</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> sign;&#125;<span class="hljs-function">string <span class="hljs-title">Person::getName</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> name;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Person::setName</span><span class="hljs-params">(string name)</span> </span>&#123;<span class="hljs-keyword">this</span>-&gt;name = name;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Person::setID</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;<span class="hljs-keyword">this</span>-&gt;id = id;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Person::setPW</span><span class="hljs-params">(string ne)</span> </span>&#123;password = ne;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Person::checkPW</span><span class="hljs-params">(string pw)</span> </span>&#123;<span class="hljs-keyword">return</span> pw == password;&#125;<span class="hljs-function">string <span class="hljs-title">Person::print</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">to_string</span>(id) + <span class="hljs-string">&quot;\t&quot;</span> + name;&#125;;Person::<span class="hljs-built_in">Person</span>()&#123;&#125;;Person::<span class="hljs-built_in">Person</span>(string name, <span class="hljs-type">int</span> id) &#123;<span class="hljs-keyword">this</span>-&gt;name = name;<span class="hljs-keyword">this</span>-&gt;id = id;<span class="hljs-keyword">this</span>-&gt;sign = <span class="hljs-string">&#x27;W&#x27;</span>;&#125;;Manager::<span class="hljs-built_in">Manager</span>(string name, string pw) &#123;<span class="hljs-keyword">this</span>-&gt;name = name;<span class="hljs-keyword">this</span>-&gt;id = m_id_count;<span class="hljs-keyword">this</span>-&gt;password = pw;<span class="hljs-keyword">this</span>-&gt;sign = <span class="hljs-string">&#x27;M&#x27;</span>;&#125;;Student::<span class="hljs-built_in">Student</span>(string name, string pw) &#123;<span class="hljs-keyword">this</span>-&gt;name = name;<span class="hljs-keyword">this</span>-&gt;id = ++m_id_count;<span class="hljs-keyword">this</span>-&gt;password = pw;<span class="hljs-keyword">this</span>-&gt;sign = <span class="hljs-string">&#x27;S&#x27;</span>;        <span class="hljs-comment">/* 实例化学生对象时，该对象会被自动添加到 学生集 */</span>Student::ss-&gt;<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">this</span>);&#125;;Teacher::<span class="hljs-built_in">Teacher</span>(string name, string pw) &#123;<span class="hljs-keyword">this</span>-&gt;name = name;<span class="hljs-keyword">this</span>-&gt;id = ++m_id_count;<span class="hljs-keyword">this</span>-&gt;password = pw;<span class="hljs-keyword">this</span>-&gt;sign = <span class="hljs-string">&#x27;T&#x27;</span>;        <span class="hljs-comment">/* 实例化教师对象时，该对象会被自动添加到 教师集 */</span>Teacher::ss-&gt;<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">this</span>);&#125;;<span class="hljs-function">List* <span class="hljs-title">Student::order</span><span class="hljs-params">(<span class="hljs-type">int</span> date, <span class="hljs-type">bool</span> time)</span> </span>&#123;List* order = <span class="hljs-keyword">new</span> <span class="hljs-built_in">List</span>(date, time, <span class="hljs-keyword">this</span>);<span class="hljs-keyword">return</span> order;&#125;<span class="hljs-function">List* <span class="hljs-title">Teacher::confirm</span><span class="hljs-params">(List* l, <span class="hljs-type">bool</span> b)</span> </span>&#123;l-&gt;<span class="hljs-built_in">confirm</span>(b, <span class="hljs-keyword">this</span>);<span class="hljs-keyword">return</span> l;&#125;;<span class="hljs-function">vector&lt;Student*&gt;* <span class="hljs-title">Student::all</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> ss;&#125;;<span class="hljs-function">Manager* <span class="hljs-title">Manager::getManager</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> ss;&#125;;<span class="hljs-function">vector&lt;Teacher*&gt;* <span class="hljs-title">Teacher::all</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> ss;&#125;;<span class="hljs-function">Student* <span class="hljs-title">Student::find</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;<span class="hljs-keyword">for</span> (vector&lt;Student*&gt;::const_iterator i = ss-&gt;<span class="hljs-built_in">begin</span>(); i != ss-&gt;<span class="hljs-built_in">end</span>(); i++) &#123;Student* temp = *i;<span class="hljs-keyword">if</span> (temp-&gt;id == id) &#123;<span class="hljs-keyword">return</span> temp;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125;;<span class="hljs-function">Student* <span class="hljs-title">Student::find</span><span class="hljs-params">(string name)</span> </span>&#123;<span class="hljs-keyword">for</span> (vector&lt;Student*&gt;::const_iterator i = ss-&gt;<span class="hljs-built_in">begin</span>(); i != ss-&gt;<span class="hljs-built_in">end</span>(); i++) &#123;Student* temp = *i;<span class="hljs-keyword">if</span> (temp-&gt;name == name) &#123;<span class="hljs-keyword">return</span> temp;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125;;<span class="hljs-function">Teacher* <span class="hljs-title">Teacher::find</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;<span class="hljs-keyword">for</span> (vector&lt;Teacher*&gt;::const_iterator i = ss-&gt;<span class="hljs-built_in">begin</span>(); i != ss-&gt;<span class="hljs-built_in">end</span>(); i++) &#123;Teacher* temp = *i;<span class="hljs-keyword">if</span> (temp-&gt;id == id) &#123;<span class="hljs-keyword">return</span> temp;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125;;<span class="hljs-function">Teacher* <span class="hljs-title">Teacher::find</span><span class="hljs-params">(string name)</span> </span>&#123;<span class="hljs-keyword">for</span> (vector&lt;Teacher*&gt;::const_iterator i = ss-&gt;<span class="hljs-built_in">begin</span>(); i != ss-&gt;<span class="hljs-built_in">end</span>(); i++) &#123;Teacher* temp = *i;<span class="hljs-keyword">if</span> (temp-&gt;name == name) &#123;<span class="hljs-keyword">return</span> temp;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125;;<span class="hljs-function">Person* <span class="hljs-title">Manager::createAccount</span><span class="hljs-params">(<span class="hljs-type">char</span> identity, string name, string pw)</span> </span>&#123;Person* get;<span class="hljs-keyword">switch</span> (identity) &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;S&#x27;</span>:get = Student::<span class="hljs-built_in">find</span>(name);<span class="hljs-keyword">if</span> (get != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Student</span>(name, pw);&#125;<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;T&#x27;</span>:get = Teacher::<span class="hljs-built_in">find</span>(name);<span class="hljs-keyword">if</span> (get != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Teacher</span>(name, pw);&#125;<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;M&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-keyword">default</span>:<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125;&#125;;<span class="hljs-comment">/* 以下是一些静态变量的初始化 */</span>Person* Person::reject_has_existed = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Person</span>(<span class="hljs-string">&quot;机房已被占用&quot;</span>, <span class="hljs-number">-9001</span>);<span class="hljs-comment">// 错误信息</span>vector&lt;Student*&gt;* Student::ss = <span class="hljs-keyword">new</span> vector&lt;Student*&gt;;<span class="hljs-comment">// 学生集</span>Manager* Manager::ss = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Manager</span>(<span class="hljs-string">&quot;Heruin&quot;</span>, <span class="hljs-string">&quot;000000&quot;</span>);<span class="hljs-comment">// 管理员初始化</span>vector&lt;Teacher*&gt;* Teacher::ss = <span class="hljs-keyword">new</span> vector&lt;Teacher*&gt;;<span class="hljs-comment">// 教师集</span><span class="hljs-type">int</span> Manager::m_id_count = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> Student::m_id_count = <span class="hljs-number">300000</span>;<span class="hljs-type">int</span> Teacher::m_id_count = <span class="hljs-number">100000</span>;</code></pre></div><p><strong>menu.cpp</strong></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;menu.h&quot;</span></span>Person* user = <span class="hljs-literal">NULL</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testing_initial</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// 初始化了一些账号和机房，以便测试之用</span><span class="hljs-keyword">new</span> <span class="hljs-built_in">Student</span>(<span class="hljs-string">&quot;胡桃&quot;</span>, <span class="hljs-string">&quot;000000&quot;</span>);<span class="hljs-keyword">new</span> <span class="hljs-built_in">Student</span>(<span class="hljs-string">&quot;香菱&quot;</span>, <span class="hljs-string">&quot;000000&quot;</span>);<span class="hljs-keyword">new</span> <span class="hljs-built_in">Student</span>(<span class="hljs-string">&quot;行秋&quot;</span>, <span class="hljs-string">&quot;000000&quot;</span>);<span class="hljs-keyword">new</span> <span class="hljs-built_in">Student</span>(<span class="hljs-string">&quot;重云&quot;</span>, <span class="hljs-string">&quot;000000&quot;</span>);<span class="hljs-keyword">new</span> <span class="hljs-built_in">Teacher</span>(<span class="hljs-string">&quot;甘雨&quot;</span>, <span class="hljs-string">&quot;000000&quot;</span>);<span class="hljs-keyword">new</span> <span class="hljs-built_in">Teacher</span>(<span class="hljs-string">&quot;凝光&quot;</span>, <span class="hljs-string">&quot;000000&quot;</span>);<span class="hljs-keyword">new</span> <span class="hljs-built_in">Room</span>(<span class="hljs-number">15</span>);<span class="hljs-keyword">new</span> <span class="hljs-built_in">Room</span>(<span class="hljs-number">20</span>);<span class="hljs-keyword">new</span> <span class="hljs-built_in">Room</span>(<span class="hljs-number">40</span>);&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">menu0</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">testing_initial</span>();<span class="hljs-comment">/* initial for test only */</span><span class="hljs-type">bool</span> running = <span class="hljs-literal">true</span>;<span class="hljs-keyword">while</span> (running) &#123;<span class="hljs-built_in">show_menu0</span>();cout &lt;&lt; <span class="hljs-string">&quot;请选择：&quot;</span>;<span class="hljs-type">int</span> choice = <span class="hljs-number">0</span>;cin &gt;&gt; choice;<span class="hljs-keyword">if</span> (choice &gt; <span class="hljs-number">0</span> &amp;&amp; choice &lt; <span class="hljs-number">4</span>) &#123;user = <span class="hljs-built_in">log_in</span>(choice);<span class="hljs-keyword">if</span> (user == <span class="hljs-literal">NULL</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;登录失败&quot;</span> &lt;&lt; endl;<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;cls&quot;</span>);<span class="hljs-keyword">continue</span>;&#125;&#125;<span class="hljs-keyword">switch</span> (choice) &#123;<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;cls&quot;</span>);<span class="hljs-built_in">menu_stu</span>();<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;cls&quot;</span>);<span class="hljs-built_in">menu_tea</span>();<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;cls&quot;</span>);<span class="hljs-built_in">menu_man</span>();<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:<span class="hljs-keyword">if</span> (<span class="hljs-built_in">log_out</span>()) &#123;running = <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">default</span>:cout &lt;&lt; <span class="hljs-string">&quot;输入有误，请重新输入&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">break</span>;&#125;user = <span class="hljs-literal">NULL</span>;<span class="hljs-keyword">if</span> (running) <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;cls&quot;</span>);&#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_menu0</span><span class="hljs-params">()</span> </span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;—————机房预约系统（登陆页面）—————&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;\t\t1 学 生 登 录&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;\t\t2 教 师 登 录&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;\t\t3 管 理 员 登 录&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;\t\t9 退 出 系 统&quot;</span> &lt;&lt; endl;&#125;;<span class="hljs-function">Person* <span class="hljs-title">log_in</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;——————————&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;请输入 ID：&quot;</span>;<span class="hljs-type">int</span> id;cin &gt;&gt; id;cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;请输入密码：&quot;</span>;string pw;cin &gt;&gt; pw;<span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;Student* ts = Student::<span class="hljs-built_in">find</span>(id);<span class="hljs-keyword">if</span> (ts == <span class="hljs-literal">NULL</span> || !ts-&gt;<span class="hljs-built_in">checkPW</span>(pw)) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> ts;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) &#123;Teacher* ts = Teacher::<span class="hljs-built_in">find</span>(id);<span class="hljs-keyword">if</span> (ts == <span class="hljs-literal">NULL</span> || !ts-&gt;<span class="hljs-built_in">checkPW</span>(pw)) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> ts;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">3</span>) &#123;Manager* manager = Manager::<span class="hljs-built_in">getManager</span>();<span class="hljs-keyword">if</span> (id == manager-&gt;<span class="hljs-built_in">getID</span>() &amp;&amp; manager-&gt;<span class="hljs-built_in">checkPW</span>(pw)) &#123;<span class="hljs-keyword">return</span> manager;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">menu_stu</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">bool</span> running = <span class="hljs-literal">true</span>;Student* student = (Student*)user;<span class="hljs-keyword">while</span> (running) &#123;<span class="hljs-built_in">show_menu_stu</span>();cout &lt;&lt; <span class="hljs-string">&quot;请选择：&quot;</span>;<span class="hljs-type">int</span> choice;cin &gt;&gt; choice;<span class="hljs-keyword">switch</span> (choice) &#123;<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<span class="hljs-built_in">stu_order</span>(student);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<span class="hljs-built_in">check_order</span>(student);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<span class="hljs-built_in">check_all</span>();<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<span class="hljs-built_in">cancel</span>(student);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:<span class="hljs-keyword">if</span> (<span class="hljs-built_in">log_out</span>()) &#123;running = <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">default</span>:cout &lt;&lt; <span class="hljs-string">&quot;输入有误&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">if</span> (running) <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;cls&quot;</span>);&#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_menu_stu</span><span class="hljs-params">()</span> </span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;————机房预约系统（学生端：&quot;</span> &lt;&lt; user-&gt;<span class="hljs-built_in">getID</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; user-&gt;<span class="hljs-built_in">getName</span>() &lt;&lt; <span class="hljs-string">&quot;）————&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;\t\t1 预 约 机 房&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;\t\t2 预 约 查 询&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;\t\t3 机 房 状 态 查 询&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;\t\t4 取 消 预 约&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;\t\t9 注 销 登 录&quot;</span> &lt;&lt; endl;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">menu_tea</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">bool</span> running = <span class="hljs-literal">true</span>;Teacher* teacher = (Teacher*)user;<span class="hljs-keyword">while</span> (running) &#123;<span class="hljs-built_in">show_menu_tea</span>();cout &lt;&lt; <span class="hljs-string">&quot;请选择：&quot;</span>;<span class="hljs-type">int</span> choice = <span class="hljs-number">0</span>;cin &gt;&gt; choice;<span class="hljs-keyword">switch</span> (choice) &#123;<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<span class="hljs-built_in">check_all</span>();<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<span class="hljs-built_in">confirm</span>(teacher);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:<span class="hljs-keyword">if</span> (<span class="hljs-built_in">log_out</span>()) &#123;running = <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">default</span>:cout &lt;&lt; <span class="hljs-string">&quot;输入有误&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">if</span> (running) <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;cls&quot;</span>);&#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_menu_tea</span><span class="hljs-params">()</span> </span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;————机房预约系统（教师端：&quot;</span> &lt;&lt; user-&gt;<span class="hljs-built_in">getID</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; user-&gt;<span class="hljs-built_in">getName</span>() &lt;&lt; <span class="hljs-string">&quot;）————&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;\t\t1 查 看 预 约&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;\t\t2 审 核 查 询&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;\t\t9 注 销 登 录&quot;</span> &lt;&lt; endl;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">menu_man</span><span class="hljs-params">()</span> </span>&#123;Manager* manager = (Manager*)user;<span class="hljs-type">bool</span> running = <span class="hljs-literal">true</span>;<span class="hljs-keyword">while</span> (running) &#123;<span class="hljs-built_in">show_menu_man</span>();cout &lt;&lt; <span class="hljs-string">&quot;请选择：&quot;</span>;<span class="hljs-type">int</span> choice = <span class="hljs-number">0</span>;cin &gt;&gt; choice;<span class="hljs-keyword">switch</span> (choice) &#123;<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<span class="hljs-built_in">add_account</span>(manager);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<span class="hljs-built_in">show_accounts</span>();<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<span class="hljs-built_in">change_account</span>();<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<span class="hljs-built_in">show_rooms</span>();<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<span class="hljs-built_in">clear_history</span>();<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:<span class="hljs-keyword">if</span> (<span class="hljs-built_in">log_out</span>()) &#123;running = <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">default</span>:cout &lt;&lt; <span class="hljs-string">&quot;输入有误&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">if</span> (running) <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;cls&quot;</span>);&#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_menu_man</span><span class="hljs-params">()</span> </span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;————机房预约系统（管理员：&quot;</span> &lt;&lt; user-&gt;<span class="hljs-built_in">getID</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; user-&gt;<span class="hljs-built_in">getName</span>() &lt;&lt; <span class="hljs-string">&quot;）————&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;\t\t1 添 加 账 号&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;\t\t2 查 看 账 号&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;\t\t3 修 改 账 号&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;\t\t4 查 看 机 房&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;\t\t5 清 空 记 录&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;\t\t9 注 销 登 录&quot;</span> &lt;&lt; endl;&#125;;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">log_out</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">char</span> confirm = <span class="hljs-string">&#x27;N&#x27;</span>;cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;确定要退出吗？（Y / N）：&quot;</span>;cin &gt;&gt; confirm;<span class="hljs-keyword">if</span> (confirm == <span class="hljs-string">&#x27;Y&#x27;</span> || confirm == <span class="hljs-string">&#x27;y&#x27;</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stu_order</span><span class="hljs-params">(Student* student)</span> </span>&#123;cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;============预 定 机 房============&quot;</span> &lt;&lt; endl;<span class="hljs-built_in">show_rooms</span>();cout &lt;&lt; <span class="hljs-string">&quot;请输入要预定的机房序号：&quot;</span>;<span class="hljs-type">int</span> room = <span class="hljs-number">0</span>;cin &gt;&gt; room;room--;<span class="hljs-keyword">if</span> (room &gt;= Room::rooms-&gt;<span class="hljs-built_in">size</span>() || room &lt; <span class="hljs-number">0</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;输入错误：不存在的机房&quot;</span> &lt;&lt; endl;&#125;cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;请输入要预定的日期（周一 到 周末）&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;输入 1 - 7 的数字：&quot;</span>;<span class="hljs-type">int</span> date = <span class="hljs-number">0</span>;cin &gt;&gt; date;<span class="hljs-keyword">if</span> (date &lt; <span class="hljs-number">1</span> || date &gt; <span class="hljs-number">7</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;输入错误：日期需是 1 - 7 的整数&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-type">char</span> time = <span class="hljs-string">&#x27;P&#x27;</span>;cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;请输入要预定的时间段（N 上午/ A 下午）：&quot;</span>;cin &gt;&gt; time;<span class="hljs-type">bool</span> t = <span class="hljs-literal">true</span>;<span class="hljs-keyword">if</span> (time == <span class="hljs-string">&#x27;N&#x27;</span> || time == <span class="hljs-string">&#x27;n&#x27;</span>) &#123;t = <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (time == <span class="hljs-string">&#x27;A&#x27;</span> || time == <span class="hljs-string">&#x27;a&#x27;</span>) &#123;t = <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;输入错误：只能是上午（N）或下午（A）&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">return</span>;&#125;Room* temp = Room::rooms-&gt;<span class="hljs-built_in">at</span>(room);<span class="hljs-keyword">if</span> (temp-&gt;<span class="hljs-built_in">add_request</span>(student-&gt;<span class="hljs-built_in">order</span>(date, t))) &#123;cout &lt;&lt; <span class="hljs-string">&quot;预定提交成功&quot;</span> &lt;&lt; endl;&#125;<span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;预定提交失败&quot;</span> &lt;&lt; endl;&#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">check_order</span><span class="hljs-params">(Student* student)</span> </span>&#123;cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;============预 定 查 询============&quot;</span> &lt;&lt; endl;<span class="hljs-type">int</span> count = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (vector&lt;Room*&gt;::const_iterator i = Room::rooms-&gt;<span class="hljs-built_in">begin</span>(); i != Room::rooms-&gt;<span class="hljs-built_in">end</span>(); i++) &#123;Room* temp_room = *i;cout &lt;&lt; <span class="hljs-string">&quot;☆·&quot;</span> &lt;&lt; temp_room-&gt;<span class="hljs-built_in">getName</span>() &lt;&lt; endl;<span class="hljs-keyword">for</span> (vector&lt;List*&gt;::const_iterator il = temp_room-&gt;tbd.<span class="hljs-built_in">begin</span>(); il != temp_room-&gt;tbd.<span class="hljs-built_in">end</span>(); il++) &#123;List* temp = *il;<span class="hljs-keyword">if</span> (temp-&gt;requester == student) &#123;cout &lt;&lt; <span class="hljs-string">&quot;\t&lt;&quot;</span> &lt;&lt; count++ &lt;&lt; <span class="hljs-string">&quot;&gt; &quot;</span> &lt;&lt; temp-&gt;<span class="hljs-built_in">print</span>() &lt;&lt; endl;&#125;&#125;<span class="hljs-keyword">for</span> (vector&lt;List*&gt;::const_iterator il = temp_room-&gt;confirmed.<span class="hljs-built_in">begin</span>(); il != temp_room-&gt;confirmed.<span class="hljs-built_in">end</span>(); il++) &#123;List* temp = *il;<span class="hljs-keyword">if</span> (temp-&gt;requester == student) &#123;cout &lt;&lt; <span class="hljs-string">&quot;\t&lt;&quot;</span> &lt;&lt; count++ &lt;&lt; <span class="hljs-string">&quot;&gt; &quot;</span> &lt;&lt; temp-&gt;<span class="hljs-built_in">print</span>() &lt;&lt; (temp -&gt; state &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;\t★&quot;</span> : <span class="hljs-string">&quot;\t☆&quot;</span>) &lt;&lt; endl;&#125;&#125;&#125;&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">check_all</span><span class="hljs-params">()</span> </span>&#123;cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;============查 看 全 部 预 约============&quot;</span> &lt;&lt; endl;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;ret += <span class="hljs-built_in">check_all_tbd</span>();cout &lt;&lt; endl;ret += <span class="hljs-built_in">check_all_confirmed</span>();<span class="hljs-keyword">return</span> ret;&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">check_all_tbd</span><span class="hljs-params">()</span> </span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;==============待 审 核 预 约=============&quot;</span> &lt;&lt; endl;<span class="hljs-type">int</span> count = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (vector&lt;Room*&gt;::const_iterator i = Room::rooms-&gt;<span class="hljs-built_in">begin</span>(); i != Room::rooms-&gt;<span class="hljs-built_in">end</span>(); i++) &#123;Room* temp_room = *i;cout &lt;&lt; <span class="hljs-string">&quot;☆·&quot;</span> &lt;&lt; temp_room-&gt;<span class="hljs-built_in">getName</span>() &lt;&lt; endl;<span class="hljs-keyword">for</span> (vector&lt;List*&gt;::const_iterator il = temp_room-&gt;tbd.<span class="hljs-built_in">begin</span>(); il != temp_room-&gt;tbd.<span class="hljs-built_in">end</span>(); il++) &#123;List* temp = *il;cout &lt;&lt; <span class="hljs-string">&quot;\t&lt;&quot;</span> &lt;&lt; count++ &lt;&lt; <span class="hljs-string">&quot;&gt; &quot;</span> &lt;&lt; temp-&gt;<span class="hljs-built_in">print</span>() &lt;&lt; endl;&#125;&#125;<span class="hljs-keyword">return</span> count - <span class="hljs-number">1</span>;&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">check_all_confirmed</span><span class="hljs-params">()</span> </span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;==============已 通 过 预 约=============&quot;</span> &lt;&lt; endl;<span class="hljs-type">int</span> count = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (vector&lt;Room*&gt;::const_iterator i = Room::rooms-&gt;<span class="hljs-built_in">begin</span>(); i != Room::rooms-&gt;<span class="hljs-built_in">end</span>(); i++) &#123;Room* temp_room = *i;cout &lt;&lt; <span class="hljs-string">&quot;★·&quot;</span> &lt;&lt; temp_room-&gt;<span class="hljs-built_in">getName</span>() &lt;&lt; endl;<span class="hljs-keyword">for</span> (vector&lt;List*&gt;::const_iterator il = temp_room-&gt;confirmed.<span class="hljs-built_in">begin</span>(); il != temp_room-&gt;confirmed.<span class="hljs-built_in">end</span>(); il++) &#123;List* temp = *il;<span class="hljs-keyword">if</span> (temp-&gt;state &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;cout &lt;&lt; <span class="hljs-string">&quot;\t&lt;&quot;</span> &lt;&lt; count++ &lt;&lt; <span class="hljs-string">&quot;&gt; &quot;</span> &lt;&lt; temp-&gt;<span class="hljs-built_in">print</span>() &lt;&lt; endl;&#125;&#125;<span class="hljs-keyword">return</span> count - <span class="hljs-number">1</span>;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cancel</span><span class="hljs-params">(Student* student)</span> </span>&#123;cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;============取 消 预 定===========&quot;</span> &lt;&lt; endl;<span class="hljs-type">int</span> n = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (vector&lt;Room*&gt;::const_iterator i = Room::rooms-&gt;<span class="hljs-built_in">begin</span>(); i != Room::rooms-&gt;<span class="hljs-built_in">end</span>(); i++) &#123;Room* temp_room = *i;cout &lt;&lt; <span class="hljs-string">&quot;☆·&quot;</span> &lt;&lt; temp_room-&gt;<span class="hljs-built_in">getName</span>() &lt;&lt; endl;<span class="hljs-keyword">for</span> (vector&lt;List*&gt;::const_iterator il = temp_room-&gt;tbd.<span class="hljs-built_in">begin</span>(); il != temp_room-&gt;tbd.<span class="hljs-built_in">end</span>(); il++) &#123;List* temp = *il;<span class="hljs-keyword">if</span> (temp-&gt;requester == student) &#123;cout &lt;&lt; <span class="hljs-string">&quot;\t&lt;&quot;</span> &lt;&lt; n++ &lt;&lt; <span class="hljs-string">&quot;&gt; &quot;</span> &lt;&lt; temp-&gt;<span class="hljs-built_in">print</span>() &lt;&lt; endl;&#125;&#125;&#125;cout &lt;&lt; <span class="hljs-string">&quot;请输入要取消的订单号：&quot;</span>;<span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;cin &gt;&gt; num;<span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">1</span> || num &gt; n) &#123;cout &lt;&lt; <span class="hljs-string">&quot;输入有误：（输入值 &quot;</span> &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot;，订单号范围 &quot;</span> &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot; - &quot;</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot;）&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">return</span>;&#125;n = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (vector&lt;Room*&gt;::const_iterator i = Room::rooms-&gt;<span class="hljs-built_in">begin</span>(); i != Room::rooms-&gt;<span class="hljs-built_in">end</span>(); i++) &#123;Room* temp_room = *i;<span class="hljs-keyword">for</span> (vector&lt;List*&gt;::const_iterator il = temp_room-&gt;tbd.<span class="hljs-built_in">begin</span>(); il != temp_room-&gt;tbd.<span class="hljs-built_in">end</span>(); il++) &#123;List* temp = *il;<span class="hljs-keyword">if</span> (temp-&gt;requester == student) &#123;<span class="hljs-keyword">if</span> (n == num) &#123;<span class="hljs-keyword">if</span> (temp_room-&gt;<span class="hljs-built_in">cancel</span>(il)) &#123;cout &lt;&lt; <span class="hljs-string">&quot;取消成功&quot;</span> &lt;&lt; endl;&#125;<span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;取消失败！&quot;</span> &lt;&lt; endl;&#125;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">else</span> &#123;n++;&#125;&#125;&#125;&#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">confirm</span><span class="hljs-params">(Teacher* t)</span> </span>&#123;cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;★============·审 核 预 约·===========★&quot;</span> &lt;&lt; endl;<span class="hljs-type">int</span> count = <span class="hljs-built_in">check_all_tbd</span>();<span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;当前没有要审核的预约&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">return</span>;&#125;cout &lt;&lt; <span class="hljs-string">&quot;输入要批复的预约编号：&quot;</span>;<span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;cin &gt;&gt; num;cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;是否批准？（Y / N）：&quot;</span>;<span class="hljs-type">char</span> con = <span class="hljs-string">&#x27;P&#x27;</span>;cin &gt;&gt; con;<span class="hljs-type">bool</span> done = <span class="hljs-literal">false</span>;<span class="hljs-keyword">switch</span> (con) &#123;<span class="hljs-keyword">case</span><span class="hljs-number">&#x27;</span>Y<span class="hljs-number">&#x27;</span>:<span class="hljs-keyword">case</span><span class="hljs-number">&#x27;</span>y<span class="hljs-number">&#x27;</span>:done = <span class="hljs-built_in">confirm_it</span>(num, <span class="hljs-literal">true</span>, t);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span><span class="hljs-number">&#x27;</span>n<span class="hljs-number">&#x27;</span>:<span class="hljs-keyword">case</span><span class="hljs-number">&#x27;</span>N<span class="hljs-number">&#x27;</span>:done = <span class="hljs-built_in">confirm_it</span>(num, <span class="hljs-literal">false</span>, t);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">default</span>:cout &lt;&lt; <span class="hljs-string">&quot;输入错误！&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">if</span> (done) &#123;cout &lt;&lt; <span class="hljs-string">&quot;审核成功&quot;</span> &lt;&lt; endl;&#125;<span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;审核失败！&quot;</span> &lt;&lt; endl;&#125;cout &lt;&lt; <span class="hljs-string">&quot;是否继续？（Y / N）：&quot;</span>;cin &gt;&gt; con;<span class="hljs-keyword">if</span> (con == <span class="hljs-string">&#x27;Y&#x27;</span> || con == <span class="hljs-string">&#x27;y&#x27;</span> || con == <span class="hljs-string">&#x27;1&#x27;</span>) <span class="hljs-built_in">confirm</span>(t);&#125;;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">confirm_it</span><span class="hljs-params">(<span class="hljs-type">int</span> num, <span class="hljs-type">bool</span> passed, Teacher* t)</span> </span>&#123;<span class="hljs-keyword">for</span> (vector&lt;Room*&gt;::const_iterator i = Room::rooms-&gt;<span class="hljs-built_in">begin</span>(); i != Room::rooms-&gt;<span class="hljs-built_in">end</span>(); i++) &#123;Room* temp_room = *i;<span class="hljs-keyword">for</span> (vector&lt;List*&gt;::const_iterator il = temp_room-&gt;tbd.<span class="hljs-built_in">begin</span>(); il != temp_room-&gt;tbd.<span class="hljs-built_in">end</span>(); il++) &#123;num--;<span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) &#123;temp_room-&gt;<span class="hljs-built_in">confirm_request</span>(il, passed, t);<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_account</span><span class="hljs-params">(Manager* m)</span> </span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;★=============·创 建 账 号·=============★&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;请输入姓名：&quot;</span>;string name = <span class="hljs-string">&quot;&quot;</span>;cin &gt;&gt; name;cout &lt;&lt; <span class="hljs-string">&quot;请输入初始密码：&quot;</span>;string pw = <span class="hljs-string">&quot;&quot;</span>;cin &gt;&gt; pw;cout &lt;&lt; <span class="hljs-string">&quot;要创建何种账号？（S 学生账号/ T 教师账号）：&quot;</span>;<span class="hljs-type">char</span> acc = <span class="hljs-string">&#x27;M&#x27;</span>;cin &gt;&gt; acc;Person* p = <span class="hljs-literal">NULL</span>;<span class="hljs-keyword">switch</span> (acc) &#123;<span class="hljs-keyword">case</span><span class="hljs-number">&#x27;</span>s<span class="hljs-number">&#x27;</span>:<span class="hljs-keyword">case</span><span class="hljs-number">&#x27;</span>S<span class="hljs-number">&#x27;</span>:p = m-&gt;<span class="hljs-built_in">createAccount</span>(<span class="hljs-string">&#x27;S&#x27;</span>, name, pw);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span><span class="hljs-number">&#x27;</span>T<span class="hljs-number">&#x27;</span>:<span class="hljs-keyword">case</span><span class="hljs-number">&#x27;</span>t<span class="hljs-number">&#x27;</span>:p = m-&gt;<span class="hljs-built_in">createAccount</span>(<span class="hljs-string">&#x27;T&#x27;</span>, name, pw);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span><span class="hljs-number">&#x27;</span>m<span class="hljs-number">&#x27;</span>:<span class="hljs-keyword">case</span><span class="hljs-number">&#x27;</span>M<span class="hljs-number">&#x27;</span>:p = m-&gt;<span class="hljs-built_in">createAccount</span>(<span class="hljs-string">&#x27;M&#x27;</span>, name, pw);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">default</span>:cout &lt;&lt; <span class="hljs-string">&quot;输入错误！&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;创建失败！&quot;</span> &lt;&lt; endl;&#125;<span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;创建成功：&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt;  p-&gt;<span class="hljs-built_in">print</span>() &lt;&lt; endl;&#125;cout &lt;&lt; <span class="hljs-string">&quot;继续吗？（Y / N）：&quot;</span>;cin &gt;&gt; acc;<span class="hljs-keyword">if</span> (acc == <span class="hljs-string">&#x27;y&#x27;</span> || acc == <span class="hljs-string">&#x27;Y&#x27;</span> || acc == <span class="hljs-string">&#x27;1&#x27;</span>) <span class="hljs-built_in">add_account</span>(m);&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_accounts</span><span class="hljs-params">()</span> </span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;=================显示全部账号=================&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;———————学 生 账 号———————&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">if</span> (Student::<span class="hljs-built_in">all</span>()-&gt;<span class="hljs-built_in">empty</span>()) &#123;cout &lt;&lt; <span class="hljs-string">&quot;\t\t 尚无学生账号&quot;</span> &lt;&lt; endl;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">for</span> (vector&lt;Student*&gt;::const_iterator i = Student::<span class="hljs-built_in">all</span>()-&gt;<span class="hljs-built_in">begin</span>(); i != Student::<span class="hljs-built_in">all</span>()-&gt;<span class="hljs-built_in">end</span>(); i++) &#123;Student* temp = *i;cout &lt;&lt; temp-&gt;<span class="hljs-built_in">print</span>() &lt;&lt; endl;&#125;&#125;cout &lt;&lt; <span class="hljs-string">&quot;———————教 师 账 号———————&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">if</span> (Teacher::<span class="hljs-built_in">all</span>()-&gt;<span class="hljs-built_in">empty</span>()) &#123;cout &lt;&lt; <span class="hljs-string">&quot;\t\t 尚无教师账号&quot;</span> &lt;&lt; endl;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">for</span> (vector&lt;Teacher*&gt;::const_iterator i = Teacher::<span class="hljs-built_in">all</span>()-&gt;<span class="hljs-built_in">begin</span>(); i != Teacher::<span class="hljs-built_in">all</span>()-&gt;<span class="hljs-built_in">end</span>(); i++) &#123;Teacher* temp = *i;cout &lt;&lt; temp-&gt;<span class="hljs-built_in">print</span>() &lt;&lt; endl;&#125;&#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change_account</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">show_accounts</span>();cout &lt;&lt; <span class="hljs-string">&quot;★=============·修改账号信息·=============★&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;请输入更改账号的类别（S 学生账号/ T 教师账号）：&quot;</span>;<span class="hljs-type">char</span> acc = <span class="hljs-string">&#x27;M&#x27;</span>;cin &gt;&gt; acc;cout &lt;&lt; <span class="hljs-string">&quot;请输入账号 ID：&quot;</span>;<span class="hljs-type">int</span> id = <span class="hljs-number">0</span>;cin &gt;&gt; id;Person* account = <span class="hljs-literal">NULL</span>;<span class="hljs-keyword">switch</span> (acc) &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>:<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;S&#x27;</span>:account = Student::<span class="hljs-built_in">find</span>(id);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;t&#x27;</span>:<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;T&#x27;</span>:account = Teacher::<span class="hljs-built_in">find</span>(id);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;m&#x27;</span>:<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;M&#x27;</span>:<span class="hljs-keyword">return</span>;<span class="hljs-keyword">default</span>:cout &lt;&lt; <span class="hljs-string">&quot;错误的账号类别！&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span> (account == <span class="hljs-literal">NULL</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;未找到该账号&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">else</span> &#123;cout &lt;&lt; account-&gt;<span class="hljs-built_in">print</span>() &lt;&lt; endl;&#125;cout &lt;&lt; <span class="hljs-string">&quot;请输入姓名：&quot;</span>;string name;cin &gt;&gt; name;account-&gt;<span class="hljs-built_in">setName</span>(name);cout &lt;&lt; <span class="hljs-string">&quot;请输入密码：&quot;</span>;cin &gt;&gt; name;account-&gt;<span class="hljs-built_in">setPW</span>(name);cout &lt;&lt; <span class="hljs-string">&quot;修改完毕：&quot;</span>;cout &lt;&lt; account-&gt;<span class="hljs-built_in">print</span>() &lt;&lt; endl;cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;继续吗？（Y / N）：&quot;</span>;cin &gt;&gt; acc;<span class="hljs-keyword">if</span> (acc == <span class="hljs-string">&#x27;y&#x27;</span> || acc == <span class="hljs-string">&#x27;Y&#x27;</span>) &#123;<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;cls&quot;</span>);<span class="hljs-built_in">change_account</span>();&#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_rooms</span><span class="hljs-params">()</span> </span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;可用机房如下：&quot;</span> &lt;&lt; endl;<span class="hljs-type">int</span> n = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (vector&lt;Room*&gt;::const_iterator i = Room::rooms-&gt;<span class="hljs-built_in">begin</span>(); i != Room::rooms-&gt;<span class="hljs-built_in">end</span>(); i++) &#123;Room* temp = *i;cout &lt;&lt; n++ &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; temp-&gt;<span class="hljs-built_in">getName</span>() &lt;&lt; <span class="hljs-string">&quot;\t座位数：&quot;</span> &lt;&lt; temp-&gt;<span class="hljs-built_in">getSeat</span>() &lt;&lt; endl;&#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear_history</span><span class="hljs-params">()</span> </span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;★★★=========·清空预定记录·=========★★★&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;现有记录会被全部清空！确定吗？（Y / N）：&quot;</span>;<span class="hljs-type">char</span> confirm = <span class="hljs-string">&#x27;N&#x27;</span>;cin &gt;&gt; confirm;<span class="hljs-keyword">if</span> (confirm == <span class="hljs-string">&#x27;Y&#x27;</span> || confirm == <span class="hljs-string">&#x27;y&#x27;</span>) &#123;<span class="hljs-keyword">for</span> (vector&lt;Room*&gt;::const_iterator ri = Room::rooms-&gt;<span class="hljs-built_in">begin</span>(); ri != Room::rooms-&gt;<span class="hljs-built_in">end</span>(); ri++) &#123;Room* room = *ri;<span class="hljs-keyword">for</span> (vector&lt;List*&gt;::const_iterator i = room-&gt;tbd.<span class="hljs-built_in">begin</span>(); i != room-&gt;tbd.<span class="hljs-built_in">end</span>(); i++) &#123;List* temp = *i;<span class="hljs-keyword">delete</span> temp;&#125;room-&gt;tbd.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span> (vector&lt;List*&gt;::const_iterator i = room-&gt;confirmed.<span class="hljs-built_in">begin</span>(); i != room-&gt;confirmed.<span class="hljs-built_in">end</span>(); i++) &#123;List* temp = *i;<span class="hljs-keyword">delete</span> temp;&#125;room-&gt;confirmed.<span class="hljs-built_in">clear</span>();room-&gt;tbd.<span class="hljs-built_in">swap</span>(room-&gt;confirmed);&#125;&#125;cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;清空完成&quot;</span> &lt;&lt; endl;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>程序</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java Web&gt;目录</title>
    <link href="/2022/05/23/Java/Java%20Web/0%20%E7%9B%AE%E5%BD%95/"/>
    <url>/2022/05/23/Java/Java%20Web/0%20%E7%9B%AE%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="目录">目录</h1><h2 id="html-和-css">1 <ahref="../../../../../../2022/05/23/Java/Java%20Web/1%20HTML%20%E5%92%8C%20CSS/">HTML和 CSS</a></h2><ul><li><h3 id="html">1.1 <ahref="../../../../../../2022/05/23/Java/Java%20Web/1%20HTML%20%E5%92%8C%20CSS/#1-1-HTML">HTML</a></h3><ul><li><h4 id="html-标签">1.1.1 <ahref="../../../../../../2022/05/23/Java/Java%20Web/1%20HTML%20%E5%92%8C%20CSS/#1-1-1-HTML-%E6%A0%87%E7%AD%BE">HTML标签</a></h4></li><li><h4 id="常用的标签">1.1.2 <ahref="../../../../../../2022/05/23/Java/Java%20Web/1%20HTML%20%E5%92%8C%20CSS/#1-1-2-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%A0%87%E7%AD%BE">常用的标签</a></h4></li></ul></li><li><h3 id="css-技术">1.2 <ahref="../../../../../../2022/05/23/Java/Java%20Web/1%20HTML%20%E5%92%8C%20CSS/#1-2-CSS-%E6%8A%80%E6%9C%AF">CSS技术</a></h3><ul><li><h4 id="css-与-html-的组合">1.2.1 <ahref="../../../../../../2022/05/23/Java/Java%20Web/1%20HTML%20%E5%92%8C%20CSS/#1-2-1-CSS-%E4%B8%8E-HTML-%E7%9A%84%E7%BB%84%E5%90%88">CSS与 HTML 的组合</a></h4></li><li><h4 id="css-选择器">1.2.2 <ahref="../../../../../../2022/05/23/Java/Java%20Web/1%20HTML%20%E5%92%8C%20CSS/#1-2-2-CSS-%E9%80%89%E6%8B%A9%E5%99%A8">CSS选择器</a></h4></li><li><h4 id="选择器常用样式">1.2.3 <ahref="../../../../../../2022/05/23/Java/Java%20Web/1%20HTML%20%E5%92%8C%20CSS/#1-2-3-%E9%80%89%E6%8B%A9%E5%99%A8%E5%B8%B8%E7%94%A8%E6%A0%B7%E5%BC%8F">选择器常用样式</a></h4></li></ul></li></ul><hr />]]></content>
    
    
    <categories>
      
      <category>Java Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>目录</tag>
      
      <tag>Java Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java Web&gt;1 HTML 和 CSS</title>
    <link href="/2022/05/23/Java/Java%20Web/1%20HTML%20%E5%92%8C%20CSS/"/>
    <url>/2022/05/23/Java/Java%20Web/1%20HTML%20%E5%92%8C%20CSS/</url>
    
    <content type="html"><![CDATA[<h1 id="html-和-css">1 HTML 和 CSS</h1><blockquote><p>网页由三部分组成：内容（结构）、表现、行为</p><p>内容：在页面中可以看到的数据称为内容。一般使用 HTML 技术来展示</p><p>表现：内容在页面上的展示形式，如布局、颜色、大小等。一般使用 CSS技术实现。</p><p>行为：页面中元素与输入设备交互的相应。一般使用 JavaScript技术实现。</p></blockquote><h2 id="html">1.1 HTML</h2><blockquote><p>HTML 即 Hyper Text Markup Language（超文本标记语言）</p><p>HTML通过标签来标记要显示的网页中的各个部分。网页文件本身是一种文本文件。通过在文本文件中添加标记符，可以告诉浏览器如何显示其中的内容。</p><p>Java 文件需要编译后才能运行，但 HTML 文件可以直接由浏览器运行。</p></blockquote><p><strong>HTML 的代码注释：</strong></p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 这是一段注释 --&gt;</span></code></pre></div><p><strong>编写规范：</strong></p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-comment">&lt;!-- [1] --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- [2] --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-comment">&lt;!-- [3] --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>标题<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-comment">&lt;!-- [4] --&gt;</span>        Hello <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>World<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><ol type="1"><li><p>约束、声明：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span></code></pre></div></li><li><p>HTML 标签：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- lang=&quot;en&quot; 即语言是英文。中文的场合 lang=&quot;zh_CN&quot; --&gt;</span>    ...<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p><code>&lt;html&gt;</code> 表示 HTML的开始。<code>&lt;/html&gt;</code> 表示 HTML 的结束。</p><p>HTML 标签中一般包含有 2 部分。分别是 head 和 body</p></li><li><p>head 标签：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- meta charset=&quot;UTF-8&quot; 即使用 utf8 字符集 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>标题<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre></div><p><code>&lt;head&gt;</code>表示头部信息的开始。<code>&lt;/head&gt;</code> 表示头部信息的结束</p><p>头部信息一般包含 3 部分内容：</p><ol type="1"><li>title 标签</li><li>css 样式</li><li>js 代码</li></ol></li><li><p>body 标签：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    Hello <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>World<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><p>body 标签是整个 HTML 页面显示的主体内容</p></li></ol><h3 id="html-标签">1.1.1 HTML 标签</h3><p><strong>标签的格式：</strong></p><div class="code-wrapper"><pre><code class="hljs html">&lt;标签名&gt;封装的数据&lt;/标签名&gt;</code></pre></div><ul><li><p>标签名的大小写不敏感。</p><p>比如：<code>&lt;b&gt;bold&lt;/b&gt;</code>（<b>bold</b>）和<code>&lt;B&gt;bold&lt;/B&gt;</code>（<B>bold</B>）效果相同</p></li><li><p>标签分为两种：</p><ul><li><p>单标签：<code>&lt;标签名/&gt;</code></p><p>也称作自结束标签。如 <code>&lt;hr/&gt;</code>（水平线）</p><hr/></li><li><p>双标签：<code>&lt;标签名&gt;封装的数据&lt;/标签名&gt;</code></p><p>其中 <code>&lt;标签名&gt;</code>为开始标签，<code>&lt;/标签名&gt;</code> 为结束标签</p></li></ul></li><li><p>标签拥有自己的属性。属性分为 2 种：</p><ul><li><p>基本属性。可以修改简单的样式效果</p><p>比如：<code>&lt;a bgcolor="blue"&gt;RED&lt;/a&gt;"</code>（<a bgcolor="blue">RED</a>）</p></li><li><p>事件属性。可以直接设置事件响应后的代码</p><p>比如：<code>&lt;b onclick="alert('Clicked')"&gt;CLICK&lt;/b&gt;</code>（<b onclick="alert('Clicked')">CLICK</b>）</p></li></ul></li></ul><p><strong>标签的语法：</strong></p><p>有时错误的语法也能正确显示，这是因为浏览器会尽可能修复那些错误的标签。<font color="#FAAAA0"><del>听我说谢谢你，因为有你……</del></font ></p><ul><li>标签不能交叉嵌套</li><li>双标签必须正确闭合</li><li>属性必须有值。属性值必须加引号</li><li>注释不能嵌套</li></ul><h3 id="常用的标签">1.1.2 常用的标签</h3><h4 id="font-标签">font 标签：</h4><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;#FF7CAA&quot;</span> <span class="hljs-attr">face</span>=<span class="hljs-string">&quot;华文行楷&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;6&quot;</span>&gt;</span>font 标签<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span></code></pre></div><blockquote><p><font color="#FF7CAA" face="华文行楷" size="6">font 标签</font></p></blockquote><p>可选的属性：</p><ul><li>color：颜色。可以是颜色名或十六进制色号</li><li>face：字体</li><li>size：字号</li></ul><h4 id="特殊字符">特殊字符：</h4><ul><li><p><code>&lt;br/&gt;</code>：换行符</p></li><li><p><code>&lt;hr/&gt;</code>：水平线</p></li><li><p><code>&amp;lt;</code>：&lt;</p><p><code>&amp;gt;</code>：&gt;</p></li><li><p><code>&amp;nbsp</code>：空格</p><p>通常情况下，HTML 会将连续的空格压缩成 1个空格。使用该字符以实现多个连续空格</p></li></ul><h4 id="标题标签">标题标签：</h4><p>HTML 提供了 6 级标题标签</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>H1<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>H2<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>H3<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h4</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>H4<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span>H5<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span>H6<span class="hljs-tag">&lt;/<span class="hljs-name">h6</span>&gt;</span></code></pre></div><p>可选属性：</p><ul><li>align：对齐属性。<code>left</code>（左对齐，默认）、<code>right</code>（右对齐）、<code>center</code>（居中对齐）</li></ul><h4 id="超链接">超链接：</h4><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://***********&quot;</span>&gt;</span>通道 A<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://***********&quot;</span> <span class="hljs-attr">targrt</span>=<span class="hljs-string">&quot;_self&quot;</span>&gt;</span>通道 B<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://***********&quot;</span> <span class="hljs-attr">targrt</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span>通道 C<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre></div><blockquote><p><a href="https://www.bilibili.com/video/BV1Yt4y1y7yv">通道 A</a><a href="https://www.bilibili.com/video/BV19K4y1Q74b" targrt="_self">通道B</a><a href="https://www.bilibili.com/video/BV1M64y167tb" targrt="_blank">通道C</a></p></blockquote><p>可选属性：</p><ul><li>taget：跳转方式。<code>_self</code>（当前页面跳转，默认），<code>_blank</code>（打开新页面跳转）</li></ul><h4 id="列表标签">列表标签：</h4><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>刻晴<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>胡桃<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;none&quot;</span>&gt;</span>甘雨<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span></code></pre></div><blockquote><ul><li>刻晴</li></ul><ol><li>胡桃</li><li type="none">甘雨</li></ol></blockquote><p>其中，<code>&lt;ul&gt;</code> 是无序列表（unorderedlist），<code>&lt;ol&gt;</code> 是有序列表（orderedlist），<code>&lt;li&gt;</code> 是列表项</p><p>可选属性：</p><ul><li>type：列表样式。<code>none</code> 的场合不显示列表符号</li></ul><h4 id="图片标签">图片标签：</h4><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;*********&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;500&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;500&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;刻晴&quot;</span>/&gt;</span></code></pre></div><blockquote><p><img src="\img\favorite2.png" width="500" height="500" alt="刻晴"/></p></blockquote><p>可选属性：</p><ul><li><p>src：图片路径</p><p>可以是绝对路径（<code>http://ip:port/工程名/资源路径</code>）或相对路径（<code>../img/1.jpg</code>）</p></li><li><p>width：图片宽度</p><p>height：图片高度</p></li><li><p>border：图片边框宽度</p></li><li><p>alt：图片加载失败时，使用指定文本内容替代显示</p></li></ul><h4 id="表格标签">表格标签：</h4><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;5&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;150&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;150&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">ceilspacing</span>=<span class="hljs-string">&quot;5&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>1.1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>1.3<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2.1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2.2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">rowspan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>2.3<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>3.1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></code></pre></div><blockquote><table border="5" width="150" height="150"><tr ceilspacing="5"><td>1.1</td><th>1.2</th><th>1.3</th></tr><tr align="right"><td>2.1</td><td>2.2</td><td rowspan="2">2.3</td></tr><tr><td colspan="2">3.1</td></tr></table></blockquote><p>其中 <code>&lt;table&gt;</code> 是表格标签，<code>&lt;tr&gt;</code>为行标签，<code>&lt;th&gt;</code> 为表头标签，<code>&lt;td&gt;</code>为单元格标签</p><p>可选属性：</p><ul><li><p>width：表格宽度</p><p>height：表格高度</p></li><li><p>border：表格边框宽度</p></li><li><p>cellspacing：单元格间距</p></li><li><p>colspan：单元格合并（行）</p><p>rowspan：单元格合并（列）</p><p>那个合并的场合，被合并的单元格需要删除</p></li></ul><h4 id="框架标签">框架标签：</h4><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;********&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;600&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;420&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;tar&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;********&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;tar&quot;</span>&gt;</span>按钮A<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;********&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;tar&quot;</span>&gt;</span>按钮B<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;********&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;tar&quot;</span>&gt;</span>按钮C<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;********&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;tar&quot;</span>&gt;</span>按钮D<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;********&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;tar&quot;</span>&gt;</span>按钮E<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></code></pre></div><blockquote><iframe src="//player.bilibili.com/player.html?aid=76862428&amp;bvid=BV1qJ41197na&amp;cid=131466372&amp;page=1" width="800" height="600" name="tar"></iframe><table><tr><td><a href="//player.bilibili.com/player.html?aid=246272990&bvid=BV1cv411s76y&cid=285147989&page=1" target="tar">按钮A</a></td><td><a href="//player.bilibili.com/player.html?aid=99432570&bvid=BV1i7411C7aL&cid=169723357&page=1" target="tar">按钮B</a></td><td><a href="//player.bilibili.com/player.html?aid=375087547&bvid=BV1UZ4y1c7Up&cid=323309774&page=1" target="tar">按钮C</a></td><td><a href="//player.bilibili.com/player.html?aid=676776161&bvid=BV1HU4y1M7hb&cid=446405333&page=1" target="tar">按钮D</a></td><td><a href="//player.bilibili.com/player.html?aid=503523369&bvid=BV1ig411G7LY&cid=353617961&page=1" target="tar">按钮E</a></td><td><a href="//player.bilibili.com/player.html?aid=76862428&bvid=BV1qJ41197na&cid=131466372&page=1" target="tar">按钮F</a></td></tr></table></blockquote><p>iframe 标签和 a 标签组合使用的步骤：</p><ol type="1"><li>在 iframe 标签中使用 name 属性定义一个名称</li><li>让 a 标签的 target 属性指向 iframe 声明的 name</li></ol><h4 id="表单标签">表单标签：</h4><p>表单就是 HTML页面中，用来收集用户信息的所有元素的集合。收集后会把信息发送给服务器。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;******&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;get&quot;</span>&gt;</span>    一个框：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;ᓚᘏᗢ&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;50&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>    又一个框：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>    双一个框：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;t&quot;</span>/&gt;</span>喵 <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;t&quot;</span> <span class="hljs-attr">checked</span>=<span class="hljs-string">&quot;checked&quot;</span>/&gt;</span>汪<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>    叒一个框：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span>/&gt;</span>☆ <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span>/&gt;</span>★<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>    叕一个框：<span class="hljs-tag">&lt;<span class="hljs-name">select</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>ฅʕ•̫͡•ʔฅ<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>    叒一个框：<span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;15&quot;</span>&gt;</span>༼ つ ◕_◕ ༽つ<span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>    双一个框：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;reset&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>    又一个框：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>    一个框：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>    最后一个框：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre></div><blockquote><form>一个框：<input type="text" value="ᓚᘏᗢ" size="50"/><br/>又一个框：<input type="password"/><br/>双一个框：<input type="radio" name="t"/>喵<input type="radio" name="t" checked="checked"/>汪<br/>叒一个框：<input type="checkbox"/>☆ <input type="checkbox"/>★<br/>叕一个框：<select> <option>-</option> <option>ฅʕ•̫͡•ʔฅ</option></select><br/> 叒一个框：<textarea rows="1" cols="15">༼ つ ◕_◕ ༽つ</textarea><br/> 双一个框：<input type="reset"/><br/>又一个框：<input type="submit"/><br/> 一个框：<input type="file"/><br/>最后一个框：<input type="hidden"/></form></blockquote><ul><li>input type="text"：文本输入框。value 设置初始内容</li><li>input type="password"：密码输入框。value 设置初始内容</li><li>input type="radio"：单选框。通过 name 进行分组，checked变更初始状态</li><li>input type="checkbox"：复选框。checked 变更初始状态</li><li>select：下拉列表框。option 是其中选项。selected 设置默认选中</li><li>textarea：多行文本输入框。rows 显示行数，cols 是显示列数</li><li>input type="reset"：重置按钮。value 设置按钮文字</li><li>input type="submit"：提交按钮。value 设置按钮文字</li><li>input type="file"：文件上传按钮。</li><li>input type="hidden"：隐藏框</li></ul><p><code>&lt;form&gt;</code> 的可选属性有：</p><ul><li><p>action：这些信息的接收地址</p><p>要发送信息，必须给每个输入框添加 name，给选择框添加 value</p></li><li><p>method：信息的发送方式</p><p>get 的场合，传送 URL 中的表单内容，格式<code>URL?name=value&amp;name=value...</code>。该方法不安全，且有长度限制（100字符）</p><p>post 的场合，传送 request 主体中的表单内容。</p></li></ul><h4 id="其他标签">其他标签：</h4><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>div标签1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>div标签2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>span标签1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>span标签2<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>段落标签1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>段落标签2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre></div><blockquote><div>div标签1</div><div>div标签2</div><p><span>span标签1</span> <span>span标签2</span></p><p>段落标签1</p><p>段落标签2</p></blockquote><ul><li><code>&lt;div&gt;</code> 标签，默认独占 1 行</li><li><code>&lt;span&gt;</code> 标签，其长度等于封装数据的长度</li><li><code>&lt;p&gt;</code>标签，默认在段落前方或后方各空一行，除非已有空行</li></ul><h2 id="css-技术">1.2 CSS 技术</h2><blockquote><p>CSS（层叠样式表单）是用于增强网页样式，并允许将信息与网页内容分离的一种标记性语言</p></blockquote><p>语法：</p><div class="code-wrapper"><pre><code class="hljs css">选择器 &#123;    属性:值;<span class="hljs-comment">/*注释内容*/</span>&#125;</code></pre></div><ul><li>选择器：根据选择器决定受 CSS 样式影响的 HTML 元素（标签）</li><li>属性：要改变的样式名。每个属性有一个值，被 <code>:</code> 分开</li><li>多个声明：多个声明之间以 <code>;</code>分开。最后一条声明最后可以不加分号，但还是建议加上</li></ul><h3 id="css-与-html-的组合">1.2.1 CSS 与 HTML 的组合</h3><ul><li><p>方法 1：行内样式</p><p>在每个标签上添加 style 属性</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">controls</span>=<span class="hljs-string">&quot;controls&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;*********&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color: transparent&quot;</span>&gt;</span>audio<span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span></code></pre></div><blockquote><audio controls="controls" src="/audio/黒子鸟.mp3" style="background-color: transparent">audio</audio></blockquote><p>这样做的缺点：可读性、复用性差</p></li><li><p>方法 2：内嵌样式</p><p>在 head 标签中，使用 style 标签定义所需 CSS 样式</p><p>注意 style 标签内为 CSS 格式，其中注释也要用 CSS 格式书写</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>标题<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>  <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-tag">div</span> &#123;</span><span class="language-css">            <span class="hljs-attribute">border</span>: <span class="hljs-number">4px</span> double <span class="hljs-number">#FFA0A0</span>;</span><span class="language-css">            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#30AFD0</span>;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>测试内嵌样式<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><blockquote><div style="border: 4px double #FFA0A0;            background-color: #F0FFF0;">测试内嵌样式</div></blockquote><p>这样做的缺点：只能在同一页面内复用代码，并且不便于维护</p></li><li><p>方法 3：外部样式</p><p>把 CSS 写成单独的 CSS 文件，再通过 link 标签引入</p><p>1.css：</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">span</span> &#123;    <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-number">#aFAfAf</span>;    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#0DA0FF</span>;    <span class="hljs-attribute">color</span>: <span class="hljs-number">#FFFFFF</span>;    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;&#125;</code></pre></div><p>test.html：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;1.css&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>测试外部样式<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><blockquote><p><spanstyle="border: 2px solid #aFAfAf; background-color: #0DA0FF; color: #FFFFFF; font-size: 20px;"><b>测试外部样式</b></span></p></blockquote></li></ul><p>以上三种方法的优先级为：行内样式 &gt; 内嵌样式 &gt; 外部样式</p><h3 id="css-选择器">1.2.2 CSS 选择器</h3><h4 id="标签名选择器">标签名选择器：</h4><p>可以选择哪些标签被动的使用该样式</p><div class="code-wrapper"><pre><code class="hljs css">标签名 &#123;    属性: 值;&#125;</code></pre></div><p>这个场合，那些标签名变成选择器指定的样式。</p><h4 id="id-选择器">id 选择器：</h4><p>可以让我们通过 id 属性选择性地使用样式</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-id">#id</span>属性值 &#123;    属性: 值;&#125;</code></pre></div><p>这个场合，那些持有相应 id 属性的标签变成选择器指定的样式</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/* CSS 文件 */</span><span class="hljs-selector-id">#id19</span> &#123;    <span class="hljs-attribute">color</span>: <span class="hljs-number">#00DFD0</span>;    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML 文件 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;id19&quot;</span>&gt;</span>测试 id 选择器<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre></div><blockquote><p><span id="id19" style="color: #00DFD0; font-size: 20px;">测试 id选择器</span></p></blockquote><h4 id="class-选择器">class 选择器：</h4><p>能通过 class 属性有效地选择性使用样式</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.class</span>属性值 &#123;    属性: 值;&#125;</code></pre></div><p>这个场合，那些持有相应 class 属性的标签变成选择器指定的样式</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/* CSS 文件 */</span><span class="hljs-selector-class">.class35</span> &#123;    <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid green;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML 文件 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;class35&quot;</span>&gt;</span>测试 class 选择器<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre></div><blockquote><p><span class="class35" style="border: 2px solid green;">测试 class选择器</span></p></blockquote><h4 id="组合选择器">组合选择器：</h4><div class="code-wrapper"><pre><code class="hljs css">选择器<span class="hljs-number">1</span>, 选择器<span class="hljs-number">2</span>, 选择器<span class="hljs-number">3</span> &#123;    属性: 值;&#125;</code></pre></div><p>这个场合，符合至少一个选择器的标签变成指定样式</p><h3 id="选择器常用样式">1.2.3 选择器常用样式</h3><ul><li><p>颜色：color</p><p>背景颜色：background-color</p><p>值可以是：颜色名（<code>white</code>）、RGB值（<code>rgb(255, 255, 255)</code>）、十六进制表示值（<code>#FFFFFF</code>）</p></li><li><p>宽度：width</p><p>高度：height</p><p>字体大小：font-size</p><p>值可以是：像素值（<code>15px</code>）、百分比值（<code>20%</code>）</p></li><li><p>边框：border</p><p>值有三部分，以空格分隔。分别是：宽度、样式、颜色</p><p>其中，样式有：none（默认值无边框）、hidden（隐藏边框，IE不支持）、dotted（点线）、dashed（虚线）、solid（实线）、double（双线）、groove（3D凹槽）、ridge（3D 凸槽）、inset（3D 凹边）、outset（3D 凸边）</p><p>这个样式值的数量会影响每条边的样式表现</p></li><li><p>DIV 居中：margin-left、margin-right</p><p>值为auto。配置一个的场合会远离那个方向对齐。两个都配置时居中</p></li><li><p>文本对齐方式：text-align</p><p>可以是 center、right、left、start、end 等</p></li><li><p>超链接去除下划线：text-decoration: none</p></li><li><p>表格边框合并：border-collapse: collapse</p></li><li><p>列表去除修饰：list-style: none</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Java Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;C++&gt;12 项目：演讲比赛管理系统</title>
    <link href="/2022/05/21/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/12%20%E9%A1%B9%E7%9B%AE%EF%BC%9A%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/05/21/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/12%20%E9%A1%B9%E7%9B%AE%EF%BC%9A%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="项目演讲比赛管理系统">12 项目：演讲比赛管理系统</h1><h2 id="项目需求">12.1 项目需求</h2><blockquote><p>共有 12 名选手，编号 10001 - 10012</p><p>比赛分为 2 轮：</p><ol type="1"><li>第一轮比赛分为 2 组分别进行。每组前 3 名晋级下一轮比赛</li><li>第二轮比赛的前 3 名胜出</li></ol><p>打分方式：10个评委分别对每位选手打分，去除最高分和最低分，剩余的平均分为选手本轮成绩</p><p>每轮比赛过后，显示晋级选手（胜出选手）的信息</p></blockquote><p>选手信息：姓名、编号、性别、成绩、排名</p><p>打分范围：0 - 100（随机）</p><p>菜单：</p><ul><li>选手报名</li><li>选手信息变更</li><li>选手查询（按姓名、编号查找）</li><li>开始比赛<ul><li>显示选手信息、轮次信息（输出至 .csv 文档）</li><li>随机打分、手动打分</li><li>确认晋级选手（输出至 .csv 文档）</li><li>第二轮</li><li>确认胜出选手（输出至 .csv 文档）</li></ul></li><li>查看往届记录</li><li>清空比赛记录</li><li>退出系统</li></ul><h2 id="附录">附录</h2><h3 id="演讲比赛管理系统">演讲比赛管理系统</h3><p>执行以下代码：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;menu.h&quot;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">menu0</span>();&#125;</code></pre></div><h4 id="头文件">头文件</h4><p><strong>player.h</strong></p><blockquote><p>包含 Player 类、Com 类</p><ul><li><p>Player 类：选手类。对象包含选手信息（ID、姓名、得分）。</p><p>该类包含一个静态容器，代表参赛选手的集合</p></li><li><p>Com 类：仿函数。实现对 Player* 的按 socre 的比较</p></li></ul></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fstream&gt;</span></span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Com</span>;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span> &#123;<span class="hljs-keyword">public</span>:<span class="hljs-type">static</span> <span class="hljs-type">int</span> id_count;<span class="hljs-comment">// ID 计数。实例化时的 ID 值一般从 10000 开始</span><span class="hljs-type">static</span> set&lt;Player*, Com&gt;* players;<span class="hljs-comment">// 静态容器，代表参赛选手的集合</span><span class="hljs-built_in">Player</span>(string name);<span class="hljs-comment">// 构造方法。传入姓名</span>~<span class="hljs-built_in">Player</span>();<span class="hljs-comment">// 析构方法。是空实现</span><span class="hljs-function">string <span class="hljs-title">print</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 返回选手信息的字符串</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_socre</span><span class="hljs-params">(<span class="hljs-type">double</span> s)</span></span>;<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">get_socre</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_name</span><span class="hljs-params">(string s)</span></span>;<span class="hljs-function">string <span class="hljs-title">get_name</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_id</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">initial</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 初始化 Player 类。会清空参赛选手，并重置 ID 计数</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">flush</span><span class="hljs-params">(set&lt;Player*, Com&gt;&amp; p)</span></span>;<span class="hljs-comment">// 用新的选手集合取代目前的集合</span><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(Player&amp; p);<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(Player&amp; p);<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(Player&amp; p);<span class="hljs-keyword">private</span>:<span class="hljs-type">double</span> socre = <span class="hljs-number">0</span>;<span class="hljs-comment">// 选手得分，初始为 -1</span><span class="hljs-type">int</span> id;<span class="hljs-comment">// 选手 ID。不能更改</span>string name;<span class="hljs-comment">// 选手姓名</span>&#125;;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Com</span> &#123;<span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Player* p1, Player* p2)</span> <span class="hljs-type">const</span></span>;&#125;;</code></pre></div><p><strong>menu.h</strong></p><blockquote><p>程序入口。包含了大部分方法</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;numeric&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;player.h&quot;</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">menu0</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 程序主方法</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showMenu0</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 仅展示菜单</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_player</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 添加一位选手</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">affirm_player</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 查找选手</span><span class="hljs-function">Player* <span class="hljs-title">affirm_by_id</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span></span>;<span class="hljs-comment">// 按照 ID 查找选手</span><span class="hljs-function">Player* <span class="hljs-title">affirm_by_name</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; name)</span></span>;<span class="hljs-comment">// 按照姓名查找选手</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">changePlayer</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 变更选手信息</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start_match</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 开始比赛</span><span class="hljs-function">set&lt;Player*, Com&gt;&amp; <span class="hljs-title">round1</span><span class="hljs-params">(set&lt;Player*, Com&gt;&amp; p)</span></span>;<span class="hljs-comment">// 第一轮比赛</span><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">socre</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 生成一个随机的分数</span><span class="hljs-function">set&lt;Player*, Com&gt;&amp; <span class="hljs-title">round2</span><span class="hljs-params">(set&lt;Player*, Com&gt;&amp; p)</span></span>;<span class="hljs-comment">// 第二轮比赛</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">histroy</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 查看历史记录</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear_histroy</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 清空历史记录</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 将目前的赛况导出</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_all</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 展示参赛选手信息</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">log_out</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 退出程序前的确认</span></code></pre></div><h4 id="源文件">源文件</h4><p><strong>player.cpp</strong></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;player.h&quot;</span></span>Player::<span class="hljs-built_in">Player</span>(string name) &#123;<span class="hljs-comment">// 构造器。每次构造时会更新随机值的种子</span><span class="hljs-keyword">this</span>-&gt;id = ++id_count;<span class="hljs-keyword">this</span>-&gt;name = name;<span class="hljs-keyword">this</span>-&gt;socre = <span class="hljs-number">-1</span>;<span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));&#125;Player::~<span class="hljs-built_in">Player</span>() &#123;&#125;<span class="hljs-comment">// 析构函数。是空实现</span><span class="hljs-function">string <span class="hljs-title">Player::print</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// 返回选手信息的字符串。项之间以 \t 分隔</span><span class="hljs-keyword">return</span> <span class="hljs-built_in">to_string</span>(id) + <span class="hljs-string">&quot;\t&quot;</span> + name + <span class="hljs-string">&quot;\t&quot;</span> + (socre &lt; <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;-&quot;</span> : (<span class="hljs-built_in">to_string</span>(socre)));&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Player::set_socre</span><span class="hljs-params">(<span class="hljs-type">double</span> s)</span> </span>&#123;<span class="hljs-keyword">this</span>-&gt;socre = s;&#125;;<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Player::get_socre</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;socre;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Player::set_name</span><span class="hljs-params">(string s)</span> </span>&#123;<span class="hljs-keyword">this</span>-&gt;name = s;&#125;;<span class="hljs-function">string <span class="hljs-title">Player::get_name</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;name;&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Player::get_id</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;id;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Player::flush</span><span class="hljs-params">(set&lt;Player*, Com&gt;&amp; p)</span> </span>&#123;<span class="hljs-comment">// 静态方法。该方法会替换原先的参赛选手集合</span><span class="hljs-keyword">if</span> (Player::players != <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-keyword">delete</span> Player::players;Player::players = <span class="hljs-literal">NULL</span>;&#125;Player::players = &amp;p;&#125;;<span class="hljs-type">bool</span> Player::<span class="hljs-keyword">operator</span>&gt;(Player&amp; p) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;socre != p.socre) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;socre &gt; p.socre;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;id &gt; p.id;&#125;;<span class="hljs-type">bool</span> Player::<span class="hljs-keyword">operator</span>&lt;(Player&amp; p) &#123;<span class="hljs-keyword">return</span> p &gt; *<span class="hljs-keyword">this</span>;&#125;;<span class="hljs-type">bool</span> Player::<span class="hljs-keyword">operator</span>==(Player&amp; p) &#123;<span class="hljs-keyword">return</span> p.id == <span class="hljs-keyword">this</span>-&gt;id &amp;&amp; p.name == <span class="hljs-keyword">this</span>-&gt;name;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Player::initial</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// 静态方法。该方法会清空参赛选手集合，并重置 ID 计数</span>Player::id_count = <span class="hljs-number">10000</span>;<span class="hljs-keyword">if</span> (Player::players != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">delete</span> Player::players;Player::players = <span class="hljs-literal">NULL</span>;Player::players = <span class="hljs-keyword">new</span> set&lt;Player*, Com&gt;;&#125;;<span class="hljs-comment">// 以下是两个静态变量的初始化</span><span class="hljs-type">int</span> Player::id_count = <span class="hljs-number">10000</span>;set&lt;Player*, Com&gt;* Player::players = <span class="hljs-keyword">new</span> set&lt;Player*, Com&gt;;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Com::operator</span><span class="hljs-params">()</span><span class="hljs-params">(Player* p1, Player* p2)</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-comment">// 仿函数，比较两个 Player*</span><span class="hljs-keyword">if</span> (p1-&gt;<span class="hljs-built_in">get_socre</span>() != p2-&gt;<span class="hljs-built_in">get_socre</span>()) &#123;<span class="hljs-keyword">return</span> p1-&gt;<span class="hljs-built_in">get_socre</span>() &gt; p2-&gt;<span class="hljs-built_in">get_socre</span>();&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> p1-&gt;<span class="hljs-built_in">get_id</span>() &gt; p2-&gt;<span class="hljs-built_in">get_id</span>();&#125;;</code></pre></div><p><strong>menu.cpp</strong></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;menu.h&quot;</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showMenu0</span><span class="hljs-params">()</span> </span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;————————·演讲比赛:★:管理系统·————————&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;\t\t1.选 手 报 名&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;\t\t2.选 手 查 询&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;\t\t3.变 更 选 手&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;\t\t4.比 赛 开 始&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;\t\t5.查 看 往 届 记 录&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;\t\t6.清 空 比 赛 记 录&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;\t\t7.查 看 全 部 选 手&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;\t\t9.退 出 系 统&quot;</span> &lt;&lt; endl;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">menu0</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">bool</span> running = <span class="hljs-literal">true</span>;<span class="hljs-keyword">while</span> (running) &#123;<span class="hljs-built_in">showMenu0</span>();<span class="hljs-type">int</span> choice = <span class="hljs-number">0</span>;cout &lt;&lt; <span class="hljs-string">&quot;请输入您的选择：&quot;</span>;cin &gt;&gt; choice;cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;——————————————————————&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">switch</span> (choice) &#123;<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<span class="hljs-built_in">add_player</span>();<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<span class="hljs-built_in">affirm_player</span>();<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<span class="hljs-built_in">changePlayer</span>();<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<span class="hljs-built_in">start_match</span>();<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<span class="hljs-built_in">histroy</span>();<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<span class="hljs-built_in">clear_histroy</span>();<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<span class="hljs-built_in">show_all</span>();<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:<span class="hljs-keyword">if</span> (<span class="hljs-built_in">log_out</span>()) running = <span class="hljs-literal">false</span>;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">default</span>:cout &lt;&lt; <span class="hljs-string">&quot;输入有误，请重新输入！&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;cls&quot;</span>);&#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_player</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">if</span> (Player::players-&gt;<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-number">12</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;选手数量已满！(最多 12 人)&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">return</span>;&#125;cout &lt;&lt; <span class="hljs-string">&quot;========= 添 加 选 手 =========&quot;</span> &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;请输入选手姓名：&quot;</span>;string name;cin &gt;&gt; name;Player* temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Player</span>(name);Player::players-&gt;<span class="hljs-built_in">insert</span>(temp);cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;选手信息：&quot;</span> &lt;&lt; temp-&gt;<span class="hljs-built_in">print</span>() &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;继续吗？（Y / N）：&quot;</span>;<span class="hljs-type">char</span> confirm = <span class="hljs-string">&#x27;N&#x27;</span>;cin &gt;&gt; confirm;<span class="hljs-keyword">if</span> (confirm == <span class="hljs-string">&#x27;Y&#x27;</span> || confirm == <span class="hljs-string">&#x27;y&#x27;</span> || confirm == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;cout &lt;&lt; endl;<span class="hljs-built_in">add_player</span>();&#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">affirm_player</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">if</span> (Player::players-&gt;<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;目前暂无选手报名。&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">return</span>;&#125;cout &lt;&lt; <span class="hljs-string">&quot;========= 查 找 选 手 =========&quot;</span> &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;请输入查找方法（1[id] / 2[姓名]）：&quot;</span>;<span class="hljs-type">int</span> choice = <span class="hljs-number">1</span>;cin &gt;&gt; choice;<span class="hljs-keyword">if</span> (choice == <span class="hljs-number">2</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;========= 姓 名 查 找 =========&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;请输入姓名：&quot;</span>;string s;cin &gt;&gt; s;<span class="hljs-built_in">affirm_by_name</span>(s);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (choice == <span class="hljs-number">1</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;========= ID 查 找 =========&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;请输入 ID：&quot;</span>;cin &gt;&gt; choice;<span class="hljs-built_in">affirm_by_id</span>(choice);&#125;<span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;返回菜单。&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">return</span>;&#125;&#125;;<span class="hljs-function">Player* <span class="hljs-title">affirm_by_id</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;<span class="hljs-keyword">for</span> (set&lt;Player*&gt;::const_iterator i = Player::players-&gt;<span class="hljs-built_in">begin</span>(); i != Player::players-&gt;<span class="hljs-built_in">end</span>(); i++) &#123;Player* temp = *i;<span class="hljs-keyword">if</span> (temp-&gt;<span class="hljs-built_in">get_id</span>() == id) &#123;cout &lt;&lt; <span class="hljs-string">&quot;找到以下选手：&quot;</span> &lt;&lt; temp-&gt;<span class="hljs-built_in">print</span>() &lt;&lt; endl;<span class="hljs-keyword">return</span> *i;&#125;&#125;cout &lt;&lt; <span class="hljs-string">&quot;未找到该选手信息&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125;;<span class="hljs-function">Player* <span class="hljs-title">affirm_by_name</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; name)</span> </span>&#123;<span class="hljs-type">bool</span> found = <span class="hljs-literal">false</span>;set&lt;Player*&gt; ss;<span class="hljs-keyword">for</span> (set&lt;Player*&gt;::const_iterator i = Player::players-&gt;<span class="hljs-built_in">begin</span>(); i != Player::players-&gt;<span class="hljs-built_in">end</span>(); i++) &#123;Player* temp = *i;<span class="hljs-keyword">if</span> (temp-&gt;<span class="hljs-built_in">get_name</span>() == name) &#123;ss.<span class="hljs-built_in">insert</span>(*i);found = <span class="hljs-literal">true</span>;&#125;&#125;<span class="hljs-keyword">if</span> (!found) &#123;cout &lt;&lt; <span class="hljs-string">&quot;未找到该选手信息&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125;<span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;找到以下 &quot;</span> &lt;&lt; ss.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot; 位选手：&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">for</span> (set&lt;Player*&gt;::const_iterator i = ss.<span class="hljs-built_in">begin</span>(); i != ss.<span class="hljs-built_in">end</span>(); i++) &#123;Player* temp = *i;cout &lt;&lt; temp-&gt;<span class="hljs-built_in">print</span>() &lt;&lt; endl;&#125;<span class="hljs-keyword">if</span> (ss.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">return</span> *ss.<span class="hljs-built_in">begin</span>();&#125;cout &lt;&lt; <span class="hljs-string">&quot;是否再通过 ID 查找？（Y / N）：&quot;</span>;<span class="hljs-type">char</span> confirm = <span class="hljs-string">&#x27;N&#x27;</span>;cin &gt;&gt; confirm;<span class="hljs-keyword">if</span> (confirm == <span class="hljs-string">&#x27;Y&#x27;</span> || confirm == <span class="hljs-string">&#x27;y&#x27;</span>) &#123;<span class="hljs-type">int</span> id = <span class="hljs-number">0</span>;cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;请输入 ID：&quot;</span>;cin &gt;&gt; id;<span class="hljs-keyword">return</span> <span class="hljs-built_in">affirm_by_id</span>(id);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">changePlayer</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">show_all</span>();cout &lt;&lt; <span class="hljs-string">&quot;请输入要改变的选手 ID：&quot;</span>;<span class="hljs-type">int</span> id = <span class="hljs-number">-1</span>;cin &gt;&gt; id;cout &lt;&lt; endl;Player* player = <span class="hljs-built_in">affirm_by_id</span>(id);<span class="hljs-keyword">if</span> (player == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;cout &lt;&lt; <span class="hljs-string">&quot;请输入选手姓名：&quot;</span>;string name;cin &gt;&gt; name;player-&gt;<span class="hljs-built_in">set_name</span>(name);<span class="hljs-built_in">affirm_by_id</span>(id);&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start_match</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">if</span> (Player::players-&gt;<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">12</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;人数不足！&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;cls&quot;</span>);cout &lt;&lt; <span class="hljs-string">&quot;展示本轮参赛选手：&quot;</span> &lt;&lt; endl;<span class="hljs-built_in">show_all</span>();cout &lt;&lt; endl;<span class="hljs-comment">//write(0);</span>cout &lt;&lt; <span class="hljs-string">&quot;按任意键开始比赛&quot;</span> &lt;&lt; endl;<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;cls&quot;</span>);Player::<span class="hljs-built_in">flush</span>(<span class="hljs-built_in">round1</span>(*Player::players));<span class="hljs-comment">//write(1);</span>cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;晋级选手是：&quot;</span> &lt;&lt; endl;<span class="hljs-built_in">show_all</span>();cout &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;下一轮比赛即将开始&quot;</span> &lt;&lt; endl;<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;cls&quot;</span>);Player::<span class="hljs-built_in">flush</span>(<span class="hljs-built_in">round2</span>(*Player::players));<span class="hljs-built_in">write</span>();cout &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;比赛的胜出者是：&quot;</span> &lt;&lt; endl &lt;&lt; endl;set&lt;Player*, Com&gt;::const_iterator i = Player::players-&gt;<span class="hljs-built_in">begin</span>();Player* temp = *i;i++;cout &lt;&lt; <span class="hljs-string">&quot;★★·第一名：&quot;</span> &lt;&lt; temp-&gt;<span class="hljs-built_in">print</span>() &lt;&lt; <span class="hljs-string">&quot;·★★&quot;</span> &lt;&lt; endl &lt;&lt; endl;temp = *i;i++;cout &lt;&lt; <span class="hljs-string">&quot;·☆·第二名：&quot;</span> &lt;&lt; temp-&gt;<span class="hljs-built_in">print</span>() &lt;&lt; <span class="hljs-string">&quot;·☆·&quot;</span> &lt;&lt; endl &lt;&lt; endl;temp = *i;i++;cout &lt;&lt; <span class="hljs-string">&quot;···第三名：&quot;</span> &lt;&lt; temp-&gt;<span class="hljs-built_in">print</span>() &lt;&lt; <span class="hljs-string">&quot;···&quot;</span> &lt;&lt; endl &lt;&lt; endl;<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);Player::<span class="hljs-built_in">initial</span>();&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">if</span> (Player::players-&gt;<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;ofstream ost;ost.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;game_data.csv&quot;</span>, ios::out | ios::app);<span class="hljs-keyword">for</span> (set&lt;Player*&gt;::const_iterator i = Player::players-&gt;<span class="hljs-built_in">begin</span>(); i != Player::players-&gt;<span class="hljs-built_in">end</span>(); i++) &#123;Player* temp = *i;ost &lt;&lt; temp-&gt;<span class="hljs-built_in">print</span>() &lt;&lt; endl;&#125;ost &lt;&lt; endl;ost.<span class="hljs-built_in">close</span>();&#125;;<span class="hljs-function">set&lt;Player*, Com&gt;&amp; <span class="hljs-title">round1</span><span class="hljs-params">(set&lt;Player*, Com&gt;&amp; p)</span></span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;———————Round 1———————&quot;</span> &lt;&lt; endl;set&lt;Player*, Com&gt; team1;set&lt;Player*, Com&gt; team2;set&lt;Player*, Com&gt;* winner = <span class="hljs-keyword">new</span> set&lt;Player*, Com&gt;;set&lt;Player*&gt;::const_iterator it = p.<span class="hljs-built_in">begin</span>();<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; it != p.<span class="hljs-built_in">end</span>(); it++, i++) &#123;<span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;······第一组······&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;·ID\t姓名\t得分·&quot;</span> &lt;&lt; endl;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">6</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;······第二组······&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;·ID\t姓名\t得分·&quot;</span> &lt;&lt; endl;&#125;Player* temp = *it;temp-&gt;<span class="hljs-built_in">set_socre</span>(<span class="hljs-built_in">socre</span>());cout &lt;&lt; temp-&gt;<span class="hljs-built_in">print</span>() &lt;&lt; endl;<span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">6</span>) team1.<span class="hljs-built_in">insert</span>(temp);<span class="hljs-keyword">else</span> team2.<span class="hljs-built_in">insert</span>(temp);&#125;set&lt;Player*, Com&gt;::const_iterator i1 = team1.<span class="hljs-built_in">begin</span>();set&lt;Player*, Com&gt;::const_iterator i2 = team2.<span class="hljs-built_in">begin</span>();<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<span class="hljs-keyword">if</span> (i1 != team1.<span class="hljs-built_in">end</span>()) &#123;winner-&gt;<span class="hljs-built_in">insert</span>(*i1);i1++;&#125;<span class="hljs-keyword">if</span> (i2 != team2.<span class="hljs-built_in">end</span>()) &#123;winner-&gt;<span class="hljs-built_in">insert</span>(*i2);i2++;&#125;&#125;<span class="hljs-keyword">return</span> *winner;&#125;;<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">socre</span><span class="hljs-params">()</span></span>&#123;vector&lt;<span class="hljs-type">int</span>&gt; ss;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;ss.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">101</span>);&#125;<span class="hljs-built_in">sort</span>(ss.<span class="hljs-built_in">begin</span>(), ss.<span class="hljs-built_in">end</span>());<span class="hljs-type">double</span> socre = <span class="hljs-built_in">accumulate</span>(++ss.<span class="hljs-built_in">begin</span>(), --ss.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);socre /= <span class="hljs-number">8</span>;<span class="hljs-keyword">return</span> socre;&#125;;<span class="hljs-function">set&lt;Player*, Com&gt;&amp; <span class="hljs-title">round2</span><span class="hljs-params">(set&lt;Player*, Com&gt;&amp; p)</span></span>&#123;set&lt;Player*, Com&gt;* winner = <span class="hljs-keyword">new</span> set&lt;Player*, Com&gt;;cout &lt;&lt; <span class="hljs-string">&quot;———————Round 2———————&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;·ID\t姓名\t得分·&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">for</span> (set&lt;Player*, Com&gt;::const_iterator it = p.<span class="hljs-built_in">begin</span>(); it != p.<span class="hljs-built_in">end</span>(); it++) &#123;Player* temp = *it;temp-&gt;<span class="hljs-built_in">set_socre</span>(<span class="hljs-built_in">socre</span>());cout &lt;&lt; temp-&gt;<span class="hljs-built_in">print</span>() &lt;&lt; endl;winner-&gt;<span class="hljs-built_in">insert</span>(temp);&#125;set&lt;Player*, Com&gt;::const_iterator it = winner-&gt;<span class="hljs-built_in">begin</span>();it++;it++;it++;winner-&gt;<span class="hljs-built_in">erase</span>(it, winner-&gt;<span class="hljs-built_in">end</span>());<span class="hljs-keyword">return</span> *winner;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">histroy</span><span class="hljs-params">()</span></span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;========= 历 史 记 录 =========&quot;</span> &lt;&lt; endl;ifstream ifs;ifs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;game_data.csv&quot;</span>, ios::in);<span class="hljs-keyword">if</span> (!ifs.<span class="hljs-built_in">is_open</span>()) &#123;cout &lt;&lt; <span class="hljs-string">&quot;当前没有比赛记录&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-type">char</span> c;ifs &gt;&gt; c;<span class="hljs-keyword">if</span> (ifs.<span class="hljs-built_in">eof</span>()) &#123;cout &lt;&lt; <span class="hljs-string">&quot;当前没有比赛记录&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">return</span>;&#125;ifs.<span class="hljs-built_in">putback</span>(c);<span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;string data;<span class="hljs-keyword">while</span> (ifs &gt;&gt; data) &#123;<span class="hljs-keyword">if</span> (n % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>) &#123;cout &lt;&lt; endl;<span class="hljs-keyword">if</span> (n % <span class="hljs-number">9</span> == <span class="hljs-number">0</span>) &#123;cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;———————第 &quot;</span> &lt;&lt; (n / <span class="hljs-number">9</span>) + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot; 届演讲比赛———————&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;·ID\t姓名\t得分·&quot;</span> &lt;&lt; endl;&#125;&#125;n++;cout &lt;&lt; data &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span>;&#125;cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;——————————————————&quot;</span> &lt;&lt; endl;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear_histroy</span><span class="hljs-params">()</span></span>&#123;ofstream ost;ost.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;game_data.csv&quot;</span>, ios::out | ios::trunc);ost.<span class="hljs-built_in">close</span>();&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_all</span><span class="hljs-params">()</span> </span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;========= 选 手 信 息 =========&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;·ID·\t-姓名-\t·成绩·&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">for</span> (set&lt;Player*&gt;::const_iterator i = Player::players-&gt;<span class="hljs-built_in">begin</span>(); i != Player::players-&gt;<span class="hljs-built_in">end</span>(); i++) &#123;Player* temp = *i;cout &lt;&lt; temp-&gt;<span class="hljs-built_in">print</span>() &lt;&lt; endl;&#125;cout &lt;&lt; <span class="hljs-string">&quot;========= 展 示 完 毕 =========&quot;</span> &lt;&lt; endl;&#125;;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">log_out</span><span class="hljs-params">()</span></span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;确定要退出吗？未保存的记录将会消失（Y / N）：&quot;</span>;<span class="hljs-type">char</span> affirm = <span class="hljs-string">&#x27;N&#x27;</span>;cin &gt;&gt; affirm;<span class="hljs-keyword">return</span> affirm == <span class="hljs-string">&#x27;Y&#x27;</span> || affirm == <span class="hljs-string">&#x27;y&#x27;</span>;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>程序</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;C++&gt;11 STL</title>
    <link href="/2022/05/05/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/11%20STL/"/>
    <url>/2022/05/05/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/11%20STL/</url>
    
    <content type="html"><![CDATA[<h1 id="stl">11 STL</h1><blockquote><p>长久以来，软件界一直希望建立一种可重复利用的东西。C++的面向对象和泛型编程的思想，目的就是代码复用性的提升。</p><p>多数情况下，数据结构和算法都未能有一套标准，这导致了大量的重复工作。</p><p>STL（Standard TemplateLibrary）的诞生就是为了建立数据结构和算法的一套标准。</p></blockquote><p>STL从广义上分为：<strong>容器（container）</strong>、<strong>算法（algorithm）</strong>、<strong>迭代器（iterator）</strong>。容器和算法间通过迭代器进行无缝连接。STL几乎所有代码都采用了模板类或模板函数。</p><p>STL 的六大组件是：</p><ul><li><p><strong>容器</strong>：各种数据结构，如vector、list、deque、set、map 等，用以存放数据</p><p>容器就是运用最广泛的一些数据结构（数组、链表、树、栈、队列、集合、映射表等）的实现</p><p>容器分为两种：</p><ul><li>序列式容器：强调值的排序。序列式容器中每个元素都有固定的位置</li><li>关联式容器：二叉树结构，各元素间没有严格的物理上的顺序关系</li></ul></li><li><p><strong>算法</strong>：各种常用算法，如sort、find、copy、for_each 等</p><p>用有限的步骤，解决逻辑或数学上的问题，这样的学科称为算法</p><p>算法分为两种：</p><ul><li>质变算法：运算过程中会改变区间内元素的内容。如拷贝、替换、删除等</li><li>非质变算法：运算过程不会改变区间内的元素内容。如查找、计数、遍历、寻找极值等</li></ul></li><li><p><strong>迭代器</strong>：扮演了容器和算法间的胶合剂</p><p>提供一种方法，使之能依序寻访某个容器所含的各个元素，而无需暴露该容器的内部表示方式</p><p>每个容器都有自己的迭代器</p><p>迭代器分为五种：</p><ul><li>输入迭代器：对数据的只读访问。支持 ++、==、!、=</li><li>输出迭代器：对数据的只写访问。支持 ++</li><li>前向迭代器：读写操作，并能向前推进迭代器。支持 ++、==、!、=</li><li>双向迭代器：读写操作，并能向前、后操作。支持 ++、--</li><li>随机访问迭代器：读写操作，可以跳跃访问任意数据。支持++、--、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</li></ul></li><li><p><strong>仿函数</strong>：行为类似函数，可以作为算法的某种策略</p></li><li><p><strong>适配器</strong>：一种用来修饰容器或仿函数或迭代器接口的东西</p></li><li><p><strong>空间配置器</strong>：负责空间的配置与管理</p></li></ul><h2 id="stl-常用容器">11.1 STL 常用容器</h2><blockquote><p>容器就是运用最广泛的一些数据结构（数组、链表、树、栈、队列、集合、映射表等）的实现</p></blockquote><h3 id="string-容器">11.1.1 string 容器</h3><blockquote><p>string 是 C++ 风格的字符串。string 的本质是一个类</p><p>使用前应该包含头文件：<code>#include&lt;string&gt;</code></p></blockquote><p><b>string 与 char* 的区别：</b></p><ul><li>char* 是一个指针</li><li>string 是一个类，其内部封装了 char*，管理字符串，是一个 char*型的容器</li></ul><p><strong>构造方法：</strong></p><ul><li><code>string()</code>：创建空串</li><li><code>string(const char* s)</code>：以指定字符串初始化</li><li><code>string(const string&amp; str)</code>：用另一个 string初始化</li><li><code>string(int n, char c)</code>：用 n 个 c 进行初始化</li></ul><p><strong>string 赋值操作：</strong></p><ul><li><p><code>string&amp; operator=(const char* s)</code>：把 s 赋给当前string。重载了 = 操作符</p><p><code>string&amp; operator=(const string&amp; s)</code></p><p><code>string&amp; operator=(char s)</code></p></li><li><p><code>string&amp; assign(const string&amp; s)</code>：把 s赋给当前 string。</p><p><code>string&amp; assign(const char* s)</code></p><p><code>string&amp; assign(const char* s, int n)</code>：把 s 的前 n个字符赋给当前 string</p><p><code>string&amp; assign(int n, char c)</code>：把 n 个 c 赋给当前string</p></li></ul><p><strong>string 拼接操作：</strong></p><ul><li><p><code>string&amp; operator+=(const char* s)</code>：在当前 string末尾拼接 s。重载了 += 操作符</p><p><code>string&amp; operator+=(const char c)</code></p><p><code>string&amp; operator+=(const string&amp; s)</code></p></li><li><p><code>string&amp; append(const char* s)</code>：在当前 string末尾拼接 s。</p><p><code>string&amp; append(const string&amp; s)</code></p><p><code>string&amp; append(const char* s, int n)</code>：拼接 s 的前 n个字符</p><p><code>string&amp; append(const string&amp; s, int pos, int n)</code>：拼接s 的 [pos, pos + n) 范围的字符</p></li></ul><p><strong>string 查找和替换：</strong></p><ul><li><p><code>int find(const string&amp; s, int pos = 0)</code>：从 pos位置开始，查找 s 第一次出现的位置</p><p>返回那个找到位置的起始下标。没有找到的场合，返回 -1</p><p><code>int find(const char* s, int pos = 0)</code></p><p><code>int find(const char c, int pos = 0)</code></p><p><code>int find(const char* s, int pos, int n)</code>：从 pos位置开始，查找 s 中前 n 个字符第一次出现的位置</p></li><li><p><code>int rfind(const string&amp; s, int pos = npos)</code>：从pos 位置开始，查找 s 最后一次出现的位置</p><p><code>int rfind(const char* s, int pos = npos)</code></p><p><code>int rfind(const char c, int pos = npos)</code></p><p><code>int rfind(const char* s, int pos, int n)</code>：从 pos位置开始，查找 s 中前 n 个字符最后一次出现的位置</p></li><li><p><code>string&amp; replace(int pos, int n, const string&amp; s)</code>：把[pos, pos + n) 处字符串替换为 s</p><p><code>string&amp; replace(int pos, int n, const char* s)</code></p></li><li><p><code>int size()</code>：获取 string 的长度</p></li></ul><p><strong>string 的比较：</strong></p><ul><li><p><code>int compare(const string&amp; s)</code>：与字符串进行比较</p><p>相同的场合返回 0。不同的场合，根据 出现的第一处不同的字符的 ASCII码的差值 返回 1 或 -1</p><p><code>int compare(const char* s)</code></p></li></ul><p><strong>string 字符存取：</strong></p><ul><li><p><code>char&amp; operator[](int n)</code>：通过下标获取字符。重载了[] 操作符</p><p>因为获取的是 char&amp;，所以获取以后可以修改</p></li><li><p><code>char&amp; at(int n)</code>：通过下标获取字符</p></li><li><p><code>string substr(int pos = 0, int n =npos)</code>：截取 [pos,pos + n) 范围的子串，返回其构成的 string</p></li></ul><p><strong>string 插入和删除</strong></p><ul><li><p><code>string&amp; insert(int pos, const char* s)</code>：在 pos位置插入 s</p><p><code>string&amp; insert(int pos, const string&amp; s)</code></p><p><code>string&amp; insert(int pos, int n, const char c)</code>：在 pos位置插入 n 个 c</p></li><li><p><code>string&amp; erase(int pos, int n = npos)</code>：删除 [pos,pos + n) 范围的字符</p></li></ul><h3 id="vector-容器">11.1.2 vector 容器</h3><blockquote><p>vector 是可变容量的单端数组，能从尾部执行插入和删除元素</p><p>使用前应该包含头文件：<code>#include&lt;vector&gt;</code></p></blockquote><p><strong>vector 与 数组 的区别：</strong></p><ul><li><p>数组是静态空间，其容量大小固定</p></li><li><p>vector 可以动态扩展空间。</p><p>动态扩展是找到一块更大的空间，之后拷贝原数据到新空间，并释放原空间。</p></li></ul><p><strong>构造函数：</strong></p><ul><li><code>vector&lt;T&gt;()</code>：采用模板实现类实现的空的默认vector</li><li><code>vector&lt;T&gt;(iterator begin, iterator end)</code>：初始加入由迭代器所指示的 [begin, end) 范围内元素的 vector</li><li><code>vector&lt;T&gt;(int n, T element)</code>：初始加入 n 个element 元素的 vector</li><li><code>vector&lt;T&gt;(const vector&amp; v)</code>：拷贝构造函数</li></ul><p><strong>迭代器：</strong></p><blockquote><p>vector 容器的迭代器是：随机访问迭代器</p></blockquote><ul><li><code>const_iterator&amp; begin()</code>：返回一个指向第一个元素的迭代器</li><li><code>reverse_iterator&amp; rbegin()</code>：返回一个指向最后一个元素的迭代器</li><li><code>const_iterator&amp; end()</code>：返回一个指向最后一个元素后方空间的迭代器</li><li><code>reverse_iterator&amp; rend()</code>：返回一个指向第一个元素前方空间的迭代器</li></ul><p><strong>赋值操作：</strong></p><ul><li><p><code>vector&amp; operator=(const vector&amp; v)</code>：用另一个vector 赋值。重载了 = 操作符</p></li><li><p><code>assign(iterator begin, iterator end)</code>：用由迭代器所指示的 [begin, end) 范围内的元素 赋值</p><p><code>assigne(int n, T element)</code>：用 n 个 element元素赋值</p></li></ul><p><strong>容量和大小：</strong></p><ul><li><p><code>bool empty()</code>：判断是否为空</p></li><li><p><code>int capacity()</code>：返回容器的容量</p></li><li><p><code>int size()</code>：返回容器包含的元素数量</p></li><li><p><code>void resize(int num)</code>：重新指定容器容量。</p><p>容量变大的场合，以默认值填充多余位置。变小的场合，末尾的多余元素会被丢弃。</p><p><code>void resize(int num, T element)</code>：重新指定容器容量。如有需要，以element 填充多余位置</p></li></ul><p><strong>插入和删除：</strong></p><ul><li><p><code>push_back(T element)</code>：尾部插入元素 element</p></li><li><p><code>pop_back()</code>：删除最后一个元素</p></li><li><p><code>const_iterator insert(iterator pos, T element)</code>：在迭代器的指示位置插入element</p><p>返回值是该插入位置（的迭代器）</p><p><code>const_iterator insert(iterator pos, int n, T element)</code>：在迭代器的指示位置插入n 个 element</p><p><code>const_iterator insert(iterator pos, iterator start, iterator end)</code>：在迭代器的指示位置插入迭代器所指示的 [begin, end) 范围内的元素</p></li><li><p><code>erase(iterator pos)</code>：删除迭代器指示位置的元素</p><p><code>erase(iterator start, iterator end)</code>：删除迭代器所指示的[begin, end) 范围内的元素</p></li><li><p><code>clear()</code>：<i>用<font color=#FFC000><strong>圣光</strong></font>净化这个容器</i></p></li></ul><p><strong>数据存取：</strong></p><ul><li><code>T&amp; operator[](index)</code>：获取指定下标位置的元素。重载了[] 运算符</li><li><code>T&amp; at(int index)</code>：获取指定下标位置的元素。</li><li><code>T&amp; front()</code>：获取容器中第一个元素</li><li><code>T&amp; back()</code>：获取容器中最后一个元素</li></ul><p><strong>互换容器：</strong></p><ul><li><p><code>swap(vector&amp; v)</code>：互换……就是互换。</p><p>巧妙地使用 swap 可以收缩内存空间。哇哦 ~</p></li></ul><p><strong>预留空间：</strong></p><ul><li><p><code>reserve(int len)</code>：容器预留 len个位置。预留位置不初始化，元素不可访问</p><p>这样，能减少 vector 容器动态扩展时的扩展次数</p></li></ul><p><strong>遍历 vector：</strong></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span> </span>&#123;<span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::const_iterator i = v.<span class="hljs-built_in">begin</span>(); i &lt; v.<span class="hljs-built_in">end</span>(); i++) &#123;cout &lt;&lt; *i &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span>;&#125;cout &lt;&lt; endl;&#125;</code></pre></div><blockquote><p>不难懂吧</p></blockquote><h3 id="deque-容器">11.1.3 deque 容器</h3><blockquote><p>双端数组。可以从头端或尾端进行插入删除操作</p><p>deque内部有一个中控器，维护每段缓冲区中的内容。缓冲区中存放真实数据</p><p>中控器维护的是每个缓冲区的地址，使得使用 deque时貌似是一片连续的内存空间</p></blockquote><p><img src="/img/C++_InputImage/deque_11.1.3.png" /></p><p><em>（deque 中控器图_11.1.3）</em></p><p><strong>deque 与 vector 的区别：</strong></p><ul><li>vector从头部插入删除的效率低（需要移动元素）。数据量越大，效率越低</li><li>deque 相对而言，对头部插入、删除的速度比 vector 快</li><li>vector 访问元素的速度比 deque 快</li></ul><p><strong>迭代器：</strong></p><p>和 vector 一样</p><p><strong>构造器：</strong></p><p>和 vector 一样，欸嘿 ★~</p><p><strong>常用方法：</strong></p><p>大部分和 vector 一样</p><p>注意 deque 容器 <strong>没有容量</strong>（其容量无限。原因见<em>[deque中控器图_11.1.3]</em>），所以也不能获取容量。但可以改变容量。效果和vector 相似</p><p>此外，还有这些额外的方法：</p><ul><li><code>push_front(T element)</code>：头部插入元素 element</li><li><code>pop_front()</code>：删除容器第一个数据</li></ul><h3 id="stack-容器">11.1.4 stack 容器</h3><blockquote><p>stack 栈容器是一种 <strong>先进后出</strong>的数据结构。它只有一个出口。只有栈顶的数据能被访问。</p><p>栈容器不允许有遍历行为。栈中进入数据称为<strong>入栈</strong>，弹出数据称为 <strong>出栈</strong>。</p></blockquote><p><img src="/img/C++_InputImage/stack_11.1.4.png" /></p><p><em>（stack 栈图_11.1.4）</em></p><p><strong>构造函数：</strong></p><ul><li><code>stack&lt;T&gt;()</code>：默认构造</li><li><code>stack&lt;T&gt;(const stack&lt;T&gt;&amp; s)</code>：拷贝构造函数</li></ul><p><strong>赋值操作：</strong></p><ul><li><code>stack&amp; operator=(const stack&amp; s)</code>：重载 =操作符</li></ul><p><strong>数据存取：</strong></p><ul><li><code>push(T element)</code>：向栈顶添加元素</li><li><code>pop()</code>：从栈顶移除第一个元素</li><li><code>T&amp; top()</code>：从栈顶获取第一个元素</li></ul><p><strong>容量操作：</strong></p><ul><li><code>bool empty()</code>：是否为空</li><li><code>int size()</code>：返回栈的大小</li></ul><h3 id="queue-容器">11.1.5 queue 容器</h3><blockquote><p>queue 队列容器是一种 <strong>先进先出</strong>的数据结构。有两个出口，只有队首与队尾能被访问。</p><p>队列容器不允许遍历行为。进数据称为 <strong>入队</strong>，出数据称为<strong>出队</strong>。</p></blockquote><p><img src="/img/C++_InputImage/queue_11.1.5.png" /></p><p><em>（queue 队列图_11.1.5）</em></p><p><strong>构造函数：</strong></p><ul><li><code>queue&lt;T&gt;()</code>：默认构造函数</li><li><code>queue&lt;T&gt;(const queue&lt;T&gt;&amp; q)</code>：拷贝构造函数</li></ul><p><strong>赋值操作：</strong></p><ul><li><code>queue&amp; operator=(const queue&amp; q)</code>：重载 =操作符</li></ul><p><strong>数据存取：</strong></p><ul><li><p><code>push(T ele)</code>：向队尾添加元素</p></li><li><p><code>pop()</code>：从队首移除一个元素</p></li><li><p><code>T&amp; back()</code>：返回最后一个元素。</p><p>既然是先进先出，那么最后显然指的是队尾（后进）元素</p></li><li><p><code>T&amp; front()</code>：返回第一个元素</p></li></ul><p><strong>容量操作：</strong></p><ul><li><code>bool empty()</code>：你猜这个方法是用来干什么的？</li><li><code>int size()</code>：你再猜一个？</li></ul><h3 id="list-容器">11.1.6 list 容器</h3><blockquote><p>list 链表是一种存储单元上非连续的数据结构。</p><p>链表由一系列节点串联组成。每个节点中包含 <strong>数据域</strong> 和<strong>指针域</strong>。</p><p>由于存储方式是不连续的内存空间，其迭代器只能前移或后移，属于双向迭代器</p></blockquote><p><img src="/img/C++_InputImage/list_11.1.6.png" /></p><p><em>（list 链表图_11.1.6）</em></p><p><strong>list 的特点：</strong></p><ul><li>采用动态存储分配，不会造成内存浪费和溢出</li><li>插入和删除操作方便，只需要修改指针，而不需要移动大量元素</li><li>其空间（占用额外指针域）和时间（遍历速度慢）消耗较大</li></ul><p><strong>构造函数：</strong></p><ul><li><code>list&lt;T&gt;()</code>：默认构造</li><li><code>list&lt;T&gt;(iterator start, iterator end)</code>：用迭代器指示的 [start, end) 区间的元素 进行初始化</li><li><code>list&lt;T&gt;(int n, T ele)</code>：用 n 个 ele进行初始化</li><li><code>list&lt;T&gt;(const list&lt;T&gt;&amp; list)</code>：拷贝构造</li></ul><p><strong>常用方法：</strong></p><p>大部分和 deque 一样。你往上翻翻嘛</p><p>不能用 &lt;、&gt; 来对 list 提供的双向迭代器进行比较，也不能进行 +、-操作。但是 ++、-- 操作符是有效的</p><p>list 不支持随机访问。只能通过 front() 或 back()访问第一个或最后一个元素。其余时候，使用迭代器遍历元素</p><p>此外，还有以下方法：</p><ul><li><code>remove(T ele)</code>：删除链表中所有与 ele 匹配的元素</li></ul><h3 id="set-multiset-容器">11.1.7 set / multiset 容器</h3><blockquote><p>set 关联式容器（集合容器）底层结构是用 <strong>二叉树</strong>实现。所有元素在插入时会被自动排序。</p><p>set 不允许重复元素。multiset 允许重复元素</p></blockquote><p><strong>构造函数：</strong></p><ul><li><code>set&lt;T&gt;()</code>：这是啥呀，这是一个无参构造器呀</li><li><code>set&lt;T&gt;(const set&lt;T&gt;&amp; s)</code>：拷贝构造</li></ul><p><strong>常用方法：</strong></p><p>set / multiset 容器没有 push_xxx 方法 或 pop_xxx 方法。</p><p>set / multiset 容器插入元素只能使用 insert 方法，删除元素只能使用erase 方法</p><p>set 插入元素时会返回一个 pair&lt;iterator, bool&gt;对象，以表示插入成功或失败。multiset 不会有返回值</p><p>此外，还有以下方法：</p><ul><li><p><code>iterator&amp; find(T key)</code>：查找 key 是否存在。</p><p>存在的场合，返回指示那个位置的迭代器。不存在的场合，返回那个 end()迭代器</p></li><li><p><code>int count(key)</code>：统计 key 的个数</p></li></ul><p><strong>排序：</strong></p><p>set / multiset容器默认排序规则为从小到大。可以利用仿函数改变排序规则。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">OComparator</span> &#123;<span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> o1, <span class="hljs-type">const</span> <span class="hljs-type">int</span> o2)</span> </span>&#123;<span class="hljs-comment">// &lt;———— 仿函数</span><span class="hljs-keyword">return</span> o1 &gt; o2;&#125;&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;set&lt;<span class="hljs-type">int</span>, OComparator&gt; s;<span class="hljs-comment">// &lt;———— 这个场合，排序规则变为指定规则</span>&#125;</code></pre></div><p>对于自定义的数据类型，往往都会给定排序规则。</p><h3 id="pair-对组">11.1.8 pair 对组</h3><blockquote><p>pair 是成对出现的数据。利用对组可以实现返回两个数据</p></blockquote><p><strong>构造方法：</strong></p><ul><li><code>pair&lt;T, S&gt;(T value1, S value2)</code>：构造一个对组</li><li><code>make_pair&lt;T, S&gt;(T value1, S value2)</code>：该方法返回一个对组</li></ul><p><strong>访问对组元素：</strong></p><ul><li><code>T&amp; first()</code>：访问第一个元素</li><li><code>S&amp; second()</code>：访问第二个元素</li></ul><h3 id="map-multimap-容器">11.1.9 map / multimap 容器</h3><blockquote><p>map / multimap也属于关联式容器。底层结构用二叉树实现，其中所有元素都是 pair。</p><p>pair 中第一个元素为 key（键），起索引作用。第二个元素为value（值）</p><p>map / multimap 容器的所有元素按照键值排序。可以根据键值快速找到 value值</p><p>map 不允许重复键值，multimap 允许重复键值</p></blockquote><p><strong>构造函数：</strong></p><ul><li><code>map&lt;T, S&gt;()</code>：默认构造函数</li><li><code>map&lt;T, S&gt;(const map&lt;T, S&gt;&amp; m)</code>：拷贝构造函数</li></ul><p><strong>常用方法：</strong></p><p>和 set 容器差不多</p><p>map / multimap 容器在使用 insert 插入时，插入的是一个 pair对象：<code>insert(pair&lt;T, S&gt;(t, s))</code></p><p>使用 erase 删除、find 查找、count统计时，按照那个键值确定对象：<code>erase(T&amp; key)</code></p><p><strong>排序：</strong></p><p>和 set一样，利用仿函数：<code>map&lt;T, S, OComparator&gt; m;</code></p><h2 id="stl-函数对象">11.2 STL 函数对象</h2><blockquote><p>重载函数调用操作符的类，其对象称为 <strong>函数对象</strong></p><p>函数对象使用重载的 <code>()</code> 时，行为类似函数调用，也叫<strong>仿函数</strong></p><p>函数对象的本质是一个类，不是一个函数。</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddInt</span>&#123;<span class="hljs-comment">// &lt;———— 函数对象</span><span class="hljs-keyword">public</span>:    <span class="hljs-type">int</span> extra = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">(<span class="hljs-type">int</span> n1, <span class="hljs-type">int</span> n2)</span> </span>&#123;<span class="hljs-comment">// &lt;———— 仿函数</span>        <span class="hljs-keyword">return</span> n1 + n2 + extra++;    &#125;&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    AddInt adding;    <span class="hljs-type">int</span> n = <span class="hljs-built_in">adding</span>(<span class="hljs-number">1</span>, <span class="hljs-number">14</span>);&#125;</code></pre></div><p><strong>特点：</strong></p><ul><li>函数对象使用时，可以像普通函数那样调用。可以有参数和返回值</li><li>函数对象超出普通函数的概念，可以有自己的状态</li><li>函数对象可以作为参数传递</li></ul><h3 id="谓词">11.2.1 谓词</h3><blockquote><p>返回 bool 类型的仿函数称为 <strong>谓词</strong></p><p>接受一个参数的仿函数被称为<strong>一元谓词</strong>、接受两个参数的仿函数被称为<strong>二元谓词</strong></p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CompareInt</span>&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> n1, <span class="hljs-type">int</span> n2 = <span class="hljs-number">0</span>)</span> </span>&#123;        <span class="hljs-keyword">return</span> n1 &gt; n2;    &#125;&#125;;</code></pre></div><h3 id="内建函数对象">11.2.2 内建函数对象</h3><blockquote><p>STL 内建了一些函数对象。这些函数对象用法和一般函数完全相同。</p><p>要使用这些函数对象，要包含头文件：<code>#include&lt;functional&gt;</code></p></blockquote><p>内建函数对象又分为三种：</p><ul><li>算数仿函数</li><li>关系仿函数</li><li>逻辑仿函数</li></ul><p><strong>算数仿函数：</strong></p><blockquote><p>主要功能是实现四则运算。</p></blockquote><ul><li><p><code>template&lt;class T&gt; plus&lt;T&gt;</code>：加法仿函数</p><div class="code-wrapper"><pre><code class="hljs c++">plus&lt;<span class="hljs-type">int</span>&gt; p;cout &lt;&lt; <span class="hljs-built_in">p</span>(<span class="hljs-number">1</span>, <span class="hljs-number">15</span>) &lt;&lt; endl;<span class="hljs-comment">// &lt;———— 输出 16</span></code></pre></div></li><li><p><code>template&lt;class T&gt; minus&lt;T&gt;</code>：减法仿函数</p></li><li><p><code>template&lt;class T&gt; multiplies&lt;T&gt;</code>：乘法仿函数</p></li><li><p><code>template&lt;class T&gt; divides&lt;T&gt;</code>：除法仿函数</p></li><li><p><code>template&lt;class T&gt; modulus&lt;T&gt;</code>：取模仿函数</p></li><li><p><code>template&lt;class T&gt; negate&lt;T&gt;</code>：取反仿函数（一元运算）</p></li></ul><p><strong>关系仿函数：</strong></p><ul><li><p><code>template&lt;class T&gt; bool equal_to&lt;T&gt;</code>：等于</p></li><li><p><code>template&lt;class T&gt; bool not_equal_to&lt;T&gt;</code>：不等于</p></li><li><p><code>template&lt;class T&gt; bool greater&lt;T&gt;</code>：大于</p><div class="code-wrapper"><pre><code class="hljs c++">set&lt;<span class="hljs-type">int</span>, greater&lt;<span class="hljs-type">int</span>&gt;&gt; s;<span class="hljs-comment">// &lt;———— 一个降序排序的 set</span></code></pre></div></li><li><p><code>template&lt;class T&gt; bool greater_equal&lt;T&gt;</code>：大于等于</p></li><li><p><code>template&lt;class T&gt; bool less&lt;T&gt;</code>：小于</p></li><li><p><code>template&lt;class T&gt; bool less_equal&lt;T&gt;</code>：小于等于</p></li></ul><p><strong>逻辑仿函数：</strong></p><ul><li><code>template&lt;class T&gt; bool logical_and&lt;T&gt;</code>：逻辑与</li><li><code>template&lt;class T&gt; bool logical_or&lt;T&gt;</code>：逻辑或</li><li><code>template&lt;class T&gt; bool logical_not&lt;T&gt;</code>：逻辑非</li></ul><h2 id="stl-常用算法">11.3 STL 常用算法</h2><p>算法主要由头文件<code>&lt;algorithm&gt;</code>、<code>&lt;functional&gt;</code>、<code>&lt;numeric&gt;</code>组成：</p><ul><li><code>&lt;algorithm&gt;</code>：所有 STL头文件中最大的一个，涉及比较、交换、查找、遍历、复制、修改等</li><li><code>&lt;numeric&gt;</code>：体积很小，只包括几个在序列上面进行简单数学运算的模板函数</li><li><code>&lt;functional&gt;</code>：定义了一些模板类，以声明函数对象</li></ul><p>不支持随机访问迭代器的容器，很多算法不支持。那个场合，应该使用那些容器内部内置方法</p><h3 id="常用遍历算法">11.3.1 常用遍历算法</h3><ul><li><p><code>void for_each(iterator start, iterator end, consumer)</code>：遍历。</p><p>把 [start, end) 范围的元素依次进行 consumer操作。不会改变原本对象。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printInt</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;cout &lt;&lt; n &lt;&lt; endl;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintInteger</span> &#123;<span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;cout &lt;&lt; n &lt;&lt; endl;&#125;&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;set&lt;<span class="hljs-type">int</span>, greater&lt;<span class="hljs-type">int</span>&gt;&gt; s;PrintInteger p;s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">1</span>);for_each(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>(), printInt);<span class="hljs-comment">// &lt;———— 传入函数</span>for_each(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">PrintInteger</span>());<span class="hljs-comment">// &lt;———— 传入函数对象（匿名初始化）</span>for_each(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>(), p);<span class="hljs-comment">// &lt;———— 传入函数对象</span>&#125;</code></pre></div></li><li><p><code>void transform(iterator beg1, interator end1, iterator beg2, function)</code>：搬运容器内容至另一个容器中</p><p>把源容器的 [beg1, end1) 范围的元素，经过 function处理后，添加到新容器的 beg2 位置。</p><p>function 的返回值应该是新容器指定的泛型类型</p><p><strong>注意：新容器必须具备合适的容量，否则会报错</strong></p></li></ul><h3 id="常用查找算法">11.3.2 常用查找算法</h3><ul><li><p><code>iterator&amp; find(iterator start, iterator end, T&amp; ele)</code>：查找元素</p><p>在 [start, end) 范围内查找 ele元素。找到的场合返回该元素初次出现的位置，否则返回 end</p><p>那个泛型 T 是自定义类型的场合，需要重载运算符 <code>==</code>以使算法能够进行对比</p></li><li><p><code>iterator&amp; find_if(iterator start, iterator end, function)</code>：按条件查找元素</p><p>其中的 function 是一个一元谓词</p></li><li><p><code>iterator&amp; adjacent_find(iterator start, iterator end)</code>：查找相邻的重复元素</p><p>找到的场合返回那组相邻元素中靠前元素的位置，否则返回 end</p></li><li><p><code>bool binary_search(iterator start, iterator end, T&amp; ele)</code>：用二分法查找元素是否存在</p><p>找到的场合返回 true，否则返回 false。</p><p><strong>注意：该方法不能在无序序列中使用</strong>。在无序序列查找的场合，结果未知</p></li><li><p><code>int count(iterator start, iterator end, T&amp; ele)</code>：统计元素个数</p></li><li><p><code>int count_if(iterator start, iterator end, function)</code>：按条件统计个数</p><p>其中的 function 是一个一元谓词</p></li></ul><h3 id="常用排序算法">11.3.3 常用排序算法</h3><ul><li><p><code>sort(iterator start, iterator end, consumer)</code>：排序</p><p>其中，consumer是一个二元谓词。也可以不写，那个场合，默认使用内建函数的 less仿函数</p></li><li><p><code>random_shuffle(iterator start, iterator end)</code>：打乱</p></li><li><p><code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)</code>：容器元素合并</p><p>把 [beg1, end1) 和 [beg2, end2) 的元素合并，并放入 dest 位置</p><p>源容器必须是有序的。</p></li><li><p><code>reserve(iterator start, iterator end)</code>：反转</p></li></ul><h3 id="常用拷贝和替换算法">11.3.4 常用拷贝和替换算法</h3><ul><li><p><code>copy(iterator beg1, iterator end1, iterator dest)</code>：拷贝</p></li><li><p><code>replace(iterator beg, iterator end, T&amp; old, T&amp; new)</code>：替换</p><p>将范围内的 old 元素替换为 new</p></li><li><p><code>replace_ifreplace(iterator beg, iterator end, consumer, T&amp; new)</code>：替换满足条件的元素</p><p>其中 consumer 是一个一元谓词</p></li><li><p><code>swap(container c1, container c2)</code>：互换两个容器的元素</p><p>两种容器必须是同一类型</p></li></ul><h3 id="常用算术生成算法">11.3.5 常用算术生成算法</h3><blockquote><p>算术生成算法是小型算法，其头文件为<code>include&lt;numeric&gt;</code></p></blockquote><ul><li><p><code>accumulate(iterator beg, iterator end, value)</code>：计算容器元素累计总和</p><p>计算 [beg, end) 范围的元素累加结果。累加初始值为 value</p></li><li><p><code>fill(iterator beg, iterator end, value)</code>：向容器中填充元素</p><p>[beg, end) 范围的元素变成 value</p></li></ul><h3 id="常用集合算法">11.3.6 常用集合算法</h3><ul><li><p><code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)</code>：求两个容器的交集</p><p>将在 [beg1, end1) 和 [beg2, end2) 两个范围内都出现过的元素，放入 dest位置</p><p>不会出现多次匹配到另一范围内的某个单一元素。</p><p>两个容器必须是有序排列的</p></li><li><p><code>set_union</code>：求两个容器的并集</p><p>将 [beg1, end1) 和 [beg2, end2) 两个范围内的元素放入 dest位置。重复元素只添加一次</p></li><li><p><code>set_difference</code>：求两个容器的差集</p><p>将 [beg1, end1) 和 [beg2, end2) 两个范围内的元素放入 dest位置。但是会去除那些重复出现过的元素</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;C++&gt;10 模板</title>
    <link href="/2022/04/30/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/10%20%E6%A8%A1%E6%9D%BF/"/>
    <url>/2022/04/30/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/10%20%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="模板">10 模板</h1><blockquote><p>C++ 另一种编程思想称为：泛型编程。主要利用的技术就是模板</p><p>C++ 提供两种模板：函数模板、类模板</p></blockquote><h2 id="函数模板">10.1 函数模板</h2><blockquote><p>函数模板：建立一个通用函数，其返回值类型和形参类型可以不具体指定，用一个虚拟的类型来代表。</p></blockquote><p><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-comment">// &lt;———— 声明模板</span><span class="hljs-function">T <span class="hljs-title">met</span><span class="hljs-params">(T obj)</span> </span>&#123;<span class="hljs-comment">// &lt;———— 这里是一处函数的声明或定义</span>    <span class="hljs-keyword">return</span> obj;&#125;</code></pre></div><blockquote><p>template：声明创建模板</p><p>typename：其后面的符号是一种数据类型。也能写成 class</p><p>T：通用数据类型。名字随便起</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> HOMU&gt;</span><span class="hljs-function">HOMU <span class="hljs-title">mosiMita</span><span class="hljs-params">(HOMU homu)</span> </span>&#123;    cout &lt;&lt; <span class="hljs-string">&quot;HomuHomu MiniDomu!&quot;</span> &lt;&lt; endl;    <span class="hljs-keyword">return</span> homu;&#125;</code></pre></div></blockquote><p><strong>注意事项：</strong></p><ul><li><p>自动类型推导，必须推导出一致的泛型才能使用</p></li><li><p>模板必须确定泛型的数据类型才能使用。</p><p>不能推导的场合，应该显式地指定泛型类型</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">biat</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// &lt;———— 不能进行类型推导</span>    cout &lt;&lt; <span class="hljs-string">&quot;Ye dada!&quot;</span> &lt;&lt; endl;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heli</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">biat</span>&lt;<span class="hljs-type">int</span>&gt;();<span class="hljs-comment">// &lt;———— 因不能进行类型推导，必须显式指定那个泛型类型</span>&#125;</code></pre></div></li></ul><p><strong>普通函数与函数模板的区别：</strong></p><ul><li><p>函数模板在编译时不生成任何目标代码。仅当通过模板生成具体的函数实例时才生成目标代码。</p></li><li><p>函数指针只能指向模板的实例，而不能指向模板本身</p></li><li><p>被多个源文件引用的函数模板，应当连同函数体一起放在头文件中</p></li><li><p>普通函数调用时能发生自动类型转换</p><p>函数模板调用时，如果<strong>利用自动类型推导，则不发生自动类型转换</strong>。</p><p>如果<strong>显式指定泛型类型，则仍会发生自动类型转换</strong></p></li></ul><p><strong>普通函数和函数模板的调用规则：</strong></p><ul><li><p>函数模板可以发生重载</p></li><li><p>如果普通函数和函数模板都能实现，则优先调用普通函数</p><p>可以通过空模板参数列表来强制调用函数模板</p></li><li><p>如果函数模板可以产生更好的匹配，则优先调用函数模板</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">act</span><span class="hljs-params">(T t)</span> </span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;模板函数&quot;</span> &lt;&lt; endl;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">act</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;普通函数&quot;</span> &lt;&lt; endl;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">act</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">// &lt;—————— 调用普通函数</span>act&lt;&gt;(<span class="hljs-number">1</span>);<span class="hljs-comment">// &lt;—————— 调用函数模板（空模板参数）</span><span class="hljs-built_in">act</span>(<span class="hljs-string">&#x27;1&#x27;</span>);<span class="hljs-comment">// &lt;—————— 调用函数模板（更好的匹配）</span>&#125;</code></pre></div></li></ul><p><strong>模板的局限性：</strong></p><ul><li><p>模板的通用性不是万能的。C++提供模板的重载，可以为特定类型实现更好的操作</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">act</span><span class="hljs-params">(T t)</span> </span>&#123;<span class="hljs-comment">// &lt;—————— 函数模板</span>cout &lt;&lt; <span class="hljs-string">&quot;T&quot;</span> &lt;&lt; endl;&#125;<span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">act</span><span class="hljs-params">(string s)</span> </span>&#123;<span class="hljs-comment">// &lt;—————— 函数模板的重载</span>cout &lt;&lt; s &lt;&lt; endl;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    string s = <span class="hljs-string">&quot;Heruin&quot;</span>;    <span class="hljs-built_in">act</span>(s);<span class="hljs-comment">// &lt;—————— 此处调用重载模板</span>&#125;</code></pre></div></li></ul><h2 id="类模板">10.2 类模板</h2><blockquote><p>声明模板 template 后加一个类即构成类模板</p></blockquote><p><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Y</span>&gt;<span class="hljs-comment">// &lt;—————— class 也可以写成 typename，一样的</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Lumine</span> &#123;<span class="hljs-comment">// &lt;—————— 类的声明或定义</span><span class="hljs-keyword">public</span>:    T lum_bro;    Y lum_wep;        <span class="hljs-built_in">Lumine</span>(T t, Y y) &#123;<span class="hljs-comment">// &lt;—————— 构造器</span>        <span class="hljs-keyword">this</span>-&gt;lum_bro = t;        <span class="hljs-keyword">this</span>-&gt;lum_wep = y;    &#125;        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">introduce</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// &lt;—————— 一个函数。模板类型变化时也可能出问题</span>        cout &lt;&lt; lum_bro &lt;&lt; endl;        cout &lt;&lt; lum_wep &lt;&lt; endl;    &#125;&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">Lumine&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; <span class="hljs-title">lumine</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span></span>;<span class="hljs-comment">// &lt;—————— 要这样去实例化</span>&#125;</code></pre></div><p><strong>与函数模板的区别：</strong></p><ul><li><p>类模板不能自动类型推导，所以必须显式指定类型</p></li><li><p>类模板在模板列表中可以有默认参数</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> = string, <span class="hljs-keyword">class</span> Y&gt;<span class="hljs-comment">// &lt;———— 添加了默认参数。这样，不显示指定就用默认类型</span><span class="hljs-keyword">class</span> Lumine;</code></pre></div></li></ul><p><strong>类模板中成员函数的创建时机：</strong></p><ul><li><p>普通类的成员函数在一开始就能创建</p></li><li><p>类模板的成员函数在调用时才能创建</p><p>因为数据类型不确定，该类在模板被调用前不会被创建</p></li></ul><p><strong>类模板继承问题：</strong></p><ul><li><p>子类继承的父类是一个模板的场合，子类声明时要指明那个父类的泛型类型</p><p>不指定的场合，编译器不能给子类分配内存</p></li><li><p>想要灵活指定父类泛型类型的场合，子类也要称为模板</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">TAR</span>&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">DF17</span> &#123;&#125;;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">TAR</span>&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">HX8</span> : <span class="hljs-keyword">private</span> DF17&lt;TAR&gt; &#123;&#125;;<span class="hljs-comment">// &lt;—————— [优质答案：“我不知道。”]</span></code></pre></div></li></ul><p><strong>类模板成员函数的类外实现：</strong></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ELE</span>&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Cryo</span> &#123;<span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">act</span><span class="hljs-params">(ELE t)</span></span>;<span class="hljs-built_in">Cryo</span>();&#125;;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">R</span>&gt;Cryo&lt;R&gt;::<span class="hljs-built_in">Cryo</span>() &#123;&#125;<span class="hljs-comment">// &lt;—————— 类模板构造器类外实现</span>Cryo&lt;<span class="hljs-type">char</span>&gt;::<span class="hljs-built_in">Cryo</span>() &#123;&#125;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> E&gt;<span class="hljs-type">void</span> Cryo&lt;E&gt;::<span class="hljs-built_in">act</span>(E t) &#123;&#125;<span class="hljs-comment">// &lt;—————— 类模板成员函数类外实现</span></code></pre></div><h3 id="类模板对象做函数参数">10.2.1 类模板对象做函数参数</h3><p><em>（下例中的）模板类如下：</em></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Gro</span>&#123;&#125;;<span class="hljs-comment">// &lt;—————— 随便写的一个空类</span></code></pre></div><p><strong>三种方式：</strong></p><ul><li><p>指定传入类型：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">act1</span><span class="hljs-params">(Gro&lt;<span class="hljs-type">int</span>&gt;&amp; g)</span> </span>&#123;<span class="hljs-comment">// &lt;———— “都说了是 Gro&lt;int&gt; 啦，你怎么听的呀（怒）”</span>    cout &lt;&lt; <span class="hljs-string">&quot;指定传入类型&quot;</span> &lt;&lt; endl;&#125;</code></pre></div></li><li><p>参数模板化：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">act2</span><span class="hljs-params">(Gro&lt;T&gt;&amp; g)</span> </span>&#123;<span class="hljs-comment">// &lt;———— “回去告诉你们那个参数，他是个模板朕也是个模板”</span>    cout &lt;&lt; <span class="hljs-string">&quot;参数模板化&quot;</span> &lt;&lt; endl;&#125;</code></pre></div></li><li><p>整个类模板化：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">act3</span><span class="hljs-params">(T&amp; t)</span> </span>&#123;<span class="hljs-comment">// &lt;———— “啊？什么模板类，没看到啊”</span>    cout &lt;&lt; <span class="hljs-string">&quot;整个类模板化&quot;</span> &lt;&lt; endl;&#125;</code></pre></div></li></ul><h3 id="类模板分文件编写">10.2.2 类模板分文件编写</h3><blockquote><p>类模板分文件编写的场合，在运行时可能报错</p><p>这是因为，分文件编写的场合，包含的是头文件。而类模板成员函数是在调用时创建，这会导致编译器不能读取源文件中的实现。</p></blockquote><p>头文件 <code>hydro.h</code>：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ELE</span>&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Hydro</span> &#123;<span class="hljs-comment">// &lt;———— 随便写的，意思一下</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">act</span><span class="hljs-params">(ELE t)</span></span>;<span class="hljs-built_in">Hydro</span>();&#125;;</code></pre></div><p>源文件 <code>hydro.cpp</code>：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">R</span>&gt;Hydro&lt;R&gt;::<span class="hljs-built_in">Hydro</span>() &#123;&#125;<span class="hljs-comment">// &lt;———— 随便写的，意思一下</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> E&gt;<span class="hljs-type">void</span> Hydro&lt;E&gt;::<span class="hljs-built_in">act</span>(E t) &#123;&#125;<span class="hljs-comment">// &lt;———— 随便写的，意思一下</span></code></pre></div><p><strong>解决方法：</strong></p><ul><li><p>不包含头文件，而是包含源文件（一般不这样）：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hydro.cpp&quot;</span><span class="hljs-comment">// &lt;———— 包含的不是头文件而是源文件</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    Hydro h;&#125;</code></pre></div></li><li><p>将头文件和源文件合并为 <code>hydro.hpp</code>：</p><p>头文件 <code>hydro.hpp</code>：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ELE</span>&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Hydro</span> &#123;<span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">act</span><span class="hljs-params">(ELE t)</span></span>;<span class="hljs-built_in">Hydro</span>();&#125;;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">R</span>&gt;Hydro&lt;R&gt;::<span class="hljs-built_in">Hydro</span>()&#123;&#125;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> E&gt;<span class="hljs-type">void</span> Hydro&lt;E&gt;::<span class="hljs-built_in">act</span>(E t) &#123;&#125;</code></pre></div><p>之后，包含该 hpp 文件即可</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hydro.hpp&quot;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    Hydro h;&#125;</code></pre></div><p>后缀名 hpp 是约定俗成的名称。非要变也可以</p></li></ul><h3 id="类模板做友元">10.2.3 类模板做友元</h3><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">L</span>&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Anemo</span>;<span class="hljs-comment">// &lt;———— [5]</span><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> L&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">act2</span><span class="hljs-params">(Anemo&lt;L&gt; a)</span></span>;<span class="hljs-comment">// &lt;———— [4]</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">L</span>&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Anemo</span> &#123;    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">act1</span><span class="hljs-params">(Anemo&lt;L&gt; a)</span> </span>&#123;&#125;<span class="hljs-comment">// &lt;———— [1]</span>    <span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> act2&lt;&gt;(Anemo&lt;L&gt; a);<span class="hljs-comment">// &lt;———— [3]</span><span class="hljs-keyword">private</span>:    L val = <span class="hljs-number">1</span>;&#125;;<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> L&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">act2</span><span class="hljs-params">(Anemo&lt;L&gt; a)</span> </span>&#123;&#125;<span class="hljs-comment">// &lt;———— [2]</span></code></pre></div><ol type="1"><li><p>全局函数<font color="#00AA00"><strong>类内实现</strong></font>的场合，可以直接包含友元</p><blockquote><p>[1]</p><p>friend void act1(Anemo&lt;L&gt; a)<font color="#00AA00"><strong>{}</strong></font></p></blockquote></li><li><p>全局函数的类外实现，需要添加<font color="#FFA000"><strong>模板声明</strong></font></p><blockquote><p>[2]</p><p><font color="#FFA000"><strong>template&lt;typenameL&gt;</strong></font> void act2(Anemo&lt;L&gt; a) {}</p></blockquote></li><li><p>全局函数类外实现的场合，包含友元时要加入<font color="#00AA00"><strong>空模板参数列表</strong></font>，以示其为模板函数而非普通函数</p><blockquote><p>[3]</p><p>friend <font color="#FF0010"><em>voidact2</em></font><font color="#00AA00"><strong>&lt;&gt;</strong></font>(Anemo&lt;L&gt;a);</p></blockquote></li><li><p>由于类内使用了<font color="#FF0010"><em>此前未声明过的全局函数</em></font>，所以还要将全局函数在类实现前进行<font color="#FFA000"><strong>声明</strong></font>，以向编译器提示该函数的存在</p><blockquote><p>[4]</p><p>template&lt;typename L&gt; <font color="#FFA000"><strong>voidact2</strong></font>(<font color="#FF00ff"><em>Anemo&lt;L&gt;a</em></font>);</p></blockquote></li><li><p>由于该全局函数参数是一个<font color="#FF00ff"><em>此前未声明过的类</em></font>，故该类也要在全局函数声明前<font color="#00AA00"><strong>声明</strong></font>，以向编译器提示该类的存在</p><blockquote><p>[5]</p><p>template&lt;class L&gt; <font color=#00AA00><strong>classAnemo;</strong></font></p></blockquote></li></ol><h2 id="附录">附录</h2><h3 id="可变数组类">可变数组类</h3><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">OArray</span> &#123;<span class="hljs-keyword">public</span>:C* cs = <span class="hljs-literal">NULL</span>;<span class="hljs-built_in">OArray</span>() &#123;m_size = <span class="hljs-number">5</span>;cs = <span class="hljs-keyword">new</span> C[m_size];&#125;<span class="hljs-built_in">OArray</span>(<span class="hljs-type">int</span> n) &#123;<span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>) n = <span class="hljs-number">5</span>;m_size = n;cs = <span class="hljs-keyword">new</span> C[m_size];&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">const</span> C&amp; obj)</span> </span>&#123;<span class="hljs-keyword">if</span> (cs == <span class="hljs-literal">NULL</span>) cs = <span class="hljs-keyword">new</span> C[m_size];<span class="hljs-keyword">if</span> (m_length &gt;= m_size) &#123;C* temp = <span class="hljs-keyword">new</span> C[m_size * <span class="hljs-number">2</span>];<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m_size; i++) &#123;temp[i] = cs[i];&#125;<span class="hljs-keyword">delete</span>[] cs;cs = <span class="hljs-literal">NULL</span>;cs = temp;m_size *= <span class="hljs-number">2</span>;&#125;cs[m_length++] = obj;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteLast</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">if</span> (m_length &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;m_length--;cs[m_length] = <span class="hljs-literal">NULL</span>;&#125;C&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> n) &#123;<span class="hljs-keyword">return</span> cs[n];&#125;<span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>=(OArray&lt;C&gt;&amp; o) &#123;<span class="hljs-keyword">this</span>-&gt;m_size = o.m_size;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;cs != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">delete</span>[] <span class="hljs-keyword">this</span>-&gt;cs;<span class="hljs-keyword">this</span>-&gt;cs = <span class="hljs-literal">NULL</span>;<span class="hljs-keyword">this</span>-&gt;m_length = <span class="hljs-number">0</span>;<span class="hljs-keyword">this</span>-&gt;cs = <span class="hljs-keyword">new</span> C[o.<span class="hljs-built_in">getSize</span>()];<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; o.<span class="hljs-built_in">getLength</span>(); i++) &#123;<span class="hljs-built_in">add</span>(o.cs[i]);&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getLength</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> m_length;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> m_size;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n = <span class="hljs-number">0</span>; n &lt; m_length; n++) &#123;cout &lt;&lt; cs[n] &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span>;&#125;cout &lt;&lt; endl;&#125;~<span class="hljs-built_in">OArray</span>() &#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;cs != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">delete</span>[] <span class="hljs-keyword">this</span>-&gt;cs;<span class="hljs-keyword">this</span>-&gt;cs = <span class="hljs-literal">NULL</span>;&#125;<span class="hljs-keyword">private</span>:<span class="hljs-type">int</span> m_size = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> m_length = <span class="hljs-number">0</span>;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>程序</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;C++&gt;9 项目：职工管理系统</title>
    <link href="/2022/04/27/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/9%20%E9%A1%B9%E7%9B%AE%EF%BC%9A%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/04/27/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/9%20%E9%A1%B9%E7%9B%AE%EF%BC%9A%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="项目职工管理系统">9 项目：职工管理系统</h1><h2 id="业务需求">9.1 业务需求</h2><p>公司中员工分 3 类：普通员工、经理、老板</p><p>员工信息包含：职工编号、职工姓名、职工岗位、职责</p><ul><li>普通员工职责：完成经理交代的任务</li><li>经理职责：完成老板交代的任务，下发任务给员工</li><li>老板职责：管理公司所有事物</li></ul><p>管理系统实现功能包括：</p><ul><li>退出管理程序</li><li>增加职工信息<ul><li>批量添加职工</li><li>将职工信息导出至文件</li></ul></li><li>显示所有职工信息</li><li>删除离职职工：按照编号</li><li>修改职工信息：按照编号</li><li>查找职工信息：按照编号</li><li>按照编号排序：按照编号，用户能指定排序规则</li><li>清空所有文档：二次确认</li></ul><h2 id="附录">附录</h2><h3 id="职工管理系统">职工管理系统</h3><blockquote><p>包含头文件后，执行：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">menu0</span>();</code></pre></div></blockquote><p><strong>头文件：</strong></p><blockquote><p><em>MenuHead.h</em>：菜单及菜单功能。</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once<span class="hljs-comment">//由于头文件可能被重复包含，必须加上这句，避免重定义</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;myHead.h&quot;</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showMenu0</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//显示菜单。只是输出文字而已</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">menu0</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//菜单的主方法。调用该方法进入管理系统</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showAll</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//显示所有员工信息</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//查询员工</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//添加员工</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//改变员工信息</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//删除员工</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//排序</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//清空文档</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">exit</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//退出</span></code></pre></div><blockquote><p><em>myHead.h</em>：几种员工类，及一个数据处理类。</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;Windows.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<span class="hljs-comment">//普通员工类。该类是其余 2 种员工类的父类</span><span class="hljs-keyword">public</span>:<span class="hljs-type">static</span> <span class="hljs-type">int</span> count;<span class="hljs-comment">//count 属性是一个计数器。该值等于新员工的 ID 数</span><span class="hljs-type">int</span> id;<span class="hljs-comment">//id 即 ID</span>string name;<span class="hljs-comment">//姓名</span>string duty;<span class="hljs-comment">//职责</span>string pos;<span class="hljs-comment">//职位</span><span class="hljs-built_in">Employee</span>(string name);<span class="hljs-comment">//构造器</span><span class="hljs-built_in">Employee</span>();<span class="hljs-comment">//无参构造器，因为一些原因不使用</span>&#125;;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Boss</span> :<span class="hljs-keyword">public</span> Employee &#123;<span class="hljs-comment">//老板类，该类是员工类的子类</span><span class="hljs-keyword">public</span>:<span class="hljs-built_in">Boss</span>(string name);&#125;;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Manager</span> :<span class="hljs-keyword">public</span> Employee &#123;<span class="hljs-comment">//经理类。该类是员工类的子类</span><span class="hljs-keyword">public</span>:<span class="hljs-built_in">Manager</span>(string name);&#125;;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span> &#123;<span class="hljs-comment">//数据处理类。该类能实现菜单功能</span><span class="hljs-keyword">public</span>:string path;<span class="hljs-comment">//输出文件的路径</span>string temp_path;<span class="hljs-comment">//临时路径</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">add</span><span class="hljs-params">(Employee* e)</span></span>;<span class="hljs-comment">//添加一个新员工</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">showAll</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//打印全部员工信息</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span></span>;<span class="hljs-comment">//打印单个员工信息</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(Employee* e)</span></span>;<span class="hljs-comment">//修改单个员工信息</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span></span>;<span class="hljs-comment">//删除单个员工信息</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-type">int</span> func)</span></span>;<span class="hljs-comment">//员工信息排序</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//初始化员工信息</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">rollback</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//恢复数据</span><span class="hljs-keyword">private</span>:<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">flush</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//更新员工信息文档。只要进行过任何信息修改，必定调用该方法</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">showSingle</span><span class="hljs-params">(Employee* e)</span></span>;    <span class="hljs-comment">//打印特定员工信息。所有打印信息方法必定调用该方法</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(Employee* e)</span></span>;<span class="hljs-comment">//添加新员工</span><span class="hljs-type">static</span> Data data;<span class="hljs-comment">//持有一个信息类实例</span>Employee** es;<span class="hljs-comment">//信息类实例包含的信息数组</span><span class="hljs-type">bool</span> desc;<span class="hljs-comment">//信息类实例展示信息时按照升序或降序排列</span><span class="hljs-type">int</span> len;<span class="hljs-comment">//信息类实例的数组长度</span><span class="hljs-built_in">Data</span>();<span class="hljs-comment">//构造器</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(string ps)</span></span>;<span class="hljs-comment">//从指定文件中读取数据</span>&#125;;</code></pre></div><p><strong>源文件：</strong></p><blockquote><p><em>Employee.cpp</em>：3 个员工类</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;myHead.h&quot;</span></span>Employee::<span class="hljs-built_in">Employee</span>(string name) &#123;<span class="hljs-comment">//员工类构造器</span><span class="hljs-keyword">this</span>-&gt;id = count++;<span class="hljs-comment">//count 是 Employee 类的静态变量。这样保证每个员工 ID 独一无二</span><span class="hljs-keyword">this</span>-&gt;name = name;<span class="hljs-keyword">this</span>-&gt;pos = <span class="hljs-string">&quot;员工&quot;</span>;duty = <span class="hljs-string">&quot;完成经理交代的任务&quot;</span>;&#125;Employee::<span class="hljs-built_in">Employee</span>()&#123;&#125;Boss::<span class="hljs-built_in">Boss</span>(string name) &#123;<span class="hljs-comment">//老板类构造器</span><span class="hljs-keyword">this</span>-&gt;id = count++;<span class="hljs-keyword">this</span>-&gt;name = name;<span class="hljs-keyword">this</span>-&gt;pos = <span class="hljs-string">&quot;老板&quot;</span>;duty = <span class="hljs-string">&quot;管理公司所有事物&quot;</span>;&#125;Manager::<span class="hljs-built_in">Manager</span>(string name) &#123;<span class="hljs-comment">//经理类构造器</span><span class="hljs-keyword">this</span>-&gt;id = count++;<span class="hljs-keyword">this</span>-&gt;name = name;<span class="hljs-keyword">this</span>-&gt;pos = <span class="hljs-string">&quot;经理&quot;</span>;duty = <span class="hljs-string">&quot;完成老板交代的任务，下发任务给员工&quot;</span>;&#125;</code></pre></div><blockquote><p><em>Menu.cpp</em>：菜单类</p><p>接收用户指令，并对数据进行初步处理，最终移交给 Data 类执行</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;myHead.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;MenuHead.h&quot;</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showMenu0</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//展示菜单</span>cout &lt;&lt; <span class="hljs-string">&quot;—————————欢迎使用职工管理系统—————————&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;\t\t\t1 显示所有职工信息&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;\t\t\t2 查找职工信息&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;\t\t\t3 增加职工信息&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;\t\t\t4 修改职工信息&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;\t\t\t5 删除职工&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;\t\t\t6 员工排序&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;\t\t\t7 清空员工信息文档&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;\t\t\t9 退出职工管理系统&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;————————————————————————————&quot;</span> &lt;&lt; endl;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">menu0</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//想进入系统就调用该方法把</span><span class="hljs-type">bool</span> run = <span class="hljs-literal">true</span>;<span class="hljs-comment">//确定退出系统前，该值为 true</span><span class="hljs-type">bool</span> skipMenu = <span class="hljs-literal">false</span>;<span class="hljs-comment">//跳过菜单。该值没有投入使用</span><span class="hljs-keyword">while</span> (run) &#123;<span class="hljs-keyword">if</span> (!skipMenu) <span class="hljs-built_in">showMenu0</span>();<span class="hljs-comment">//展示菜单</span>skipMenu = <span class="hljs-literal">false</span>;cout &lt;&lt; <span class="hljs-string">&quot;请选择：&quot;</span>;<span class="hljs-comment">//用户选择</span>string in = <span class="hljs-string">&quot;&quot;</span>;cin &gt;&gt; in;<span class="hljs-keyword">switch</span> (in[<span class="hljs-number">0</span>]) &#123;<span class="hljs-comment">//进入分支</span><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;1&#x27;</span>:<span class="hljs-built_in">showAll</span>();<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;2&#x27;</span>:<span class="hljs-built_in">check</span>();<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;3&#x27;</span>:<span class="hljs-built_in">add</span>();<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;4&#x27;</span>:<span class="hljs-built_in">change</span>();<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;5&#x27;</span>:<span class="hljs-built_in">del</span>();<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;6&#x27;</span>:<span class="hljs-built_in">sort</span>();<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;7&#x27;</span>:<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;9&#x27;</span>:<span class="hljs-keyword">if</span> (<span class="hljs-built_in">exit</span>()) &#123; cout &lt;&lt; <span class="hljs-string">&quot;再见&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">default</span>:cout &lt;&lt; <span class="hljs-string">&quot;输入错误，请重新输入&quot;</span> &lt;&lt; endl;skipMenu = <span class="hljs-literal">true</span>;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;cls&quot;</span>);&#125;cout &lt;&lt; <span class="hljs-string">&quot;职工管理系统已停止&quot;</span> &lt;&lt; endl;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showAll</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//展示全部员工信息。</span>cout &lt;&lt; <span class="hljs-string">&quot;————————————————————————————&quot;</span> &lt;&lt; endl;Data::<span class="hljs-built_in">showAll</span>();cout &lt;&lt; endl;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">check</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//展示某个员工的信息</span>cout &lt;&lt; <span class="hljs-string">&quot;————————————————————————————&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;请输入想查询的员工编号：&quot;</span>;<span class="hljs-type">int</span> id = <span class="hljs-number">-1</span>;cin &gt;&gt; id;<span class="hljs-keyword">if</span> (!Data::<span class="hljs-built_in">check</span>(id)) &#123;<span class="hljs-comment">//Data::check(int) 会打印信息。没有该员工，则返回 false</span><span class="hljs-keyword">return</span>;<span class="hljs-comment">//多此一举了是吧</span>&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//添加员工</span>cout &lt;&lt; <span class="hljs-string">&quot;————————————————————————————&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;请输入员工姓名：&quot;</span>;string name;cin &gt;&gt; name;cout &lt;&lt; <span class="hljs-string">&quot;请选择员工职务（1员工/2经理/3老板）：&quot;</span>;string duty;cin &gt;&gt; duty;Employee* e;<span class="hljs-keyword">if</span> (duty[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<span class="hljs-comment">//是，也能 switch，但我偏不</span>e = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Employee</span>(name);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (duty[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;2&#x27;</span>) &#123;e = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Manager</span>(name);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (duty[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;3&#x27;</span>) &#123;e = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boss</span>(name);&#125;<span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;输入错误&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">return</span>;&#125;Data::<span class="hljs-built_in">add</span>(e);cout &lt;&lt; <span class="hljs-string">&quot;添加成功&quot;</span> &lt;&lt; endl;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//修改员工信息</span>cout &lt;&lt; <span class="hljs-string">&quot;————————————————————————————&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;请输入想修改的员工编号：&quot;</span>;<span class="hljs-type">int</span> id = <span class="hljs-number">-1</span>;cin &gt;&gt; id;cout &lt;&lt; <span class="hljs-string">&quot;—  —  —  —  —  —  —  —  —  —  —  —  —  —&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">if</span> (!Data::<span class="hljs-built_in">check</span>(id)) &#123;<span class="hljs-keyword">return</span>;&#125;cout &lt;&lt; <span class="hljs-string">&quot;请输入修改后的员工名字：&quot;</span>;string name;cin &gt;&gt; name;cout &lt;&lt; <span class="hljs-string">&quot;请输入修改后的员工职务（1员工/2经理/3老板）：&quot;</span>;string duty;cin &gt;&gt; duty;Employee* e;<span class="hljs-keyword">if</span> (duty[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;e = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Employee</span>(name);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (duty[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;2&#x27;</span>) &#123;e = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Manager</span>(name);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (duty[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;3&#x27;</span>) &#123;e = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boss</span>(name);&#125;<span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;输入错误&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">return</span>;&#125;e-&gt;id = id;Employee::count--;<span class="hljs-comment">//因为只是修改员工信息，不需要 count 变化。故而把自增过的该值减小</span>Data::<span class="hljs-built_in">change</span>(e);cout &lt;&lt; <span class="hljs-string">&quot;添加成功&quot;</span> &lt;&lt; endl;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//删除员工信息</span><span class="hljs-built_in">showAll</span>();cout &lt;&lt; <span class="hljs-string">&quot;————————————————————————————&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;请输入要删除的员工号：&quot;</span>;<span class="hljs-type">int</span> id;cin &gt;&gt; id;cout &lt;&lt; endl;<span class="hljs-keyword">if</span> (!Data::<span class="hljs-built_in">check</span>(id)) &#123;<span class="hljs-keyword">return</span>;&#125;cout &lt;&lt; <span class="hljs-string">&quot;此操作不能撤销，确认要删除吗（确认请输入：YES）：&quot;</span>;string emp;cin &gt;&gt; emp;<span class="hljs-keyword">if</span> (emp == <span class="hljs-string">&quot;YES&quot;</span>) cout &lt;&lt; (Data::<span class="hljs-built_in">del</span>(id) ? <span class="hljs-string">&quot;成功&quot;</span> : <span class="hljs-string">&quot;失败&quot;</span>) &lt;&lt; endl;<span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;取消&quot;</span> &lt;&lt; endl;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//排序。其实根本没排序</span>cout &lt;&lt; <span class="hljs-string">&quot;————————————————————————————&quot;</span> &lt;&lt; endl;<span class="hljs-type">int</span> desc;cout &lt;&lt; <span class="hljs-string">&quot;请输入排序方式（1升序/2降序）：&quot;</span>;cin &gt;&gt; desc;Data::<span class="hljs-built_in">sort</span>(desc == <span class="hljs-number">2</span> ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//清空。其实根本没清空</span>cout &lt;&lt; <span class="hljs-string">&quot;————————————————————————————&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;即将清空员工信息文档&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;该操作不可恢复，请确认（确认请输入：YES）：&quot;</span>;string in;cin &gt;&gt; in;<span class="hljs-keyword">if</span> (in == <span class="hljs-string">&quot;YES&quot;</span>) &#123; Data::<span class="hljs-built_in">clear</span>(); cout &lt;&lt; <span class="hljs-string">&quot;员工文档已清空&quot;</span> &lt;&lt; endl;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (in == <span class="hljs-string">&quot;ROLLBACK&quot;</span>) &#123;<span class="hljs-comment">//这是一条隐藏的恢复数据指令</span>Data::<span class="hljs-built_in">rollback</span>();&#125;<span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;取消&quot;</span> &lt;&lt; endl;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">exit</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//退出</span>cout &lt;&lt; <span class="hljs-string">&quot;————————————————————————————&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;即将退出操作系统，确定吗（Y/N）：&quot;</span>;string exit;cin &gt;&gt; exit;<span class="hljs-keyword">return</span> exit == <span class="hljs-string">&quot;y&quot;</span> || exit == <span class="hljs-string">&quot;Y&quot;</span>;&#125;</code></pre></div><blockquote><p><em>Data.cpp</em>：数据处理类</p><p>从 Menu 类处获得处理过的数据，并最终完成对数据的处理</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;myHead.h&quot;</span></span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Data::add</span><span class="hljs-params">(Employee* e)</span> </span>&#123;<span class="hljs-comment">//添加指定员工对象</span>data.<span class="hljs-built_in">put</span>(e);<span class="hljs-comment">//向数据数组内添加员工对象</span><span class="hljs-built_in">flush</span>();<span class="hljs-comment">//向信息文件内写入新数据</span><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Data::showAll</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//展示全部员工信息</span><span class="hljs-built_in">flush</span>();<span class="hljs-keyword">if</span> (data.desc) &#123;<span class="hljs-comment">//按照设置的升序、降序进行输出</span><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n = data.len - <span class="hljs-number">1</span>; n &gt;= <span class="hljs-number">0</span>; n--) &#123;<span class="hljs-keyword">if</span> (data.es[n] != <span class="hljs-literal">NULL</span>) <span class="hljs-built_in">showSingle</span>(data.es[n]);&#125;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n = <span class="hljs-number">0</span>; n &lt; data.len; n++) &#123;<span class="hljs-keyword">if</span> (data.es[n] != <span class="hljs-literal">NULL</span>) <span class="hljs-built_in">showSingle</span>(data.es[n]);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Data::check</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;<span class="hljs-comment">//按 ID 展示对象信息</span><span class="hljs-keyword">if</span> (id &lt;= data.len &amp;&amp; data.es[id] != <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-built_in">showSingle</span>(data.es[id]);<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;查无此人&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Data::change</span><span class="hljs-params">(Employee* e)</span> </span>&#123;<span class="hljs-comment">//修改对象信息</span><span class="hljs-keyword">if</span> (e-&gt;id &lt;= data.len) &#123;<span class="hljs-keyword">delete</span> data.es[e-&gt;id];data.es[e-&gt;id] = <span class="hljs-literal">NULL</span>;data.es[e-&gt;id] = e;&#125;<span class="hljs-keyword">else</span> data.<span class="hljs-built_in">put</span>(e);<span class="hljs-built_in">flush</span>();<span class="hljs-comment">//重写信息文件</span>&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Data::del</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;<span class="hljs-comment">//删除对象信息</span><span class="hljs-keyword">if</span> (id &lt;= data.len) &#123;<span class="hljs-keyword">delete</span> data.es[id];data.es[id] = <span class="hljs-literal">NULL</span>;<span class="hljs-built_in">flush</span>();<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Data::sort</span><span class="hljs-params">(<span class="hljs-type">int</span> func)</span> </span>&#123;<span class="hljs-comment">//修改排序方法。其实只是修改了一个值</span><span class="hljs-keyword">if</span> (data.desc == (func == <span class="hljs-number">2</span>)) <span class="hljs-keyword">return</span>;data.desc = (func == <span class="hljs-number">2</span>);<span class="hljs-built_in">flush</span>();&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Data::clear</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//初始化数据。信息文件会作为副本得以保留</span><span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>));string temp = data.path + <span class="hljs-built_in">to_string</span>(<span class="hljs-built_in">rand</span>());<span class="hljs-comment">//将原本的信息文件名加上了后缀</span><span class="hljs-built_in">remove</span>(temp.<span class="hljs-built_in">c_str</span>());<span class="hljs-built_in">rename</span>(data.path.<span class="hljs-built_in">c_str</span>(), temp.<span class="hljs-built_in">c_str</span>());<span class="hljs-comment">//原本的信息文件改名后放在一边</span><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n = <span class="hljs-number">0</span>; n &lt; data.len; n++) &#123;<span class="hljs-keyword">if</span> (data.es[n] != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">delete</span> data.es[n];data.es[n] = <span class="hljs-literal">NULL</span>;&#125;<span class="hljs-keyword">delete</span> data.es;data.len = <span class="hljs-number">5</span>;data.es = <span class="hljs-keyword">new</span> Employee * [data.len];Employee::count = <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Data::rollback</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">clear</span>();data.<span class="hljs-built_in">read</span>(data.temp_path);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Data::flush</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//写入信息文件。根据排序方法不同写入方式不同</span><span class="hljs-function">ofstream <span class="hljs-title">ofs</span><span class="hljs-params">(data.path, ios::out | ios::trunc)</span></span>;<span class="hljs-keyword">if</span> (!data.desc) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n = <span class="hljs-number">0</span>; n &lt; data.len; n++) &#123;<span class="hljs-keyword">if</span> (data.es[n] != <span class="hljs-literal">NULL</span>) ofs &lt;&lt; <span class="hljs-string">&quot;ID：&quot;</span> &lt;&lt; (data.es[n])-&gt;id &lt;&lt; <span class="hljs-string">&quot;\t姓名：&quot;</span> &lt;&lt; data.es[n]-&gt;name &lt;&lt; <span class="hljs-string">&quot;\t职务：&quot;</span> &lt;&lt; data.es[n]-&gt;pos &lt;&lt; <span class="hljs-string">&quot;\t职责：&quot;</span> &lt;&lt; data.es[n]-&gt;duty &lt;&lt; endl;&#125;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n = data.len - <span class="hljs-number">1</span>; n &gt;= <span class="hljs-number">0</span>; n--) &#123;<span class="hljs-keyword">if</span> (data.es[n] != <span class="hljs-literal">NULL</span>) ofs &lt;&lt; <span class="hljs-string">&quot;ID：&quot;</span> &lt;&lt; data.es[n]-&gt;id &lt;&lt; <span class="hljs-string">&quot;\t姓名：&quot;</span> &lt;&lt; data.es[n]-&gt;name &lt;&lt; <span class="hljs-string">&quot;\t职务：&quot;</span> &lt;&lt; data.es[n]-&gt;pos &lt;&lt; <span class="hljs-string">&quot;\t职责：&quot;</span> &lt;&lt; data.es[n]-&gt;duty &lt;&lt; endl;&#125;&#125;ofs.<span class="hljs-built_in">close</span>();&#125;Data::<span class="hljs-built_in">Data</span>() &#123;<span class="hljs-comment">//构造器。会且只会调用一次</span>path = <span class="hljs-string">&quot;d:\\练习\\data.data&quot;</span>;temp_path = <span class="hljs-string">&quot;d:\\练习\\data.datat&quot;</span>;desc = <span class="hljs-literal">false</span>;len = <span class="hljs-number">5</span>;es = <span class="hljs-keyword">new</span> Employee * [len]&#123;<span class="hljs-literal">NULL</span>&#125;;Employee::count = <span class="hljs-number">0</span>;<span class="hljs-built_in">read</span>();&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Data::showSingle</span><span class="hljs-params">(Employee* e)</span> </span>&#123;<span class="hljs-comment">//展示某员工对象信息</span><span class="hljs-keyword">if</span> (e == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;cout &lt;&lt; <span class="hljs-string">&quot;ID：&quot;</span> &lt;&lt; e-&gt;id &lt;&lt; <span class="hljs-string">&quot;\t姓名：&quot;</span> &lt;&lt; e-&gt;name &lt;&lt; <span class="hljs-string">&quot;\t职务：&quot;</span> &lt;&lt; e-&gt;pos &lt;&lt; <span class="hljs-string">&quot;\t职责：&quot;</span> &lt;&lt; e-&gt;duty &lt;&lt; endl;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Data::put</span><span class="hljs-params">(Employee* e)</span> </span>&#123;<span class="hljs-comment">//将对象放入数据数组</span><span class="hljs-keyword">if</span> (e-&gt;id &gt;= len) &#123;<span class="hljs-comment">//如果数组空间不够，会先扩容</span><span class="hljs-type">int</span> temp = len;len = e-&gt;id + <span class="hljs-number">5</span>;Employee** et = <span class="hljs-keyword">new</span> Employee * [len];<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n = <span class="hljs-number">0</span>; n &lt; temp; n++) &#123;et[n] = <span class="hljs-keyword">this</span>-&gt;es[n];&#125;<span class="hljs-keyword">delete</span>[] es;es = <span class="hljs-literal">NULL</span>;es = et;&#125;es[e-&gt;id] = e;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Data::read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//从已有文档读取信息</span><span class="hljs-function">ifstream <span class="hljs-title">ifs</span><span class="hljs-params">(path, ios::in)</span></span>;<span class="hljs-keyword">if</span> (!ifs.<span class="hljs-built_in">is_open</span>()) &#123;ifs.<span class="hljs-built_in">close</span>();<span class="hljs-keyword">return</span>;&#125;<span class="hljs-type">int</span> max = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> id;string name;string pos;string dump;<span class="hljs-keyword">while</span> (ifs &gt;&gt; id &amp;&amp; ifs &gt;&gt; name &amp;&amp; ifs &gt;&gt; pos &amp;&amp; ifs &gt;&gt; dump) &#123;Employee* e;<span class="hljs-keyword">if</span> (pos == <span class="hljs-string">&quot;老板&quot;</span>) e = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boss</span>(name);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pos == <span class="hljs-string">&quot;经理&quot;</span>) e = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Manager</span>(name);<span class="hljs-keyword">else</span> e = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Employee</span>(name);e-&gt;id = id;Employee::count--;<span class="hljs-keyword">if</span> (max &lt;= id) max = id + <span class="hljs-number">1</span>;<span class="hljs-built_in">put</span>(e);&#125;ifs.<span class="hljs-built_in">close</span>();Employee::count = max;&#125;<span class="hljs-type">int</span> Employee::count = <span class="hljs-number">0</span>; <span class="hljs-comment">//静态变量类外初始化</span>Data Data::data = <span class="hljs-built_in">Data</span>();<span class="hljs-comment">//静态变量类外初始化</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>程序</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt;15 图形界面设计</title>
    <link href="/2022/04/22/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/15%20%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1/"/>
    <url>/2022/04/22/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/15%20%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="图形界面设计">15 图形界面设计</h1><blockquote><p>图形用户界面（Graphical User Interface，简称GUI）是大多数程序不可缺少的部分。</p><p>Java 的图形界面由各种组件组成。在 java.awt 和 java.swing包中定义了多种用于创建图形用户界面的组件类。</p><p>Swing 组件和 AWT 组件最大的不同是 Swing组件实现时不包含任何本地代码，因此不受硬件平台的限制，而具有更多的功能，并且在任何平台上运行效果都是相同的。不包含本地代码的Swing 组件被称为 “轻量级” 组件，而 AWT 被称为 “重量级”组件。两种组件一同使用的场合，AWT 总是显示在上面。</p></blockquote><p>设计用户界面是一般有 3 个步骤：</p><ol type="1"><li>选取组件</li><li>设计布局</li><li>响应事件</li></ol><h2 id="容器">15.1 容器</h2><blockquote><p>组件分为容器组件和非容器组件。容器组件即可以包含其他组件的组件。非容器组件必须包含在容器组件中。</p><p>容器组件分为：顶层容器、一般用途容器</p></blockquote><h3 id="顶层容器">15.1.1 顶层容器</h3><p>Swing 中提供了 4 种顶层容器：</p><ul><li>JFrame：带有标题行和控制按钮（最小化、恢复/最大化、关闭）的独立窗口。有时称为框架。创建程序时要使用JFream</li><li>JApplet：创建小应用程序时要使用 JApplet。其被包含在浏览器窗口中</li><li>JDialog：创建对话框时使用 JDialog</li><li>JWindow：一个不带有标题行和控制按钮的窗口。一般很少使用</li></ul><p>构造方法：</p><ul><li><code>new JFrame()</code>：构造一个初始不可见，无标题的新框架窗体</li><li><code>new JFrame("Title")</code>：构造一个初始不可见，具有指定标题的新框架窗体</li></ul><p>常用方法：</p><ul><li><p><code>void setBounds(int x, int y, int width, int height)</code>：移动并调整框架大小。框架左上角位置为（x,y），框架大小为 width × height</p></li><li><p><code>void setSize(int width, int height)</code>：设置窗口大小</p></li><li><p><code>void setBackground(Color bg)</code>：设置框架背景色</p><p><code>void setForeground(Color fg)</code>：设置框架前景色</p></li><li><p><code>void setVisible(boolean aFlag)</code>：设置可见性</p></li><li><p><code>void pack()</code>：自适应框架大小，以符合子组件的首选大小和布局</p></li><li><p><code>void setTitle(String title)</code>：设置标题</p></li><li><p><code>Container getContentPane()</code>：返回此框架窗体的内容窗格对象</p><p><em>Container 类是所有容器类的父类，包含容器的共有操作</em></p><p><code>void setContentPane(Container contentPane)</code>：把指定内容窗格设置为此框架的内容窗格对象</p></li><li><p><code>void setLayout(LayoutManager manager)</code>：设置布局管理器</p></li></ul><p>​ <strong><em>——哦我的上帝啊，如果有什么名词是你不懂的，为什么不试着继续看下去呢？</em></strong></p><h3 id="内容窗格">15.1.2 内容窗格</h3><blockquote><p>4 个顶层容器每个都有 1个内容窗格。除菜单外，顶层容器的所有组件都放在这个内容窗格内。</p></blockquote><ul><li><p>直接添加组件至内容窗格</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Container</span> <span class="hljs-variable">contentPane</span> <span class="hljs-operator">=</span> jframe.getContentPane();<span class="hljs-comment">//[1] 获取内容窗格对象</span>contentPane.add(button, BorderLayout.CENTER);<span class="hljs-comment">//[2] 将组件添加到内容窗格</span></code></pre></div><blockquote><ol type="1"><li><p>使用顶层容器的 <code>getContentPane()</code>方法获得其内容窗格对象。</p></li><li><p>将组件添加到内容窗格。</p><p>其中 button 是一个按钮控件，BorderLayout.CENTER 代表位置在中间</p><p>向顶层容器内容窗格添加组件时，也可以直接调用顶层容器的 add()方法</p></li></ol></blockquote></li><li><p>以新的内容窗格代替原有内容窗格</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">JPanel</span> <span class="hljs-variable">contentPane</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JPanel</span>();<span class="hljs-comment">//[1] 创建 JPanel 实例</span>contentPane.setLayout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BorderLayout</span>());<span class="hljs-comment">//[2] 创建布局管理器</span>contentPane.add(button, BorderLayout.CENTER);<span class="hljs-comment">//[3] 添加组件</span>jfream.setContentPane(contentPane);<span class="hljs-comment">//[4] 添加内容窗格</span></code></pre></div><blockquote><ol type="1"><li><p>创建 JPanel（面板）实例。JPanel 是 Container 的子类。</p></li><li><p>顶层容器默认的布局管理器是 BorderLayout，而 JPanel的默认布局管理器是 FlowLayout</p></li><li><p>通过 <code>setContentPane(contentPane)</code> 方法为 jfream设置新的内容窗格</p></li></ol></blockquote></li></ul><h3 id="面板">15.1.3 面板</h3><blockquote><p>普通面板（JPanel）和滚动面板（JScrollPanel）都是用途广泛的容器。面板与顶层容器不同，不能独立存在，而必须添加到其他容器内部。面板可以嵌套，由此可以设计出复杂的图形用户界面。</p></blockquote><h4 id="jpanel">15.1.3.1 JPanel</h4><p><strong>构造方法：</strong></p><ul><li><code>new JPanel()</code>：创建具有 FlowLayout 布局的新面板</li><li><code>new JPanel(LayoutManager layout)</code>：创建指定布局的新面板</li></ul><p><strong>常用方法：</strong></p><ul><li><code>Component add(Compinent comp)</code>：将指定组件添加至面板</li></ul><h4 id="jscrollpanel">15.1.3.2 JScrollPanel</h4><p>JScrollPanel是一个带有滚动条的面板，但只能添加一个组件。添加多个组件的场合，先将那些组件添加入JPanel 对象，再将该 JPanel 对象添加进 JScrollPanel 对象中</p><p><strong>构造方法：</strong></p><ul><li><code>new JScrollPanel()</code>：创建一个空的JScrollPanel。水平、垂直滚动条都能显示</li><li><code>new JScrollPanel(Component view)</code>：创建指定组件内容的JScrollPanel</li></ul><p><strong>常用方法：</strong></p><ul><li><p><code>void setHorizontalScrollBarPolicy(int policy)</code>：确定水平滚动条何时显示</p><p>其中 policy 的可选值是以下三种：</p><ul><li>ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED：需要时可见</li><li>ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER：永远不可见</li><li>ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS：永远可见</li></ul></li><li><p><code>void setVerticalScrollBarPolicy(int policy)</code>：确定垂直滚动条何时显示</p><p>其中 policy 的可选值是以下三种：</p><ul><li>ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED：需要时可见</li><li>ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER：永远不可见</li><li>ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS：永远可见</li></ul></li></ul><h4 id="scrollbar">15.1.3.3 Scrollbar</h4><p>AWT中还有一个滚动条组件，提供了允许用户在一定范围的值中进行选择的便捷方式</p><p><strong>构造器：</strong></p><ul><li><p><code>new Scrollbar()</code>：构造一个新的滚动条</p></li><li><p><code>new Scrollbar(int orientation)</code>：构造一个有指定方向的滚动条</p><p>其中 orientation 的可选值是：</p><ul><li>Scrollbar.HORIZONTAL：水平滚动条</li><li>Scrollbar.VERTICAL：垂直滚动条</li></ul></li><li><p><code>new Scrollbar(int orientation, int value, int visible, int minimum, int maximun)</code>：构造一个有初始方向、初始值、可视量、最小/最大值的滚动条</p></li></ul><h2 id="标签和按钮">15.2 标签和按钮</h2><h3 id="标签">15.2.1 标签</h3><blockquote><p>标签（JLable）是最简单的 Swing组件，通常用于显示提示性的文本信息或图标。其不可被编辑</p></blockquote><p><strong>构造器：</strong></p><ul><li><p><code>new JLable()</code>：构造一个不显示文本或图标的空标签</p></li><li><p><code>new JLable(Icon image)</code>：构造一个显示图标的标签</p></li><li><p><code>new JLable(String text)</code>：构造一个显示文本的标签</p></li><li><p><code>new JLable(Icon image, int horizontalAlignment)</code>：构造一个显示图标的标签，并指定水平对齐方式</p><p>其中 horizontalAlignment 的取值可以是：</p><ul><li>JLable.LEFT：左对齐</li><li>JLable.RIGHT：右对齐</li><li>JLable.CENTER：居中对齐</li></ul></li><li><p><code>new JLable(String text, int horizontalAlignment)</code>：构造一个显示文本的标签，并指定水平对齐方式</p></li><li><p><code>new JLable(String text, Icon image, int horizontalAlignment)</code>：构造一个同时显示文本和图标的标签，并指定水平对齐方式</p></li></ul><h3 id="按钮">15.2.2 按钮</h3><blockquote><p>按钮（JButton）是 Java 图形用户界面的基本组件之一。</p><p>经常用到的按钮有 4种形式：按钮（JButton）、切换按钮（JToggleButton）、复选按钮（JCheckButton）、单选按钮（JRadioButton）</p><p>这些按钮类均是 AbstractButton 的子类或间接子类</p></blockquote><h4 id="jbutton">15.2.2.1 JButton</h4><p><strong>构造器：</strong></p><ul><li><code>new JButton()</code>：构造一个既没有文本也没有图标的按钮</li><li><code>new JButton(Icon icon)</code>：构造一个有图标的按钮</li><li><code>new JButton(String text)</code>：构造一个有文本的按钮</li><li><code>new JButton(String text, Icon icon)</code>：构造一个有文本也有图标的按钮</li></ul><p><strong>常用方法：</strong></p><ul><li><p><code>void setMnemonic(int mnemonic)</code>：设置当前按钮的键盘助记符</p></li><li><p><code>void setText(String text)</code>：设置按钮的文本</p><p><code>void setIcon(Icon icon)</code>：设置按钮图标</p></li><li><p><code>void setEnabled(boolean mod)</code>：是否启用按钮</p></li><li><p><code>String getText()</code>：返回按钮的文本</p></li><li><p><code>void setToolTipText()</code>：设置提示文本</p></li><li><p><code>void addActionListener(ActionListener l)</code>：为按钮添加事件监听程序</p><p><code>void removeActionListener(ActionListener l)</code>：移除事件监听程序</p></li></ul><h4 id="jtogglebuttonjcheckbuttonjradiobutton">15.2.2.2JToggleButton、JCheckButton、JRadioButton</h4><blockquote><p>JToggleButton是有两种状态（选中状态、未选中状态）的按钮。通过点击切换这两种状态</p><p>JCheckButton、JRadioButton 是 JToggleButton 的子类，构造方法与JToggleButton 相同。</p></blockquote><p><strong>构造器：</strong></p><ul><li><p><code>new JToggleButton()</code>：构造一个没有文本也没有图标的切换按钮</p></li><li><p><code>new JToggleButton(Icon icon)</code>：构造一个有图标的切换按钮</p><p><code>new JToggleButton(Icon icon, boolean selected)</code>：构造一个有图标的切换按钮，设置其初始状态</p></li><li><p><code>new JToggleButton(String text)</code>：构造一个有文本的切换按钮</p><p><code>new JToggleButton(String text, boolean selected)</code></p></li><li><p><code>new JToggleButton(String text, Icon icon)</code>：构造一个有文本也有图标的切换按钮</p><p><code>new JToggleButton(String text, Icon icon, boolean selected)</code></p></li></ul><p><strong>常用方法（除 JButton 方法外）：</strong></p><ul><li><p><code>boolean isSeleced()</code>：获取按钮的当前状态</p></li><li><p><code>void addItemListener(ItemListener l)</code>：为按钮添加事件侦听程序</p><p><code>void removeItemListener(ItemListener l)</code>：移除事件侦听程序</p></li></ul><h2 id="布局管理器">15.3 布局管理器</h2><blockquote><p>容器中包含了组件。组件的布局，包括其位置和大小，通常由布局管理器负责安排。每个容器都有一个默认的布局管理器。</p></blockquote><h3 id="flowlayout-流布局管理器">15.3.1 FlowLayout 流布局管理器</h3><blockquote><p>FlowLayout 定义在 java.awt 包中。</p></blockquote><p><strong>构造器：</strong></p><ul><li><p><code>new FlowLayout()</code>：创建默认的 FlowLayout布局管理器。</p><p>居中对齐。默认水平、垂直间距是 5 像素</p></li><li><p><code>new FlowLayout(int align)</code>：创建一个 FlowLayout布局管理器。</p><p>指定对齐方式。默认水平、垂直间距是 5 像素</p><p>align 的可选值有这些：</p><ul><li>FlowLayout.LEFT：左对齐</li><li>FlowLayout.RIGHT：右对齐</li><li>FlowLayout.CENTER：居中对齐</li></ul></li><li><p><code>new FlowLayout(int align, int hgap, int vgap)</code>：创建一个FlowLayout 布局管理器。</p><p>指定对齐方式。指定水平、垂直间距</p></li></ul><p><strong>使用说明：</strong></p><ol type="1"><li>FlowLayout对容器中组件进行布局的方式是将组件逐个放置在容器中的一行上。一行满后，另起一行。</li><li>与其他布局管理器不同。FlowLayout不会强行设定组件的大小，而是通过每个组件的 getPreferredSize()方法获取其各自的期望大小</li></ol><h3 id="borderlayout-边界布局管理器">15.3.2 BorderLayout边界布局管理器</h3><blockquote><p>BorderLayout 定义在 java.awt包中，是顶层容器的默认布局管理器。它提供了一种较为复杂的组件布局管理方案。</p></blockquote><p><strong>构造方法：</strong></p><ul><li><code>new BorderLayout()</code>：一个组件间没有间距的布局管理器</li><li><code>new BorderLayout(int hgap, int vgap)</code>：定义水平、垂直间距的布局管理器</li></ul><p><strong>使用说明：</strong></p><ol type="1"><li>每个由 BorderLayout 管理的容器被划分成 5 个区域，分别是容器的上部（BorderLayout.NORTH）、下部（BorderLayout.SOUTH）、左部（BorderLayout.WEST）、右部（BorderLayout.EAST）、中部（BorderLayout.CENTER）</li><li>在 BorderLayout 布局管理器的管理下，组件必须通过 add()方法加入容器的指定区域。不指定的场合，默认加入中部区域</li><li>容器的每个区域仅能加入一个组件。加入了多个组件的场合，只有最后一个生效</li><li>对于中部以外的 4个边界区域，没有使用的区域的大小将变为零。此时，中部区域会扩展并占据该未用区域的位置。如果4 个边界区域都没有使用，中部区域会占据整个窗口。</li><li>窗口大小改变时，按钮的相对位置不会变化。但按钮的大小会改变</li></ol><h3 id="gridlayout-网格布局管理器">15.3.3 GridLayout 网格布局管理器</h3><blockquote><p>GridLayout 定义在 java.awt 包中，是一种网格式的布局管理器。</p></blockquote><p><strong>构造器：</strong></p><ul><li><p><code>new GridLayout()</code>：创建一个一行的网格。列数根据实际需要决定</p></li><li><p><code>new GridLayout(int rows, int cols)</code>：指定行数、列数的网格布局</p><p>rows 和 cols 中，最多有一个可以是 0，但不能都为 0。那个为 0的场合，根据实际需要决定数量</p></li><li><p><code>new GridLayout(int rows, int cols, int hgap, int vgap)</code>：指定行数、列数，也指定水平、垂直间距的网格</p></li></ul><p><strong>使用说明：</strong></p><ol type="1"><li><p>GridLayout将容器空间划分成若干行乘若干列的网格。组件依次放入其中，每个组件占据一格</p></li><li><p>网格每列宽度相同，每行高度相同。组件放入的次序决定了其位置</p></li><li><p>想要组件间留有空白的场合，可以添加一个空白标签</p></li><li><p>网格数多于组件数的场合，那些多余的格子为空白。</p><p>网格数少于组件数的场合，系统根据需要适当添加。</p></li><li><p>窗口大小改变时，按钮的相对位置不会变化。但按钮的大小会改变</p></li></ol><h3 id="cardlayout-卡片式布局管理器">15.3.4 CardLayout卡片式布局管理器</h3><blockquote><p>CardLayout 定义在 java.awt 包中，是一种卡片式的布局管理器。</p></blockquote><p><strong>构造器：</strong></p><ul><li><code>new CardLayout()</code>：一个默认无间距的 CardLayout布局管理器</li><li><code>new CardLayout(int hgap, int vgap)</code>：指定水平、垂直间距的CardLayout 布局管理器</li></ul><p><strong>常用方法：</strong></p><ul><li><p><code>void first(Container parent)</code>：翻转到容器的第一张卡片</p><p><code>void next(Container parent)</code>：翻转到下一张卡片。当前是最后一张的场合，翻到第一张卡片</p><p><code>void previous(Container parent)</code>：翻转到前一张卡片。当前是第一张的场合，翻到最后一张卡片</p><p><code>void last(Container parent)</code>：翻转到容器的最后一张卡片</p></li><li><p><code>void show(Container parent, String name)</code>：翻转到卡片集中具有指定name 的卡片。没有该卡片的场合不执行任何操作</p></li></ul><p><strong>使用说明：</strong></p><ol type="1"><li>CardLayout将容器中的组件处理为一系列卡片，每一刻只显示其中一张。</li><li>容器第一次显示时，显示第一个添加的组件。</li></ol><h3 id="boxlayout-方框布局管理器">15.3.5 BoxLayout 方框布局管理器</h3><blockquote><p>BoxLayout 定义在 javax.swing包中，其组件横排一行或竖排一列，但宽度（高度）可以不同。</p></blockquote><p><strong>构造器：</strong></p><ul><li><p><code>new BoxLayout(Container target, int axis)</code>：创建一个沿给定轴放置组件的布局管理器</p><p>其中 target 表明为哪个容器设置此布局管理器，axis 指明组件排列方向</p><p>axis 的值是：</p><ul><li>BoxLayout.X_AXIS：水平方向排列</li><li>BoxLayout.Y_AXIS：竖直方向排列</li></ul><p>举个例子：</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">JPanel</span> <span class="hljs-variable">jp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JPanel</span>();jp.setLayout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BoxLayout</span>(jp, BoxLayout.X_AXXIS));</code></pre></div></blockquote></li></ul><p><strong>使用说明：</strong></p><ol type="1"><li>BoxLayout将容器中的组件横排一行或竖排一列。那些组件横排一行时，可以有不同宽度；竖排一列时，可以有不同的高度。</li><li>窗口大小改变时，按钮的相对位置不会变化。</li></ol><p><strong>Box 类</strong></p><blockquote><p>javax.swing 中定义了一个专门使用 BoxLayout 的容器 Box 类。</p></blockquote><ul><li><p><code>static Box createHorizontalBox()</code>：返回一个使用水平方向的BoxLayout 的 Box</p><p><code>static Box createVerticalBox()</code>：返回一个使用竖直方向的BoxLayout 的 Box</p></li><li><p><code>static Component createHorizontalGlue()</code>：创建一个水平方向的不可视的组件（填满剩余空间）</p><p><code>static Component createVerticalGlue()</code></p></li><li><p><code>static Component createHorizontalStrut()</code>：创建一个水平方向的不可视的组件（指定宽高）</p><p><code>static Component createVerticalStrut()</code></p></li><li><p><code>static Component createRigidArea()</code>：创建一个不可视的组件，不大不小，尺寸真是好极了</p></li></ul><h3 id="空布局">15.3.6 空布局</h3><blockquote><p>其实也能不用布局管理器的，真的</p></blockquote><ol type="1"><li>调用容器的 <code>setLayout(null)</code> 将容器的布局管理器置空</li><li>=调用组件的 <code>setBounds(x, y, w, h)</code>方法设置其位=置和大小。<sub>老东西，你的布局管理器最没用啦！</sub></li></ol><h2 id="事件处理">15.4 事件处理</h2><blockquote><p>Java 运行时，如果用户进行某个操作，程序应当做出相应。</p><p>程 · 序 · 无 · 响 · 应（噔 噔 咚）</p><p>……总之，用户在程序界面进行的操作称为用户事件，对事件的相应称为事件处理。</p></blockquote><h3 id="事件处理模型">15.4.1 事件处理模型</h3><blockquote><p>Java 事件处理是采取“委派事件模型”。当事件发生时，产生事件类对象。这里说的事件类对象实际上就是<code>java.awt.event</code>事件类库里某个类创建的对象。操作不同的场合，事件类对象不同。</p><p>会把此事件类对象传递给事件侦听程序处理。它是实现了对应侦听程序接口的一个类。</p><p>事件只是一个对象，其只向注册的侦听程序报告</p></blockquote><p>示范一个简单的事件处理：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.seing.*;<span class="hljs-keyword">import</span> java.awt.*;<span class="hljs-comment">//[0]</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Code_15_4_1</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;        <span class="hljs-type">Button</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;Button&quot;</span>);        b.addActionListener((e) -&gt; System.out.println(<span class="hljs-string">&quot;Pressed&quot;</span>));<span class="hljs-comment">//[1]</span>        <span class="hljs-type">JFrame</span> <span class="hljs-variable">jFrame</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JFrame</span>(<span class="hljs-string">&quot;Test&quot;</span>);        jFrame.setBounds(<span class="hljs-number">30</span>, <span class="hljs-number">30</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);        jFrame.add(b);        jFrame.setVisible(<span class="hljs-literal">true</span>);    &#125;&#125;</code></pre></div><blockquote><ol start="0" type="1"><li><p>引入 java.awt.event 包</p></li><li><p>注册事件侦听程序，并实现其方法</p><p>示例中的简写其实相当于以下代码（匿名内部类）：</p><div class="code-wrapper"><pre><code class="hljs java">b.addActionListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ActionListener</span>() &#123;    <span class="hljs-meta">@OverRide</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actionPerformed</span> <span class="hljs-params">(ActionEvent e)</span> &#123;        System.out.println(<span class="hljs-string">&quot;Pressed&quot;</span>);    &#125;&#125;);</code></pre></div><p><strong><em>—— 示例写法见 [27 Java8 新特性]</em></strong></p><p>事件侦听程序可以定义在单独的类中，也可以定义在组件类中：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyButton</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JButton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ActionListener</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyButton</span><span class="hljs-params">()</span> &#123;        addActionListener(<span class="hljs-built_in">this</span>);    &#125;                               <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actionPerformed</span><span class="hljs-params">(ActionEvent e)</span> &#123;        System.out.println(<span class="hljs-string">&quot;Pressed&quot;</span>);    &#125;&#125;</code></pre></div></li></ol></blockquote><h3 id="事件的种类">15.4.2 事件的种类</h3><blockquote><p>在 java.awt.event 包和 javax.swing.event包中定义了很多其他的事件类。每种事件类有一个对应的接口，接口中声明了一个或多个抽象的事件处理方法。</p></blockquote><table><thead><tr class="header"><th>事件类</th><th>组件</th><th>方法及说明</th></tr></thead><tbody><tr class="odd"><td>ActionEvent</td><td>JButton、JCheckBox、JComboBox、JMenuItem、JRaidoButton</td><td>actionPerformed(e) 单击按钮、选择菜单项或在文本框中按回车时</td></tr><tr class="even"><td>AdjustmentEvent</td><td>JScrollBar</td><td>adjustmentValueChanged(e) 当改变滚动条滑块位置时</td></tr><tr class="odd"><td>ComponentEvent</td><td>JComponent 及其子类</td><td>componentMoved(e) 组件移动时；componentHidden(e)组件隐藏时；componenetResized(e) 组件缩时；componentShown(e)组件显示时</td></tr><tr class="even"><td>ContainerEvent</td><td>JContainer 及其子类</td><td>containerAdded(e) 添加组件时；containerMoved(e)移除组件时</td></tr><tr class="odd"><td>FocusEvent</td><td>同 ComponentEvent</td><td>focusGained(e) 组件获得焦点时；focusLost(e) 组件失去焦点时</td></tr><tr class="even"><td>ItemEvent</td><td>JCheckBox、JCheckboxMenuItem、JComboBox</td><td>itemStateChanged(e)选择复选框、选项框、单击列表框、选中带复选框菜单时</td></tr><tr class="odd"><td>KeyEvent</td><td>同 ComponentEvent</td><td>keyPressed(e) 键按下时；keyReleased(e) 键释放时；keyTaped(e)击键时</td></tr><tr class="even"><td>MouseEvent</td><td>同 ComponentEvent</td><td>mousePressed(e) 鼠标按下时；mouseEntered(e)鼠标进入时；mouseExited(e) 鼠标离开时；mouseClicked(e)鼠标点击时；mouseReleased(e) 鼠标释放时</td></tr><tr class="odd"><td>MouseMotionEvent</td><td>同 ComponentEvent</td><td>mouseDragged(e) 鼠标拖放时；mouseMoved(e) 鼠标移动时</td></tr><tr class="even"><td>TextEvent</td><td>JTextField、JTextArea</td><td>textValueChanged(e) 文本框、多行文本框内容修改时</td></tr><tr class="odd"><td>WindowEvent</td><td>JFrame、JWindow、JDialog</td><td>windowOpened(e) 窗口打开时；windowClosing(e)窗口关闭时；windowClosed(e) 窗口关闭后；windowActived(e)窗口激活时；windowDeactivated(e) 窗口失去焦点时；windowIconified(e)窗口最小化时；WindowDeiconified(e) 窗口最小化还原时</td></tr></tbody></table><p>使用说明：</p><ol type="1"><li><p>XXXEvent 事件类的接口名就是XXXListener。占地方太大，上面就没写</p></li><li><p>事件侦听模式允许为一个组件多次调用 addListener方法，注册多个侦听程序。</p><p>事件发生时，单个事件的多个侦听程序的调用顺序不确定。</p></li><li><p>调用事件处理方法时会传入一个参数。该参数就是那些事件类实例，其中包含事件有关的重要信息。</p><p>调用这些事件类实例各自特有的方法获取这些信息。</p></li></ol><h3 id="事件适配器">15.4.3 事件适配器</h3><blockquote><p>侦听程序必须实现接口的全部抽象方法，但有时我们只关心其中的某一种方法。为了编程方便，Java为一些声明了多个抽象方法的 Listener 接口提供了相应的适配器类。</p></blockquote><table><thead><tr class="header"><th>接口名称</th><th>适配器名称</th></tr></thead><tbody><tr class="odd"><td>ComponentListener</td><td>ComponentAdapter</td></tr><tr class="even"><td>ContainerListener</td><td>ContainerAdapter</td></tr><tr class="odd"><td>FocusListener</td><td>FocusAdapter</td></tr><tr class="even"><td>KeyListener</td><td>KeyAdapter</td></tr><tr class="odd"><td>MouseListener</td><td>MouseAdapter</td></tr><tr class="even"><td>MouseMotionListener</td><td>MouseMotionAdapter</td></tr><tr class="odd"><td>MouseInputListener</td><td>MouseInputAdapter</td></tr><tr class="even"><td>WindowListener</td><td>WindowAdapter</td></tr></tbody></table><p>这些适配器实现了接口的全部抽象方法，只是方法内容为空</p><p>这样，创建新类时可以不必实现接口，而是继承适配器类，并重写需要的方法</p><h2 id="java-绘图技术">15.5 Java 绘图技术</h2><blockquote><p>Java 语言约定，显示屏上一个长方形区域为程序绘图区域，坐标原点（0,0）位于整个区域左上角。</p><p>一个坐标点（x, y）对应一个像素，其中坐标点的 x、y 必须是非负整数。x沿水平方向从左向右递增、y 沿竖直方向从上往下递增</p></blockquote><h3id="颜色"><font color=#FF0000>1</font><font color=#FFC800>5.</font><font color=#F9F000>5</font><font color=#00FF00>.</font><font color=#00FFFF>1</font><font color=#0000FF>颜</font><font color=#FF00FF>色</font></h3><blockquote><p>可以使用 java.awt 包中的 Color 类来定义和管理颜色。Color类的每个对象代表一种颜色。</p></blockquote><p>Color 类有 26 个常量，代表 13 种预定义颜色：</p><table><thead><tr class="header"><th>颜色</th><th>对象</th><th>ᓚᘏᗢ</th></tr></thead><tbody><tr class="odd"><td>黑色<font color=#000000>（#000000）</font></td><td>Color.black</td><td>Color.BLACK</td></tr><tr class="even"><td>蓝色<font color=#0000FF>（#0000FF）</font></td><td>Color.blue</td><td>Color.BLUE</td></tr><tr class="odd"><td>青色<font color=#00FFFF>（#00FFFF）</font></td><td>Color.cyan</td><td>Color.CYAN</td></tr><tr class="even"><td>灰色<font color=#808080>（#808080）</font></td><td>Color.gray</td><td>Color.GRAY</td></tr><tr class="odd"><td>深灰色<font color=#404040>（#404040）</font></td><td>Color.darkGary</td><td>Color.DARKGARY</td></tr><tr class="even"><td>浅灰色<font color=#C0C0C0>（#C0C0C0）</font></td><td>Color.lightGary</td><td>Color.LIGHTGARY</td></tr><tr class="odd"><td>绿色<font color=#00FF00>（#00FF00）</font></td><td>Color.green</td><td>Color.GREEN</td></tr><tr class="even"><td>洋红色<font color=#FF00FF>（#FF00FF）</font></td><td>Color.magenta</td><td>Color.MAGENTA</td></tr><tr class="odd"><td>橙色<font color=#FFC800>（#FFC800）</font></td><td>Color.orange</td><td>Color.ORANGE</td></tr><tr class="even"><td>粉红色<font color=#FFAFAF>（#FFAFAF）</font></td><td>Color.pink</td><td>Color.PINK</td></tr><tr class="odd"><td>红色<font color=#FF0000>（#FF0000）</font></td><td>Color.red</td><td>Color.RED</td></tr><tr class="even"><td>白色<font color=#FFFFFF>（#FFFFFF）</font></td><td>Color.write</td><td>Color.WRITE</td></tr><tr class="odd"><td>黄色<font color=#FFFF00>（#FFFF00）</font></td><td>Color.yellow</td><td>Color.YELLOW</td></tr></tbody></table><p>也可以通过<font color=#FF0000>红</font>、<FONT COLOR=#00FF00>绿</FONT>、<FoNt CoLoR=#0000fF>蓝</fOnT>三原色值来组合。每种颜色由三个值组成（<font color=#FF0000>R</font><font color=#00FF00>G</font><font color=#0000FF>B</font>），值的范围是[0, 256)：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Color</span> <span class="hljs-variable">color</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>(<span class="hljs-number">102</span>, <span class="hljs-number">204</span>, <span class="hljs-number">255</span>);</code></pre></div><blockquote><p>这个颜色是：<font color=#66CCFF>天依蓝（#66CCFF）</font></p><p>这部分笔记恐怕是所有 Java 笔记里唯一有五颜六色的地方了，真难得</p></blockquote><h3 id="字体"><font face="幼圆" size="7"><i>15.5.2 字体</i></font></h3><blockquote><p>文字有 字体、样式、字号 三个要素</p></blockquote><p>基本的样式有：</p><ul><li><p>Font.PLAIN：正常（0）</p></li><li><p>Font.BOLD：<strong>粗体</strong>（1）</p></li><li><p>Font.ITALIC：<em>斜体</em>（2）</p><p>样式可以组合使用，如 (Font.BOLD + Font.ITALIC) 即<strong><em>粗斜体</em></strong></p></li></ul><p>常用的字体：Times New roman<font face=Times New roman>（Times Newroman）</font>、Symbol<font face=Symbol>（Symbol）</font>、宋体<font face=(宋体)>（宋体）</font>、楷体<font face=楷体>（楷体）</font>等</p><p><strong>构造器：</strong></p><ul><li><code>new Font(String name, int style, int size)</code>：新建字体，指定字体、样式、字号</li></ul><p><strong>常用方法：</strong></p><ul><li><p><code>String getName()</code>：返回其字体名称</p><p><code>int getSize()</code>：返回其字号大小</p><p><code>int getStyle()</code>：返回其样式</p></li><li><p><code>boolean isBold()</code>：是否是粗体</p><p><code>boolean isItalic()</code>、<code>boolean isPlain()</code></p></li></ul><h3 id="graphics-类">15.5.3 Graphics 类</h3><blockquote><p>java.awt 包下的 Graohics类是所有图形处理的基础，是所有图形上下文的抽象父类。其允许应用程序在组件及屏幕图像上进行绘制。</p></blockquote><p>当先后绘制的图形不同时，确定重叠部分颜色的方法称为绘图模式。</p><p>绘图模式分为两种：</p><ul><li><p>正常模式：<code>setPaintMode()</code></p><p>后绘制的图形覆盖先绘制的图形。</p></li><li><p>异或模式：<code>setXORMode(Color c)</code></p><p>当前绘制的颜色、先前绘制的颜色 及 选定的颜色 c之间进行某种处理后，用新的颜色绘制。</p><p>这个模式下，如果使用同一颜色绘制 2次，则相当于擦除之前绘制的图形，即恢复原本状态。</p></li></ul><p>若要在某个组件中绘图，应重写该组件的 paint(Graphics g)方法，并在重写的方法内进行绘图。</p><ul><li><p><code>paint(Graphics g)</code>：组件被显示出来时，调用该方法</p><p>以下情况该方法会被调用</p><ul><li>组件第一次在屏幕显示时</li><li>窗口最小化/最大化</li><li>窗口大小发生变化</li><li><code>repaint</code> 函数被调用</li></ul></li><li><p><code>repaint()</code>：重绘组件</p><p>该方法默认情况下会调用以下方法</p><ul><li><p><code>paintCompnent(Graphics g)</code>：绘制组件</p><p>一般情况下，要在 JComponent 子类的组件中绘图，重写该方法即可</p></li><li><p><code>paintBorder(Graphics g)</code>：绘制组件边框</p></li><li><p><code>paintChildren(Graphics g)</code>：绘制组件的子组件</p></li></ul></li></ul><p><strong>设置画笔：</strong></p><ul><li><p><code>setColor(Color c)</code>：设置画笔前景色</p><p><code>setBackgroud(Color c)</code>：设置背景色</p><p>每个图形环境都有一种画图时正在使用的前景色。画图所在的每个表面都有背景色</p></li><li><p><code>setFont(Font f)</code>：设置画笔字体</p></li></ul><p><strong>绘制几何图案：</strong></p><ul><li><p><code>drawArc(int x, int y, int width, int height, int startAngle, int arcAngle)</code>：绘制弧线</p><p>该弧线是 沿着起始点为 (x, y)、宽 width、高 height 的矩形所限定的椭圆绘制一条弧线。</p><p>该弧线起始角度为 startAngle，弧度角度为 arcAngle</p><p><code>fillArc(int x, int y, int width, int height, int startAngle, int arcAngle)</code>：填充扇形</p></li><li><p><code>drawLine(int x1, int y1, int x2, int y2)</code>：绘制线段</p><p>该线段的两个端点是 (x1, y1) 和 (x2, y2)</p></li><li><p><code>drawOval(int x, int y, int width, int height)</code>：绘制椭圆</p><p>一个起始点为 (x, y)、宽 width、高 height 的矩形所限定的椭圆</p><p><code>fillOval(int x, int y, int width, int height)</code>：填充椭圆</p></li><li><p><code>drawPolygon(int[] xPoints, int[] tPoints, int nPoints)</code>：绘制多边形</p><p><code>drawPolygon(Polygon p)</code>：也能通过传入一个 Polygon对象来绘制多边形</p><p>该图形的端点由传入参数确定。如果最后一个端点和第一个端点不相等，那么图形可能不闭合</p><p><code>fillPolygon(int[] xPoints, int[] tPoints, int nPoints)</code>：填充多边形</p><p><code>fillPolygon(Polygon p)</code>：通过传入一个 Polygon对象来填充多边形</p><p>低情商：这咋填充？高情商：留给读者们思考吧</p></li><li><p><code>drawRect(int x, int y, int width, int height)</code>：绘制矩形</p><p>一个起始点为 (x, y)、宽 width、高 height 的矩形</p><p><code>fillRect(int x, int y, int width, int height)</code>：填充矩形</p></li><li><p><code>drawRoundRect(int x, int y, int width, int height, int arcWidth, int arcHeight)</code>：圆角矩形</p><p>一个起始点为 (x, y)、宽 width、高 height 的矩形，其圆角形状由arcWidth、arcHeight 确定</p><p>其实就是矩形（线段）和椭圆（圆弧）的某种拼接</p><p><code>fillRoundRect(int x, int y, int width, int height, int arcWidth, int arcHeight)</code>：填充圆角矩形</p></li><li><p><code>drawString(String str, int x, int y)</code>：输出字符串</p><p>在 (x, y) 处输出字符串 str，向右扩展</p><p><code>drawChars(char[] chars, int offSet, int length, int x, int y)</code>：输出字符串</p><p>从字符数组的 offSet 下标处起，在 (x, y) 处输出 length个字符，向右扩展</p><p><code>drawBytes(byte[] data, int offSet, int length, int x, int y)</code>：还不是一样？</p></li><li><p><code>draw3DRect(int x, int y, int width, int height, boolean raised)</code>：绘制3D 矩形</p><p><code>fill3DRect(int x, int y, int width, int height, boolean raised)</code>：填充3D 矩形</p><p>我感觉是和 PS 里的浮雕效果类似，生成了亮部和暗部。rasied决定是凸起还是凹陷。</p></li></ul><h4 id="polygon-类">15.5.3.1 Polygon 类</h4><blockquote><p>Polygon 对象封装了多边形的坐标。</p></blockquote><p>构造方法：</p><ul><li><p><code>new Polygon()</code>：构造一个空的多边形。</p><p>无为太虚，无生一，一生二，二生三，三生万物。所以，空的多边形也是多边形。</p></li><li><p><code>new Polygon(int[] xs, int[] ys, int n)</code>：构造一个 n点连接成的多边形</p></li></ul><p>常用方法：</p><ul><li><p><code>addPoint(int x, int y)</code>：将该点加入多边形中</p></li><li><p><code>boolean contains(int x, int y)</code>：如果多边形包含该点，则返回真</p><p><code>boolean contains(Point p)</code></p></li><li><p><code>get Bounds()</code>：得到多边形的外接矩形</p></li><li><p><code>translate(int dx, int dy)</code>：偏移</p><p>将多边形各点沿 x 轴偏移 dx，再沿 y 轴偏移 dy</p></li></ul><h3 id="graphics2d-类">15.5.4 Graphics2D 类</h3><blockquote><p>为了解决图形对象的局限性，Java 1.1 后 引入了 Java2D，其包含一个继承自 Graphics 的 Graphics2D类，增加了很多状态属性，扩展了 Java 的绘图功能</p><p>Graphics2D拥有强大的二维图形处理能力，提供对几何形状、坐标转换、颜色管理、文字布局等更复杂的控制</p></blockquote><h4 id="图形状态属性">15.5.4.1 图形状态属性</h4><blockquote><p>通过设定和修改属性，可以指定画笔宽度和画笔连接方式、设定平移、旋转、缩放或裁剪变换图形，还能设置填充图形的颜色和图案等。</p></blockquote><p><strong>状态属性：</strong></p><ul><li><p><strong>stroke 属性：</strong></p><p>该属性控制线宽、笔形样式、线段连接方式、短划线图案。</p><p>使用 <code>setStroke(Stroke s)</code> 方法设置 stroke 属性。</p><p>构造方法：</p><ul><li><p><code>new BasicStroke(float w)</code>：指定线宽的 stroke</p></li><li><p><code>new BasicStroke(float w, int cap, int join)</code>：指定线宽、端点样式cap、线段交汇方式 join 的 stroke</p><p>其中，端点样式 cap 的值可以是：</p><ul><li>BasicStroke.CAP_BUTT：无修饰（0）</li><li>BasicStroke.CAP_ROUND：半圆形末端（1）</li><li>BasicStroke.CAP_SQUARE：方形末端（2，默认值）</li></ul><p>线段交汇方式 join 的值可以是：</p><ul><li>BasicStroke.JOIN_BEVEL：无修饰（2）</li><li>BasicStroke.JOIN_MITER：尖型末端（0，默认值）</li><li>BasicStroke.JOIN_ROUND：圆形末端（1）</li></ul></li></ul></li><li><p><strong>paint 属性：</strong></p><p>该属性控制填充效果。</p><p>使用 <code>setPaint(Paint p)</code> 方法设置 paint 属性</p><p>构造方法：</p><ul><li><p><code>new GradientPaint(float x1, float y1, Color c1, float x2, float y2, Color c2)</code>：构造一个简单的非周期性的paint 对象。</p><p>从点 (x1, y1) 至点 (x2, y2) 处，颜色由 c1 渐变至 c2</p></li><li><p><code>new GradientPaint(float x1, float y1, Color c1, float x2, float y2, Color c2, boolean cyclic)</code>：构造一个周期或非周期性的paint 对象。</p><p>如果希望渐变至终点又是起点的颜色，将 cyclic 设定为 true</p></li></ul></li><li><p><strong>transform 属性：</strong></p><p>该属性用来实现常用的图形平移、缩放、斜切等</p><p>使用 <code>setTransform(Transform t)</code> 方法设置 transform属性</p><p>构造方法：</p><ul><li><p><code>new AffineTransform()</code>：构造一个表示仿射变换的新的tansform</p><p><em>仿射变换：用我的话来讲，就是保持坐标点不变的情况下变换坐标系，能形成的变换</em></p></li></ul><p>常用方法：</p><ul><li><p><code>setToRotation(double theta)</code>：旋转 theta 角度</p><p><code>setToRotation(double theta, double x, double y)</code>：以 (x,y) 为旋转中心旋转</p><p><code>rotate(double theta, double x, double y)</code></p></li><li><p><code>setToScale(double sx, double sy)</code>：拉伸变换</p><p>x、y 方向按照 sx、yx 比例变换</p><p><code>scale(double sx, double sy)</code></p></li><li><p><code>setToTranslation(double tx, double ty)</code>：平移变换</p><p><code>translate(double tx, double ty)</code></p></li><li><p><code>setToShear(double shx, double shy)</code>：斜切变换</p><p>shx、shy 分别指定 x、y 方向的斜拉度</p></li></ul><p>看得出来，出版社的人写到这里应该是到了下班的点了。内容不明不白的不说，还写错了好几处。</p><p>我笔记上是改过来的。放心。</p><p>就这还 ”指定教材“ 呢。垃圾，还没我笔记写得好。</p></li><li><p><strong>clip 属性：</strong></p><p>该属性用于实现剪裁效果。</p><p>使用 <code>setClip(Shape clip)</code> 方法，确定裁剪区域的Shape。可以连续使用该方法以得到其交集区域</p></li><li><p><strong>composit 属性：</strong></p><p>该属性设置图形重叠区域的效果</p><p>通过 <code>Alpha.Composite.getInstance(int rule, float alpha)</code>得到一个实例。其中 alpha（透明度）的范围是 [0.0f, 1.0f]</p><p>至于 rule 是什么……我也不知道。或许不重要吧</p><p>通过 <code>setComposite(Composite comp)</code> 设置混合效果</p></li></ul><h4 id="graphics2d-的绘图方法">15.5.4.2 Graphics2D 的绘图方法</h4><blockquote><p>Graphics2D 保留了 Graphics 的绘图方法，又增加了很多新方法</p><p>另外，在 java.awt.geom中声明了一系列类，能用于创建各种几何图形对象，包括：Line2D线段类、Rectangle2D 矩形类、RoundRectangle2D 圆角矩形类、Ellipse2D椭圆类、Arc2D 圆弧类、QuadCurve2D 二次曲线类、CubicCurve2D三次曲线类</p><p>这些类都是抽象类，但这些类包中有实现了其方法的 Double 类。</p></blockquote><div class="code-wrapper"><pre><code class="hljs java">...<span class="hljs-meta">@OverRide</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">paintComponents</span><span class="hljs-params">(Graphics g)</span> &#123;    <span class="hljs-type">Graphics2D</span> <span class="hljs-variable">g2d</span> <span class="hljs-operator">=</span> (Graphics2D)g;<span class="hljs-comment">//[1]</span>    <span class="hljs-type">Line2D</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Line2D</span>.Double(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>);<span class="hljs-comment">//[2]</span>    g2d.draw(line);<span class="hljs-comment">//[3]</span>&#125;</code></pre></div><blockquote><ol type="1"><li><p>将 Graphics 对象强制转型为 Graphics2D 对象</p></li><li><p>创建几何图形对象</p><p>这里的 Line2D.Double 表示 Line2D 包下的 Double 类。此处调用了 Double类的构造器</p></li><li><p>绘制线段</p></li></ol></blockquote><h4 id="graphics2d-中的几何图形类">15.5.4.3 Graphics2D中的几何图形类</h4><ul><li><p><code>new Line2D.Double(int x1, int y1, int x2, int y2)</code>：线段</p><p>从 (x1, y1) 到 (x2, y2) 的线段</p></li><li><p>……（略了略了。相信椭圆、矩形之类的也不用再详细说明了吧）</p></li><li><p><code>new Arc2D.Double(double x, double y, double w, double h, double start, double extent, int type)</code>：弧</p><p>但是特别地，type 的值是以下几种：</p><ul><li>Arc2D.OPEN：开弧</li><li>Arc2D.CHORD：弓弧</li><li>Arc2D.PIE：饼弧</li></ul></li><li><p><code>new QuadCurver2D.Double(double x1, double y1, double ctrlx, double ctrly, double x2, double y2)</code>：绘制二次曲线</p><p>绘制二次曲线需要 3 个点，分别是起始点 (x1, y1)、终点 (x2, y2)、控制点(ctrlx, ctrly)</p></li><li><p><code>new CubicCurve2D.Double(double x1, double y1, double ctrlx1, double ctrly1, double ctrlx2, double ctrly2, double x2, double y2)</code>：绘制三次曲线</p><p>绘制三次曲线需要 4 个点，分别是起始点、终点、两个控制点</p></li></ul><h2 id="组合框与列表">15.6 组合框与列表</h2><h3 id="jcombobox-组合框">15.6.1 JComboBox 组合框</h3><blockquote><p>JComboBox 是一个下拉式菜单。它有两种模式：可编辑的、不可编辑的。</p><p>对于不可编辑的 JComboBox，用户只能在现有列表中进行选择</p><p>对于可编辑的JComboBox，用户既能在现有选项中选择，也能输入新的内容</p></blockquote><p><strong>构造方法：</strong></p><ul><li><p><code>new JComboBox&lt;E&gt;()</code>：创建一个 E类型（泛型）的没有任何可选项的默认组合框</p></li><li><p><code>new JComboBox&lt;E&gt;(E[] items)</code>：根据 items数组创建组合框</p><p>items 数组元素即为组合框的可选项</p></li></ul><p><strong>常用方法：</strong></p><ul><li><p><code>void setEditable(boolean aFlag)</code>：设置可编辑性</p><p>不设置的场合，默认处于不可编辑状态</p></li><li><p><code>void addItem(E item)</code>：在末尾添加可选项</p><p><code>void insertItemAt(E item, int index)</code>：在指定下标处添加可选项</p></li><li><p><code>void removeAllItems()</code>：删除所有可选项</p><p><code>void removeItem(E iten)</code>：删除 item 指定的可选项</p><p><code>void removeItemAt(int index)</code>：删除指定下标处的可选项</p></li><li><p><code>E getItemAt(int index)</code>：获取指定下标的可选项</p></li><li><p><code>int getItemCount()</code>：获取列表项数</p></li><li><p><code>int getSelectedIndex()</code>：获取选中项匹配的第一个选项的索引下标</p><p><code>E getSelectedItem()</code>：获取选中项</p></li></ul><h3 id="jlist-列表">15.6.2 JList 列表</h3><blockquote><p>JList 是可供用户选择的一系列可选项</p></blockquote><p><strong>构造方法：</strong></p><ul><li><code>new JList&lt;E&gt;()</code>：构造一个空列表</li><li><code>new JList&lt;E&gt;(E[] listData)</code>：构造一个列表，可选元素由listData 指定</li><li><code>new JList&lt;E&gt;(Vector&lt;E&gt; listData)</code>：构造一个列表，使其显示指定Vector 中的元素</li></ul><p><strong>常用方法：</strong></p><ul><li><p><code>addListSelectionListener(ListSelectionListener l)</code>：添加监视器</p><p>当用户在列表上选择时，会触发 ListSelectionEvent 事件。</p><p>在 ListSelectionListener 接口中，仅有一个方法：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">valueChanged</span><span class="hljs-params">(ListSelectionEvent e)</span>;</code></pre></div><p>当列表的当前选项改变时，会调用该方法。</p></li><li><p><code>int getSelectedIndex()</code>：返回选中项第一次出现的下标索引</p><p>没有选中项的场合，返回 -1</p><p><code>E getSelectedValue()</code>：返回所选的第一个值</p><p>没有选中项的场合，返回 null</p></li><li><p><code>void setVisableRowCount(int count)</code>：设置不使用滚动条可以在列表中显示的选项行数</p></li><li><p><code>void setSelectionMode(int mode)</code>：设置列表的选择模式</p><p>其中，mode 的值可以是以下几种：</p><ul><li>ListSelectionModel.SINGLE_SELECTION：仅支持单项选择（0）</li><li>ListSelectionModel.SINGLE_INTERVAL_SELECTION：可多选，但多个选项必须是连续的（1）</li><li>ListSelectionModel.MULTIPLE_INTERVAL_SELECTION：可多选（2，默认值）</li></ul></li></ul><h2 id="文本组件">15.7 文本组件</h2><blockquote><p>文本组件可以提示信息和提供用户输入功能。Swing 中提供了JTextField（文本域）、JPasswordField（口令输入域）、JTextArea（文本区）等多个文本组件。</p></blockquote><p>文本组件的共同的父类是JTextComponent，其中定义了文本组件的共有方法：</p><ul><li><p><code>String getSelectedText()</code>：从文本组件中提取被选中的文本内容</p></li><li><p><code>String getText()</code>：从文本组件中提取全部文本内容</p><p><code>String getText(int offs, int len)</code>：从文本组件中提取指定范围的文本内容</p></li><li><p><code>void select(inr start, int end)</code>：在文本组件中选中指定范围内容</p><p><code>void selectAll()</code>：在文本组件中选中全部内容</p></li><li><p><code>void setEditable(boolean b)</code>：设置可编辑状态</p></li><li><p><code>void setText(String t)</code>：设置文本组件的文本内容</p></li><li><p><code>void setDocument(Document doc)</code>：设置文本组件的文档</p></li><li><p><code>void copy()</code>：复制选中文本至剪贴板</p><p><code>void cut()</code>：剪切选中文本至剪贴板</p><p><code>void paste()</code>：粘贴剪贴板内容至当前位置</p></li></ul><p>另外，JComponrnt 类中有如下方法：</p><ul><li><code>boolean requestFocusInWindow()</code>：请求当前组件获得输入焦点</li></ul><h3 id="jtextfield-文本域">15.7.1 JTextField 文本域</h3><blockquote><p>文本域是一个单行的文本输入框，可以用于输入少量文本</p></blockquote><p><strong>构造方法：</strong></p><ul><li><p><code>new JTextField()</code>：构造一个空文本域</p></li><li><p><code>new JTextField(int columns)</code>：构造一个指定列数的空文本域</p><p>由于组件大小通常由布局管理器确定，因此指定的列数可能被忽略</p></li><li><p><code>new JTextField(String text)</code>：构造一个显示指定初始字符的文本域</p></li><li><p><code>new JTextField(String text, int columns)</code>：构造一个指定列数及初始字符的文本域</p></li></ul><p><strong>常用方法：</strong></p><ul><li><p><code>void addActionListener(ActionListener l)</code>：添加指定侦听器</p><p><code>void removeActionListener(ActionListener l)</code>：移除指定侦听器</p></li><li><p><code>void setFont()</code>：设置当前字体</p></li><li><p><code>void setHorizontalAlignment(int alignment)</code>：设置水平对齐方式</p><p>有效值包括：</p><ul><li><p>JTextField.LEFT：左对齐（2）</p></li><li><p>JTextField.RIGHT：右对齐（4）</p></li><li><p>JTextField.CENTER：居中对齐（0）</p></li><li><p>JTextField.LEADING：领先对齐（10）</p><p>（似乎是）识别文字前端的对齐方式……好吧，我也不太明白</p></li><li><p>JTextField.TRAILING：落后对齐（11）</p></li></ul></li><li><p><code>int getColumns()</code>：返回文本域列数</p></li></ul><h3 id="jtextarea-文本区">15.7.2 JTextArea 文本区</h3><blockquote><p>JTextArea 是一个多行多列的文本输入框</p></blockquote><p><strong>构造方法：</strong></p><ul><li><code>new JTextArea()</code>：构造一个空文本区</li><li><code>new JTextArea(int rows, int columns)</code>：构造一个指定行数、列数数的空文本区</li><li><code>new JTextArea(String text)</code>：构造一个显示指定初始字符的文本区</li><li><code>new JTextArea(String text, int rows, int columns)</code>：构造一个指定行列数及初始字符的文本区</li></ul><p><strong>常用方法：</strong></p><ul><li><p><code>void append(String str)</code>：追加文本到文本区</p></li><li><p><code>void insert(String str, int pos)</code>：将指定文本插入到特定位置pos 处</p></li><li><p><code>void replaceRange(String str, int start, int end)</code>：用指定文本str 替换指定范围的文本</p></li><li><p><code>void addAncestorListener(AncestorListener listener)</code>：添加指定侦听器</p><p>特别地，用户输入文本时，按下 Enter键的场合只是向缓冲区输入一个字符，而不能表示输入的结束。因此，需要识别用户输入完成时，通常要在文本区旁放置一个确定按钮</p></li></ul><h2 id="菜单组件">15.8 菜单组件</h2><blockquote><p>菜单是最常用的 GUI 组件之一。Swing 包中提供了多种菜单组件。</p><p>菜单有下拉式菜单和弹出式菜单两种</p></blockquote><h3 id="菜单栏及菜单">15.8.1 菜单栏及菜单</h3><blockquote><p>JMenuBar 菜单栏是窗口主菜单，用来包容一组菜单</p><p>通过容器的 <code>setJMenuBar(JMenuBar m)</code>方法将菜单栏放到窗口上</p></blockquote><p><strong>菜单栏 JMenuBar 构造方法：</strong></p><ul><li><code>new JMenuBar()</code>：构建一个新的菜单栏</li></ul><p>菜单栏也能注册一些事件侦听程序，但通常情况下对于这些事件我们都不进行处理</p><p><strong>菜单构造方法：</strong></p><ul><li><code>new JMenu()</code>：构造没有文本的新菜单</li><li><code>new JMenu(String str)</code>：构造有指定标签的菜单</li><li><code>new JMenu(String str, boolean b)</code>：构造有指定标签的菜单，并指示其是否可以被分离</li></ul><p><strong>常用方法：</strong></p><ul><li><p><code>add(JMenu m)</code>：菜单可以被加入菜单栏或另一个菜单中</p></li><li><p><code>addSeparator()</code>：为菜单各项间加入间隔线</p><p><code>insertSeparator(int index)</code>：在指定位置插入间隔线</p><p>也能通过这种方式插入间隔线：</p><div class="code-wrapper"><pre><code class="hljs java">menu.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JSeparator</span>());<span class="hljs-comment">//JSeparator 类即分割线类</span></code></pre></div></li></ul><h3 id="jmenuitem-菜单项">15.8.2 JMenuItem 菜单项</h3><blockquote><p>JMenuItem 菜单项是菜单系统的最下一级</p></blockquote><p><strong>构造方法：</strong></p><ul><li><p><code>new JMenuItem()</code>：创建不带有设置文本或图标的菜单项</p></li><li><p><code>new JMenuItem(Icon i)</code>：创建只有图标的菜单项</p></li><li><p><code>new JMenuItem(String str)</code>：创建只有文本的菜单项</p></li><li><p><code>new JMenuItem(String str, Icon i)</code>：创建有图标和文本的菜单项</p></li><li><p><code>new JMenuItem(String str, int mnemonic)</code>：创建有文本和快捷键的菜单项</p><p>那个快捷键的有效值是 KeyEvent 包下的各种常量</p></li></ul><p><strong>常用方法：</strong></p><ul><li><p><code>setMnemonic(int m)</code>：设置快捷键</p></li><li><p><code>setAccelerator(KeyStroke keyStroke)</code>：设置加速键</p></li><li><p><code>addActionListener(ActionListener l)</code>：加入侦听器</p><p>菜单项被选中时，会触发 ActionEvent 事件</p></li></ul><h3 id="复选菜单项和单选菜单项">15.8.3 复选菜单项和单选菜单项</h3><blockquote><p>JCheckBoxMenuItem（复选菜单项）和JRadioButtonMenuItem（单选菜单项）是两种特殊的菜单项。</p><p>JCheckBoxMenuItem 前有个小方框，以供提示复选</p><p>JRadioButtonMenuItem 前有个小圆圈，以供提示单选</p></blockquote><p><strong>复选菜单项构造器：</strong></p><ul><li><code>new JCheckBoxMenuItem()</code>：一个无文本图标，初始未选中的菜单项</li><li><code>new JCheckBoxMenuItem(Icon i)</code>：就是有图标咯</li><li><code>new JCheckBoxMenuItem(String str)</code>：就是有文本咯</li><li><code>new JCheckBoxMenuItem(String str, boolean b)</code>：就是有文本，又指定初始状态咯</li><li><code>new JCheckBoxMenuItem(String str, Icon i)</code>：就是有文本，又有图标咯</li><li><code>new JCheckBoxMenuItem(String str, Icon i, boolean b)</code>：你猜呗</li></ul><p><strong>单选菜单项构造器：</strong></p><p>单选菜单项是 JRadioButtonMenuItem，剩下的都和上面的一样</p><h2 id="对话框">15.9 对话框</h2><blockquote><p>对话框是一个临时的可移动窗口，其依赖于其他窗口。当期依赖的窗口消失或最小化时，对话框消失。窗口还原时对话框恢复。</p><p>对话框分为强制型和非强制型。强制型对话框在关闭前，其他窗口不能接收任何形式的输入。也就是说，该对话过程不能中断。强制型对话框也被称为模式窗口。</p></blockquote><h3 id="jdialog-自定义对话框">15.9.1 JDialog 自定义对话框</h3><p><strong>构造方法：</strong></p><ul><li><p><code>new JDialog(Dialog owner)</code>：无标题无模式对话框。指定对话框为其所有者</p><p><code>new JDialog(Frame owner)</code>：指定框架为其所有者</p></li><li><p><code>new JDialog(Dialog owner, boolean model)</code>：无标题对话框，指定所有者并指示是否为有模式</p></li><li><p><code>new JDialog(Dialog owner, String title)</code></p><p><code>new JDialog(Frame owner, String title)</code></p><p><code>new JDialog(Dialog owner, String title, boolean model)</code></p><p><code>new JDialog(Frame owner, String title, boolean model)</code>：这些你都懂的吧</p></li></ul><h3 id="joptionalpane-标准对话框">15.9.2 JOptionalPane 标准对话框</h3><blockquote><p>JDialog 通常用于创建自定义对话框。此外，还有用于显示标准对话框的JOptionalPane 类</p></blockquote><p>JOptionalPane 定义了多个<strong>静态方法</strong>，分为以下 4个类型：</p><ul><li><p><strong>showConfirmDialog</strong>：确认对话框。显示问题，要求用户进行确认（yes/ no / cancel）</p><p>其同名方法有以下 3 种</p><ul><li><p>int showConfirmDialog(<font color=#FF4040>ComponentparentComponent</font>, <font color=#00E040>Objectmessage</font>)</p></li><li><p>int showConfirmDialog(<font color=#FF4040>ComponentparentComponent</font>, <font color=#00E040>Object message</font>,<font color=#EAA0FF>String title</font>, <font color=#00AAFF>intoptionType</font>)</p></li><li><p>int showConfirmDialog(<font color=#FF4040>ComponentparentComponent</font>, <font color=#00E040>Object message</font>,<font color=#EAA0FF>String title</font>, <font color=#00AAFF>intoptionType</font>, <font color=#E0AA00>int messageType</font>)</p></li></ul></li><li><p><strong>showInputDialog</strong>：输入对话框。提示用户进行输入</p><p>同名方法有以下 6 种：</p><ul><li><p>showInputDialog(<font color=#00E040>Objectmessage</font>)</p></li><li><p>showInputDialog(<font color=#00E040>Object message</font>,<font color=#0000AE>Object initialValue</font>)</p></li><li><p>showInputDialog(<font color=#FF4040>ComponentparentComponent</font>, <font color=#00E040>Objectmessage</font>)</p></li><li><p>showInputDialog(<font color=#FF4040>ComponentparentComponent</font>, <font color=#00E040>Object message</font>,<font color=#0000AE>Object initialValue</font>)</p></li><li><p>showInputDialog(<font color=#FF4040>ComponentparentComponent</font>, <font color=#00E040>Object message</font>,<font color=#EAA0FF>String title</font>, <font color=#E0AA00>intmessageType</font>)</p></li><li><p>showInputDialog(<font color=#FF4040>ComponentparentComponent</font>, <font color=#00E040>Object message</font>,<font color=#EAA0FF>String title</font>, <font color=#E0AA00>intmessageType</font>, Icon icon, <font color=#0FF0AE>Object[]options</font>, <font color=#0000AE>Object initialValue</font>)</p></li></ul></li><li><p><strong>showMessageDialog</strong>：信息对话框。显示信息</p><p>同名方法有以下 3 种：</p><ul><li><p>showMessageDialog(<font color=#FF4040>ComponentparentComponent</font>, <font color=#00E040>Objectmessage</font>)</p></li><li><p>showMessageDialog(<font color=#FF4040>ComponentparentComponent</font>, <font color=#00E040>Object message</font>,<font color=#EAA0FF>String title</font>, <font color=#E0AA00>intmessageType</font>)</p></li><li><p>showMessageDialog(<font color=#FF4040>ComponentparentComponent</font>, <font color=#00E040>Object message</font>,<font color=#EAA0FF>String title</font>, <font color=#E0AA00>intmessageType</font>, Icon icon)</p></li></ul></li><li><p><strong>showOptionDialog</strong>：选项对话框，显示选项，要求用户进行选择</p><p>其只有 1 种同名方法</p><ul><li>showOptionDialog(<font color=#FF4040>ComponentparentComponent</font>, <font color=#00E040>Object message</font>,<font color=#EAA0FF>String title</font>, <font color=#00AAFF>intoptionType</font>, <font color=#E0AA00>int messageType</font>, Iconicon, <font color=#0FF0AE>Object[] options</font>,<font color=#0000AE>Object initialValue</font>)</li></ul></li></ul><p>以上各个方法的参数分别是：</p><ul><li><p><font color=#FF4040>ComponentparentComponent</font>：对话框的父窗口对象。其父窗口位置决定了对话框位置</p><p>该值可以是 null，表示用默认的 Frame作为父窗口。这个场合，对话框位置在屏幕正中</p></li><li><p><font color=#00E040>Objectmessage</font>：显示在对话框的描述信息。</p><p>该参数通常是 String 对象，但也能是一个图标、组件或对象数组</p></li><li><p><font color=#EAA0FF>String title</font>：对话框标题</p></li><li><p><font color=#00AAFF>intoptionType</font>：对话框上的按钮类型。可以是以下常量：</p><ul><li>JOptionalPane.DEFAULT_OPTION：默认（-1）</li><li>JOptionalPane.YES_NO_OPTION：一组 yes / no（0）</li><li>JOptionalPane.YES_NO_CANCEL_OPTION：一组 yes / no / cancel（1）</li><li>JOptionalPane.OK_CANCEL_OPTION：一组 ok / cancel（2）</li></ul><p>此外，也能通过 <font color=#0FF0AE>Object[] options</font>参数指定其他形式</p></li><li><p><font color=#0FF0AE>Object[] options</font>：对话框上的选项。</p><p>在输入对话框中，通常以组合框架形式显示。在选项对话框中，则是指按钮类型。</p><p>该参数通常是一个 String[] 数组，但也能是图标数组或组件数组</p></li><li><p><font color=#E0AA00>intmessageType</font>：对话框传递的信息类型。可以是以下常量：</p><ul><li>JOptionalPane.ERROR_MESSAGE：错误信息（0）</li><li>JOptionalPane.INFORMATION_MESSAGE：普通信息（1）</li><li>JOptionalPane.WARNING_MESSAGE：警告信息（2）</li><li>JOptionalPane.QUESTION_MESSAGE：提问信息（3）</li><li>JOptionalPane.PLAIN_MESSAGE：无格式信息（-1）</li></ul><p>除 PLAIN_MESSAGE 外，每种类型对应于一个默认的图标</p></li><li><p><font color=#0000AE>ObjectinitialValue</font>：初始选项或输入值</p></li></ul><h3 id="jfilechooser-文件对话框">15.9.3 JFileChooser 文件对话框</h3><blockquote><p>JFileChooser文件对话框是专门用于对文件或目录进行浏览和选择的对话框</p></blockquote><p><strong>构造方法：</strong></p><ul><li><code>new JFileChooser()</code>：构造一个指向客户默认目录的文件对话框</li><li><code>new JFileChooser(File currentDirectory)</code>：指向指定目录的文件对话框</li><li><code>new JFileChooser(String path)</code>：指向指定目录的文件对话框</li></ul><p><strong>常用方法：</strong></p><ul><li><p><code>showOpenDialog(Component parent)</code>：弹出一个 “打开”文件对话框</p><p>parent 是对话框的父窗口对象。其父窗口位置决定了对话框位置</p><p>该值可以是 null，表示用默认的 Frame作为父窗口。这个场合，对话框位置在屏幕正中</p><p><code>showSaveDialog(Component parent)</code>：弹出一个 “保存”文件对话框</p></li><li><p><code>getSelectedFile()</code>：获得用户选择的文件</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;C++&gt;7 类和对象</title>
    <link href="/2022/04/17/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/7%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    <url>/2022/04/17/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/7%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="类和对象">7 类和对象</h1><blockquote><p>面向对象程序设计方法是 20 世纪 90年代以来软件开发方法的主流。其将问题看成是相互作用的事物的集合，即对象的集合。</p><p>对象有两个特征：状态和行为。状态即对象本身的信息，也称为属性；行为是对对象的操作。</p><p>通过对事物的抽象找出同一类对象的共同特征（静态特征）和行为（动态特征）从而得到类的概念。对象是类的一个具象，类是对象的一个抽象。</p><p>C++ 面向对象的三大特性：封装、继承、多态</p></blockquote><h2 id="封装">7.1 封装</h2><blockquote><p>封装是面向对象三大特征之一</p></blockquote><p><strong>封装的意义：</strong></p><ul><li>将属性和行为作为整体，表现生活中的事物</li><li>将属性和行为加以权限限制</li></ul><p>示例：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<span class="hljs-keyword">public</span>:<span class="hljs-comment">//[1] 访问权限：公共</span><span class="hljs-type">bool</span> b = <span class="hljs-literal">true</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doit</span><span class="hljs-params">()</span> </span>&#123;cout &lt;&lt; (b ? <span class="hljs-string">&quot;Just! Do it! Make your dream come true!&quot;</span> : <span class="hljs-string">&quot;这里头水很深，你把握不住！&quot;</span>) &lt;&lt; endl;&#125;&#125;;</code></pre></div><p><strong>三种访问权限：</strong></p><ul><li><p>public：公共权限</p><p>随意访问</p></li><li><p>private：私有权限</p><p>仅自身类内可以访问。<del>爸爸的快乐你想象不到</del></p><p>不进行说明时，成员默认为私有</p></li><li><p>protected：保护权限</p><p>仅自身及子类内可以访问。<del>爸爸的快乐我想象到了</del></p></li></ul><p><strong>struct 和 class 的区别：</strong></p><ul><li>struct 默认权限为 public</li><li>class 默认权限为 private</li></ul><p><strong>成员属性私有的优点：</strong></p><ul><li>便于控制读写权限</li><li>可以检测数据的有效性</li></ul><p><strong>下面展示一个封装：</strong></p><ul><li><p><strong>头文件（headF1.h）：</strong></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<span class="hljs-keyword">private</span>:<span class="hljs-type">double</span> x;<span class="hljs-type">double</span> y;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">Point</span>(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y);<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getX</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getY</span><span class="hljs-params">()</span></span>;&#125;;</code></pre></div></li><li><p><strong>源文件（point.cpp）：</strong></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;headF1.h&quot;</span><span class="hljs-comment">//包含该自定义头文件</span></span>Point::<span class="hljs-built_in">Point</span>(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y) &#123;<span class="hljs-keyword">this</span>-&gt;x = x;<span class="hljs-keyword">this</span>-&gt;y = y;&#125;<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Point::getX</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//Point:: 即，该函数是 Point 的成员函数</span><span class="hljs-keyword">return</span> x;&#125;<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Point::getY</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> y;&#125;</code></pre></div></li></ul><h2 id="对象的初始化和清理">7.2 对象的初始化和清理</h2><blockquote><p>初始化就是指进行初始化，而清理就是说要清理。</p><p>怎么样，明白了吧</p></blockquote><p>程序中涉及的基本数据类型的变量要先初始化再使用：</p><ul><li>对于全局变量，如果程序员声明时未进行初始化，则系统将其进行默认初始化</li><li>对于局部变量，系统不会进行默认初始化。不初始化就调用时，是一个随机值</li></ul><p>对象也要先进行初始化才能使用。因为对象的结构和行为更加复杂，需要使用构造函数完成对其初始化。</p><h3 id="构造函数和析构函数">7.2.1 构造函数和析构函数</h3><blockquote><p>如果一个对象没有初始状态，对其使用的后果是未知</p><p>使用完的对象没有及时清理，会造成一定的安全问题</p></blockquote><p>C++ 中使用 <strong>构造函数</strong> 和 <strong>析构函数</strong>解决上述问题。这两个函数会被编译器自动调用，完成初始化和清理工作。</p><p>如果我们不提供构造和析构，编译器有默认方法。默认方法是空实现。</p><ul><li>构造函数：在创建对象时被系统自动调用。为对象的成员属性赋值</li><li>析构函数：于对象销毁前被系统自动调用。执行一些清理工作</li></ul><h4 id="构造函数">7.2.1.1 构造函数</h4><blockquote><p>在创建对象时被系统自动调用。为对象的成员属性赋值</p></blockquote><p>语法：<code>类名(参数) &#123;构造函数体&#125;</code></p><p>初始化列表语法：<code>类名(参数): 属性1(值1), 属性2(值2)... &#123;构造函数体&#125;</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-type">int</span> n;    <span class="hljs-type">int</span> j;        <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// 构造函数</span>        <span class="hljs-keyword">this</span>-&gt;n = i;    &#125;        <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b): <span class="hljs-built_in">n</span>(a - <span class="hljs-number">1</span>), <span class="hljs-built_in">j</span>(b) &#123;&#125;<span class="hljs-comment">// 初始化列表语法</span>&#125;;</code></pre></div><blockquote><ol type="1"><li>构造函数没有返回值，也不写 void</li><li>构造函数名称和类名相同</li><li>构造函数有参数，可以重载</li><li>程序调用对象时会自动调用构造，且仅会调用一次，无需手动调用</li><li>特别地，只有唯一参数的构造函数也被称为<strong>类型转换构造函数</strong></li></ol></blockquote><h4 id="析构函数">7.2.1.2 析构函数</h4><blockquote><p>于对象销毁前被系统自动调用。执行一些清理工作</p></blockquote><p>语法：<code>~类名() &#123;析构函数体&#125;</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-type">int</span> n = <span class="hljs-number">-1</span>;    ~<span class="hljs-built_in">Test</span>() &#123;<span class="hljs-comment">//析构函数</span>        cout &lt;&lt; <span class="hljs-string">&quot;n = &quot;</span> &lt;&lt; n &lt;&lt; endl;    &#125;&#125;;</code></pre></div><blockquote><ol type="1"><li>析构函数没有返回值，也不写 void</li><li>析构函数名称和类名相同，名称前加上 <code>~</code></li><li>析构函数不能有参数</li><li>程序销毁对象时会自动调用析构，且仅会调用一次，无需手动调用</li></ol></blockquote><h3 id="构造函数的分类及调用">7.2.2 构造函数的分类及调用</h3><p>分类方式：</p><ul><li>按参数分类：有参构造、无参构造（默认构造）</li><li>按类型分类：普通构造、拷贝构造</li></ul><p>调用方式：</p><ul><li>括号法</li><li>显式法</li><li>隐式转换法</li></ul><p>示例：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span>&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-type">int</span> n;        <span class="hljs-built_in">Example</span>() &#123;<span class="hljs-comment">//无参构造</span>        <span class="hljs-keyword">this</span>-&gt;n = <span class="hljs-number">0</span>;    &#125;        <span class="hljs-built_in">Example</span>(<span class="hljs-type">int</span> a) &#123;<span class="hljs-comment">//有参构造</span>        <span class="hljs-keyword">this</span>-&gt;n = a;    &#125;        <span class="hljs-built_in">Example</span>(<span class="hljs-type">const</span> Example&amp; e) &#123;<span class="hljs-comment">//拷贝构造</span>        <span class="hljs-keyword">this</span>-&gt;n = e.n;    &#125;        <span class="hljs-built_in">Example</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123;        <span class="hljs-keyword">this</span>-&gt;n = a + b;    &#125;&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    Example e1;<span class="hljs-comment">//[1]括号法</span>    <span class="hljs-function">Example <span class="hljs-title">e2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;    <span class="hljs-comment">/* Example wrong(); */</span>    Example e3 = <span class="hljs-built_in">Example</span>(<span class="hljs-number">15</span>);<span class="hljs-comment">//[2]显式法</span>    Example e4 = <span class="hljs-built_in">Example</span>(e1);    <span class="hljs-comment">/* Example(e1); */</span>    Example e5 = <span class="hljs-number">20</span>;<span class="hljs-comment">//[3]隐式转换法</span>    <span class="hljs-comment">//等于 Example e4 = Example(20);</span>    Example e6 = e2;    Example e7 = &#123; <span class="hljs-number">25</span>, <span class="hljs-number">1</span> &#125;;<span class="hljs-comment">//两个参数这样写</span>&#125;</code></pre></div><p><strong>注意事项：</strong></p><ol type="1"><li><p>使用括号法调用无参构造时，不要加括号</p><p>加了括号的场合，编译器会将其视为一个函数的声明，而不是构造对象</p><p><code>Example wrong();</code> 被认为是：</p><ul><li>方法名 <code>wrong</code></li><li>返回值 <code>Example</code></li><li>参数列表 <code>()</code></li></ul></li><li><p>不要用拷贝构造函数初始化匿名对象</p><p>若如此做，编译器会将其视为该对象的声明，而不是拷贝构造</p><p><code>Example(e1);</code> 被认为是：</p><ul><li><code>Example e1;</code></li></ul><p>这与之前的声明重复，因此可能报错为重定义</p></li></ol><h3 id="拷贝构造函数的调用时机">7.2.3 拷贝构造函数的调用时机</h3><ol type="1"><li><p>使用一个已创建的对象来初始化新对象</p><div class="code-wrapper"><pre><code class="hljs c++">Example e1;<span class="hljs-comment">//默认构造</span><span class="hljs-function">Example <span class="hljs-title">e2</span><span class="hljs-params">(e1)</span></span>;<span class="hljs-comment">//拷贝构造</span></code></pre></div></li><li><p>值传递的方式给函数参数传值</p><p>传入参数实际上是拷贝构造的匿名对象</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">met</span><span class="hljs-params">(Example e)</span> </span>&#123;<span class="hljs-comment">//值传递</span>&#125;</code></pre></div></li><li><p>值方式返回局部对象</p><p>返回值实际上是拷贝构造的匿名对象</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">Example <span class="hljs-title">met2</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//返回局部对象</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Example</span>();<span class="hljs-comment">//这里其实是 显式法</span>&#125;</code></pre></div></li></ol><h3 id="构造函数的调用规则">7.2.4 构造函数的调用规则</h3><p>C++ 编译器会为一个类添加 3 个默认函数</p><ul><li><p>默认构造函数（无参，函数体为空）</p><p>用户定义了任何构造函数的场合，编译器不再提供默认构造函数</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">Example</span>() &#123;&#125;<span class="hljs-comment">//这就是默认构造函数</span></code></pre></div></li><li><p>默认析构函数（无参，函数体为空）</p><div class="code-wrapper"><pre><code class="hljs c++">~<span class="hljs-built_in">Example</span>() &#123;&#125;<span class="hljs-comment">//这就是默认析构函数</span></code></pre></div></li><li><p>默认拷贝构造函数，进行值拷贝</p><p>用户定义了拷贝构造函数的场合，编译器不再提供默认拷贝构造函数</p></li></ul><h3 id="深拷贝与浅拷贝">7.2.5 深拷贝与浅拷贝</h3><ul><li><p>浅拷贝：简单的赋值拷贝工作。</p><p>浅拷贝可能导致堆区内存的重复释放</p><p>浅拷贝示例：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">E</span>&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-type">int</span>* n;    <span class="hljs-built_in">E</span>(<span class="hljs-type">int</span> a) &#123;        <span class="hljs-keyword">this</span>-&gt;n = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(a);<span class="hljs-comment">//堆区开辟空间</span>    &#125;        <span class="hljs-built_in">E</span>(E&amp; e) &#123;        <span class="hljs-keyword">this</span>-&gt;n = e.n;<span class="hljs-comment">//浅拷贝。默认拷贝函数即浅拷贝</span>    &#125;        ~<span class="hljs-built_in">E</span>() &#123;<span class="hljs-comment">//析构函数</span>        <span class="hljs-keyword">if</span> (n != <span class="hljs-literal">NULL</span>) &#123;            <span class="hljs-keyword">delete</span> n;<span class="hljs-comment">//释放空间</span>            n = <span class="hljs-literal">NULL</span>;        &#125;    &#125;&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">E <span class="hljs-title">e1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;    <span class="hljs-function">E <span class="hljs-title">e2</span><span class="hljs-params">(e1)</span></span>;<span class="hljs-comment">//浅拷贝。会导致问题</span>&#125;</code></pre></div><blockquote><p>由于是浅拷贝，此时，e1.n 储存的地址和 e2.n 相同</p><p>因此，第二次执行析构函数时，已经释放的空间不能被二次释放，就会出错。</p></blockquote></li><li><p>深拷贝：在堆区重新申请空间，进行拷贝工作</p><p>深拷贝修改后的代码：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">E</span>&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-type">int</span>* n;    <span class="hljs-built_in">E</span>(<span class="hljs-type">int</span> a) &#123;        <span class="hljs-keyword">this</span>-&gt;n = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(a);<span class="hljs-comment">//堆区开辟空间</span>    &#125;        <span class="hljs-built_in">E</span>(E&amp; e) &#123;        <span class="hljs-keyword">this</span>-&gt;n = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*e.n);<span class="hljs-comment">//深拷贝</span>    &#125;        ~<span class="hljs-built_in">E</span>() &#123;<span class="hljs-comment">//析构函数</span>        <span class="hljs-keyword">if</span> (n != <span class="hljs-literal">NULL</span>) &#123;            <span class="hljs-keyword">delete</span> n;<span class="hljs-comment">//释放空间</span>            n = <span class="hljs-literal">NULL</span>;        &#125;    &#125;&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">E <span class="hljs-title">e1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;    <span class="hljs-function">E <span class="hljs-title">e2</span><span class="hljs-params">(e1)</span></span>;<span class="hljs-comment">//此时就不会有问题了</span>&#125;</code></pre></div></li></ul><h3 id="类对象作为类成员">7.2.6 类对象作为类成员</h3><blockquote><p>C++类中的成员可以是另一个类的对象。我们称之为成员对象。包含成员对象的类叫封闭类</p><p>生成封闭类对象的语句应说明那些成员对象是如何初始化的。否则，编译器会使用默认构造函数（或能省略参数的构造函数）进行初始化。</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-type">int</span> a;    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> n = <span class="hljs-number">10</span>) : <span class="hljs-built_in">a</span>(n) &#123;&#125;&#125;;<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123;<span class="hljs-keyword">public</span>:    A Ca;<span class="hljs-comment">//A 类对象为 B 类成员</span>    <span class="hljs-type">int</span> b;    <span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> an, <span class="hljs-type">int</span> bn) : <span class="hljs-built_in">Ca</span>(an), <span class="hljs-built_in">b</span>(bn) &#123;&#125;    <span class="hljs-comment">//该构造器中，Ca(an) 即 A Ca = an; 隐式转换法</span>&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    B cb = <span class="hljs-built_in">B</span>(<span class="hljs-number">15</span>, <span class="hljs-number">6</span>);&#125;</code></pre></div><p>这个场合的构造函数、析构函数调用顺序是：</p><ol type="1"><li>类成员构造函数被调用</li><li>类构造函数被调用</li><li>类析构函数被调用</li><li>类成员析构函数被调用</li></ol><h3 id="静态成员">7.2.7 静态成员</h3><h4 id="静态变量">静态变量：</h4><p>全局变量是指在大括号外声明的变量，其作用域范围是全局可见。</p><p>使用 static修饰的全局变量称为静态全局变量。其作用域限于定义该变量的源文件中</p><p>使用 static修饰的局部变量是静态局部变量。其具有局部作用域，却有全局生存期。就是说，静态局部变量在整个运行期间存在，其占用空间直到程序结束才释放，但只能在其定义块内访问。</p><p>静态局部变量只进行一次初始化。如果显式给出初始值，则其初始化发生在该静态变量所在的块第一次执行时。</p><h4 id="类的静态成员">类的静态成员：</h4><p>在类体内定义类成员时，在前方添加 static关键字，即使其成为静态成员。</p><p>类的静态成员被类的所有对象共享。</p><p>在类体外为静态成员赋初始值时，那个赋值时前面不能加static，以免和静态全局变量混淆</p><p>静态成员分为：</p><ul><li>静态成员变量<ul><li>所有对象共享一份数据</li><li>在编译阶段分配内存（在全局区）</li><li>类内声明，类外初始化。</li></ul></li><li>静态成员函数<ul><li>所有对象共享一个函数</li><li>静态成员函数只能访问静态成员变量</li></ul></li></ul><p>访问静态成员：</p><ul><li>通过类对象：<code>类对象.静态成员</code></li><li>通过类名：<code>类名::静态成员</code></li></ul><h2 id="c-对象模型和-this-指针">7.3 C++ 对象模型和 this 指针</h2><blockquote><p>C++中，类内的成员变量和成员函数分开存储。只有非静态成员变量才属于类的对象</p></blockquote><ul><li>C++ 编译器会为每个空对象分配 1字节的空间，以区分空对象占用内存的位置</li><li>非静态成员变量，属于类的对象</li><li>静态成员变量，不属于类的对象</li><li>非静态成员函数，不属于类的对象</li><li>静态成员函数，不属于类的对象</li></ul><h3 id="this-指针">7.3.1 this 指针</h3><blockquote><p>this指针是隐含在每一个非静态成员函数内的一种指针。指向被调用的成员函数所属的对象。</p><p>this指针不需要定义，可以直接使用。类的每个成员函数中都包含该指针。</p><p>this 的本质是 指针常量。其指向不能修改<strong><em>（见 <ahref="../../../../../../2022/03/31/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/4%20%E6%8C%87%E9%92%88%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93/#4-1-3-const-%E4%BF%AE%E9%A5%B0%E6%8C%87%E9%92%88">[4.1.3.2指针常量]</a>）</em></strong></p></blockquote><p>this 指针的用途：</p><ul><li>形参和成员变量同名时，使用 this 指针进行区分</li><li>在类的非静态成员函数中返回对象本身</li></ul><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">E</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setN</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">this</span>-&gt;n = n;    &#125;    <span class="hljs-function">E&amp; <span class="hljs-title">doit</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>-&gt;n += <span class="hljs-number">10</span>;        cout &lt;&lt; n &lt;&lt; endl;        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-type">int</span> n;&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    E e;    e.<span class="hljs-built_in">setN</span>(<span class="hljs-number">10</span>);    e.<span class="hljs-built_in">doit</span>().<span class="hljs-built_in">doit</span>().<span class="hljs-built_in">doit</span>();&#125;</code></pre></div><h3 id="空指针访问成员函数">7.3.2 空指针访问成员函数</h3><blockquote><p>C++ 中空指针也能调用成员函数，但要注意是否用到 this</p><p>如果用到 this，需要判断以保证代码健壮性</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">E</span>&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-type">int</span> n;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">met1</span><span class="hljs-params">()</span> </span>&#123;        cout &lt;&lt; <span class="hljs-string">&quot;Method1&quot;</span> &lt;&lt; endl;    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">met2</span><span class="hljs-params">()</span> </span>&#123;        cout &lt;&lt; <span class="hljs-string">&quot;Method2&quot;</span> &lt;&lt; n &lt;&lt; endl;    &#125;&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    E* e = <span class="hljs-literal">NULL</span>;    e.<span class="hljs-built_in">met1</span>();<span class="hljs-comment">//这个正常</span>    <span class="hljs-comment">/* e.met2() */</span><span class="hljs-comment">//这个报错</span>&#125;</code></pre></div><h3 id="const-修饰成员函数">7.3.3 const 修饰成员函数</h3><blockquote><p>可以用 const 定义成员变量或成员函数，甚至是类对象。</p><p>使用 const 修饰的成员变量称为常量成员变量</p><p>使用 const 修饰的函数称为常量函数（常函数）</p><p>定义类对象时添加 const 关键字，该对象称为常量对象（常对象）</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">value</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 成员函数</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<span class="hljs-comment">// 常量函数。因为有 const，语法上构成重载</span>&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">A::value</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">A::value</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;&#125;</code></pre></div><ul><li><p>常函数：</p><ul><li><p>成员函数后加 const 则成为常函数</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">say</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;&#125;<span class="hljs-comment">//常函数</span></code></pre></div></li><li><p>常函数不能修改成员属性</p></li><li><p>成员属性声明时加关键字 mutable 后，可以被常函数修改</p></li><li><p>在成员函数后加 const，本质上是修饰了 this 指针</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">const</span> E* <span class="hljs-type">const</span> <span class="hljs-keyword">this</span>;</code></pre></div><p>这样一来，this 指针指向的值也不能修改了</p></li><li><p>常对象只能访问常函数，普通对象既能访问普通函数也能访问常函数</p><p>对于重载的常函数，根据调用对象是常对象或普通对象，系统会进行自动匹配</p></li><li><p>如果一个成员函数中没有调用非常函数，也没有修改成员变量，那么建议将其写成常函数</p></li></ul></li><li><p>常对象：</p><ul><li><p>声明对象前加 const 称为常对象</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">const</span> E e;<span class="hljs-comment">//常对象</span></code></pre></div></li><li><p>常对象的所有属性值都不能修改，除非其属性有 mutable关键字</p></li><li><p>常对象只能调用常函数。因为普通成员函数能修改属性</p></li></ul></li></ul><h2 id="友元">7.4 友元</h2><blockquote><p>让一个函数或类访问另一个函数中的私有成员。友元关系是单向的</p><p>友元关键字：friend</p><p>友元不受类中访问关键字限制。将其放在类的公有、私有、保护部分，结果是相同的</p></blockquote><p>友元的三种实现：</p><ul><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ul><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">InazumaCastle</span>;<span class="hljs-keyword">class</span> <span class="hljs-title class_">LaSignora</span> &#123;<span class="hljs-keyword">public</span>:    string name = <span class="hljs-string">&quot;女士&quot;</span>;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">announce</span><span class="hljs-params">(InazumaCastle* q)</span></span>;&#125;;<span class="hljs-keyword">class</span> <span class="hljs-title class_">RaidenEi</span> &#123;<span class="hljs-keyword">public</span>:    string name = <span class="hljs-string">&quot;雷电影&quot;</span>;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(InazumaCastle* q)</span></span>;&#125;;<span class="hljs-keyword">class</span> <span class="hljs-title class_">InazumaCastle</span> &#123;    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(InazumaCastle* q)</span></span>;<span class="hljs-comment">//将全局函数做友元</span>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RaidenEi</span>;<span class="hljs-comment">//类做友元</span>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">LaSignora::announce</span><span class="hljs-params">(InazumaCastle* q)</span></span>;<span class="hljs-comment">//成员函数做友元</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">InazumaCastle</span>()&#123;&#125;<span class="hljs-keyword">private</span>:    string npc = <span class="hljs-string">&quot;雷电将军&quot;</span>;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(InazumaCastle* q)</span> </span>&#123;<span class="hljs-comment">//全局函数</span>    cout &lt;&lt; q-&gt;npc &lt;&lt; endl;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RaidenEi::visit</span><span class="hljs-params">(InazumaCastle* q)</span> </span>&#123;<span class="hljs-comment">//成员函数</span>    cout &lt;&lt; <span class="hljs-string">&quot;雷军亦未寝&quot;</span> &lt;&lt; endl;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LaSignora::announce</span><span class="hljs-params">(InazumaCastle* q)</span> </span>&#123;<span class="hljs-comment">//成员函数</span>    cout &lt;&lt; q-&gt;npc &lt;&lt; <span class="hljs-string">&quot;听仔细了！&quot;</span> &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;你要战，我便战，我有愚人众兄弟千千万！单挑群挑你们也不是对手，别把我们惹急了！&quot;</span> &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;明天我就上你们几个神家里挨个收神之心，不给别怪我不客气！&quot;</span> &lt;&lt; endl;&#125;</code></pre></div><h2 id="运算符重载">7.5 运算符重载</h2><blockquote><p>对已有运算符重新定义，以适应不同数据类型</p></blockquote><p>对于类运算的运算符通常都要重载。系统提供了两个运算符的默认重载版本：</p><p><code>=</code> 系统默认进行对象成员变量的值拷贝。<code>&amp;</code>系统默认返回任何类对象的地址</p><p><strong>运算符重载的格式是：</strong></p><div class="code-wrapper"><pre><code class="hljs c++">返回值 <span class="hljs-keyword">operator</span>运算符 (形参列表) &#123;    函数体&#125;</code></pre></div><p>可以重载的运算符有：</p><table><tr><th>双目算术运算符</th><td>+、-、*、/、%</td></tr><tr><th>关系运算符</th><td>==、!=、&amp;lt、&amp;gt、&amp;lt=、&amp;gt=</td></tr><tr><th>逻辑运算符</th><td>||、&amp;&amp;、!</td></tr><tr><th>单目运算符</th><td>+（正）、-（负）、*（指针）、&amp;（取址）</td></tr><tr><th>自增自减运算符</th><td>++、--</td></tr><tr><th>位运算符</th><td>&amp;lt&amp;lt、&amp;gt&amp;gt、~、|、&amp;、^</td></tr><tr><th>赋值运算符</th><td>=、+=、-=、*=、/=、&amp;=、|=、^=、&amp;lt&amp;lt=、&amp;gt&amp;gt=、~=</td></tr><tr><th>空间申请与释放</th><td>new、delete、new[]、delete[]</td></tr><tr><th>其他运算符</th><td>()、-&gt;、[]、,</td></tr></table><p>不能重载的运算符有：</p><table><tr><th>成员访问运算符</th><td>.</td></tr><tr><th>成员指针访问运算符</th><td>.<em>、-&gt;</em></td></tr><tr><th>域运算符</th><td>::</td></tr><tr><th>长度运算符</th><td>sizeof</td></tr><tr><th>条件运算符</th><td>?:</td></tr><tr><th>预处理符号</th><td>#</td></tr></table><h4 id="注意事项">注意事项：</h4><ul><li>重载运算符的含义应符合原有用法习惯。<ul><li>避免给自己的猫取名字叫 “小狗” 或者 “笔记本电脑”</li></ul></li><li>运算符重载不能改变运算符原有的语义，包括运算符的优先级和结合性<ul><li>不要让自己的猫睡在床上，而自己睡在猫窝里</li></ul></li><li>运算符重载不能改变运算符的操作数个数及语法结构<ul><li>给猫投食时，食物从嘴巴进入，而不能从菊花进入</li></ul></li><li>不能创建新的运算符。即，重载运算符不能超出 C++语言允许重载的运算符范围<ul><li>可以去养一只猫，但不要和猫生小孩</li></ul></li><li>重载运算符<code>()</code>、<code>[]</code>、<code>-&gt;</code>、<code>=</code>时，只能将它们重载为成员函数，不能重载为全局函数<ul><li>把猫养在家里，不要养在大街上</li></ul></li><li>运算符重载不能改变该运算符用于基本数据类型对象的含义（即其原本含义）。<ul><li>不要指望猫能变成猫娘</li></ul></li></ul><h3 id="加号运算符重载">7.5.1 加号运算符重载</h3><blockquote><p><code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>同理</p></blockquote><ul><li><p>通过成员函数重载：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">E</span>&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-type">int</span> n;    E <span class="hljs-keyword">operator</span>+ (E&amp; e) &#123;<span class="hljs-comment">//成员函数</span>        E ne;        ne.n = e.n + <span class="hljs-keyword">this</span>-&gt;n;        <span class="hljs-keyword">return</span> ne;    &#125;&#125;;</code></pre></div></li><li><p>通过全局函数重载：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">E</span>&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-type">int</span> n;&#125;;E <span class="hljs-keyword">operator</span>+ (E&amp; e1, E&amp; e2) &#123;<span class="hljs-comment">//全局函数，参数是两个</span>    E ne;    ne.n = e1.n + e2.n;    <span class="hljs-keyword">return</span> ne;&#125;</code></pre></div></li></ul><p><strong>注意事项：</strong></p><ul><li><p>内置数据类型的运算符不能改变</p></li><li><p>不要滥用运算符重载</p><p><code>+</code> 结果实现的是减法，那不是找麻烦吗</p></li></ul><h3 id="左移运算符重载">7.5.2 左移运算符重载</h3><blockquote><p>重载左移运算符，配合友元，可以输出自定义数据类型</p></blockquote><ul><li><p>通常不会利用成员函数重载 <code>&lt;&lt;</code> 运算符，因为无法使cout 在左侧</p></li><li><p>通过全局函数重载：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">E</span> &#123;<span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt; (ostream&amp; cout, E&amp; e);<span class="hljs-keyword">private</span>:    <span class="hljs-type">int</span> n = <span class="hljs-number">100</span>;&#125;;ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt; (ostream&amp; cout, E&amp; e) &#123;<span class="hljs-comment">//ostream 对象是唯一的</span>    cout &lt;&lt; e.n;    <span class="hljs-keyword">return</span> cout;&#125;</code></pre></div></li></ul><h3 id="递增运算符重载">7.5.3 递增运算符重载</h3><ul><li><p>用成员函数重载：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">E</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123;<span class="hljs-comment">//后置 ++。用占位符 int 作为区分</span>        <span class="hljs-type">int</span> ret = <span class="hljs-keyword">this</span>-&gt;n;        <span class="hljs-keyword">this</span>-&gt;n += <span class="hljs-number">1</span>;        <span class="hljs-keyword">return</span> ret;    &#125;             E&amp; <span class="hljs-keyword">operator</span>++() &#123;<span class="hljs-comment">//前置 ++</span>        <span class="hljs-keyword">this</span>-&gt;n++;        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-type">int</span> n = <span class="hljs-number">100</span>;&#125;;</code></pre></div></li><li><p>通过全局函数重载：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">E</span> &#123;    <span class="hljs-keyword">friend</span> E&amp; <span class="hljs-keyword">operator</span>-- (E&amp; e);    <span class="hljs-keyword">friend</span> <span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>-- (E&amp; e, <span class="hljs-type">int</span>);<span class="hljs-keyword">private</span>:    <span class="hljs-type">int</span> n = <span class="hljs-number">100</span>;&#125;;E&amp; <span class="hljs-keyword">operator</span>-- (E&amp; e) &#123;<span class="hljs-comment">//前置 --</span>    e.n -= <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> e;&#125;<span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>-- (E&amp; e, <span class="hljs-type">int</span>) &#123;<span class="hljs-comment">//后置 --。用占位符 int 作为区分</span>    <span class="hljs-type">int</span> ret = e.n;    e.n -= <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> ret;&#125;</code></pre></div></li></ul><h3 id="赋值运算符重载">7.5.4 赋值运算符重载</h3><p>C++ 编译器至少给一个类添加 4 个函数</p><ul><li>默认构造函数</li><li>默认析构函数</li><li>默认拷贝构造函数，对属性进行值拷贝</li><li>赋值运算符 <code>=</code>，对属性进行值拷贝</li></ul><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">E</span> &#123;<span class="hljs-keyword">public</span>:    E&amp; <span class="hljs-keyword">operator</span>=(E&amp; e) &#123;<span class="hljs-comment">//重载喵</span>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;n != <span class="hljs-literal">NULL</span>) &#123;            <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;n;            <span class="hljs-keyword">this</span>-&gt;n = <span class="hljs-literal">NULL</span>;        &#125;        <span class="hljs-keyword">this</span>-&gt;n = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*e.n);<span class="hljs-comment">//深拷贝喵</span>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    &#125;        ~<span class="hljs-built_in">E</span>() &#123;<span class="hljs-comment">//析构喵</span>        <span class="hljs-keyword">if</span> (n != <span class="hljs-literal">NULL</span>) &#123;            <span class="hljs-keyword">delete</span> n;            n = <span class="hljs-literal">NULL</span>;        &#125;    &#125;    <span class="hljs-keyword">private</span>:    <span class="hljs-type">int</span>* n = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">100</span>);<span class="hljs-comment">//在堆里喵</span>&#125;;</code></pre></div><h3 id="关系运算符重载">7.5.5 关系运算符重载</h3><blockquote><p>略。</p><p>就略了，你看着办吧。</p><p>关系运算符就是 <code>==</code>、<code>&gt;</code>、<code>&gt;=</code>之类。返回值显然是布尔类型。</p></blockquote><h3 id="仿函数">7.5.6 仿函数</h3><ul><li>函数调用运算符 <code>( )</code> 居然也可以重载</li><li>重载后的使用方式像函数的调用，所以被称为 仿函数</li><li>仿函数没有固定写法，非常灵活</li></ul><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">P</span>&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(string str)</span> </span>&#123;        cout &lt;&lt; str &lt;&lt; endl;    &#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> n1, <span class="hljs-type">int</span> n2 = <span class="hljs-number">0</span>)</span> </span>&#123;        <span class="hljs-keyword">return</span> n1 + n2;    &#125;&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    P p;    <span class="hljs-built_in">p</span>(<span class="hljs-string">&quot;函数调用运算符重载！&quot;</span>);<span class="hljs-comment">//仿函数</span>    cout &lt;&lt; <span class="hljs-built_in">P</span>()(<span class="hljs-number">15</span>, <span class="hljs-number">27</span>) &lt;&lt; endl;<span class="hljs-comment">//P() 匿名对象调用仿函数，即匿名函数对象</span>&#125;</code></pre></div><h3 id="类型转换操作符重载">7.5.7 类型转换操作符重载</h3><p>C++中，类型的名字（包括类的名字）本身也是一种操作符，即强制类型转换操作符。</p><p>强制类型转换操作符是单目运算符，仅能被重载为成员函数，不能重载为全局函数。</p><p>重载后，<code>(类型名)对象</code> 就等价于<code>对象.operator类型名()</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// 重载强制类型转换操作符 (double)</span><span class="hljs-keyword">return</span> <span class="hljs-number">100.001</span>;&#125;&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;A a;cout &lt;&lt; (<span class="hljs-type">double</span>)a &lt;&lt; endl;<span class="hljs-comment">// 输出 100.001</span>cout &lt;&lt; a - <span class="hljs-number">100</span> &lt;&lt; endl;<span class="hljs-comment">// 输出 0.001</span>&#125;</code></pre></div><p>重载类型转换运算符时，<strong>不能指定返回值类型</strong>。因为返回值类型是确定的。</p><p>有了类型转换运算符的重载，在本该出现该转换类型的地方，如果出现了一个重载类型，则语法上视为正确。</p><h2 id="继承">7.6 继承</h2><blockquote><p>面向对象三大特性之一。</p><p>利用继承技术，减少重复代码</p></blockquote><p>语法：<code>class S: public F&#123;...&#125;</code></p><ul><li><p>S 类即子类（派生类）</p><p>子类中包含父类继承的成员及子类自己的成员</p><p>子类的大小等于：继承的父类大小 + 子类自身大小</p></li><li><p>F 类即父类（基类）</p></li></ul><h3 id="继承方式">7.6.1 继承方式</h3><p>继承方式共 3 种：</p><ul><li><p>公共继承 <code>class B: public A&#123;&#125;</code></p><p>成员继承后的访问权限不变</p></li><li><p>保护继承 <code>class B: protected A&#123;&#125;</code></p><p>private（访问不到）外，其余成员继承后的访问权限变为protected</p></li><li><p>私有继承 <code>class B: private A&#123;&#125;</code></p><p>private（访问不到）外，其余成员继承后的访问权限变为 private</p><p>不进行说明时，默认进行私有继承</p><p><strong><em>——访问修饰符见 <a href="#封装">7.1封装</a></em></strong></p></li></ul><h3 id="继承中的对象模型">7.6.2 继承中的对象模型</h3><ul><li><p>父类中所有非静态成员属性都会被子类继承（包括 private）</p></li><li><p>父类中 private 成员属性是被编译器隐藏了，故访问不到</p></li><li><p>使用 <code>VS 开发人员命令提示符</code>跳转到项目目录下，输入指令：</p><div class="code-wrapper"><pre><code class="hljs cmd">cl /d1 reportSingleClassLayout类名 所属文件名</code></pre></div><p>以查看类的构造。</p></li><li><p>父类持有的友元，在继承后仍只能访问父类成员对象。</p><p>其他类持有父类作为友元，继承后子类也是那些类的友元</p></li><li><p>子类构造器中使用父类构造器：</p><div class="code-wrapper"><pre><code class="hljs c++">子类名(参数): 父类<span class="hljs-number">1</span>(参数), 父类<span class="hljs-number">2</span>(参数) &#123;    ...&#125;</code></pre></div><p>同一父类的构造器只能调用一次，不声明时默认调用无参构造器</p><p>这个调用的顺序和类声明时的继承声明顺序<strong>相关</strong>，与该初始化列表中的顺序<strong>无关</strong></p></li></ul><h3 id="继承中构造和析构顺序">7.6.3 继承中构造和析构顺序</h3><blockquote><p>子类继承父类后，创建子类对象时，也会调用父类构造函数</p></blockquote><ol type="1"><li>父类构造函数</li><li>子类构造函数</li><li>子类析构函数</li><li>父类析构函数</li></ol><h3 id="继承同名成员的处理方式">7.6.4 继承同名成员的处理方式</h3><ul><li><p>访问子类同名成员：直接访问</p></li><li><p>访问父类同名成员：加作用域</p></li><li><p>子类同名函数会隐藏所有父类同名函数及其重载函数。此时必须加作用域</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">doiy</span><span class="hljs-params">()</span> </span>&#123;        cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;    &#125;&#125;;<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-type">int</span> n = <span class="hljs-number">20</span>;    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">doiy</span><span class="hljs-params">()</span> </span>&#123;        cout &lt;&lt; <span class="hljs-number">4</span> &lt;&lt; endl;    &#125;&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    B b;    B::<span class="hljs-built_in">doiy</span>();<span class="hljs-comment">//直接访问子类成员</span>    b.<span class="hljs-built_in">doiy</span>();<span class="hljs-comment">//直接访问子类成员</span>    B::A::<span class="hljs-built_in">doiy</span>();<span class="hljs-comment">//加作用域以访问父类成员</span>    cout &lt;&lt; b.n &lt;&lt; endl;<span class="hljs-comment">//直接访问子类成员</span>    cout &lt;&lt; b.A::n &lt;&lt; endl;<span class="hljs-comment">//加作用域以访问父类成员</span>&#125;</code></pre></div></li></ul><h3 id="多继承语法">7.6.5 多继承语法</h3><p>语法：<code>class A: public Ba, public Bb, private Bc&#123;...&#125;</code></p><p>多继承可能引发父类中有同名成员出现。访问时必须加上作用域</p><p>C++ 中不建议使用多继承。</p><h3 id="菱形继承">7.6.6 菱形继承</h3><p>菱形继承（钻石继承）：</p><ul><li>两个子类继承同一父类</li><li>某个类同时继承这两个子类</li></ul><p>菱形继承的场合，两个父类有相同数据，需要用作用域加以区分</p><p>两个父类数据重复，只需要一份。可以利用虚继承，解决菱形继承问题。</p><ul><li><p>虚继承：<code>class A: virtual public B, public C&#123;...&#125;</code></p><p>其中加入 <code>virtual</code> 的是虚继承，类 B、C 的共有父类被称为虚基类</p></li></ul><h2 id="多态">7.7 多态</h2><blockquote><p>面向对象三大特性之一</p><p>“一种接口，多种实现”。实现了多态机制的程序，可以使用同一名字实现不同功能</p></blockquote><p>多态分为：静态多态、动态多态</p><h4 id="静态多态">静态多态</h4><p>静态多态通过函数名、参数个数及类型，在编译阶段即建立函数代码与函数调用的对应关系。</p><p>静态多态也称 静态连编 或 静态绑定</p><p>静态多态的函数地址早绑定：编译阶段确定地址</p><p>静态多态使程序可读性好，但在控制程序运行和对象行为多样性方面存在局限性</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">say</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//静态多态</span>        cout &lt;&lt; <span class="hljs-string">&quot;哒哒哒&quot;</span> &lt;&lt; endl;;    &#125;&#125;;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Father &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">say</span><span class="hljs-params">()</span> </span>&#123;        cout &lt;&lt; <span class="hljs-string">&quot;芭芭拉冲呀&quot;</span> &lt;&lt; endl;    &#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">check</span><span class="hljs-params">(Father&amp; f)</span> </span>&#123;    f.<span class="hljs-built_in">say</span>();&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    Son s;    <span class="hljs-built_in">check</span>(s);<span class="hljs-comment">//即使传入子类，也是调用父类方法</span>&#125;</code></pre></div><h4 id="动态多态">动态多态</h4><p>由于多态的存在，编译器不能在编译阶段得知指针指向父类还是继承子类，也就不能确定调用的函数版本。函数调用与代码入口地址的绑定发生在运行时。</p><p>动态多态也称 动态连编 或 动态绑定。</p><p>动态多态的函数地址晚绑定：运行阶段确定函数地址、</p><p>实现方法：加入 virtual 关键字</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">say</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//虚函数</span>        cout &lt;&lt; <span class="hljs-string">&quot;哒哒哒&quot;</span> &lt;&lt; endl;;    &#125;&#125;;<span class="hljs-comment">/* 其余同上，略 */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    Son s;    <span class="hljs-built_in">check</span>(s);<span class="hljs-comment">//传入子类则调用子类方法</span>&#125;</code></pre></div><p>在满足赋值兼容的情况下，动态多态需满足以下条件：</p><ol type="1"><li>必须声明虚函数</li><li>通过子类类型的引用或指针调用虚函数</li></ol><h3 id="虚函数">7.7.1 虚函数</h3><p>编译器看到哪个指针，就认为要通过该指针访问哪个类的成员，并不会分辨指针是否指向子类对象。仅凭借继承机制，无法实现动态绑定。</p><p>在函数声明时加上 virtual 关键字，即成为虚函数。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">act</span><span class="hljs-params">()</span></span>;&#125;;<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A &#123;<span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">act</span><span class="hljs-params">()</span></span>;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">A::act</span><span class="hljs-params">()</span> </span>&#123;cout &lt;&lt; <span class="hljs-string">&#x27;A&#x27;</span> &lt;&lt; endl;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">B::act</span><span class="hljs-params">()</span> </span>&#123;cout &lt;&lt; <span class="hljs-string">&#x27;B&#x27;</span> &lt;&lt; endl;&#125;</code></pre></div><p>只有类的成员函数声明时才能声明为虚函数。成员函数的类外实现 和静态成员函数 不能包含 virtual 关键字。</p><h4 id="虚函数原理">虚函数原理</h4><p>虚函数在类内部保存一个虚函数指针。该指针指向该类的虚函数表内，该虚函数的地址</p><p>子类会继承该指针和虚函数表</p><p>子类重写该虚函数的场合，指针指向的虚函数被重写后的函数覆盖</p><h4 id="注意事项-1">注意事项</h4><ul><li><p>如果想要调用虚函数对象，需要在调用前加上基类名及作用域限定符</p><div class="code-wrapper"><pre><code class="hljs c++">A* n = <span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>();n-&gt;<span class="hljs-built_in">act</span>();<span class="hljs-comment">// B</span>n-&gt;A::<span class="hljs-built_in">act</span>();<span class="hljs-comment">// A</span></code></pre></div></li><li><p>虽然不会引起错误，但一般不将虚函数声明为内联函数。</p><p>这是因为：内联函数在编译阶段即进行静态处理，而虚函数是在运行时动态绑定。</p></li><li><p>只有类的成员函数声明时才能声明为虚函数。静态成员函数、友元函数不能定义为虚函数。</p></li><li><p>虚函数类外实现时，只有类内声明有 virtual关键字，类外实现不加该关键字</p></li><li><p>构造函数不能定义为虚函数。最好也不要将 operator=定义为虚函数，以免混淆。</p><p>最好将父类的析构函数声明为虚函数。</p></li><li><p>不要在构造函数、析构函数中调用虚函数。因为在构造函数、析构函数中，对象是不完整的，可能出现未定义的行为。</p></li></ul><h3 id="纯虚函数和抽象类">7.7.2 纯虚函数和抽象类</h3><blockquote><p>多态中，父类虚函数的实现往往是无意义的，主要调用子类重写的内容。因此，可以将虚函数改为纯虚函数。</p></blockquote><p>语法：<code>cirtual 返回值类型 函数名 (参数列表) = 0;</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vir</span>&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">met</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;&#125;;</code></pre></div><p>有纯虚函数的类被称为抽象类。</p><p><strong>抽象类特点：</strong></p><ol type="1"><li>抽象类不能实例化对象</li><li>子类必须重写抽象类的纯虚函数，否则也属于抽象类</li></ol><h3 id="虚析构和纯虚析构">7.7.3 虚析构和纯虚析构</h3><blockquote><p>多态使用时，父类指针释放时无法调用子类析构代码</p><p>拥有纯虚析构函数的类也属于抽象类</p></blockquote><p>语法：</p><ul><li><p>虚析构：<code>virtual ~类名() &#123;析构代码&#125;</code></p></li><li><p>纯虚析构：<code>virtual ~类名() = 0;</code></p><p>和纯虚函数不同。即使是纯虚析构，也要求（在类外）实现代码。</p><p>一言以蔽之：take off trouser to fart</p></li></ul><p>只要父类的析构函数是虚析构函数，则子类的虚构函数 <strong>无论是否用virtual 关键字声明，都自动成为虚析构函数</strong></p><p>一般来说，只要一个类定义了虚函数，就最好将其析构函数也定义为虚析构函数。</p><p>构造函数不能是虚函数。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;C++&gt;6 内存和引用</title>
    <link href="/2022/04/02/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/6%20%E5%86%85%E5%AD%98%E5%92%8C%E5%BC%95%E7%94%A8/"/>
    <url>/2022/04/02/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/6%20%E5%86%85%E5%AD%98%E5%92%8C%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="内存和引用">6 内存和引用</h1><h2 id="内存分区模型">6.1 内存分区模型</h2><blockquote><p>不同区域存放的数据被赋予不同的生命周期，提高编程灵活性</p></blockquote><p>C++ 程序执行时，将内存大致分为 4 个区域：</p><ul><li>代码区：存放函数体的二进制代码，由操作系统进行管理</li><li>全局区：存放全局变量、静态变量以及常量</li><li>栈区：由编译器自动分配释放。存放函数的参数值、局部变量等</li><li>堆区：由程序员分配和释放。若程序员不释放，程序结束时会由操作系统回收</li></ul><h3 id="程序运行前">6.1.1 程序运行前</h3><p>程序编译后，生产了 exe 可执行程序。未执行该程序前分为 2 个区域：</p><ul><li><p>代码区：</p><p>存放 CPU 执行的机器指令</p><p>代码区是 <strong>共享</strong>的。对于频繁被执行的程序，只要在代码区有一份代码即可</p><p>代码区是 <strong>只读</strong> 的，以防止程序意外修改其指令</p></li><li><p>全局区：</p><p><strong>全局变量</strong> 和 <strong>静态变量</strong> 存放在这里</p><p>全局区还包含 <strong>常量区</strong>，<strong>字符串常量</strong>和其他 <strong>常量</strong> 也存放在这里</p><p>（局部变量、局部常量 不放在这里）</p><p>该区域的数据在程序结束后由系统操作释放</p></li></ul><h3 id="程序运行后">6.1.2 程序运行后</h3><ul><li><p>栈区：</p><p>存放函数的参数值、局部变量等。</p><p>由编译器自动分配释放。<strong>因此，应该避免把局部变量地址作为返回值。</strong>若如此做，编译器仅一次会保留指针指向的值。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">met1</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<span class="hljs-comment">//一个局部变量</span>    <span class="hljs-keyword">return</span> &amp;a;<span class="hljs-comment">//把局部变量地址作为返回值</span>&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span>* p = <span class="hljs-built_in">met1</span>();<span class="hljs-comment">//接收上面的局部变量地址</span>    cout &lt;&lt; *p &lt;&lt; endl;<span class="hljs-comment">//仅一次，编译器保留的局部变量值</span>    cout &lt;&lt; *p &lt;&lt; endl;<span class="hljs-comment">//此时会输出错误的值</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div></li><li><p>堆区：</p><p>由程序员分配和释放。若程序员不释放，程序结束时会由操作系统回收</p><p>在 C++ 中主要利用 new 在栈区开辟内存空间</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">met2</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span>* a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//开辟了一个内存空间</span>    <span class="hljs-keyword">return</span> a;<span class="hljs-comment">//把内存空间地址作为返回值</span>&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span>* p = <span class="hljs-built_in">met2</span>();<span class="hljs-comment">//接收上面的内存空间地址</span>    cout &lt;&lt; *p &lt;&lt; endl;    cout &lt;&lt; *p &lt;&lt; endl;<span class="hljs-comment">//正常输出</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div></li></ul><h3 id="new-操作符">6.1.3 new 操作符</h3><blockquote><p>在 C++ 中主要利用 new 在栈区开辟内存空间</p></blockquote><p>堆区由程序员手动分配和释放空间</p><ul><li><p>分配空间：<code>new 数据类型</code></p></li><li><p>释放空间：<code>delete 指针</code></p></li></ul><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">24</span>);<span class="hljs-comment">//[1]</span>cout &lt;&lt; *p &lt;&lt; endl;<span class="hljs-comment">//这里，输出 24</span><span class="hljs-keyword">delete</span> p;<span class="hljs-comment">//[2]</span><span class="hljs-comment">/* cout &lt;&lt; *p; */</span><span class="hljs-comment">//这里就不能再访问该内存空间了</span><span class="hljs-type">int</span>* p2 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];<span class="hljs-comment">//[3]</span><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;<span class="hljs-comment">//赋值</span>    p2[i] = i;&#125;<span class="hljs-keyword">delete</span>[] p2;<span class="hljs-comment">//[4]</span></code></pre></div><blockquote><ol type="1"><li>new 返回一个该数据类型的指针</li><li>delete 释放该数据内存</li><li>为一个长度 10的数组开辟了空间。这个场合数组中的元素也都在堆区内</li><li>delete[] 释放该数组内存。需要加 <code>[ ]</code>中括号以表示释放多个内存</li></ol></blockquote><h2 id="引用">6.2 引用</h2><blockquote><p>引用：给变量起别名</p></blockquote><h3 id="引用的基本使用">6.2.1 引用的基本使用</h3><p>语法：<code>数据类型&amp; 别名 = 原名</code></p><div class="code-wrapper"><pre><code class="hljs c++">string keQing = <span class="hljs-string">&quot;霓霆快雨&quot;</span>;string&amp; waifu = keQing;<span class="hljs-comment">// 为 keQing 起了别名 waifu</span>waifu = <span class="hljs-string">&quot;玉衡星&quot;</span>;cout &lt;&lt; keQing;<span class="hljs-comment">// 玉衡星</span></code></pre></div><p>上面的 waifu 就是引用，其类型是 string&amp;。</p><p>引用声明后，系统不会为其分配空间，而是让其指向被引用的地址。</p><h3 id="引用注意事项">6.2.2 引用注意事项</h3><ul><li><p>引用必须初始化</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* int&amp; temp; */</span><span class="hljs-comment">// 不可以，不可以哟</span></code></pre></div><p>引用的对象也必须完成初始化。</p></li><li><p>引用初始化后即不能改变</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> S_H_Ark = <span class="hljs-number">101</span>;<span class="hljs-type">int</span> S_H_Dark = <span class="hljs-number">101</span>;<span class="hljs-type">int</span>&amp; card = S_H_Ark;<span class="hljs-comment">/* int&amp; card = S_H_Dark; */</span><span class="hljs-comment">// 快住手，这根本不是引用</span>card = S_H_Dark;<span class="hljs-comment">// 这里是赋值操作</span></code></pre></div></li><li><p>不能声明地址的引用</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;<span class="hljs-comment">/* int&amp; nn = &amp;n; */</span><span class="hljs-comment">// 这，这不对吧</span></code></pre></div><p>不能声明宏常量的引用，也不能声明一个表达式的引用（除非表达式的结果是一个变量的引用）</p></li></ul><h3 id="引用做函数参数">6.2.3 引用做函数参数</h3><blockquote><p>传入参数时，利用引用方法让形参修饰实参。这样，可以简化指针修改实参。</p></blockquote><ul><li><p>值传递：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">met1</span> <span class="hljs-params">(<span class="hljs-type">int</span> n1)</span> </span>&#123;    n1++;&#125;</code></pre></div><blockquote><p>值传递的场合，形参是另一个局部变量。其值改变<strong>不</strong>影响原本的变量。</p></blockquote></li><li><p>地址传递：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">met2</span> <span class="hljs-params">(<span class="hljs-type">int</span>* n2)</span> </span>&#123;    (*n2)++;&#125;</code></pre></div><blockquote><p>地址传递的场合，形参即原变量的指针。其值改变<strong>会</strong>影响原本的变量。</p></blockquote></li><li><p>引用传递：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">met3</span> <span class="hljs-params">(<span class="hljs-type">int</span>&amp; n3)</span> </span>&#123;    n3++;&#125;</code></pre></div><blockquote><p>引用传递的场合，形参即原变量的引用。其值改变<strong>会</strong>影响原本的变量。</p><p>引用传递的效果和地址传递相同，但语法更简单</p></blockquote></li></ul><h3 id="引用做返回值">6.2.4 引用做返回值</h3><ul><li><p>不要返回局部变量的引用</p><p><strong><em>—— 同 <ahref="../../../../../../2022/04/02/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/6%20%E5%86%85%E5%AD%98%E5%92%8C%E5%BC%95%E7%94%A8/#6-1-2-%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%90%8E">[6.1.2栈区]</a></em></strong></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">met4</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> n = <span class="hljs-number">100</span>;    <span class="hljs-keyword">return</span> n;<span class="hljs-comment">//[1]</span>&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span>&amp; ref = <span class="hljs-built_in">met4</span>();    cout &lt;&lt; ref &lt;&lt; endl;<span class="hljs-comment">//[2]</span>    cout &lt;&lt; ref &lt;&lt; endl;<span class="hljs-comment">//[3]</span>&#125;</code></pre></div><blockquote><ol type="1"><li>返回了局部变量（的引用）</li><li>编译器保留一次</li><li>此时变量已经被释放，结果会出错</li></ol></blockquote></li><li><p><strong>如果函数的返回值是引用，则该函数调用可以作为左值</strong></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">met5</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&#123;    <span class="hljs-type">static</span> <span class="hljs-type">int</span> n = a;<span class="hljs-comment">//[1]</span>    <span class="hljs-keyword">return</span> n;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span>&amp; ref = <span class="hljs-built_in">met5</span>(<span class="hljs-number">1</span>);    cout &lt;&lt; ref &lt;&lt; endl;<span class="hljs-comment">//[2]</span>    <span class="hljs-built_in">met5</span>(<span class="hljs-number">20</span>) = <span class="hljs-number">100</span>;<span class="hljs-comment">//[3]</span>    cout &lt;&lt; ref &lt;&lt; <span class="hljs-string">&#x27;,&#x27;</span> &lt;&lt; <span class="hljs-built_in">met5</span>(<span class="hljs-number">4</span>);<span class="hljs-comment">//[4]</span>&#125;</code></pre></div><blockquote><ol type="1"><li><p>静态变量，储存在全局区。全局区数据在系统结束后被释放</p><p><strong><em>—— 全局区 见 <ahref="../../../../../../2022/04/02/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/6%20%E5%86%85%E5%AD%98%E5%92%8C%E5%BC%95%E7%94%A8/#6-1-1-%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%89%8D">[6.1.1全局区]</a></em></strong></p></li><li><p>此时输出 1</p></li><li><p><code>met5()</code> 返回值是引用，所以可以作为左值</p><p><code>met5()</code> 相当于是 <code>ref</code>变量的原名，<code>ref</code> 是别名</p><p>所以此处，<code>ref</code> 变量变为 100</p><p>经过测试，虽然 <code>met5()</code> 方法的参数改变了，但值是同一个，即100</p><p><strong><em>—— 原因 见 …… 就往下看呗 <ahref="../../../../../../2022/04/02/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/6%20%E5%86%85%E5%AD%98%E5%92%8C%E5%BC%95%E7%94%A8/#6-2-5-%E5%BC%95%E7%94%A8%E7%9A%84%E6%9C%AC%E8%B4%A8">[6.2.5引用的本质]</a></em></strong></p></li><li><p>输出：100,100</p></li></ol></blockquote></li></ul><h3 id="引用的本质">6.2.5 引用的本质</h3><blockquote><p>引用的本质在 C++ 内部实现是一个指针常量</p><p><strong><em>—— 指针常量 见 <ahref="../../../../../../2022/03/31/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/4%20%E6%8C%87%E9%92%88%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93/#4-1-3-const-%E4%BF%AE%E9%A5%B0%E6%8C%87%E9%92%88">[4.1.3.2指针常量]</a></em></strong></p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/*—&gt; —&gt; —&gt; —&gt; —&gt; —&gt; —&gt; —&gt; —&gt; 去伪存真 —&gt; —&gt; —&gt; —&gt; —&gt; —&gt; —&gt; —&gt; —&gt;*/</span><span class="hljs-comment">//</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">met3</span> <span class="hljs-params">(<span class="hljs-type">int</span>&amp; n3)</span> </span>&#123;<span class="hljs-comment">//void met3 (int* const n3) &#123;</span>    n3++;<span class="hljs-comment">//(*n3)++;</span>&#125;<span class="hljs-comment">//&#125;</span><span class="hljs-comment">//</span><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">met5</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&#123;<span class="hljs-comment">//int* met5(int a) &#123;</span>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> n = a;<span class="hljs-comment">//static int n = a;</span>    <span class="hljs-keyword">return</span> n;<span class="hljs-comment">//int* const met5 = &amp;n;</span>    <span class="hljs-comment">///* [1] */</span><span class="hljs-comment">//return met5;</span>&#125;<span class="hljs-comment">//&#125;</span><span class="hljs-comment">//</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//int main() &#123;</span>    <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<span class="hljs-comment">//int a = 0;</span>    <span class="hljs-built_in">met3</span>(a);<span class="hljs-comment">//met3(&amp;a);</span>    <span class="hljs-type">int</span>&amp; ref = <span class="hljs-built_in">met5</span>(a);<span class="hljs-comment">//int* ref = met5(a);</span>    cout &lt;&lt; ref &lt;&lt; endl;<span class="hljs-comment">//cout &lt;&lt; *ref &lt;&lt; endl;</span>    <span class="hljs-built_in">met5</span>(<span class="hljs-number">20</span>) = <span class="hljs-number">100</span>;<span class="hljs-comment">//*met5 = 100;</span>    cout &lt;&lt; ref &lt;&lt; <span class="hljs-built_in">met5</span>(<span class="hljs-number">4</span>);<span class="hljs-comment">//cout &lt;&lt; *ref &lt;&lt; *met5;</span>&#125;<span class="hljs-comment">//&#125;</span></code></pre></div><blockquote><ol type="1"><li>此处解释了 <ahref="../../../../../../2022/04/02/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/6%20%E5%86%85%E5%AD%98%E5%92%8C%E5%BC%95%E7%94%A8/#6-2-4-%E5%BC%95%E7%94%A8%E5%81%9A%E8%BF%94%E5%9B%9E%E5%80%BC">[6.2.4.3]</a>出现的参数变化的问题：指针常量的指向是不变的</li></ol></blockquote><h3 id="常量引用">6.2.6 常量引用</h3><blockquote><p>常量引用主要用来修饰形参，防止误操作</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* int&amp; n1 = 10; */</span><span class="hljs-comment">//引用必须指向合法的内存空间，而常量在常量区</span><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; n = <span class="hljs-number">10</span>;<span class="hljs-comment">//int temp = 10;</span><span class="hljs-comment">//const int&amp; n = temp;</span><span class="hljs-comment">/* n = 20 */</span><span class="hljs-comment">//此时，n 不可修改</span></code></pre></div><p>修饰形参：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; n)</span> </span>&#123;    <span class="hljs-comment">/* n = 100; */</span><span class="hljs-comment">//此时，n 不可修改</span>    cout &lt;&lt; n &lt;&lt; endl;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;C++&gt;5 项目：通讯录管理系统</title>
    <link href="/2022/04/01/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/5%20%E9%A1%B9%E7%9B%AE%EF%BC%9A%E9%80%9A%E8%AE%AF%E5%BD%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/04/01/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/5%20%E9%A1%B9%E7%9B%AE%EF%BC%9A%E9%80%9A%E8%AE%AF%E5%BD%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="项目通讯录管理系统">5 项目：通讯录管理系统</h1><p><strong>项目需求：</strong></p><ul><li>添加联系人：（序号、姓名、性别、年龄、联系电话、家庭住址）最多 1000条</li><li>显示联系人</li><li>删除联系人：按照 姓名 / 电话 / 序号 删除联系人</li><li>查找联系人</li><li>修改联系人</li><li>清空联系人</li><li>退出通讯录</li></ul><p>一些功能：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<span class="hljs-comment">//按任意键继续</span><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;cls&quot;</span>);<span class="hljs-comment">//清屏</span></code></pre></div><h2 id="附录通讯录管理系统">附录：通讯录管理系统</h2><h3 id="here.cpp">Here.cpp</h3><blockquote><p>main 方法</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;headF1.h&quot;</span><span class="hljs-comment">//自定义头文件</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">menu</span>();<span class="hljs-comment">//通讯录方法</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="headf1.h">headF1.h</h3><blockquote><p>头文件</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Data</span>;<span class="hljs-comment">//每条记录对应一个结构体变量</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Book</span>;<span class="hljs-comment">//所有记录被包含在该结构体变量中</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">menu</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//程序主方法</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showSingle</span><span class="hljs-params">(<span class="hljs-type">const</span> Data* dp)</span></span>;<span class="hljs-comment">//展示一条记录</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showMenu</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>* num)</span></span>;<span class="hljs-comment">//展示通讯录菜单</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addList</span><span class="hljs-params">(Data* dp, <span class="hljs-type">int</span>* num)</span></span>;<span class="hljs-comment">//添加一条记录</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showList</span><span class="hljs-params">(<span class="hljs-type">const</span> Data* p, <span class="hljs-type">int</span> num)</span></span>;<span class="hljs-comment">//展示全部记录</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">searchList</span><span class="hljs-params">(<span class="hljs-type">const</span> Data* dp, <span class="hljs-type">int</span> num)</span></span>;<span class="hljs-comment">//搜索记录</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">changeList</span><span class="hljs-params">(Data* dp, <span class="hljs-type">int</span> num)</span></span>;<span class="hljs-comment">//修改记录</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteSingle</span><span class="hljs-params">(Data* dp, <span class="hljs-type">int</span>* num)</span></span>;<span class="hljs-comment">//删除一条记录</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearList</span><span class="hljs-params">(Data* dp, <span class="hljs-type">int</span>* num)</span></span>;<span class="hljs-comment">//删除全部记录</span></code></pre></div><h3 id="menutool.cpp">menuTool.cpp</h3><blockquote><p>源文件</p><p>混沌！毁灭！RUA！！！</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;headF1.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_SIZE = <span class="hljs-number">1000</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Data</span> &#123;<span class="hljs-type">int</span> id = <span class="hljs-number">-1</span>;<span class="hljs-comment">//联系人 ID，该变量由系统生成，-1 的场合表示空</span>string name;<span class="hljs-comment">//联系人名</span><span class="hljs-type">char</span> gender;<span class="hljs-comment">//联系人性别</span><span class="hljs-type">int</span> age;<span class="hljs-comment">//联系人年龄</span>string call;<span class="hljs-comment">//联系人电话</span>string home;<span class="hljs-comment">//联系人住址</span>&#125;;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Book</span> &#123;<span class="hljs-comment">//保存全部联系人的结构体</span>    <span class="hljs-comment">//不如此做会导致一些问题</span>Data list[MAX_SIZE];<span class="hljs-comment">//联系人数组</span><span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<span class="hljs-comment">//已添加的联系人数量</span>&#125;book;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">menu</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> userIn;<span class="hljs-comment">//接收用户输入</span><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<span class="hljs-built_in">showMenu</span>(&amp;book.num);<span class="hljs-comment">//方法：显示菜单</span>cin &gt;&gt; userIn;<span class="hljs-keyword">switch</span> (userIn) &#123;<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:cout &lt;&lt; <span class="hljs-string">&quot;————添加联系人————&quot;</span> &lt;&lt; endl;<span class="hljs-built_in">addList</span>(book.list, &amp;book.num);<span class="hljs-comment">//方法：添加联系人</span><span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:cout &lt;&lt; <span class="hljs-string">&quot;————显示全部联系人————&quot;</span> &lt;&lt; endl;<span class="hljs-built_in">showList</span>(book.list, book.num);<span class="hljs-comment">//方法：显示通讯录</span><span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:cout &lt;&lt; <span class="hljs-string">&quot;————查找联系人————&quot;</span> &lt;&lt; endl;<span class="hljs-built_in">searchList</span>(book.list, book.num);<span class="hljs-comment">//方法：查找联系人</span><span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:cout &lt;&lt; <span class="hljs-string">&quot;————修改联系人————&quot;</span> &lt;&lt; endl;<span class="hljs-built_in">changeList</span>(book.list, book.num);<span class="hljs-comment">//方法：修改联系人</span><span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:cout &lt;&lt; <span class="hljs-string">&quot;————删除联系人————&quot;</span> &lt;&lt; endl;<span class="hljs-built_in">deleteSingle</span>(book.list, &amp;book.num);<span class="hljs-comment">//方法：删除联系人</span><span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:cout &lt;&lt; <span class="hljs-string">&quot;————清空联系人————&quot;</span> &lt;&lt; endl;<span class="hljs-built_in">clearList</span>(book.list, &amp;book.num);<span class="hljs-comment">//方法：清空联系人</span><span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:cout &lt;&lt; <span class="hljs-string">&quot;再次输入 9 退出通讯录系统：&quot;</span>;cin &gt;&gt; userIn;<span class="hljs-keyword">if</span> (userIn == <span class="hljs-number">9</span>) &#123;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<span class="hljs-comment">//添加一个暂停</span><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;cls&quot;</span>);<span class="hljs-comment">//清屏</span>&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showMenu</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> * num)</span> </span>&#123;<span class="hljs-comment">//方法：显示菜单</span>cout &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;————通讯录系统（共 &quot;</span> &lt;&lt; *num &lt;&lt; <span class="hljs-string">&quot; 条记录）————&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;\t\t1.添加联系人&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;\t\t2.显示全部联系人&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;\t\t3.查找联系人&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;\t\t4.修改联系人&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;\t\t5.删除联系人&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;\t\t6.清空联系人&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;\t\t9.退      出&quot;</span> &lt;&lt; endl;cout &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;请选择：&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showSingle</span><span class="hljs-params">(<span class="hljs-type">const</span> Data* dp)</span> </span>&#123;<span class="hljs-comment">//方法：展示单条记录</span>cout &lt;&lt; dp-&gt;id &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; dp-&gt;name &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; dp-&gt;gender &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; dp-&gt;age &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; dp-&gt;call &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; dp-&gt;home &lt;&lt; endl;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addList</span><span class="hljs-params">(Data* dp, <span class="hljs-type">int</span>* num)</span> </span>&#123;<span class="hljs-comment">//方法：添加联系人</span><span class="hljs-keyword">if</span> (*num &gt;= MAX_SIZE) &#123;cout &lt;&lt; <span class="hljs-string">&quot;通讯录已满&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-type">int</span> id = <span class="hljs-number">0</span>;<span class="hljs-comment">//准备分配 ID</span><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<span class="hljs-comment">//遍历全部通讯录位置，直到找到空位</span>++id;<span class="hljs-comment">//其实，ID 即数组下标 + 1</span><span class="hljs-keyword">if</span> (dp-&gt;id == <span class="hljs-number">-1</span>) &#123;<span class="hljs-comment">//位置 id = -1 表示该位为空位</span><span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">else</span> &#123;dp++;&#125;&#125;Data nextP;<span class="hljs-comment">//创建新的联系人，并初始化</span>cout &lt;&lt; <span class="hljs-string">&quot;请输入联系人姓名：&quot;</span>;cin &gt;&gt; nextP.name;cout &lt;&lt; <span class="hljs-string">&quot;请输入联系人性别（M/F）：&quot;</span>;cin &gt;&gt; nextP.gender;<span class="hljs-keyword">if</span> ((nextP.gender != <span class="hljs-string">&#x27;M&#x27;</span>) &amp;&amp; (nextP.gender != <span class="hljs-string">&#x27;F&#x27;</span>)) &#123;nextP.gender = <span class="hljs-string">&#x27;-&#x27;</span>;&#125;cout &lt;&lt; <span class="hljs-string">&quot;请输入联系人年龄：&quot;</span>;cin &gt;&gt; nextP.age;cout &lt;&lt; <span class="hljs-string">&quot;请输入联系人电话：&quot;</span>;cin &gt;&gt; nextP.call;cout &lt;&lt; <span class="hljs-string">&quot;请输入联系人家庭住址：&quot;</span>;cin &gt;&gt; nextP.home;nextP.id = id;*dp = nextP;<span class="hljs-comment">//在刚才确定的位置上，添加联系人</span>(*num)++;<span class="hljs-comment">//添加的联系人数量 + 1</span>&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showList</span><span class="hljs-params">(<span class="hljs-type">const</span> Data* dp, <span class="hljs-type">int</span> num)</span> </span>&#123;<span class="hljs-comment">//方法：展示通讯录</span>cout &lt;&lt; <span class="hljs-string">&quot;ID\t姓名\t性别\t年龄\t联系电话\t家庭住址&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">while</span> (num &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">if</span> (dp-&gt;id &gt;= <span class="hljs-number">0</span>) &#123;num--;<span class="hljs-built_in">showSingle</span>(dp);<span class="hljs-comment">//方法：展示单条记录</span>&#125;dp++;&#125;&#125;<span class="hljs-comment">/*——————————对了，我写啥注释啊，又没人看，溜了——————————*/</span><span class="hljs-comment">/*…………………………………………这么个破代码还看啥看…………………………………………*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">searchList</span><span class="hljs-params">(<span class="hljs-type">const</span> Data* dp, <span class="hljs-type">int</span> num)</span> </span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;请输入查找模式（1.ID；2.姓名；3.电话号码；0.取消）：&quot;</span> &lt;&lt; endl;<span class="hljs-type">int</span> user;cin &gt;&gt; user;string temp;<span class="hljs-keyword">switch</span> (user) &#123;<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:cout &lt;&lt; <span class="hljs-string">&quot;请输入要查询的 ID：&quot;</span>;cin &gt;&gt; user;<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">0</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;没有找到该联系人&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">if</span> (dp-&gt;id == <span class="hljs-number">-1</span>) &#123;<span class="hljs-keyword">continue</span>;&#125;num--;<span class="hljs-keyword">if</span> (dp-&gt;id == user) &#123;cout &lt;&lt; <span class="hljs-string">&quot;ID\t姓名\t性别\t年龄\t联系电话\t家庭住址&quot;</span> &lt;&lt; endl;<span class="hljs-built_in">showSingle</span>(dp);<span class="hljs-keyword">break</span>;&#125;dp++;&#125;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:cout &lt;&lt; <span class="hljs-string">&quot;请输入要查询的 姓名：&quot;</span>;cin &gt;&gt; temp;user = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">0</span>) &#123;cout &lt;&lt; (user == <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;没有找到该联系人&quot;</span> : <span class="hljs-string">&quot;查询完毕&quot;</span>) &lt;&lt; endl;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">if</span> (dp-&gt;id == <span class="hljs-number">-1</span>) &#123;<span class="hljs-keyword">continue</span>;&#125;num--;<span class="hljs-keyword">if</span> (dp-&gt;name == temp) &#123;cout &lt;&lt; <span class="hljs-string">&quot;ID\t姓名\t性别\t年龄\t联系电话\t家庭住址&quot;</span> &lt;&lt; endl;<span class="hljs-built_in">showSingle</span>(dp);user++;&#125;dp++;&#125;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:cout &lt;&lt; <span class="hljs-string">&quot;请输入要查询的 电话号码：&quot;</span>;cin &gt;&gt; temp;user = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">0</span>) &#123;cout &lt;&lt; (user == <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;没有找到该联系人&quot;</span> : <span class="hljs-string">&quot;查询完毕&quot;</span>) &lt;&lt; endl;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">if</span> (dp-&gt;id == <span class="hljs-number">-1</span>) &#123;<span class="hljs-keyword">continue</span>;&#125;num--;<span class="hljs-keyword">if</span> (dp-&gt;call == temp) &#123;cout &lt;&lt; <span class="hljs-string">&quot;ID\t姓名\t性别\t年龄\t联系电话\t家庭住址&quot;</span> &lt;&lt; endl;<span class="hljs-built_in">showSingle</span>(dp);user++;&#125;dp++;&#125;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">default</span>:<span class="hljs-keyword">return</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">changeList</span><span class="hljs-params">(Data* dp, <span class="hljs-type">int</span> num)</span> </span>&#123;Data* start = dp;<span class="hljs-type">int</span> num2 = num;cout &lt;&lt; <span class="hljs-string">&quot;请输入查找模式（1.ID；2.姓名；0.返回）：&quot;</span> &lt;&lt; endl;<span class="hljs-type">int</span> user;cin &gt;&gt; user;string temp;<span class="hljs-keyword">if</span> (user &gt; <span class="hljs-number">2</span> || user &lt; <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span> (user == <span class="hljs-number">2</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;请输入要查询的联系人姓名：&quot;</span>;cin &gt;&gt; temp;user = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">if</span> (user == <span class="hljs-number">0</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;没有找到该联系人&quot;</span> &lt;&lt; endl;&#125;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">if</span> (dp-&gt;id == <span class="hljs-number">-1</span>) &#123;<span class="hljs-keyword">continue</span>;&#125;num--;<span class="hljs-keyword">if</span> (dp-&gt;name == temp) &#123;cout &lt;&lt; <span class="hljs-string">&quot;ID\t姓名\t性别\t年龄\t联系电话\t家庭住址&quot;</span> &lt;&lt; endl;<span class="hljs-built_in">showSingle</span>(dp);user++;&#125;dp++;&#125;&#125;<span class="hljs-keyword">if</span> (user == <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">return</span>;&#125;dp = start;num = num2;cout &lt;&lt; <span class="hljs-string">&quot;请输入要修改的 ID：&quot;</span>;<span class="hljs-type">int</span> id;cin &gt;&gt; id;<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">0</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;没有找到该联系人&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span> (dp-&gt;id == <span class="hljs-number">-1</span>) &#123;<span class="hljs-keyword">continue</span>;&#125;num--;<span class="hljs-keyword">if</span> (dp-&gt;id == id) &#123;<span class="hljs-keyword">break</span>;&#125;dp++;&#125;<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;——————————————————————————————&quot;</span> &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">&quot;ID\t姓名\t性别\t年龄\t联系电话\t家庭住址&quot;</span> &lt;&lt; endl;<span class="hljs-built_in">showSingle</span>(dp);cout &lt;&lt; <span class="hljs-string">&quot;请输入要修改的项（1.姓名；2.性别；3.年龄；4.联系电话；5.家庭住址；0.返回）：&quot;</span>;cin &gt;&gt; user;<span class="hljs-keyword">switch</span> (user) &#123;<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:cout &lt;&lt; <span class="hljs-string">&quot;请输入姓名：&quot;</span>;cin &gt;&gt; dp-&gt;name;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:cout &lt;&lt; <span class="hljs-string">&quot;请输入性别：&quot;</span>;cin &gt;&gt; dp-&gt;gender;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:cout &lt;&lt; <span class="hljs-string">&quot;请输入年龄：&quot;</span>;cin &gt;&gt; dp-&gt;age;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:cout &lt;&lt; <span class="hljs-string">&quot;请输入联系电话：&quot;</span>;cin &gt;&gt; dp-&gt;call;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:cout &lt;&lt; <span class="hljs-string">&quot;请输入家庭住址：&quot;</span>;cin &gt;&gt; dp-&gt;home;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">default</span>:<span class="hljs-keyword">return</span>;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteSingle</span><span class="hljs-params">(Data* dp, <span class="hljs-type">int</span>* num)</span> </span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;首先查询联系人（不需要查询输入0）&quot;</span> &lt;&lt; endl;<span class="hljs-built_in">searchList</span>(dp, *num);cout &lt;&lt; <span class="hljs-string">&quot;请输入要删除的 ID（0.取消）：&quot;</span>;<span class="hljs-type">int</span> id;cin &gt;&gt; id;<span class="hljs-keyword">if</span> (id == <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (id &gt; <span class="hljs-number">1000</span> || id &lt; <span class="hljs-number">0</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;ID 错误&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-type">int</span> count = *num;<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;没有找到该联系人&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span> (dp-&gt;id == <span class="hljs-number">-1</span>) &#123;<span class="hljs-keyword">continue</span>;&#125;count--;<span class="hljs-keyword">if</span> (dp-&gt;id == id) &#123;<span class="hljs-keyword">break</span>;&#125;dp++;&#125;cout &lt;&lt; <span class="hljs-string">&quot;ID\t姓名\t性别\t年龄\t联系电话\t家庭住址&quot;</span> &lt;&lt; endl;<span class="hljs-built_in">showSingle</span>(dp);cout &lt;&lt; <span class="hljs-string">&quot;确定删除该联系人吗？（Y/N）：&quot;</span>;<span class="hljs-type">char</span> confirm;cin &gt;&gt; confirm;<span class="hljs-keyword">if</span> (confirm != <span class="hljs-string">&#x27;Y&#x27;</span> &amp;&amp; confirm != <span class="hljs-string">&#x27;y&#x27;</span>) &#123;<span class="hljs-keyword">return</span>;&#125;dp-&gt;id = <span class="hljs-number">-1</span>;(*num)--;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearList</span><span class="hljs-params">(Data* dp, <span class="hljs-type">int</span>* num)</span> </span>&#123;<span class="hljs-type">char</span> user;cout &lt;&lt; <span class="hljs-string">&quot;确定要删除全部联系人吗？（Y/N）：&quot;</span>;cin &gt;&gt; user;<span class="hljs-keyword">if</span> (user != <span class="hljs-string">&#x27;Y&#x27;</span> &amp;&amp; user != <span class="hljs-string">&#x27;y&#x27;</span>) &#123;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<span class="hljs-keyword">if</span> (*num &lt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span> (dp-&gt;id != <span class="hljs-number">-1</span>) &#123;(*num)--;dp-&gt;id = <span class="hljs-number">-1</span>;&#125;dp++;&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>程序</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;C++&gt;3 函数和数组</title>
    <link href="/2022/03/31/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/3%20%E5%87%BD%E6%95%B0%E5%92%8C%E6%95%B0%E7%BB%84/"/>
    <url>/2022/03/31/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/3%20%E5%87%BD%E6%95%B0%E5%92%8C%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="函数和数组">3 函数和数组</h1><h2 id="函数的定义和使用">3.1 函数的定义和使用</h2><blockquote><p>函数：将一段代码封装起来，提高复用率</p></blockquote><h3 id="函数的定义">3.1.1 函数的定义</h3><p>函数的定义一般有 5 个步骤：</p><ol type="1"><li><p>返回值类型：可以无返回值（void）或返回一个值</p></li><li><p>函数名</p></li><li><p>参数列表：可以无参或设置任意个参数</p><p>参数可以不加标识符，但那个场合可能无法调用参数。</p></li><li><p>函数体语句</p></li><li><p>return 表达式：无返回值的场合可以没有</p></li></ol><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><span class="hljs-comment">返回值类型 函数名 (参数列表) &#123;</span><span class="hljs-comment">    函数体语句</span><span class="hljs-comment">    return 表达式</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">repeat</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<span class="hljs-comment">// void 的场合是表示没有返回值</span>    <span class="hljs-keyword">while</span> (n-- &gt; <span class="hljs-number">0</span>) &#123;        cout &lt;&lt;             (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;耽误的时间太多，事情可就做不完了&quot;</span>              : <span class="hljs-string">&quot;劳逸结合是不错，但也不要放松过头&quot;</span>)             &lt;&lt; endl;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">repeat</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span> </span>&#123;<span class="hljs-comment">// 这样也行</span>    cout &lt;&lt; <span class="hljs-string">&quot;前面的区域，以后再来探索吧！&quot;</span> &lt;&lt; endl;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getGameID</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">100278842</span>;&#125;</code></pre></div><h3 id="函数的调用">3.1.2 函数的调用</h3><p>语法：<code>函数名(参数)</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">keQing</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">repeat</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//这就是调用啊！</span>&#125;</code></pre></div><h3 id="函数的声明">3.1.3 函数的声明</h3><blockquote><p>先告诉编译器函数名称及调用方式。之后，再对函数主体进行定义</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">chop</span><span class="hljs-params">(<span class="hljs-type">int</span> times)</span></span>;<span class="hljs-comment">//声明了该函数</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">chop</span>(<span class="hljs-number">20</span>);<span class="hljs-comment">//调用了该函数</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">chop</span><span class="hljs-params">(<span class="hljs-type">int</span> times)</span> </span>&#123;<span class="hljs-comment">//这个场合，即使定义在调用之后，也能正常运行</span>    <span class="hljs-keyword">while</span> (times-- &gt; <span class="hljs-number">0</span>) &#123;        cout &lt;&lt; <span class="hljs-string">&quot;剑光如我，斩尽芜杂！&quot;</span> &lt;&lt; endl;    &#125;&#125;</code></pre></div><p><strong>函数可以多次声明，但定义只能进行一次</strong></p><h3 id="标识符的作用域与可见性">3.1.4 标识符的作用域与可见性</h3><h4 id="函数原型作用域">函数原型作用域</h4><p>函数声明中的标识符，其作用域仅限于该声明中参数列表的括号间，在程序其他地方不能引用该标识符。因此，在函数声明时往往不写形参名，而仅写参数类型</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>;<span class="hljs-comment">// 声明时只写函数类型</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<span class="hljs-comment">// 定义时可以写形参名</span><span class="hljs-keyword">return</span> a + b;&#125;</code></pre></div><h4 id="局部作用域">局部作用域</h4><p>程序中使用大括号包裹的程序称为块。作用域局限在块内，即为局部作用域。</p><p>函数定义中，形参列表中形参的作用域即从形参声明处开始，到函数体结束为止。</p><p>函数体内声明的变量，其作用域从声明处开始，到声明所在块的大括号结束为止。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">act</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<span class="hljs-comment">// n 的作用域从此处开始，到函数结束为止</span>    <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<span class="hljs-comment">// b 的作用域从此处开始，到函数结束为止</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; b; i++) &#123;<span class="hljs-comment">// i 的作用域从此处开始，到该循环括号结束为止</span>        n += i;    &#125;    <span class="hljs-keyword">return</span> n;&#125;</code></pre></div><h4 id="类作用域">类作用域</h4><p>类可被看作是一组有名字的成员的集合。其成员具有类作用域。</p><p>在类内，如果没有声明同名的局部作用域标识符，则类作用域标识符可以直接访问。</p><p>在类外，通过表达式 <code>实例名.对象名</code> 或<code>类名::静态对象名</code> 访问。或者 <code>指针名-&gt;对象名</code>访问</p><h4 id="文件作用域">文件作用域</h4><p>文件作用域也称单文件作用域。</p><p>定义在函数和块外的标识符具有文件作用域。其作用域从定义处（声明处）开始，到整个文件结束。</p><p>文件中定义的全局变量和函数都具有文件作用域</p><h4 id="程序作用域">程序作用域</h4><p>程序作用域也叫多文件作用域。</p><p>属于程序作用域的有通过 extern 关键字修饰的外部变量和外部函数等</p><h4 id="命名空间作用域">命名空间作用域</h4><p>一个命名空间确定了命名空间作用域。凡在命名空间内的，不属于前述几个作用域的标识符，都是命名空间作用域标识符。具有命名空间作用域的变量也称为全局变量。</p><p>在命名空间内部可以直接引用当前命名空间作用域的标识符。</p><p>从其他命名空间访问的场合，使用 <code>命名空间名:: 标识符</code>的方式访问。也能使用 <code>using</code>语句启用整个命名空间或暴露空间中某特定标识符，届时就能直接访问该空间全部或部分标识符。</p><h4 id="标识符的可见性">标识符的可见性</h4><ul><li><p>标识符必须声明在前，引用在后。</p></li><li><p>在同一作用域中，不能声明同名标识符。在没有互相包含关系的不同作用域中，标识符间互不影响。</p></li><li><p>具有相互包含关系的作用域中，外层标识符在内层可见。</p><p>内层声明了标识符的场合，那些外层的同名标识符变得不可见。这种机制称为隐藏机制。</p></li></ul><h3 id="函数的分文件编写">3.1.5 函数的分文件编写</h3><blockquote><p>分文件编写，使代码结构更清晰</p></blockquote><p>一般有 4 个步骤：</p><ol type="1"><li><p>创建头文件 <code>xxx.h</code></p></li><li><p>创建源文件 <code>xxx.cpp</code></p></li><li><p>在头文件中声明函数</p><p><strong>headF1.h：</strong></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">chop</span><span class="hljs-params">(<span class="hljs-type">int</span> times)</span></span>;</code></pre></div></li><li><p>在源文件中定义函数</p><p><strong>test.cpp：</strong></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;headF1.h&quot;</span><span class="hljs-comment">//包含自定义的头文件时使用 &quot; &quot;</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">chop</span><span class="hljs-params">(<span class="hljs-type">int</span> times)</span> </span>&#123;    <span class="hljs-keyword">while</span> (times-- &gt; <span class="hljs-number">0</span>) &#123;        cout &lt;&lt; <span class="hljs-string">&quot;剑光如我，斩尽芜杂！&quot;</span> &lt;&lt; endl;    &#125;&#125;</code></pre></div></li><li><p>在 main 文件中包含该自定义头文件，并调用</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;headF1.h&quot;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">chop</span>(<span class="hljs-number">5</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div></li></ol><h3 id="默认参数">3.1.6 默认参数</h3><blockquote><p>C++ 中，函数的形参列表可以有默认值</p></blockquote><p>语法：<code>返回值 函数名(参数 = 默认值) &#123;&#125;</code></p><p><strong>注意事项：</strong></p><ol type="1"><li><p>如果某个参数有默认值，则该参数之后的所有参数也都要有默认值</p></li><li><p>如果我们传入了自己的数据，该数据会替代默认值。否则，使用默认值</p></li><li><p>如果函数声明有默认参数，则函数实现不能有默认参数。</p><p>即，该函数所有的声明和实现中，只能有一处出现默认参数。</p><p>否则，运行时报错</p></li></ol><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">met</span><span class="hljs-params">(<span class="hljs-type">int</span> n1, <span class="hljs-type">int</span> n2 = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> n3 = <span class="hljs-number">0</span>)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">met</span><span class="hljs-params">(<span class="hljs-type">int</span> n1, <span class="hljs-type">int</span> n2, <span class="hljs-type">int</span> n3)</span>；</span><span class="hljs-function">    </span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">met</span><span class="hljs-params">(<span class="hljs-type">int</span> n1, <span class="hljs-type">int</span> n2, <span class="hljs-type">int</span> n3)</span> </span>&#123;    <span class="hljs-keyword">return</span> n1 + n2 + n3;&#125;</code></pre></div><h3 id="占位参数">3.1.7 占位参数</h3><blockquote><p>C++中函数的形参列表中可以有占位参数，用来占位。调用函数时要填补该位置</p></blockquote><p>语法：<code>返回值 函数名(数据类型) &#123;&#125;</code></p><p><strong>注意事项：</strong></p><ol type="1"><li>调用函数时要填补占位参数的位置</li><li>现阶段，无法调用占位参数。但后面的学习有办法调用。</li><li>占位参数可以有默认参数。</li></ol><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> </span>&#123;    cout &lt;&lt; endl;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print10</span><span class="hljs-params">(<span class="hljs-type">int</span> = <span class="hljs-number">10</span>)</span> </span>&#123;    cout &lt;&lt; <span class="hljs-number">10</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">print10</span>();    <span class="hljs-built_in">println</span>(<span class="hljs-number">10</span>);&#125;</code></pre></div><h3 id="函数重载">3.1.8 函数重载</h3><blockquote><p>函数名相同，但参数不同，则构成重载。可以提高代码复用性</p></blockquote><p><strong>函数重载满足条件：</strong></p><ul><li>在同一作用域下</li><li>函数名相同</li><li>函数参数的 <strong>类型、个数或顺序</strong> 不同</li><li>返回值不能作为重载条件。但在构成重载的函数之间，返回值可以不同</li></ul><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">println</span><span class="hljs-params">()</span> </span>&#123;    cout &lt;&lt; endl;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;    cout &lt;&lt; n;    <span class="hljs-built_in">println</span>();&#125;</code></pre></div><h4 id="注意事项">注意事项：</h4><ul><li><p>引用作为重载条件的场合：</p><p><code>const</code> 的有无，也能作为重载的条件</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">met</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; n)</span> </span>&#123;    cout &lt;&lt; n &lt;&lt; endl;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">met</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; n)</span> </span>&#123;    cout &lt;&lt; n - <span class="hljs-number">1</span> &lt;&lt; endl;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;    <span class="hljs-built_in">met</span>(a);<span class="hljs-comment">//[1] 输出 10</span>    <span class="hljs-built_in">met</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//[2] 输出 9</span>&#125;</code></pre></div><blockquote><ol type="1"><li><p>这个场合，调用 <code>void met(int&amp; n)</code></p></li><li><p>这个场合，调用 <code>void met(const int&amp; n)</code></p><p>因为，传入的是常量，<code>int&amp; n = 10</code> 不成立而<code>const int&amp; n = 10</code> 成立</p><p><strong><em>—— 见 [6.2.6 常量引用]</em></strong></p></li></ol></blockquote></li><li><p>函数重载有默认参数的场合：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">met2</span><span class="hljs-params">(<span class="hljs-type">int</span> n1, <span class="hljs-type">int</span> n2 = <span class="hljs-number">10</span>)</span> </span>&#123;    cout &lt;&lt; n1 + n2;&#125;<span class="hljs-comment">/* void met2(int n)&#123;//出现二义性</span><span class="hljs-comment">      cout &lt;&lt; n1;</span><span class="hljs-comment">   &#125; */</span></code></pre></div><p>这个场合，默认参数本身相当于某种重载，再使用重载时，可能出现二义性</p></li></ul><h3 id="内联函数">3.1.9 内联函数</h3><p>在程序中使用函数的目的之一是增加代码复用率，提高程序的开发效率和可维护性</p><p>调用函数时，需要保存主调函数的现场和返回地址，在栈中为形参和局部变量分配存储空间，实现实参与形参的参数传递，再将程序转移到被调用函数的起始地址继续执行。执行结束后，要回收占用的存储空间，恢复主调函数的现场，取出返回地址，将返回值赋给函数调用本身，再返回地址开始处继续执行。</p><p>调用函数时会产生上述时间、空间开销。当函数体较简单，并被频繁调用时，上述开销会影响程序的性能。</p><p>为避免这种情况，C++ 引入了内联函数的概念。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">inline</span> 返回值类型 函数名(参数列表) &#123;    ...&#125;</code></pre></div><p>使用内联函数时，编译器在<strong>编译时</strong>不产生函数调用，而是将程序中出现的每一个内联函数的调用表达式直接用其函数体替换。使用内联函数会让最终可执行程序的体积变大，是一种空间换时间的方式。</p><p>代码量较大的函数通常不定义为内联函数，因为其代码增加对时空效率的不利影响很可能超过了内联函数的速度改善。</p><p><strong>加入 inline关键字并不能保证函数成为内联函数。</strong>该关键字只是提示编译器，程序员希望该函数成为内联函数。但编译器可能根据其自身处理方式忽略这一提示，而生成函数调用。</p><h2 id="数组">3.2 数组</h2><blockquote><p>数组：一个相同类型元素的集合</p></blockquote><p>特点：</p><ul><li><p>数组中每个元素都是<strong>相同的数据类型</strong></p></li><li><p>数组是由<strong>连续的内存位置</strong>组成的</p></li></ul><h3 id="一维数组">3.2.1 一维数组</h3><p>三种定义方式：</p><ul><li><p><code>数据类型 数组名[数组长度];</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr1[<span class="hljs-number">10</span>];</code></pre></div></li><li><p><code>数据类型 数组名[数组长度] = &#123;值1, 值2, ...&#125;;</code></p><div class="code-wrapper"><pre><code class="hljs c++">string strs[<span class="hljs-number">4</span>] = &#123;<span class="hljs-string">&quot;make&quot;</span>, <span class="hljs-string">&quot;Poland&quot;</span>, <span class="hljs-string">&quot;disapper&quot;</span>, <span class="hljs-string">&quot;again&quot;</span>&#125;;</code></pre></div></li><li><p><code>数据类型 数组名[] = &#123;值1, 值2, ...&#125;;</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">char</span> waifu[] = &#123;<span class="hljs-string">&#x27;k&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;q&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>&#125;;</code></pre></div></li></ul><h4 id="动态内存分配">动态内存分配：</h4><p>数组的长度是声明时决定的。C++中，不允许定义元素个数不确定的数组（不允许变量作为数组长度）</p><p>C++语言提供了一种动态内存分配的机制。程序运行期间，根据实际需要，临时分配一段内存空间用以存储数据。这种分配是程序运行期间进行的，故而称为<strong>动态内存分配</strong>。</p><p>使用 new 运算符实现动态内存分配，以分配任意大小的数组</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n = <span class="hljs-number">15</span>;<span class="hljs-type">int</span>* array = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n];</code></pre></div><p><strong><em>——见 [4.1 指针]</em></strong></p><h4 id="数组名用途">数组名用途：</h4><ul><li><p>统计整个数组在内存中的长度</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> all = <span class="hljs-built_in">sizeof</span>(waife);<span class="hljs-comment">//[1]</span><span class="hljs-type">int</span> signal = <span class="hljs-built_in">sizeof</span>(strs[<span class="hljs-number">0</span>]);<span class="hljs-comment">//[2]</span><span class="hljs-type">int</span> num = <span class="hljs-built_in">sizeof</span>(strs) / <span class="hljs-built_in">sizeof</span>(strs[<span class="hljs-number">0</span>]);<span class="hljs-comment">//[3]</span></code></pre></div><ol type="1"><li>整个数组占用的内存空间</li><li>单个元素占用的内存空间</li><li>数组的元素个数</li></ol></li><li><p>获取数组在内存中的首地址</p><div class="code-wrapper"><pre><code class="hljs c++">cout &lt;&lt; waifu;<span class="hljs-comment">//[1]</span>cout &lt;&lt; (<span class="hljs-type">int</span>)waifu;<span class="hljs-comment">//[2]</span>cout &lt;&lt; &amp;waifu[<span class="hljs-number">0</span>];<span class="hljs-comment">//[3]</span></code></pre></div><ol type="1"><li><p>数组首地址（16 进制），该地址即首元素的首地址</p></li><li><p>数组首地址（10 进制）</p></li><li><p>某元素的首地址</p><p><code>&amp;</code> 是一个取址符</p></li></ol></li></ul><p>数组名是常量，不可以进行赋值操作</p><h3 id="二维数组">3.2.2 二维数组</h3><p>四种定义方式：</p><ul><li><p><code>数据类型 数组名[行数][列数];</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">char</span> chess[<span class="hljs-number">8</span>][<span class="hljs-number">8</span>];</code></pre></div></li><li><p>`数据类型 数组名[行数][列数] =</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;C++&gt;4 指针和结构体</title>
    <link href="/2022/03/31/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/4%20%E6%8C%87%E9%92%88%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <url>/2022/03/31/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/4%20%E6%8C%87%E9%92%88%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<h1 id="指针和结构体">4 指针和结构体</h1><h2 id="指针">4.1 指针</h2><blockquote><p>指针的作用：可以通过指针间接访问内存</p></blockquote><ul><li>内存编号是从 0 开始记录的。一般用十六进制数字表示</li><li>可以用指针变量保存地址</li></ul><h3 id="指针的定义和使用">4.1.1 指针的定义和使用</h3><p>语法：</p><ul><li>声明指针：<code>数据类型 * 指针变量名</code></li><li>记录地址：<code>指针变量名 = &amp;变量名</code></li><li>使用指针：<code>*指针变量名</code></li></ul><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> var = <span class="hljs-number">10</span>;<span class="hljs-comment">//这是某个变量</span><span class="hljs-type">int</span> * p;<span class="hljs-comment">//声明了指针 p</span>p = &amp;var;<span class="hljs-comment">//让 p 记录 var 的地址。&amp; 是一个取址符</span>*p = <span class="hljs-number">5</span>;<span class="hljs-comment">//*p 即通过 p 的地址找到其引用的变量</span><span class="hljs-comment">//这个场合，var 的数值改变了</span></code></pre></div><p><strong>指针所占内存空间：</strong></p><ul><li><p>32 位操作系统（x86）：4 字节（任何类型）</p></li><li><p>64 位操作系统（x64）：8 字节（任何类型）</p></li></ul><h3 id="空指针和野指针">4.1.2 空指针和野指针</h3><blockquote><p>空指针：指针变量指向内存中编号为 0的空间。空指针指向的内存不能被访问。</p><p>可以用空指针初始化指针变量。</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">char</span> * p;<span class="hljs-type">char</span> a = <span class="hljs-string">&#x27;a&#x27;</span>;p = &amp;a;p = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//此时 p 成为空指针</span></code></pre></div><blockquote><p>野指针：指针变量指向非法的内存空间</p></blockquote><h3 id="const-修饰指针">4.1.3 const 修饰指针</h3><p>const 修饰指针有三种情况：</p><ol type="1"><li><p>const修饰指针（常量指针）：<code>const 数据类型 * 指针名</code></p><blockquote><p>常量指针：指针的 <strong>指向</strong> 可以修改，但指针<strong>指向的值</strong> 不能修改</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">double</span> d = <span class="hljs-number">1.5</span>;<span class="hljs-type">const</span> <span class="hljs-type">double</span> * dp = &amp;d;<span class="hljs-comment">//常量指针</span><span class="hljs-type">double</span> d2 = <span class="hljs-number">3.5</span>;dp = &amp;d2;<span class="hljs-comment">//指针的指向可以修改</span><span class="hljs-comment">/*dp = 2.5;这个不行*/</span><span class="hljs-comment">//指针指向的值不能修改</span></code></pre></div></li><li><p>const修饰常量（指针常量）：<code>数据类型 * const 指针名</code></p><blockquote><p>指针常量：指针 <strong>指向的值</strong> 可以修改，但指针的<strong>指向</strong> 不能修改</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">10</span>;<span class="hljs-type">int</span> * <span class="hljs-type">const</span> ip = &amp;i;<span class="hljs-comment">//指针常量</span>*ip = <span class="hljs-number">15</span>;<span class="hljs-comment">//指针指向的值可以修改</span><span class="hljs-type">int</span> n = <span class="hljs-number">25</span>;<span class="hljs-comment">/*ip = &amp;n;这个不行*/</span><span class="hljs-comment">//指针的指向不能修改</span></code></pre></div></li><li><p>const既修饰指针，又修饰常量：<code>const 数据类型 * const 指针名</code></p><blockquote><p>那就，都不能改呗</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;\n&#x27;</span>;<span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> cp = &amp;c;</code></pre></div></li></ol><h3 id="指针和数组">4.1.4 指针和数组</h3><blockquote><p>可以利用指针访问数组的元素</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">char</span> waifusWish[] = &#123; <span class="hljs-string">&#x27;雾&#x27;</span>, <span class="hljs-string">&#x27;切&#x27;</span>, <span class="hljs-string">&#x27;之&#x27;</span>, <span class="hljs-string">&#x27;回&#x27;</span>, <span class="hljs-string">&#x27;光&#x27;</span>&#125;;<span class="hljs-type">char</span> * p = waifuWish;<span class="hljs-comment">//[1]</span><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">sizeof</span>(waifuWish) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>); i++) &#123;    cout &lt;&lt; *p++;<span class="hljs-comment">//[2]</span>&#125;</code></pre></div><ol type="1"><li><p>指针指向数组首地址。</p><p><strong><em>——见 <ahref="../../../../../../2022/03/31/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/3%20%E5%87%BD%E6%95%B0%E5%92%8C%E6%95%B0%E7%BB%84/#3-2-1-1-%E6%95%B0%E7%BB%84%E5%90%8D">[3.2.1.1数组名]</a></em></strong></p></li><li><p>通过指针访问数组元素</p><p>由于数组的空间是连续的，指针自增时，会来到下一个元素的位置</p></li></ol><h3 id="指针和函数">4.1.5 指针和函数</h3><blockquote><p>利用指针作为函数参数，可以修改实参的值</p></blockquote><p>地址传递：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> * a; <span class="hljs-type">int</span> * b)</span></span>;<span class="hljs-comment">//用两个指针接收两个地址</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> n1 = <span class="hljs-number">10</span>;    <span class="hljs-type">int</span> n2 = <span class="hljs-number">100</span>;    <span class="hljs-built_in">swap</span>(&amp;n1; &amp;n2);<span class="hljs-comment">//参数中写入地址</span>&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> * a; <span class="hljs-type">int</span> * b)</span> </span>&#123;<span class="hljs-comment">//这个场合，修改了实参的值</span>    <span class="hljs-type">int</span> temp = *a;    *a = *b;    *b = temp;&#125;</code></pre></div><h3 id="指针数组和函数">4.1.6 指针、数组和函数</h3><p>示意一个冒泡排序：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span>* b)</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>* arr, <span class="hljs-type">int</span> len)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>&#125;;    <span class="hljs-type">int</span> len = <span class="hljs-built_in">sizeof</span>(arr) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>);    <span class="hljs-built_in">bubbleSort</span>(arr, len);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span>* b)</span> </span>&#123;    <span class="hljs-type">int</span> temp = *a;    *a = *b;    *b = temp;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>* arr, <span class="hljs-type">int</span> len)</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; len - <span class="hljs-number">1</span>; k++) &#123;            <span class="hljs-keyword">if</span> (*(arr + k) &gt; *(arr + k + <span class="hljs-number">1</span>)) &#123;                <span class="hljs-built_in">swap</span>(arr + k, arr + k + <span class="hljs-number">1</span>);            &#125;        &#125;    &#125;&#125;</code></pre></div><h2 id="结构体">4.2 结构体</h2><blockquote><p>结构体属于用户自定义的数据类型，允许用户存储不同的数据类型</p></blockquote><h3 id="结构体的定义">4.2.1 结构体的定义</h3><p>语法：<code>struct 结构体名 &#123;结构体成员列表&#125;;</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Character</span> &#123;    <span class="hljs-type">int</span> life;    <span class="hljs-type">int</span> atk;    <span class="hljs-type">int</span> prof;    <span class="hljs-type">double</span> crit;    <span class="hljs-type">double</span> crid;&#125;;</code></pre></div><p><strong>结构体的成员可以是另一个结构体</strong></p><h3 id="创建结构体变量">4.2.2 创建结构体变量</h3><p>通过结构体创建变量的方式有三种：</p><ul><li><p><code>struct 结构体名 变量名;</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    Character keqing;<span class="hljs-comment">//这个场合，struct 关键字可以省略</span>    keqing.life = <span class="hljs-number">18716</span>;    keqing.prof = <span class="hljs-number">61</span>;    keqing.atk = <span class="hljs-number">2328</span>;    keqing.crit = <span class="hljs-number">74.4</span>;    keqing.crid = <span class="hljs-number">168.5</span>;    ...&#125;</code></pre></div></li><li><p><code>struct 结构体名 变量名 = &#123;成员1值, 成员2值...&#125;;</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Character</span> ganyu = &#123;<span class="hljs-number">14577</span>, <span class="hljs-number">2474</span>, <span class="hljs-number">176</span>, <span class="hljs-number">72.7</span>, <span class="hljs-number">166.9</span>&#125;;    <span class="hljs-comment">//这里，struct 关键字也可以省略</span>    ...&#125;</code></pre></div></li><li><p>定义结构体时顺便创建变量</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Character</span> &#123;    <span class="hljs-type">int</span> life;    <span class="hljs-type">int</span> atk;    <span class="hljs-type">int</span> prof;    <span class="hljs-type">double</span> crit;    <span class="hljs-type">double</span> crid;&#125;hutao;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    hutao.lif = <span class="hljs-number">34641</span>;    hutao.atk = <span class="hljs-number">1059</span>;    hutao.prof = <span class="hljs-number">82</span>;    hutao.crit = <span class="hljs-number">73.0</span>;    hutao.crid = <span class="hljs-number">212.1</span>;&#125;</code></pre></div></li></ul><h3 id="结构体指针">4.2.3 结构体指针</h3><blockquote><p>通过指针访问结构体成员</p><p>操作符 <code>-&gt;</code> 可以实现通过指针访问结构中的属性</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S1</span> &#123;    <span class="hljs-type">int</span> n1;    <span class="hljs-type">int</span> n2;&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    S1 arr[] = &#123; &#123;<span class="hljs-number">0</span>, <span class="hljs-number">10</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">11</span>&#125; &#125;;<span class="hljs-comment">//[1]</span>    S1* p = arr;<span class="hljs-comment">//[2]</span>    p-&gt;n1 = <span class="hljs-number">-50</span>;<span class="hljs-comment">//[3]</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><ol type="1"><li>一个结构体数组</li><li>这里，p 相当于指向 arr[0] 的地址</li><li>这个场合，arr[0].n1 改变了</li></ol><h3 id="结构体做函数参数">4.2.4 结构体做函数参数</h3><p>不写了，就一点：值传递不影响原变量、地址传递影响原变量</p><h3 id="const-修饰结构体">4.2.5 const 修饰结构体</h3><blockquote><p>用 const 防止误操作</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">St</span> &#123;    <span class="hljs-type">int</span> n;    <span class="hljs-type">char</span> c;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> St * p)</span></span>;<span class="hljs-comment">//[1]</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    St str = &#123;<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;i&#x27;</span>&#125;;    <span class="hljs-built_in">print</span>(&amp;str);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> St * p)</span> </span>&#123;    cout &lt;&lt; p-&gt;n &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; p-&gt;c &lt;&lt; endl;    <span class="hljs-comment">/* *p-&gt;n = 100; 因为加了 const，这个会报错*/</span>&#125;</code></pre></div><ol type="1"><li><p>用 const 保证该指针值不会被修改</p><p><strong><em>——见 <ahref="../../../../../../2022/03/31/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/4%20%E6%8C%87%E9%92%88%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93/#4-1-3-const-%E4%BF%AE%E9%A5%B0%E6%8C%87%E9%92%88">[4.1.3.1常量指针]</a></em></strong></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;C++&gt;1 C++ 基础知识</title>
    <link href="/2022/03/28/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/1%20C++%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/03/28/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/1%20C++%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="c-基础知识">1 C++ 基础知识</h1><blockquote><p>根据是否可以操作计算机底层硬件，将程序设计语言分为：低级语言、中级语言、高级语言。</p><p>机器语言和汇编语言属于低级语言，因为它们能直接操作计算机的寄存器和内存。</p><p>高级语言是面向用户的语言。很多语言在形式上接近算术语言和自然语言，程序员编写方便。使用高级语言编写的程序易读且通用性强，但大部分不能直接接触硬件，也不能直接在计算机上执行。C++语言就属于高级语言的范畴。</p><p>C++既有高级语言的形式，也能在一定程度上以特定方式直接操作硬件。有些观点也将C++ 划分到中级语言一类。</p><p>C 语言是 C++ 的前身。可以认为 C++ 语言是 C 语言的超集。标准的 C程序也能在 C++ 开发环境下运行。</p></blockquote><p>前置操作：配置 <ahref="https://visualstudio.microsoft.com/zh-hans/">Visual Studio</a></p><p><ahref="https://www.bilibili.com/video/BV1gb411Y7Yh?share_source=copy_web">配置教程</a></p><p>示范一个简单的 C++ 代码</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;Melody is learning c++&quot;</span> &lt;&lt; endl;<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="注释">1.1 注释</h2><blockquote><p>在代码中添加的说明和解释，用以增强代码可读性</p></blockquote><ul><li><p>单行注释：</p><div class="code-wrapper"><pre><code class="hljs c++">...<span class="hljs-comment">//单行注释</span></code></pre></div></li><li><p>多行注释：</p><div class="code-wrapper"><pre><code class="hljs c++">...<span class="hljs-comment">/*多行注释*/</span></code></pre></div></li></ul><h2 id="标识符">1.2 标识符</h2><h3 id="变量">1.2.1 变量</h3><blockquote><p>命名一段指定的数据空间，以便后续调用</p></blockquote><p>语法：<code>数据类型 变量名 = 初始值</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//数据类型 变量名 = 初始值;</span><span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;</code></pre></div><h3 id="常量">1.2.2 常量</h3><blockquote><p>常量用于记录程序中不可修改的数据</p></blockquote><p>C++ 中对常量有两种定义方式：</p><ul><li>#define 宏常量：<code>#define 常量名 常量值</code></li><li>const 修饰的变量：<code>const 数据类型 常量名 = 常量值</code></li></ul><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-comment">//声明一个宏常量。宏常量通常放在文件上方</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> num 7</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//声明一个 const 修饰的变量</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> n = <span class="hljs-number">100</span>;    cout &lt;&lt; n + num &lt;&lt; endl;<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<span class="hljs-keyword">return</span> num;&#125;</code></pre></div><h3 id="关键字">1.2.3 关键字</h3><blockquote><p>C++中预先保留的单词（标识符）。这些单词不能被用于定义变量名或常量名。</p></blockquote><p>具体有哪些？略……</p><h3 id="标识符命名规则">1.2.4 标识符命名规则</h3><ol type="1"><li>标识符名称不能是关键字</li><li>标识符名称只能由<strong>字母</strong>、<strong>数字</strong>、<strong>下划线</strong>组成</li><li>第一个字符必须是 字母或下划线（即，不能以数字开头）</li><li>表示符中字母区分大小写</li><li>在相同作用域内，标识符不能重复进行定义。</li></ol><h2 id="数据类型">1.3 数据类型</h2><blockquote><p>C++ 中创建变量或常量时，必须指定相应的数据类型</p></blockquote><h3 id="整形">1.3.1 整形</h3><blockquote><p>整数类型的数据</p></blockquote><p>C++ 中的整形有以下几种，其取值范围与所占空间不同</p><table style="width:100%;"><thead><tr class="header"><th>数据类型</th><th>占用空间</th><th>表示范围</th></tr></thead><tbody><tr class="odd"><td>short</td><td>2 字节</td><td>-2<sup>15</sup> ~ 2<sup>15</sup> - 1</td></tr><tr class="even"><td>int</td><td>4 字节</td><td>-2<sup>31</sup> ~ 2<sup>31</sup> - 1</td></tr><tr class="odd"><td>long</td><td>4 字节（Windows、32 位 Linux）或 8 字节（64 位 Linux）</td><td>-2<sup>31</sup> ~ 2<sup>31</sup> - 1</td></tr><tr class="even"><td>long long</td><td>8 字节</td><td>-2<sup>63</sup> ~ 2<sup>63</sup> - 1</td></tr></tbody></table><p>语法：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<span class="hljs-type">long</span> l = <span class="hljs-number">0</span>;<span class="hljs-type">long</span> <span class="hljs-type">long</span> ll = <span class="hljs-number">0</span>;</code></pre></div><h3 id="实型浮点型">1.3.2 实型（浮点型）</h3><blockquote><p>用于表示小数</p></blockquote><p>有以下几种：</p><table><thead><tr class="header"><th>数据类型</th><th>占用空间</th><th>表示范围</th></tr></thead><tbody><tr class="odd"><td>float</td><td>4 字节</td><td>7 位有效数字</td></tr><tr class="even"><td>double</td><td>8 字节</td><td>15 ~ 16 位有效数字</td></tr></tbody></table><p>语法：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">float</span> f = <span class="hljs-number">3.14f</span>;<span class="hljs-comment">//这里和 Java 相同，float 需要加上 f</span><span class="hljs-type">double</span> d = <span class="hljs-number">3.14</span>;<span class="hljs-type">float</span> f2 = <span class="hljs-number">3e3</span>;<span class="hljs-comment">//科学计数法。3e3 == 3 * 10 ^ 3</span><span class="hljs-type">double</span> d2 = <span class="hljs-number">3e-10</span>;<span class="hljs-comment">//科学计数法。3e-10 == 3 * 10 ^ -10</span></code></pre></div><h3 id="字符型">1.3.3 字符型</h3><blockquote><p>用于显示单个字符，占用 1 字节</p></blockquote><p>存放时，存放的是字符对应的 ASCII 编码</p><p>几个重要的 ASCII 码：</p><ul><li>a：97</li><li>A：65</li><li>0：48</li></ul><p>经测试，C++ 中的 char 也可以作为数字进行运算</p><p>语法：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>;<span class="hljs-type">char</span> c1 = <span class="hljs-number">99</span>;<span class="hljs-comment">//这个场合，c1 是 &#x27;c&#x27;</span><span class="hljs-type">char</span> c2 = <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">9</span>;<span class="hljs-comment">//这个场合，c2 是 &#x27;j&#x27;</span><span class="hljs-type">int</span> n = c2 - <span class="hljs-number">16</span>;<span class="hljs-comment">//这个场合，n 是 90</span></code></pre></div><h4 id="转义字符">1.3.3.1 转义字符</h4><blockquote><p>用于表示一些不能显示出来的 ASCII 字符</p></blockquote><table><thead><tr class="header"><th>转义字符</th><th>含义</th></tr></thead><tbody><tr class="odd"><td><code>\a</code></td><td>警报</td></tr><tr class="even"><td><code>\b</code></td><td>退格，将当前位置前移一列</td></tr><tr class="odd"><td><code>\f</code></td><td>换页，将当前位置移到下页开头</td></tr><tr class="even"><td><code>\n</code></td><td>换行，将当前位置移到下一行开头</td></tr><tr class="odd"><td><code>\r</code></td><td>回车，将当前位置移到本行开头</td></tr><tr class="even"><td><code>\t</code></td><td>水平制表</td></tr><tr class="odd"><td><code>\v</code></td><td>垂直制表</td></tr><tr class="even"><td><code>\\</code></td><td>一个反斜线 <code>\</code></td></tr><tr class="odd"><td><code>\'</code></td><td>一个单引号 <code>‘</code></td></tr><tr class="even"><td><code>\?</code></td><td>一个问号 <code>?</code></td></tr></tbody></table><h3 id="字符串型">1.3.4 字符串型</h3><blockquote><p>用于表示一串字符</p></blockquote><p>两种风格：</p><ul><li><p>C 风格字符串：<code>char 变量名[] = "字符串值";</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">char</span> str1[] = <span class="hljs-string">&quot;字符串1&quot;</span>;<span class="hljs-comment">//注意不能这样写：char[] str2 = &quot;..&quot;;</span></code></pre></div></li><li><p>C++ 风格字符串：<code>string 变量名 = "字符串值";</code></p><p>使用前需要包含 string 的头文件</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>...string str2 = <span class="hljs-string">&quot;字符串2&quot;</span>;</code></pre></div></li></ul><h3 id="布尔类型">1.3.5 布尔类型</h3><blockquote><p>bool 代表真或假的值，占用 1 字节</p></blockquote><p>bool 类型只有两个值：</p><ul><li>true —— 真（本质是1）</li><li>false —— 假（本质是0）</li></ul><p><strong>布尔类型中，只要是非 0，就代表真</strong></p><p>语法：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">bool</span> b = <span class="hljs-literal">true</span>;cout &lt;&lt; b &lt;&lt; endl;<span class="hljs-comment">//此处输出 1</span></code></pre></div><h3 id="sizeof-关键字">1.3.6 sizeof 关键字</h3><blockquote><p>该关键字可以统计数据类型所占内存的大小</p></blockquote><p>语法：<code>sizeof(数据类型/常量)</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> num 7</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> n = <span class="hljs-number">100</span>;<span class="hljs-type">int</span> n2 = <span class="hljs-number">0</span>;    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(num) &lt;&lt; endl;<span class="hljs-comment">//输出 4</span>cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(n) &lt;&lt; endl;<span class="hljs-comment">//输出 8</span>cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(n2) &lt;&lt; endl;<span class="hljs-comment">//输出 4</span>cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(n2 + num + n) &lt;&lt; endl;<span class="hljs-comment">//输出 8</span>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">short</span>) &lt;&lt; endl;<span class="hljs-comment">//输出 2</span>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<span class="hljs-keyword">return</span> num;&#125;</code></pre></div><h2 id="运算符">1.4 运算符</h2><blockquote><p>用于执行代码的运算</p></blockquote><p>这里主要介绍以下四种：</p><ul><li>算术运算符：处理四则运算</li><li>赋值运算符：用于将表达式的值赋给变量</li><li>比较运算符：用于表达式的比较，返回布尔值</li><li>逻辑运算符：根据表达式的值返回布尔值</li></ul><h3 id="算术运算符">1.4.1 算术运算符</h3><blockquote><p>处理四则运算</p></blockquote><ul><li><p><code>+</code>：正号、相加（+3、3 + 2）</p></li><li><p><code>-</code>：负号、相减</p></li><li><p><code>*</code>：乘</p></li><li><p><code>/</code>：除</p></li><li><p><code>%</code>：取模（10 % 3）</p><p>两个小数间不能进行取模运算</p></li><li><p><code>++</code>：递增（a++、++a）</p><p><code>++a</code> 即前置递增、<code>a++</code> 即后置递增。</p><p>前置递增先递增，后运算表达式；后置递增先运算表达式，后递增。</p></li><li><p><code>--</code>：递减</p></li></ul><h3 id="赋值运算符">1.4.2 赋值运算符</h3><blockquote><p>用于把表达式的值赋给变量</p></blockquote><ul><li><p><code>=</code>：赋值</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> a1, a2, a3;a1 = a2 = a3 = <span class="hljs-number">1</span>;<span class="hljs-comment">//这样写也是可以的</span></code></pre></div></li><li><p><code>+=</code>：加等于</p><p><code>a += 2</code> 即 <code>a = a + 2</code></p><p><code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code>同理</p></li></ul><h3 id="比较运算符">1.4.3 比较运算符</h3><blockquote><p>用于表达式的比较</p></blockquote><ul><li><code>==</code>：相当于</li><li><code>!=</code>：不等于</li><li><code>&lt;</code>：小于</li><li><code>&gt;</code> ：大于</li><li><code>&gt;=</code>：大于等于</li><li><code>&lt;=</code>：小于等于</li></ul><h3 id="逻辑运算符">1.4.4 逻辑运算符</h3><ul><li><code>!</code>：非</li><li><code>&amp;&amp;</code>：与（只要有一个为假即为假）</li><li><code>||</code>：或（只要有一个为真即为真）</li></ul><h3 id="强制类型转换运算符">1.4.5 强制类型转换运算符</h3><p>当不同类型的量进行混合算术运算时，系统会自动进行合理的类型转换。也能在程序中使用强制类型转换符进行转换。</p><ul><li><p><code>static_cast&lt;类型&gt;(表达式)</code>：用于将一种数据类型转换成另一种数据类型</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">double</span> d = <span class="hljs-number">3.2</span>;<span class="hljs-type">double</span> n = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(d * <span class="hljs-number">2</span>);</code></pre></div></li><li><p><code>const_cast&lt;类型&gt;(表达式)</code>：用于去除指针和引用的常量性。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-type">const</span> n = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">// 常量指针常量</span><span class="hljs-type">int</span>* i = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(n);*i += <span class="hljs-number">1</span>;cout &lt;&lt; *n &lt;&lt; endl;<span class="hljs-comment">// 3</span>cout &lt;&lt; *i &lt;&lt; endl;<span class="hljs-comment">// 3</span></code></pre></div><p><strong><em>——见 [4.1 指针]</em></strong></p><p>将常量指针转化为非常量指针，且仍指向原来的对象。</p><p>或者，将常量引用转化为非常量引用，且仍指向原来的对象。</p><p>特别地，<strong>该运算符不能去除变量的常量性</strong>：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;<span class="hljs-comment">// 常量</span><span class="hljs-type">int</span>* a = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(&amp;n);*a += <span class="hljs-number">5</span>;cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; *a &lt;&lt; endl;<span class="hljs-comment">// 000000BBFCEFF7D415</span>cout &lt;&lt; &amp;n &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; n &lt;&lt; endl;<span class="hljs-comment">// 000000BBFCEFF7D410</span></code></pre></div><blockquote><p>出现了地址相同，但值不同的奇观！</p></blockquote></li></ul><h2 id="数据的输入与输出">1.5 数据的输入与输出</h2><p>在 C++ 中，类库中提供了输入流类 istream 和输出流类 ostream。</p><p>cin 和 cout 分别是 istream 类对象和 ostream类对象。用来实现键盘输入和屏幕输出。</p><p>从输入流中获取数据的操作称为提取操作。向输出流中添加数据的操作称为插入操作。</p><p>运算符 <code>&gt;&gt;</code> 和 <code>&lt;&lt;</code>是移位操作符。但 C++ 类库的头文件中对其进行了重载，使其分别作为<strong>流提取运算符</strong> 和 <strong>流插入运算符</strong>。</p><p>当程序中用到 cin 和 cout 时，需要在程序中包含头文件&lt;iostream&gt;</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span></code></pre></div><h4 id="数据的输入">数据的输入：</h4><p>可以使用流提取运算符从键盘输入数据并赋值：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> x;<span class="hljs-type">int</span> y;cin &gt;&gt; x &gt;&gt; y;</code></pre></div><p>cin中的变量可以是任意基本类型的变量。连续从键盘读取数据时，以空格、制表符或换行为分隔符。</p><p>当读取数据时，cin会忽略并清除第一个空格、制表符或换行符，继续读取下一个字符。这意味着不能将空格、制表符会换行符输入给字符变量。如有需要，应使用getchar() 函数</p><p>使用 cin输入时，如果输入的是字符类型，则系统会根据变量类型从输入流中提取相应长度的字节。如果输入的是数值类型，需要用空格、制表符或换行符将各个数值分开</p><p>字符串可以是字符数组 char[]，也能是 string 对象。</p><h4 id="数据的输出">数据的输出：</h4><p>cout 是一个标准输出对象。使用流插入运算符向屏幕设备输出信息：</p><div class="code-wrapper"><pre><code class="hljs c++">cout &lt;&lt; <span class="hljs-string">&quot;☆&quot;</span> &lt;&lt; <span class="hljs-string">&quot;★&quot;</span>;</code></pre></div><p>cout语句中的表达式可以是各种基本类型的变量、常量，及由变量和常量组合得到的正确表达式。</p><p>在输出时，字符串过长的场合，添加符号 <code>\</code>就能将字符串分为多行</p><div class="code-wrapper"><pre><code class="hljs c++">cout &lt;&lt; <span class="hljs-string">&quot;这是一个不那么长，\</span><span class="hljs-string">但我们可以想象它很长的字符串。&quot;</span>;</code></pre></div><p>其实咱不妨就把上面的字符串分为两段输出</p><div class="code-wrapper"><pre><code class="hljs c++">cout &lt;&lt; <span class="hljs-string">&quot;这是一个不那么长，&quot;</span>     &lt;&lt; <span class="hljs-string">&quot;但我们可以想象它很长的字符串。&quot;</span>;</code></pre></div><h2 id="头文件和命名空间">1.6 头文件和命名空间</h2><h4 id="头文件">头文件：</h4><p>C++ 中使用头文件保存程序中用到的声明，如函数声明、常量定义等。</p><p>需要先用 <code>#include</code>语句包含头文件，进而使用该头文件包含的内容</p><p>每条 <code>#include</code>语句仅能包含一个头文件。要包含多个头文件时，要使用多条语句</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span><span class="hljs-comment">// 包含标准输入输出流</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span><span class="hljs-comment">// 包含 string 字符串类</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span><span class="hljs-comment">// 包含标准数学函数</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;myh.h&quot;</span><span class="hljs-comment">// 包含了一个自定义的头文件 myh.h</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;d:\temp\myh.h&quot;</span><span class="hljs-comment">// 包含了 d:\temp\ 目录下的一个自定义的头文件 myh.h</span></span></code></pre></div><p>使用尖括号 <code>&lt; &gt;</code> 时，C++ 编译器首先在 C++系统设定的目录中寻找要包含的头文件。没有找到时，再去指令指定的目录去找。</p><p>使用双引号 <code>“ ”</code> 时，C++编译器在用户当前目录下或指令指定的目录下寻找头文件。</p><h4 id="命名空间">命名空间：</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-comment">// 使用命名空间 std</span></code></pre></div><p>一个大型程序通常由不同模块组成。各个模块间的标识符可能重名。为避免命名冲突，C++引入了命名空间的概念。</p><p>定义一个命名空间的语法如下：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> 空间名 &#123;    ...&#125;</code></pre></div><p>命名空间又称名字空间。使用关键字 namespace把大量有逻辑联系的程序实体组合在一个标识符下。</p><p>C++ 标准程序库中所有标识符都定义在命名空间 std中。当程序使用标准程序库的标识符时，如果没有使用 std 命名空间，则cin、cout、string 乃至 endl 都不能识别。</p><p>引用其他命名空间标识符的语法如下：</p><div class="code-wrapper"><pre><code class="hljs c++">命名空间名::标识符名;</code></pre></div><p>也能使用 using 语句，简化上述写法。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> 命名空间名::标识符名;<span class="hljs-comment">// 可以在本文件中使用指定标识符</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> 命名空间名;<span class="hljs-comment">// 可以在本文件中使用该命名空间中的所有标识符</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;C++&gt;2 程序流程结构</title>
    <link href="/2022/03/28/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/2%20%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84/"/>
    <url>/2022/03/28/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/2%20%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="程序流程结构">2 程序流程结构</h1><blockquote><p>C++ 支持最基本的三种程序运行结构：顺序结构、选择结构、循环结构</p></blockquote><ul><li>顺序结构：程序按顺序执行，不发生跳转</li><li>选择结构：依据条件是否满足，有选择性地执行代码</li><li>循环结构：依据条件是否满足，循环多次执行代码</li></ul><h2 id="选择结构">2.1 选择结构</h2><blockquote><p>依据条件是否满足，有选择性地执行代码</p></blockquote><h3 id="if-语句">2.1.1 if 语句</h3><p>if 语句的三种形式：</p><ul><li><p>单行格式 if 语句：<code>if (判断条件) &#123;执行语句&#125;</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;    cout &lt;&lt; <span class="hljs-string">&quot;多 · 此 · 一 · 举&quot;</span> &lt;&lt; endl;&#125;</code></pre></div></li><li><p>多行格式 if语句：<code>if (判断条件) &#123;执行语句&#125; else &#123;执行语句&#125;</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (boolean) &#123;    cout &lt;&lt; <span class="hljs-string">&quot;殊 · 途 · 同 · 归&quot;</span> &lt;&lt; endl;&#125;<span class="hljs-keyword">else</span> &#123;    cout &lt;&lt; <span class="hljs-string">&quot;殊 · 途 · 同 · 归&quot;</span> &lt;&lt; endl;&#125;</code></pre></div></li><li><p>多条件 if语句：<code>if (判断条件) &#123;执行语句&#125; else if (判断条件) &#123;执行语句&#125;</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (loseToThailand) &#123;    cout &lt;&lt; <span class="hljs-string">&quot;你到告诉我，怎么解释呢？&quot;</span> &lt;&lt; endl;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (loseToVietnam) &#123;    cout &lt;&lt; <span class="hljs-string">&quot;脸都不要了&quot;</span> &lt;&lt; endl;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (loseToMyanmer) &#123;    cout &lt;&lt; <span class="hljs-string">&quot;接下来没人输了&quot;</span> &lt;&lt; endl;&#125;</code></pre></div></li><li><p>嵌套 if 语句</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (loseToSyrian) &#123;    <span class="hljs-keyword">if</span> (fansAccompanyToTheEnd) &#123;        cout &lt;&lt; <span class="hljs-string">&quot;对得起我们吗？RNM，退钱！&quot;</span> &lt;&lt; endl;    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (areYouGuysDisappointed) &#123;        cout &lt;&lt; <span class="hljs-string">&quot;太TM失望啦！&quot;</span> &lt;&lt; endl;    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (butWeStilHaveChance) &#123;        cout &lt;&lt; <span class="hljs-string">&quot;已经结束咧！&quot;</span> &lt;&lt; endl;    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (willYouGuysKeepSupporting) &#123;        cout &lt;&lt; <span class="hljs-string">&quot;还有两场能全赢吗？赢不下来吧。很难的啦&quot;</span> &lt;&lt; endl;    &#125;&#125;</code></pre></div></li></ul><h3 id="三目运算符">2.1.2 三目运算符</h3><blockquote><p>通过三目运算实现简单判断（同 Java 三元运算符）</p></blockquote><p>语法：<code>表达式1 ? 表达式2 : 表达式3</code></p><p>解释：如果 表达式1 为真，则执行表达式2，否则执行表达式3</p><div class="code-wrapper"><pre><code class="hljs c++">cout &lt;&lt; <span class="hljs-string">&quot;哥们，这瓜多少钱一斤？&quot;</span> &lt;&lt; endl;<span class="hljs-type">int</span> price;cin &gt;&gt; price;cout &lt;&lt; (price &gt; <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;这瓜皮子是金子做的还是瓜粒子是金子做的？&quot;</span> : <span class="hljs-string">&quot;给我挑一个&quot;</span>) &lt;&lt; endl;</code></pre></div><h3 id="switch-语句">2.1.3 switch 语句</h3><blockquote><p>执行多条分支语句</p></blockquote><p>语法：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">switch</span> (条件语句) &#123;    <span class="hljs-keyword">case</span> 条件值:         语句;         <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> 条件值:         语句;         <span class="hljs-keyword">break</span>;&#125;</code></pre></div><p>示范：</p><div class="code-wrapper"><pre><code class="hljs c++">cout &lt;&lt; <span class="hljs-string">&quot;树上qi个猴，地下一个猴，问你几个猴&quot;</span> &lt;&lt; endl;<span class="hljs-type">int</span> answer;cin &gt;&gt; answer;<span class="hljs-keyword">switch</span> (answer) &#123;    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:        cout &lt;&lt; <span class="hljs-string">&quot;树上骑个猴，地下一个猴&quot;</span> &lt;&lt; endl;        <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:        cout &lt;&lt; <span class="hljs-string">&quot;树上七个猴，地下一个猴&quot;</span> &lt;&lt; endl;        <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">default</span>:        cout &lt;&lt; <span class="hljs-string">&quot;怀孕一个猴&quot;</span> &lt;&lt; endl;        <span class="hljs-keyword">break</span>;&#125;</code></pre></div><p>注意：如果在 switch 语句中不写 <code>break</code>，会发生<strong>穿透</strong></p><h2 id="循环结构">2.2 循环结构</h2><blockquote><p>依据条件是否满足，循环多次执行代码</p></blockquote><h3 id="while-循环语句">2.2.1 while 循环语句</h3><p>语法：<code>while (条件) &#123;循环语句&#125;</code></p><p>示范一个猜数游戏：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> target = <span class="hljs-built_in">rand</span>()%<span class="hljs-number">100</span>;<span class="hljs-comment">//生成 0 - 99 的随机值</span><span class="hljs-type">int</span> guess = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;    cout &lt;&lt; <span class="hljs-string">&quot;请输入您的猜测数字&quot;</span> &lt;&lt; endl;    cin &gt;&gt; guess;    <span class="hljs-keyword">if</span> (guess == target) &#123;        <span class="hljs-keyword">break</span>;    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;您的猜测值&quot;</span> &lt;&lt; (guess &gt; target ? <span class="hljs-string">&quot;高了&quot;</span> : <span class="hljs-string">&quot;低了&quot;</span>) &lt;&lt; endl;&#125;cout &lt;&lt; <span class="hljs-string">&quot;恭喜您猜对了，值是：&quot;</span> &lt;&lt; target &lt;&lt; endl;</code></pre></div><h3 id="do...while-循环语句">2.2.2 do...while 循环语句</h3><p>语法：<code>do &#123;循环语句&#125; while (条件语句)</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">char</span> ans;<span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<span class="hljs-keyword">do</span> &#123;    cout &lt;&lt; <span class="hljs-string">&quot;（一阵拳打脚踢）&quot;</span> &lt;&lt; <span class="hljs-string">&quot;说不说？（Y/N）&quot;</span> &lt;&lt; endl;    cin &gt;&gt; ans;&#125; <span class="hljs-keyword">while</span> (count++ &lt; <span class="hljs-number">10</span>);cout &lt;&lt; <span class="hljs-string">&quot;说什么？你TM倒是问啊！&quot;</span> &lt;&lt; endl;</code></pre></div><h3 id="for-循环语句">2.2.3 for 循环语句</h3><p>语法：<code>for(起始表达式; 条件表达式; 末尾循环体) &#123;循环语句&#125;</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n = <span class="hljs-number">0</span>; n &lt; <span class="hljs-built_in">sizeof</span>(heeler) / <span class="hljs-built_in">sizeof</span>(heeler[<span class="hljs-number">0</span>]); n++) &#123;    cout &lt;&lt; heeler[n] &lt;&lt; <span class="hljs-string">&quot;合在一起做撒尿牛丸啊笨！&quot;</span> &lt;&lt; endl;    <span class="hljs-keyword">if</span> (find) &#123;        <span class="hljs-keyword">break</span>;    &#125;&#125;</code></pre></div><h3 id="嵌套循环">2.2.4 嵌套循环</h3><blockquote><p>就是套娃</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n = <span class="hljs-number">0</span>; n &lt; <span class="hljs-number">10</span>; n++) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        cout &lt;&lt; <span class="hljs-string">&quot;禁止&quot;</span>;    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;套娃&quot;</span> &lt;&lt; endl;&#125;</code></pre></div><h2 id="跳转语句">2.3 跳转语句</h2><blockquote><p>让程序跳跃式地执行代码</p></blockquote><h3 id="break-语句">2.3.1 break 语句</h3><blockquote><p>用于跳出选择结构或循环结构</p></blockquote><p>使用时机：</p><ul><li>出现在 switch 语句中，作用是终止 case 并跳出switch。不写的场合发生穿透</li><li>出现在循环语句中，作用是跳出当前循环语句</li><li>出现在嵌套循环中，跳出最近的一层循环语句</li></ul><h3 id="continue-语句">2.3.2 continue 语句</h3><blockquote><p>用以中断本次循环，执行下次循环</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;    <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">continue</span>;    &#125;    cout &lt;&lt; i &lt;&lt; endl;&#125;</code></pre></div><h3 id="goto-语句">2.3.3 goto 语句</h3><blockquote><p>可以无条件跳转语句</p></blockquote><p>语法：<code>goto 标记;</code></p><p>标记：<code>标记名:</code></p><p>解释：如果标记存在，goto 语句执行时会直接跳转到该标记处。</p><div class="code-wrapper"><pre><code class="hljs c++">cout &lt;&lt; <span class="hljs-string">&quot;刻晴来到了山脚下&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">goto</span> tar;<span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;        tar:        cout &lt;&lt; <span class="hljs-string">&quot;迅影如剑！喝！&quot;</span> &lt;&lt; endl;    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;刻晴登上了山顶&quot;</span> &lt;&lt; endl;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;C++&gt;目录</title>
    <link href="/2022/03/27/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/0%20%E7%9B%AE%E5%BD%95/"/>
    <url>/2022/03/27/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/0%20%E7%9B%AE%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="目录">目录</h1><hr /><p>2022.3.27 22:08</p><h2 id="c-基础知识">1 <ahref="../../../../../../2022/03/28/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/1%20C++%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">C++基础知识</a></h2><ul><li><h3 id="注释">1.1 <ahref="../../../../../../2022/03/28/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/1%20C++%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#1-1-%E6%B3%A8%E9%87%8A">注释</a></h3></li><li><h3 id="标识符">1.2 <ahref="../../../../../../2022/03/28/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/1%20C++%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#1-2-%E6%A0%87%E8%AF%86%E7%AC%A6">标识符</a></h3><ul><li><h4 id="变量">1.2.1 变量</h4></li><li><h4 id="常量">1.2.2 常量</h4></li><li><h4 id="关键字">1.2.3 关键字</h4></li><li><h4 id="标识符命名规则">1.2.4 标识符命名规则</h4></li></ul></li><li><h3 id="数据类型">1.3 <ahref="../../../../../../2022/03/28/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/1%20C++%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#1-3-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a></h3><ul><li><h4 id="整形">1.3.1 整形</h4></li><li><h4 id="实型浮点型">1.3.2 实型（浮点型）</h4></li><li><h4 id="字符型">1.3.3 字符型</h4></li><li><h4 id="字符串型">1.3.4 字符串型</h4></li><li><h4 id="布尔类型">1.3.5 布尔类型</h4></li><li><h4 id="sizeof-关键字">1.3.6 sizeof 关键字</h4></li></ul></li><li><h3 id="运算符">1.4 <ahref="../../../../../../2022/03/28/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/1%20C++%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#1-4-%E8%BF%90%E7%AE%97%E7%AC%A6">运算符</a></h3><ul><li><h4 id="算术运算符">1.4.1 算术运算符</h4></li><li><h4 id="赋值运算符">1.4.2 赋值运算符</h4></li><li><h4 id="比较运算符">1.4.3 比较运算符</h4></li><li><h4 id="逻辑运算符">1.4.4 逻辑运算符</h4></li><li><h4 id="强制类型转换运算符">1.4.5 强制类型转换运算符</h4></li></ul></li><li><h3 id="数据的输入与输出">1.5 <ahref="../../../../../../2022/03/28/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/1%20C++%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#1-5-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA">数据的输入与输出</a></h3></li><li><h3 id="头文件和命名空间">1.6 头文件和命名空间</h3></li></ul><hr /><h2 id="程序流程结构">2 <ahref="../../../../../../2022/03/28/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/2%20%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84/">程序流程结构</a></h2><ul><li><h3 id="选择结构">2.1 <ahref="../../../../../../2022/03/28/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/2%20%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84/#2-1-%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84">选择结构</a></h3><ul><li><h4 id="if-语句">2.1.1 if 语句</h4></li><li><h4 id="三目运算符">2.1.2 三目运算符</h4></li><li><h4 id="switch-语句">2.1.3 switch 语句</h4></li></ul></li><li><h3 id="循环结构">2.2 <ahref="../../../../../../2022/03/28/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/2%20%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84/#2-2-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84">循环结构</a></h3><ul><li><h4 id="while-循环语句">2.2.1 while 循环语句</h4></li><li><h4 id="do...while-循环语句">2.2.2 do...while 循环语句</h4></li><li><h4 id="for-循环语句">2.2.3 for 循环语句</h4></li><li><h4 id="嵌套循环">2.2.4 嵌套循环</h4></li></ul></li><li><h3 id="跳转语句">2.3 <ahref="../../../../../../2022/03/28/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/2%20%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84/#2-3-%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5">跳转语句</a></h3><ul><li><h4 id="break-语句">2.3.1 break 语句</h4></li><li><h4 id="continue-语句">2.3.2 continue 语句</h4></li><li><h4 id="goto-语句">2.3.3 goto 语句</h4></li></ul></li></ul><hr /><h2 id="函数和数组">3 <ahref="../../../../../../2022/03/31/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/3%20%E5%87%BD%E6%95%B0%E5%92%8C%E6%95%B0%E7%BB%84/">函数和数组</a></h2><ul><li><h3 id="函数的定义和使用">3.1 <ahref="../../../../../../2022/03/31/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/3%20%E5%87%BD%E6%95%B0%E5%92%8C%E6%95%B0%E7%BB%84/#3-1-%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8">函数的定义和使用</a></h3><ul><li><h4 id="函数的定义">3.1.1 函数的定义</h4></li><li><h4 id="函数的调用">3.1.2 函数的调用</h4></li><li><h4 id="函数的声明">3.1.3 函数的声明</h4></li><li><h4 id="标识符的作用域与可见性">3.1.4标识符的作用域与可见性</h4></li><li><h4 id="函数的分文件编写">3.1.5 函数的分文件编写</h4></li><li><h4 id="默认参数">3.1.6 默认参数</h4></li><li><h4 id="占位参数">3.1.7 占位参数</h4></li><li><h4 id="函数重载">3.1.8 函数重载</h4></li><li><h4 id="内联函数">3.1.9 内联函数</h4></li></ul></li><li><h3 id="数组">3.2 <ahref="../../../../../../2022/03/31/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/3%20%E5%87%BD%E6%95%B0%E5%92%8C%E6%95%B0%E7%BB%84/#3-2-%E6%95%B0%E7%BB%84">数组</a></h3><ul><li><h4 id="一维数组">3.2.1 一维数组</h4></li><li><h4 id="二维数组">3.2.2 二维数组</h4></li></ul></li></ul><hr /><h2 id="指针和结构体">4 <ahref="../../../../../../2022/03/31/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/4%20%E6%8C%87%E9%92%88%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93/">指针和结构体</a></h2><ul><li><h3 id="指针">4.1 <ahref="../../../../../../2022/03/31/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/4%20%E6%8C%87%E9%92%88%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93/#4-1-%E6%8C%87%E9%92%88">指针</a></h3><ul><li><h4 id="指针的定义和使用">4.1.1 指针的定义和使用</h4></li><li><h4 id="空指针和野指针">4.1.2 空指针和野指针</h4></li><li><h4 id="const-修饰指针">4.1.3 const 修饰指针</h4></li><li><h4 id="指针和数组">4.1.4 指针和数组</h4></li><li><h4 id="指针和函数">4.1.5 指针和函数</h4></li><li><h4 id="指针数组和函数">4.1.6 指针、数组和函数</h4></li></ul></li><li><h3 id="结构体">4.2 <ahref="../../../../../../2022/03/31/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/4%20%E6%8C%87%E9%92%88%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93/#4-2-%E7%BB%93%E6%9E%84%E4%BD%93">结构体</a></h3><ul><li><h4 id="结构体的定义">4.2.1 结构体的定义</h4></li><li><h4 id="创建结构体变量">4.2.2 创建结构体变量</h4></li><li><h4 id="结构体指针">4.2.3 结构体指针</h4></li><li><h4 id="结构体做函数参数">4.2.4 结构体做函数参数</h4></li><li><h4 id="const-修饰结构体">4.2.5 const 修饰结构体</h4></li></ul></li></ul><hr /><h2 id="项目通讯录管理系统">5 <ahref="../../../../../../2022/04/01/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/5%20%E9%A1%B9%E7%9B%AE%EF%BC%9A%E9%80%9A%E8%AE%AF%E5%BD%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/">项目：通讯录管理系统</a></h2><ul><li><h3 id="附录通讯录管理系统">附录：<ahref="../../../../../../2022/04/01/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/5%20%E9%A1%B9%E7%9B%AE%EF%BC%9A%E9%80%9A%E8%AE%AF%E5%BD%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/#%E9%99%84%E5%BD%95%EF%BC%9A%E9%80%9A%E8%AE%AF%E5%BD%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F">通讯录管理系统</a></h3></li></ul><hr /><h2 id="内存和引用">6 <ahref="../../../../../../2022/04/02/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/6%20%E5%86%85%E5%AD%98%E5%92%8C%E5%BC%95%E7%94%A8/">内存和引用</a></h2><ul><li><h3 id="内存分区模型">6.1 <ahref="../../../../../../2022/04/02/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/6%20%E5%86%85%E5%AD%98%E5%92%8C%E5%BC%95%E7%94%A8/#6-1-%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E6%A8%A1%E5%9E%8B">内存分区模型</a></h3><ul><li><h4 id="程序运行前">6.1.1 程序运行前</h4></li><li><h4 id="程序运行后">6.1.2 程序运行后</h4></li><li><h4 id="new-操作符">6.1.3 new 操作符</h4></li></ul></li><li><h3 id="引用">6.2 <ahref="../../../../../../2022/04/02/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/6%20%E5%86%85%E5%AD%98%E5%92%8C%E5%BC%95%E7%94%A8/#6-2-%E5%BC%95%E7%94%A8">引用</a></h3><ul><li><h4 id="引用的基本使用">6.2.1 引用的基本使用</h4></li><li><h4 id="引用注意事项">6.2.2 引用注意事项</h4></li><li><h4 id="引用做函数参数">6.2.3 引用做函数参数</h4></li><li><h4 id="引用做返回值">6.2.4 引用做返回值</h4></li><li><h4 id="引用的本质">6.2.5 引用的本质</h4></li><li><h4 id="常量引用">6.2.6 常量引用</h4></li></ul></li></ul><hr /><h2 id="类和对象">7 <ahref="../../../../../../2022/04/17/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/7%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/">类和对象</a></h2><ul><li><h3 id="封装">7.1 <ahref="../../../../../../2022/04/17/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/7%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/#7-1-%E5%B0%81%E8%A3%85">封装</a></h3></li><li><h3 id="对象的初始化和清理">7.2 <ahref="../../../../../../2022/04/17/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/7%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/#7-2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E7%90%86">对象的初始化和清理</a></h3><ul><li><h4 id="构造函数和析构函数">7.2.1 构造函数和析构函数</h4><ul><li><h5 id="构造函数">7.2.1.1 构造函数</h5></li><li><h5 id="析构函数">7.2.1.2 析构函数</h5></li></ul></li><li><h4 id="构造函数的分类及调用">7.2.2 构造函数的分类及调用</h4></li><li><h4 id="拷贝构造函数的调用时机">7.2.3拷贝构造函数的调用时机</h4></li><li><h4 id="构造函数的调用规则">7.2.4 构造函数的调用规则</h4></li><li><h4 id="深拷贝与浅拷贝">7.2.5 深拷贝与浅拷贝</h4></li><li><h4 id="类对象作为类成员">7.2.6 类对象作为类成员</h4></li><li><h4 id="静态成员">7.2.7 静态成员</h4></li></ul></li><li><h3 id="c-对象模型和-this-指针">7.3 <ahref="../../../../../../2022/04/17/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/7%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/#7-3-C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%92%8C-this-%E6%8C%87%E9%92%88">C++对象模型和 this 指针</a></h3><ul><li><h4 id="this-指针">7.3.1 this 指针</h4></li><li><h4 id="空指针访问成员函数">7.3.2 空指针访问成员函数</h4></li><li><h4 id="const-修饰成员函数">7.3.3 const 修饰成员函数</h4></li></ul></li><li><h3 id="友元">7.4 <ahref="../../../../../../2022/04/17/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/7%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/#7-4-%E5%8F%8B%E5%85%83">友元</a></h3></li><li><h3 id="运算符重载">7.5 <ahref="../../../../../../2022/04/17/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/7%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/#7-5-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">运算符重载</a></h3><ul><li><h4 id="加号运算符重载">7.5.1 加号运算符重载</h4></li><li><h4 id="左移运算符重载">7.5.2 左移运算符重载</h4></li><li><h4 id="递增运算符重载">7.5.3 递增运算符重载</h4></li><li><h4 id="赋值运算符重载">7.5.4 赋值运算符重载</h4></li><li><h4 id="关系运算符重载">7.5.5 关系运算符重载</h4></li><li><h4 id="仿函数">7.5.6 仿函数</h4></li><li><h4 id="类型转换操作符重载">7.5.7 类型转换操作符重载</h4></li></ul></li><li><h3 id="继承">7.6 <ahref="../../../../../../2022/04/17/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/7%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/#7-6-%E7%BB%A7%E6%89%BF">继承</a></h3><ul><li><h4 id="继承方式">7.6.1 继承方式</h4></li><li><h4 id="继承中的对象模型">7.6.2 继承中的对象模型</h4></li><li><h4 id="继承中构造和析构顺序">7.6.3 继承中构造和析构顺序</h4></li><li><h4 id="继承同名成员的处理方式">7.6.4继承同名成员的处理方式</h4></li><li><h4 id="多继承语法">7.6.5 多继承语法</h4></li><li><h4 id="菱形继承">7.6.6 菱形继承</h4></li></ul></li><li><h3 id="多态">7.7 <ahref="../../../../../../2022/04/17/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/7%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/#7-7-%E5%A4%9A%E6%80%81">多态</a></h3><ul><li><h4 id="虚函数">7.7.1 虚函数</h4></li><li><h4 id="纯虚函数和抽象类">7.7.2 纯虚函数和抽象类</h4></li><li><h4 id="虚析构和纯虚析构">7.7.3 虚析构和纯虚析构</h4></li></ul></li></ul><hr /><h2 id="io-流">8 <ahref="../../../../../../2022/06/18/C++/入门阶段/8%20IO%20流/">I/O流</a></h2><ul><li><h3 id="标准流对象">8.1 <ahref="../../../../../../2022/06/18/C++/入门阶段/8%20IO%20流/#8-1-标准流对象">标准流对象</a></h3></li><li><h3 id="控制-io-格式">8.2 <ahref="../../../../../../2022/06/18/C++/入门阶段/8%20IO%20流/#8-2-%E6%8E%A7%E5%88%B6-I-x2F-O-%E6%A0%BC%E5%BC%8F">控制I/O 格式</a></h3><ul><li><h4 id="流操作符">8.2.1 流操作符</h4></li><li><h4 id="标志字">8.2.2 标志字</h4></li></ul></li><li><h3 id="cincout-常用函数">8.3 <ahref="../../../../../../2022/06/18/C++/入门阶段/8%20IO%20流/#8-3-cin-x2F-cout-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0">cin/cout常用函数</a></h3></li><li><h3 id="文件操作">8.4 <ahref="../../../../../../2022/06/18/C++/入门阶段/8%20IO%20流/#8-4-文件操作">文件操作</a></h3><ul><li><h4 id="打开和关闭文件">8.4.1 打开和关闭文件</h4></li><li><h4 id="读写文件">8.4.2 读写文件</h4></li><li><h4 id="二进制文件">8.4.3 二进制文件</h4></li><li><h4 id="随机访问文件">8.4.4 随机访问文件</h4></li></ul></li></ul><hr /><h2 id="项目职工管理系统">9 <ahref="../../../../../../2022/04/27/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/9%20%E9%A1%B9%E7%9B%AE%EF%BC%9A%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/">项目：职工管理系统</a></h2><ul><li><h3 id="业务需求">9.1 <ahref="../../../../../../2022/04/27/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/9%20%E9%A1%B9%E7%9B%AE%EF%BC%9A%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/#9-1-%E4%B8%9A%E5%8A%A1%E9%9C%80%E6%B1%82">业务需求</a></h3></li><li><h3 id="附录职工管理系统">附录：<ahref="../../../../../../2022/04/27/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/9%20%E9%A1%B9%E7%9B%AE%EF%BC%9A%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/#%E9%99%84%E5%BD%95">职工管理系统</a></h3></li></ul><hr /><h2 id="模板">10 <ahref="../../../../../../2022/04/30/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/10%20%E6%A8%A1%E6%9D%BF/">模板</a></h2><ul><li><h3 id="函数模板">10.1 <ahref="../../../../../../2022/04/30/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/10%20%E6%A8%A1%E6%9D%BF/#10-1-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF">函数模板</a></h3></li><li><h3 id="类模板">10.2 <ahref="../../../../../../2022/04/30/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/10%20%E6%A8%A1%E6%9D%BF/#10-2-%E7%B1%BB%E6%A8%A1%E6%9D%BF">类模板</a></h3><ul><li><h4 id="类模板对象做函数参数">10.2.1 类模板对象做函数参数</h4></li><li><h4 id="类模板分文件编写">10.2.2 类模板分文件编写</h4></li><li><h4 id="类模板做友元">10.2.3 类模板做友元</h4></li></ul></li><li><h3 id="附录可变数组类">附录：<ahref="../../../../../../2022/04/30/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/10%20%E6%A8%A1%E6%9D%BF/#%E5%8F%AF%E5%8F%98%E6%95%B0%E7%BB%84%E7%B1%BB">可变数组类</a></h3></li></ul><hr /><h2 id="stl">11 <ahref="../../../../../../2022/05/05/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/11%20STL/">STL</a></h2><ul><li><h3 id="stl-常用容器">11.1 <ahref="../../../../../../2022/05/05/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/11%20STL/#11-1-STL-%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8">STL常用容器</a></h3><ul><li><h4 id="string-容器">11.1.1 <ahref="../../../../../../2022/05/05/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/11%20STL/#11-1-1-string-%E5%AE%B9%E5%99%A8">string容器</a></h4></li><li><h4 id="vector-容器">11.1.2 <ahref="../../../../../../2022/05/05/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/11%20STL/#11-1-2-vector-%E5%AE%B9%E5%99%A8">vector容器</a></h4></li><li><h4 id="deque-容器">11.1.3 <ahref="../../../../../../2022/05/05/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/11%20STL/#11-1-3-deque-%E5%AE%B9%E5%99%A8">deque容器</a></h4></li><li><h4 id="stack-容器">11.1.4 <ahref="../../../../../../2022/05/05/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/11%20STL/#11-1-4-stack-%E5%AE%B9%E5%99%A8">stack容器</a></h4></li><li><h4 id="queue-容器">11.1.5 <ahref="../../../../../../2022/05/05/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/11%20STL/#11-1-5-queue-%E5%AE%B9%E5%99%A8">queue容器</a></h4></li><li><h4 id="list-容器">11.1.6 <ahref="../../../../../../2022/05/05/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/11%20STL/#11-1-6-list-%E5%AE%B9%E5%99%A8">list容器</a></h4></li><li><h4 id="set-multiset-容器">11.1.7<ahref="../../../../../../2022/05/05/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/11%20STL/#11-1-7-set-x2F-multiset-%E5%AE%B9%E5%99%A8">set/ multiset 容器</a></h4></li><li><h4 id="pair-对组">11.1.8 <ahref="../../../../../../2022/05/05/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/11%20STL/#11-1-8-pair-%E5%AF%B9%E7%BB%84">pair对组</a></h4></li><li><h4 id="map-multimap-容器">11.1.9 <ahref="../../../../../../2022/05/05/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/11%20STL/#11-1-9-map-x2F-multimap-%E5%AE%B9%E5%99%A8">map/ multimap 容器</a></h4></li></ul></li><li><h3 id="stl-函数对象">11.2 <ahref="../../../../../../2022/05/05/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/11%20STL/#11-2-STL-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1">STL函数对象</a></h3><ul><li><h4 id="谓词">11.2.1 <ahref="../../../../../../2022/05/05/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/11%20STL/#11-2-1-%E8%B0%93%E8%AF%8D">谓词</a></h4></li><li><h4 id="内建函数对象">11.2.2 <ahref="../../../../../../2022/05/05/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/11%20STL/#11-2-2-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1">内建函数对象</a></h4></li></ul></li><li><h3 id="stl-常用算法">11.3 <ahref="../../../../../../2022/05/05/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/11%20STL/#11-3-STL-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95">STL常用算法</a></h3><ul><li><h4 id="常用遍历算法">11.3.1 <ahref="../../../../../../2022/05/05/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/11%20STL/#11-3-1-%E5%B8%B8%E7%94%A8%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95">常用遍历算法</a></h4></li><li><h4 id="常用查找算法">11.3.2 <ahref="../../../../../../2022/05/05/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/11%20STL/#11-3-2-%E5%B8%B8%E7%94%A8%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95">常用查找算法</a></h4></li><li><h4 id="常用排序算法">11.3.3 <ahref="../../../../../../2022/05/05/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/11%20STL/#11-3-3-%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">常用排序算法</a></h4></li><li><h4 id="常用拷贝和替换算法">11.3.4 <ahref="../../../../../../2022/05/05/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/11%20STL/#11-3-4-%E5%B8%B8%E7%94%A8%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95">常用拷贝和替换算法</a></h4></li><li><h4 id="常用算术生成算法">11.3.5 <ahref="../../../../../../2022/05/05/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/11%20STL/#11-3-5-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%9C%AF%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95">常用算术生成算法</a></h4></li><li><h4 id="常用集合算法">11.3.6 <ahref="../../../../../../2022/05/05/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/11%20STL/#11-3-6-%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E7%AE%97%E6%B3%95">常用集合算法</a></h4></li></ul></li></ul><hr /><h2 id="项目演讲比赛管理系统">12 <ahref="../../../../../../2022/05/21/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/12%20%E9%A1%B9%E7%9B%AE%EF%BC%9A%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/">项目：演讲比赛管理系统</a></h2><ul><li><h3 id="项目需求">12.1 <ahref="../../../../../../2022/05/21/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/12%20%E9%A1%B9%E7%9B%AE%EF%BC%9A%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/#12-1-%E9%A1%B9%E7%9B%AE%E9%9C%80%E6%B1%82">项目需求</a></h3></li><li><h3 id="附录演讲比赛管理系统">附录：<ahref="../../../../../../2022/05/21/C++/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/12%20%E9%A1%B9%E7%9B%AE%EF%BC%9A%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/#%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F">演讲比赛管理系统</a></h3></li></ul><hr /><h2 id="项目机房预约系统">13 项目：机房预约系统</h2><ul><li><h3 id="项目需求-1">13.1 项目需求</h3></li><li><h3 id="附录机房预约系统">附录：机房预约系统</h3></li></ul><hr />]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>目录</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt;27 Java 8 新特性</title>
    <link href="/2022/03/09/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/27%20Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2022/03/09/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/27%20Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="java-8-新特性">27 Java 8 新特性</h1><blockquote><p>Java 8 是 Java 语言开发的一个主要版本，其为 Java 带来了大量新特性</p></blockquote><h2 id="lambda-表达式">27.1 Lambda 表达式</h2><blockquote><p>Lambda是一个匿名函数，可以理解为一段可传递的代码。使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java 语言的表达能力得到了提升。</p><p>（Java 中）Lambda 的本质：作为函数式接口的实例</p></blockquote><p>原代码：</p><div class="code-wrapper"><pre><code class="hljs java">Comparator&lt;Integer&gt; comp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;        <span class="hljs-keyword">return</span> Integer.compare(o1, o2);    &#125;&#125;;System.out.println(comp.compare(<span class="hljs-number">11</span>, <span class="hljs-number">10</span>));</code></pre></div><p>使用 Lambda 表达式重写的代码：</p><div class="code-wrapper"><pre><code class="hljs java">Comparator&lt;Integer&gt; comp = (o1, o2) -&gt; Integer.compare(o1, o2);System.out.println(comp.compare(<span class="hljs-number">11</span>, <span class="hljs-number">10</span>));</code></pre></div><p>通过 方法引用 进一步改写代码：</p><div class="code-wrapper"><pre><code class="hljs java">Comparator&lt;Integer&gt; comp = Integer::compare;System.out.println(comp.compare(<span class="hljs-number">11</span>, <span class="hljs-number">10</span>));</code></pre></div><h3 id="lambda-表达式的使用">27.1.1 Lambda 表达式的使用</h3><blockquote><p>Lambda 表达式：在 Java 8语言中引入的一种新的语法元素和操作符。这个操作符 <code>-&gt;</code>被称为 Lambda 操作符（箭头操作符）。它将 Lambda 分为两部分：</p><p>左侧：Lambda形参列表。可以进行类型推断的场合，能省略参数类型；参数唯一的场合，能省略小括号。</p><p>右侧：Lambda 体。只有一条语句的场合，能省略大括号和<code>return</code>。</p></blockquote><ol type="1"><li><p>无参，无返回值：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Runnable</span> <span class="hljs-variable">r1</span> <span class="hljs-operator">=</span> () -&gt; &#123;    System.out.println(<span class="hljs-string">&quot;格式一&quot;</span>);&#125;;</code></pre></div></li><li><p>有参，无返回值：</p><div class="code-wrapper"><pre><code class="hljs java">Consumer&lt;String&gt; con = (String str) -&gt; &#123;    System.out.println(<span class="hljs-string">&quot;格式二&quot;</span>);&#125;;</code></pre></div></li><li><p>有参，无返回值。但参数的数据类型可由编译器推断得出，即“类型推断”：</p><div class="code-wrapper"><pre><code class="hljs java">Consumer&lt;String&gt; con = (str) -&gt; &#123;    System.out.println(<span class="hljs-string">&quot;格式三&quot;</span>);&#125;;</code></pre></div></li><li><p>有参，无返回值。但只需要一个参数：</p><div class="code-wrapper"><pre><code class="hljs java">Consumer&lt;String&gt; con = str -&gt; &#123;    System.out.println(<span class="hljs-string">&quot;格式四&quot;</span>);&#125;;</code></pre></div></li><li><p>多个参数，多条执行语句，可以有返回值：</p><div class="code-wrapper"><pre><code class="hljs java">Comparator&lt;Integer&gt; comp = (o1, o2) -&gt; &#123;    System.out.println(<span class="hljs-string">&quot;格式五&quot;</span>);    <span class="hljs-keyword">return</span> Integer.compare(o1, o2);&#125;;</code></pre></div></li><li><p>只有一条执行语句时，<code>&#123; &#125;</code> 和 <code>return</code>都能省略：</p><div class="code-wrapper"><pre><code class="hljs java">Comparator&lt;Integer&gt; comp = (o1, o2) -&gt; Integer.compare(o1, o2);</code></pre></div></li></ol><h2 id="函数式接口">27.2 函数式接口</h2><blockquote><p>一个接口中只声明了一个抽象方法，这种接口就被称为函数式接口</p><p>可以在一个接口上使用 <code>@FunctionalInterface</code>注解，以检查其是否是一个函数式接口。</p></blockquote><h3 id="java-内置的函数式接口">27.2.1 Java 内置的函数式接口</h3><p><strong>常用的四个函数式接口：</strong></p><table><thead><tr class="header"><th>函数式接口</th><th>参数类型</th><th>返回类型</th><th>用途</th><th>抽象方法</th></tr></thead><tbody><tr class="odd"><td><code>Consumer&lt;T&gt;</code>：消费型接口</td><td>T</td><td>void</td><td>对类型 T 的对象进行操作</td><td><code>void accept(T t)</code></td></tr><tr class="even"><td><code>Supplier&lt;T&gt;</code>：供给型接口</td><td>无</td><td>T</td><td>返回类型 T 的对象</td><td><code>T get()</code></td></tr><tr class="odd"><td><code>Function&lt;T, R&gt;</code>：函数型接口</td><td>T</td><td>R</td><td>对类型 T 的对象进行操作，返回类型 R 的对象</td><td><code>R apply(T t)</code></td></tr><tr class="even"><td><code>Predicate&lt;T&gt;</code>：断定型接口</td><td>T</td><td>boolean</td><td>确定类型 T 的对象是否满足约束</td><td><code>boolean test(T t)</code></td></tr></tbody></table><p><strong>其他的函数式接口：</strong></p><table><thead><tr class="header"><th>函数式接口</th><th>参数类型</th><th>返回类型</th><th>用途</th><th>抽象方法</th></tr></thead><tbody><tr class="odd"><td><code>BiFunction&lt;T, U, R&gt;</code></td><td>T、U</td><td>R</td><td>对类型 T、U 的对象进行操作，返回类型 R 的对象</td><td><code>R apply(T t, U u)</code></td></tr><tr class="even"><td><code>UnaryOperator&lt;T&gt;</code>（<code>Function</code>子接口）</td><td>T</td><td>T</td><td>对类型 T 的对象进行一元运算，返回类型 T 的对象</td><td><code>T apply(T t)</code></td></tr><tr class="odd"><td><code>BinaryOperator&lt;T&gt;</code>（<code>BiFunction</code>子接口）</td><td>T、T</td><td>T</td><td>对类型 T 的对象进行二元运算，返回类型 T 的对象</td><td><code>T apply(T t1, T t2)</code></td></tr><tr class="even"><td><code>BiConsumer&lt;T, U&gt;</code></td><td>T、U</td><td>void</td><td>对类型 T、U 的对象进行操作</td><td><code>void accept(T t, U u)</code></td></tr><tr class="odd"><td><code>BiPredicate&lt;T, U&gt;</code></td><td>T、U</td><td>boolean</td><td>确定类型 T、U 的对象是否满足约束</td><td><code>boolean test(T t, U u)</code></td></tr><tr class="even"><td><code>ToIntFunction&lt;T&gt;</code>、<code>ToLongFunction&lt;T&gt;</code>、<code>ToDoubleFunction&lt;T&gt;</code></td><td>T</td><td>int / long / double</td><td>计算 int / long /double 值的函数</td><td><code>int apply(T t)</code></td></tr><tr class="odd"><td><code>IntFunction&lt;T&gt;</code>、<code>LongFunction&lt;T&gt;</code>、<code>DoubleFunction&lt;T&gt;</code></td><td>int / long / double</td><td>T</td><td>参数是 int / long /double 的函数</td><td><code>T applt(int n)</code></td></tr></tbody></table><h2 id="方法引用和构造器引用">27.3 方法引用和构造器引用</h2><blockquote><p>当要传递给 Lambda 体的操作已经有实现方法了，可以使用方法引用。</p><p>方法引用可以看作是 Lambda 表达式深层次的表达。换句话说，方法引用就是Lambda 表达式，即函数式接口的一个实例。通过方法名指向一个方法。</p></blockquote><h3 id="方法引用">27.3.1 方法引用</h3><blockquote><p>实现接口的抽象方法的参数列表和返回值，与引用方法的参数列表和返回值一致</p></blockquote><ol type="1"><li><p><code>对象::非静态方法</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">PrintStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> System.out;Consumer&lt;String&gt; con = out::println;</code></pre></div></li><li><p><code>类::静态方法</code></p><div class="code-wrapper"><pre><code class="hljs java">Supplier&lt;Long&gt; sl = System::currentTimeMillis;</code></pre></div></li><li><p><code>类::非静态方法</code></p><div class="code-wrapper"><pre><code class="hljs java">Comparator&lt;String&gt; bp = String::compareTo;</code></pre></div><p>上面的代码等同于以下写法</p><div class="code-wrapper"><pre><code class="hljs java">Comparator&lt;String&gt; bp = (str1, str2) -&gt; str1.compareTo(str2);</code></pre></div></li></ol><h3 id="构造器引用">27.3.2 构造器引用</h3><blockquote><p>实现接口的抽象方法的参数列表与构造器参数列表一致，返回类型与构造器所在类一致</p></blockquote><ol type="1"><li><p>无参构造器 <div class="code-wrapper"><pre><code class="hljs java">Supplier&lt;String&gt; s = String::<span class="hljs-keyword">new</span>;</code></pre></div></p><p>等同于以下写法</p><div class="code-wrapper"><pre><code class="hljs java">Supplier&lt;String&gt; s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Supplier</span>&lt;String&gt;()&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">get</span><span class="hljs-params">()</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>();    &#125;&#125;</code></pre></div></li><li><p>有参构造器</p><div class="code-wrapper"><pre><code class="hljs java">Function&lt;String, String&gt; function = String::<span class="hljs-keyword">new</span>;</code></pre></div></li></ol><h3 id="数组引用">27.3.3 数组引用</h3><blockquote><p>把数组看成一个类，则其用法与构造器引用相同</p></blockquote><div class="code-wrapper"><pre><code class="hljs java">Function&lt;Integer, <span class="hljs-type">char</span>[]&gt; f = n -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[n];Function&lt;Integer, <span class="hljs-type">char</span>[]&gt; f2 = <span class="hljs-type">char</span>[]::<span class="hljs-keyword">new</span>;</code></pre></div><h2 id="stream-api">27.4 Stream API</h2><blockquote><p>StreamAPI（<code>java.util.stream</code>）把真正的函数式编程风格引入到 Java中。这是目前为止对 Java 类库最好的补充。因为 Stream API 可以极大提高Java 程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p><p>Stream 是 Java8中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用Stream API 对集合进行数据操作，就类似于使用 SQL执行的数据库查询。也可以使用 Stream API 来并行执行操作。简言之，StreamAPI 提供了一种高效且易于使用的处理数据的方式。</p></blockquote><p>Stream API 和 Collection 的区别：Collection是一种静态的内存数据结构，而 Stream是有关计算的。前者主要面向内存，储存于内存。后者主要面向 CPU，通过 CPU实现计算。</p><h3 id="什么是-stream">27.4.1 什么是 Stream</h3><blockquote><p>Stream 是数据渠道，用于操作数据源所生成的元素序列</p></blockquote><ul><li>Stream 自己不会储存元素</li><li>Stream 不会改变源对象。他们会返回一个持有结果的新 Stream</li><li>Stream 操作是延迟执行的。这意味着他们会等到需要结果时才执行</li></ul><h3 id="stream-操作步骤">27.4.2 Stream 操作步骤</h3><ol type="1"><li><p>创建 Stream：</p><p>根据一个数据源，获取一个流</p></li><li><p>中间操作：</p><p>一个中间操作链，对数据源的数据进行处理</p></li><li><p>终止操作：</p><p>一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用</p></li></ol><h4 id="创建-stream">27.4.2.1 创建 Stream</h4><ol type="1"><li><p>通过集合：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<span class="hljs-comment">//某个集合</span><span class="hljs-type">Stream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> list.stream();<span class="hljs-comment">//返回一个顺序流</span><span class="hljs-type">Stream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> list.parallelStream();<span class="hljs-comment">//返回一个并行流</span></code></pre></div></li><li><p>通过数组：</p><p>Arrays 类提供了这个静态方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span>[] ints = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<span class="hljs-comment">//基本数据类型只有这三种</span><span class="hljs-type">IntStream</span> <span class="hljs-variable">IS</span> <span class="hljs-operator">=</span> Arrays.stream(ints);<span class="hljs-type">long</span>[] longs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[<span class="hljs-number">2</span>];<span class="hljs-type">LongStream</span> <span class="hljs-variable">LS</span> <span class="hljs-operator">=</span> Arrays.stream(longs);<span class="hljs-type">double</span>[] doubles = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[<span class="hljs-number">2</span>];<span class="hljs-type">DoubleStream</span> <span class="hljs-variable">LS</span> <span class="hljs-operator">=</span> Arrays.stream(doubles);Object[] objs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">4</span>];<span class="hljs-comment">//此处表示一个任意类</span>Stream&lt;Object&gt; stream = Arrays.stream(objs);</code></pre></div><p>这个方法的重载形式，能够处理对应基本类型的数组</p><ul><li><code>public static IntStream stream(int[] arr)</code></li><li><code>public static LongStream stream(long[] arr)</code></li><li><code>public static DoubleStream stream(double[] arr)</code></li></ul></li><li><p>通过 <code>Stream.of()</code> 方法：</p><div class="code-wrapper"><pre><code class="hljs java">Char[] chars = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Char</span>[<span class="hljs-number">4</span>];Stream&lt;Char&gt; CS = Stream.of(chars);</code></pre></div></li><li><p>创建无限流：</p><div class="code-wrapper"><pre><code class="hljs java">Stream&lt;Integer&gt; iterate = Stream.iterate(<span class="hljs-number">1</span>, o -&gt; ++o);Stream&lt;Long&gt; generate = Stream.generate(System::currentTimeMillis);</code></pre></div><ul><li><p><code>public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f)</code></p></li><li><p><code>public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</code></p><p><strong><em>——看不懂？请看 <ahref="../../../../../../2022/03/09/Java/入门阶段/27%20Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/#27-2-1-Java-%E5%86%85%E7%BD%AE%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3">[27.2.1 Java 内置的函数式接口 ]</a></em></strong></p></li></ul></li></ol><h4 id="中间操作">27.4.2.2 中间操作</h4><blockquote><p>多个中间操作连接起一个流水线。该流水线在触发终止操作前不执行任何处理，终止操作触发时一次性进行全部处理。这个流程也称为“惰性求值”。</p></blockquote><ol type="1"><li><p>筛选与切片</p><table><thead><tr class="header"><th>方法</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><code>filter(Predicate P)</code></td><td>接收一个 Lambda，从流中排除某些元素</td></tr><tr class="even"><td><code>distinct()</code></td><td>筛选，通过流生成元素的 <code>hashCode()</code> 和<code>equals()</code> 进行去重</td></tr><tr class="odd"><td><code>linmit(long maxSize)</code></td><td>截断流，使其元素不超过给定数量</td></tr><tr class="even"><td><code>skip(long n)</code></td><td>跳过元素，返回一个扔掉了前 n 给元素的流。不足 n 的场合返回空流</td></tr></tbody></table></li><li><p>映射</p><table><thead><tr class="header"><th>方法</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><code>map(Function f)</code></td><td>接收一个函数，将元素转化成其他形式提取信息</td></tr><tr class="even"><td><code>flatMap(Function f)</code></td><td>接收一个函数，将每个元素都转换成另一个流</td></tr></tbody></table></li><li><p>排序</p><table><thead><tr class="header"><th>方法</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><code>sorted()</code></td><td>产生一个新流，该流按自然顺序排序</td></tr><tr class="even"><td><code>sorted(Comparator c)</code></td><td>产生一个新流，该流按比较器顺序排序</td></tr></tbody></table></li></ol><h4 id="终止操作">27.4.2.3 终止操作</h4><ol type="1"><li><p>匹配和查找</p><table><thead><tr class="header"><th>方法</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><code>allMatch(Predicate p)</code></td><td>检查是否匹配全部元素</td></tr><tr class="even"><td><code>anyMatch(Predicate p)</code></td><td>检查是否有任意元素匹配</td></tr><tr class="odd"><td><code>noneMatch(Predicate p)</code></td><td>检查是否任意元素都不匹配</td></tr><tr class="even"><td><code>findFirst()</code></td><td>返回第一个元素</td></tr><tr class="odd"><td><code>findAny()</code></td><td>返回当前流的任意元素</td></tr><tr class="even"><td><code>count()</code></td><td>返回当前流的元素个数</td></tr><tr class="odd"><td><code>max(Comparator c)</code></td><td>返回流中的（比较器顺序下的）最大值</td></tr><tr class="even"><td><code>min(Comparator c)</code></td><td>返回流中的（比较器顺序下的）最小值</td></tr><tr class="odd"><td><code>forEach(Consumer c)</code></td><td>内部迭代</td></tr></tbody></table><ul><li>关于内部迭代：使用 <code>Collection</code>接口需要用户去做迭代，称为外部迭代。Stream API使用内部迭代，不需要用户做迭代。</li></ul></li><li><p>归约</p><table><thead><tr class="header"><th>方法</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><code>reduce(T identity, BinaryOperator b)</code></td><td>可以把流中元素反复结合起来，得到一个值。返回 <code>T</code></td></tr><tr class="even"><td><code>reduce(BinaryOperator b)</code></td><td>可以把流中元素反复结合起来，得到一个值。返回<code>Optinal&lt;T&gt;</code></td></tr></tbody></table></li><li><p>收集</p><table><thead><tr class="header"><th>方法</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><code>collect(Collector c)</code></td><td>将流转换为其他形式。接收一个 Collector 接口的实现，用于给 Stream中元素做汇总的方法</td></tr></tbody></table><ul><li><p><code>Collector</code>接口中方法的实现决定了如何对流执行收集的操作</p><p>另外，<code>Collectors</code>实用类提供了很多静态方法，可以方便地创建常见收集器实例。</p></li></ul></li></ol><h2 id="optional-类">27.5 <code>Optional</code> 类</h2><blockquote><p><code>Optional</code>类（<code>java.util.Optional</code>）是一个容器类，它可以保存类型 T的值，代表这个值存在。也可以仅仅保存 null，表示这个值不存在。原来用 null表示一个值不存在，现在 Optional可以更好地表达这个概念，而且可以避免空指针异常。</p></blockquote><h3 id="方法">27.5.1 方法</h3><p><strong>创建方法：</strong></p><ul><li><code>Optional.of(T t)</code>：创建一个 <code>Optional</code>实例。<strong><code>t</code> 必须非空</strong></li><li><code>Optional.empty()</code>：创建一个空的 <code>Optional</code>实例</li><li><code>Optional.ofNullable(T t)</code>：创建一个<code>Optional</code> 实例。<strong><code>t</code> 可以为null</strong></li></ul><p><strong>判断 <code>Optional</code> 实例是否包含对象：</strong></p><ul><li><code>isPresent()</code>：判断是否包含对象，返回 boolean</li><li><code>ifPresent(Consumer c)</code>：如果有值，则传入该值并执行<code>Consumer</code> 接口的实现代码。</li></ul><p><strong>获取 <code>Optional</code> 实例的对象：</strong></p><ul><li><code>get()</code>：如果有值，返回该值。否则抛出异常。</li><li><code>orElse(T other)</code>：如果有值，返回该值。否则返回指定的other 对象。</li><li><code>orElseGet(Supplier other)</code>：如果有值，返回该值。否则返回<code>Supplier</code> 接口实现提供的对象。</li><li><code>orElseThrow(Supplier excption)</code>：如果有值，返回该值。否则抛出<code>Supplier</code> 接口实现提供的异常。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt;25 正则表达式</title>
    <link href="/2022/03/02/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/25%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2022/03/02/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/25%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="正则表达式">25 正则表达式</h1><blockquote><p>正则表达式：对字符串执行模式匹配的技术。一个正则表达式，就是用某种模式去匹配字符串的一个公式。除Java 外，还有许多语言支持正则表达式。</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;HeruinKCoin&quot;</span>;<span class="hljs-comment">//对象文本</span><span class="hljs-type">String</span> <span class="hljs-variable">regular</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;[A-Z]&quot;</span>;<span class="hljs-comment">//[1] 创建规则</span><span class="hljs-type">Pattern</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> Pattern.compile(regular);<span class="hljs-comment">//[2] 创建模式对象</span><span class="hljs-type">Matcher</span> <span class="hljs-variable">matcher</span> <span class="hljs-operator">=</span> pattern.matcher(content);<span class="hljs-comment">//[3] 创建匹配器</span><span class="hljs-keyword">while</span> (matcher.find())&#123;<span class="hljs-comment">//[4] find() 是否找到下一个</span>    System.out.println(matcher.group(<span class="hljs-number">0</span>));<span class="hljs-comment">//[5] group(0) 输出找到的当前对象</span>&#125;</code></pre></div><blockquote><p><code>Matcher</code> 底层维护了一个 <code>group[]</code> 数组。如果<strong>[4]</strong> 在文本里匹配到对象，会在 <code>group[0]</code>记载该起始位置 n1，在 <code>group[1]</code> 记录该结束位置的下一位n2。即 [n1,n2) 为匹配的字符串，n2 位置是下次匹配的起始位置。</p><p>当 <strong>[1]</strong> 创建的规则包含分组（如<code>String regular = "(\\d\\d)(\\d\\d)";</code>），则第一组的起止位置记录在<code>group[2]</code>、<code>group[3]</code>，第二组在<code>group[4]</code>、<code>group[5]</code>。以此类推。这时，<strong>[5]</strong>的 <code>group(0)</code> 代表输出全部，<code>group[1]</code>代表输出第一组，以此类推。</p></blockquote><h2 id="语法">25.1 语法</h2><p><strong>元字符</strong></p><ul><li>限定符</li><li>选择匹配符</li><li>分组组合和反向引用符</li><li>特殊字符</li><li>字符匹配符</li><li>定位符</li></ul><h3 id="转义符号">25.1.1 转义符号 <code>\</code></h3><p>使用正则表达式去检索某些特殊字符时，需要加上转义符号（如：<code>(</code>需要写成 <code>\(</code>）</p><p>在 Java 的正则表达式中，<code>\\</code> 代表一个<code>\</code>。<strong><em>——见 <ahref="../../../../../../2021/11/21/Java/入门阶段/1%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#1-8-Java-%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6">[1.8Java 转义字符 ]</a></em></strong></p><p>需要用到转义符号的字符有：<code>.</code>、<code>+</code>、<code>(</code>、<code>)</code>、<code>$</code>、<code>/</code>、<code>\</code>、<code>?</code>、<code>[</code>、<code>]</code>、<code>^</code>、<code>&#123;</code>、<code>&#125;</code></p><h3 id="字符匹配符">25.1.2 字符匹配符</h3><table><thead><tr class="header"><th>符号</th><th>含义</th><th>示例</th><th>解释</th></tr></thead><tbody><tr class="odd"><td><code>[ ]</code></td><td>可接收的字符列表</td><td><code>[abcd]</code></td><td>abcd 中的任一字符</td></tr><tr class="even"><td><code>[^]</code></td><td>不接收的字符列表</td><td><code>[^abcd]</code></td><td>非 abcd 的任意字符</td></tr><tr class="odd"><td><code>-</code></td><td>连字符</td><td><code>[a-z]</code></td><td>a - z 中的任意字符</td></tr><tr class="even"><td><code>.</code></td><td>匹配除 <code>\n</code> 外的任意字符</td><td><code>a..b</code></td><td>a 开头，b结尾，中间含 2 字符</td></tr><tr class="odd"><td><code>\d</code></td><td>匹配单个数字字符</td><td><code>\d&#123;3&#125;</code></td><td>包含 3 个数字</td></tr><tr class="even"><td><code>\D</code></td><td>匹配单个非数字字符</td><td><code>\D(\d)*</code></td><td>单个非数字字符开头，后接任意个数字字符</td></tr><tr class="odd"><td><code>\w</code></td><td>匹配单个数字、大小写字母字符</td><td><code>\w&#123;2&#125;\d&#123;3&#125;</code></td><td>2 个数字字母字符开头，后接 3 个数字字符</td></tr><tr class="even"><td><code>\W</code></td><td>匹配单个非数字、非大小写字母字符</td><td><code>\W+\d&#123;2&#125;</code></td><td>以至少 1 个非数字字母字符开头，后接 2 个数字字符</td></tr><tr class="odd"><td><code>\s</code></td><td>匹配空白字符（空格、制表位等）</td><td></td><td></td></tr><tr class="even"><td><code>\S</code></td><td>匹配非空白字符</td><td></td><td></td></tr></tbody></table><ul><li><p>关于 <code>.</code>：特别地，出现 <code>[.]</code>的场合，那个小圆点依然表示小圆点。<code>[?]</code>同理，表示问号</p></li><li><p>正则表达式默认区分大小写。要不区分大小写，就加上<code>(?i)</code></p><ul><li><p><code>(?i)abc</code>：即 abc 都不区分大小写</p></li><li><p><code>a(?i)bc</code>：即仅 bc 不区分大小写</p></li><li><p><code>a((?i)b)c</code>：即仅 b 不区分大小写</p></li><li><p>创建模式对象时，若如此做：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Pattern</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> Pattern.compile(regular, Pattern.CASE_INSENSITIVE);</code></pre></div><p>这个场合，也能不区分大小写。</p></li></ul></li></ul><h3 id="选择匹配符">25.1.3 选择匹配符 <code>|</code></h3><p>……我的感想是，和 Java 的逻辑或 <code>|</code> 一样！</p><h3 id="限定符">25.1.4 限定符</h3><table><thead><tr class="header"><th>符号</th><th>含义</th><th>示例</th><th>解释</th></tr></thead><tbody><tr class="odd"><td><code>*</code></td><td>指定字符重复任意次（可以为 0 次）</td><td><code>(abc)*</code></td><td>仅包含任意个 abc 字符串的字符串</td></tr><tr class="even"><td><code>+</code></td><td>指定字符重复至少一次</td><td><code>m+(abc)*</code></td><td>以任意个 m 开头，后面可以有 abc 字符串的字符串</td></tr><tr class="odd"><td><code>?</code></td><td>指定字符重复最多一次（可以为 0 次）</td><td><code>m+abc?</code></td><td>以任意个 m 开头，后面可以有最多一个 abc 字符串的字符串</td></tr><tr class="even"><td><code>&#123;n&#125;</code></td><td>n 个匹配</td><td><code>[abc]&#123;3&#125;</code></td><td>长度为 3 的 abc 中的任意字符的组合</td></tr><tr class="odd"><td><code>&#123;n,&#125;</code></td><td>至少 n 个匹配</td><td><code>[abc]&#123;3,&#125;</code></td><td>长度不小于 3 的 abc 中的任意字符的组合</td></tr><tr class="even"><td><code>&#123;n,m&#125;</code></td><td>n 到 m 个匹配</td><td><code>[abc]&#123;3,5&#125;</code></td><td>长度介于 3 到 5 之间的 abc 中的任意字符的组合</td></tr></tbody></table><ul><li><p>Java 的匹配模式默认是贪婪匹配。即：<code>aaaaa</code> 匹配<code>a&#123;3,5&#125;</code> 的场合，会匹配到 <code>aaaaa</code></p><p>希望实现非贪婪匹配，可以添加额外的<code>?</code>。如：<code>*?</code>、<code>+?</code>、<code>??</code>代表各自规则的非贪婪匹配</p></li></ul><h3 id="定位符">25.1.5 定位符</h3><table><thead><tr class="header"><th>符号</th><th>含义</th><th>示例</th><th>解释</th></tr></thead><tbody><tr class="odd"><td><code>^</code></td><td>指定起始字符</td><td><code>^[0-9]+[a-z]*</code></td><td>至少一个数字开头，后接任意小写字母字符串</td></tr><tr class="even"><td><code>&amp;</code></td><td>指定结束字符</td><td><code>^[0-9][a]$</code></td><td>一个数字开头，一个 a 结尾</td></tr><tr class="odd"><td><code>\b</code></td><td>匹配目标字符串的边界</td><td><code>K\.C\b</code></td><td>匹配边界的 K.C</td></tr><tr class="even"><td><code>\B</code></td><td>匹配目标字符串的非边界</td><td><code>K\.C\B</code></td><td>匹配非边界的 K.C</td></tr></tbody></table><ul><li>边界即字符串的末尾，或字符串中空格间隔的子串的末尾。</li></ul><h3 id="分组">25.1.6 分组</h3><table><thead><tr class="header"><th>符号</th><th>含义</th></tr></thead><tbody><tr class="odd"><td><code>(pattern)</code></td><td>非命名捕获。捕获匹配的字符串。</td></tr><tr class="even"><td><code>(?&lt;name&gt;pattern)</code>、<code>(?'name'pattern)</code></td><td>命名捕获。用于 name 的字符串不能包含标点符号，也不能以数字开头</td></tr></tbody></table><ul><li>编号为 0的第一个捕获是由整个正则表达式匹配的文本。其他捕获结果根据左括号的顺序从1 开始自动编号。</li></ul><h3 id="非捕获分组">25.1.7 非捕获分组</h3><table><thead><tr class="header"><th>符号</th><th>含义</th><th>示例</th><th>解释</th></tr></thead><tbody><tr class="odd"><td><code>(?:pattern)</code></td><td>匹配 pattern 但不捕获该匹配的子表达式。</td><td><code>industr(?:y|ies)</code></td><td>等同于<code>industry|industies</code></td></tr><tr class="even"><td><code>(?=pattern)</code></td><td>匹配处于 pattern 前的搜索字符串。非捕获分组。</td><td><code>Windows(?=7|10|11)</code></td><td>匹配 Windows11 的 Windows，但不匹配 WindowsXP 的 Windows</td></tr><tr class="odd"><td><code>(?!pattern)</code></td><td>匹配不处于 pattern 前的搜索字符串。非捕获分组。</td><td><code>Windows(?!7|10|11)</code></td><td>不匹配 Windows11 的 Windows，匹配 WindowsXP 的 Windows</td></tr></tbody></table><h2 id="常用类">25.2 常用类</h2><ul><li><p><code>Pattern</code> 类：</p><p><code>Pattern</code>对象是一个正则表达式对象，该类没有公共构造方法。</p><p>用 <code>Pattern.compile(reg)</code> 获取一个 <code>Pattern</code>对象。</p></li><li><p><code>Matcher</code> 类：</p><p><code>Matcher</code>对象是输入字符串进行解释和匹配的引擎，也没有公共构造方法。</p><p>用 <code>Pattern</code> 对象的 <code>matcher(content)</code>方法获得一个 <code>Matcher</code> 对象。</p></li><li><p><code>PatternSyntaxExcption</code> 类：</p><p><code>PatternSyntaxExcption</code>是一个非强制异常类，表示一个正则表达式中的语法错误。</p></li></ul><h3 id="pattern-类常用方法">25.2.1 <code>Pattern</code> 类常用方法</h3><ul><li><p><code>Pattern.matches(reg, content)</code>：整体匹配，输入的字符串是否符合表达式。返回布尔值。</p><p><code>matcher.matches()</code>：整体匹配，字符串是否符合表达式。返回布尔值。前面的方法实际上就是这个方法。</p></li><li><p><code>Pattern.compile(reg)</code>：返回一个指定表达式的<code>Pattern</code> 对象</p></li><li><p><code>pattern.matcher(content)</code>：返回一个字串的<code>Matcher</code> 对象</p></li><li><p><code>matcher.pattern()</code>：返回该 <code>Matcher</code>对象的表达式</p><p><code>pattern.pattern()</code>：返回该 <code>Pattern</code>对象的表达式</p></li><li><p><code>matcher.find()</code>：尝试查找下一个匹配的序列，返回布尔值</p><p><code>matcher.find(int)</code>：重置该匹配器，从指定索引位置开始重新查找</p></li><li><p><code>matcher.start()</code>：返回本次匹配的字符起始位置的索引</p><p><code>matcher.end()</code>：返回本次匹配的字符结束位置 + 1 的索引</p><p>这个场合，<code>content.substring(matcher.start(), matcher.end())</code>就是匹配的字符串</p></li><li><p><code>matcher.start(int)</code>：返回本次匹配的字符的该组内容的起始位置的索引</p><p><code>matcher.end(int)</code>：返回本次匹配的字符的该组内容的结束位置+ 1 的索引</p></li><li><p><code>matcher.replaceAll(str)</code>：替换匹配到的全部内容</p><p><code>matcher.replaceFirst(str)</code>：替换第一次匹配到的内容</p><p>这些场合，返回的字符串才是替换后的字符串。原字符串不变。</p></li></ul><h2 id="分组捕获反向引用">25.3 分组、捕获、反向引用</h2><ul><li><p>分组（子表达式）</p></li><li><p>捕获：把正则表达式中，子表达式（分组）的内容保存到内存中以数字编号或显式命名的组里，方便后面引用。以分组的左括号为标志，第一组组号为1，第二组为 2，以 0 代表整个正则表达式。</p></li><li><p>反向引用：分组的内容被捕获后，可以在这个括号后使用。这种引用既可以是在正则表达式内部，也可以在外部。内部反向引用<code>\分组号</code>、外部反向引用 <code>$分组号</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">regular</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(\\w)\\1+&quot;</span>;<span class="hljs-comment">//即，重复的字母或数字</span><span class="hljs-type">Matcher</span> <span class="hljs-variable">matcher</span> <span class="hljs-operator">=</span> Pattern.compile(regular).mathcer(content);content = matcher.replaceAll(<span class="hljs-string">&quot;$1&quot;</span>);<span class="hljs-comment">//这样，就完成了去重</span></code></pre></div></li></ul><h2 id="在-string-中使用正则表达式">25.4 在 <code>String</code>中使用正则表达式</h2><ul><li><code>str.matches(reg)</code>：整体匹配</li><li><code>str.replaceAll(reg, reg)</code>：替换匹配到的全部内容</li><li><code>str.split(reg)</code>：分割内容</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt;24 项目（满汉楼）</title>
    <link href="/2022/02/26/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/24%20%E9%A1%B9%E7%9B%AE%EF%BC%9A%E6%BB%A1%E6%B1%89%E6%A5%BC/"/>
    <url>/2022/02/26/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/24%20%E9%A1%B9%E7%9B%AE%EF%BC%9A%E6%BB%A1%E6%B1%89%E6%A5%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="项目满汉楼">24 项目：满汉楼</h1><ul><li>登录界面<ul><li>登录（账号、密码）</li><li>退出</li></ul></li><li>菜单界面<ul><li>餐桌状态（显示编号、状态）</li><li>预定餐桌（编号[核对、二次确认]、预定人名字、电话）</li><li>菜单（名称、价格、类别、编号）<ul><li>全部、分类</li></ul></li><li>点餐（桌号[核对]、菜品[核对]、数量）</li><li>账单（按照桌号分组。菜品、数量、金额、桌号、日期、状态）</li><li>结账（桌号、方式、二次确认）</li><li>退出系统</li></ul></li><li>数据库<ul><li>登录用户：login（id、name、password[md5]）</li><li>餐桌状态：table（id、order、seat、customer）</li><li>顾客：customer（id、name、card_id、call）</li><li>菜单：dishes（id、name、price、species、available）</li><li>账单：bill（id、date、customer、num、table、clear、dishes）</li></ul></li></ul><h2 id="代码万民堂">代码：万民堂</h2><del>说是满汉楼，其实是万民堂</del><p><strong>没有优化过，所以健壮性不强。懒得做优化了，反正之前的项目做过了</strong></p><h3 id="数据库">1. 数据库</h3><blockquote><div class="code-wrapper"><pre><code class="hljs awk">mysql:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">3306</span>/wan_min</code></pre></div></blockquote><h4 id="表">表</h4><blockquote><p>以下大部分是润色后的 <code>show create table xxx</code>的返回语句</p></blockquote><h5 id="table餐桌">table（餐桌）</h5><blockquote><p>餐桌号 id（主键）、餐桌状态 order、座数 seat、订餐人 customer</p></blockquote><div class="code-wrapper"><pre><code class="hljs mysql">CREATE TABLE `table` (      `id` smallint(5) unsigned NOT NULL AUTO_INCREMENT ,      `order` enum(&#x27;已预定&#x27;,&#x27;用餐&#x27;,&#x27;空&#x27;,&#x27;不可用&#x27;) COLLATE utf8_bin NOT NULL DEFAULT &#x27;空&#x27;,      `seat` smallint(5) unsigned NOT NULL DEFAULT &#x27;2&#x27;,      `customer` smallint(5) unsigned DEFAULT NULL,      PRIMARY KEY (`id`),      KEY `customer` (`customer`),      CONSTRAINT `table_ibfk_1` FOREIGN KEY (`customer`) REFERENCES `customer` (`id`)    )</code></pre></div><h5 id="dishes菜单">dishes（菜单）</h5><blockquote><p>餐品号 id（主键）、餐品名 name（唯一）、价格 price、分类species、是否可用 available</p></blockquote><div class="code-wrapper"><pre><code class="hljs mysql">CREATE TABLE `dishes` (      `id` smallint(5) unsigned NOT NULL AUTO_INCREMENT,      `name` char(8) COLLATE utf8_bin NOT NULL,      `price` smallint(5) unsigned NOT NULL DEFAULT &#x27;0&#x27;,      `species` enum(&#x27;主食&#x27;,&#x27;主菜&#x27;,&#x27;汤品&#x27;,&#x27;凉菜&#x27;,&#x27;甜点&#x27;,&#x27;饮料&#x27;,&#x27;&#x27;) COLLATE utf8_bin NOT NULL DEFAULT &#x27;&#x27;,      `available` enum(&#x27;y&#x27;,&#x27;n&#x27;) COLLATE utf8_bin NOT NULL DEFAULT &#x27;y&#x27;,      PRIMARY KEY (`id`),      UNIQUE KEY `name` (`name`))</code></pre></div><h5 id="customer客人信息">customer（客人信息）</h5><blockquote><p>顾客ID id（主键）、顾客名字 name、顾客证件号card_id（可为空）、顾客电话 call</p></blockquote><div class="code-wrapper"><pre><code class="hljs mysql">CREATE TABLE `customer` (      `id` smallint(5) unsigned NOT NULL AUTO_INCREMENT,      `name` varchar(12) COLLATE utf8_bin NOT NULL,      `card_id` char(18) COLLATE utf8_bin DEFAULT NULL,      `call` char(11) COLLATE utf8_bin NOT NULL,      PRIMARY KEY (`id`))</code></pre></div><h5 id="login登录验证">login（登录验证）</h5><blockquote><p>系统登录ID id（主键）、系统登录名 name（唯一）、密码 password（md5加密）</p></blockquote><div class="code-wrapper"><pre><code class="hljs mysql">CREATE TABLE `login` (      `id` smallint(5) unsigned NOT NULL AUTO_INCREMENT,      `name` varchar(10) COLLATE utf8_bin NOT NULL,      `password` char(32) COLLATE utf8_bin NOT NULL,      PRIMARY KEY (`id`),      UNIQUE KEY `name` (`name`))</code></pre></div><h5 id="bill订单">bill（订单）</h5><blockquote><p>订单ID id（主键）、日期 date、顾客 customer（外键）、菜品IDid（外键）、菜品数量 num、桌号 table（外键）、结算状态clear（枚举，y现金、alipay支付宝、wcpay微信、n未付）</p></blockquote><div class="code-wrapper"><pre><code class="hljs mysql">CREATE TABLE `bill` (      `id` int(10) unsigned NOT NULL AUTO_INCREMENT,      `date` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,      `customer` smallint(5) unsigned NOT NULL,      `num` smallint(5) unsigned NOT NULL DEFAULT &#x27;1&#x27;,      `table` smallint(5) unsigned NOT NULL,      `clear` enum(&#x27;y&#x27;,&#x27;n&#x27;,&#x27;alipay&#x27;,&#x27;wc_pay&#x27;) COLLATE utf8_bin NOT NULL DEFAULT &#x27;n&#x27;,      `dishes` smallint(5) unsigned NOT NULL,      PRIMARY KEY (`id`),      KEY `customer` (`customer`),      KEY `table` (`table`),      KEY `dishes` (`dishes`),      CONSTRAINT `bill_ibfk_1` FOREIGN KEY (`customer`) REFERENCES `customer` (`id`),      CONSTRAINT `bill_ibfk_2` FOREIGN KEY (`table`) REFERENCES `table` (`id`),      CONSTRAINT `bill_ibfk_3` FOREIGN KEY (`dishes`) REFERENCES `dishes` (`id`))</code></pre></div><h5id="detail_billview查询订单信息">detail_bill（view，查询订单信息）</h5><div class="code-wrapper"><pre><code class="hljs mysql">CREATE VIEW `detail_bill` AS select `customer`.`name` AS `name`,       `customer`.`call` AS `call`,       `bill`.`table` AS `table`,       `dishes`.`name` AS `dishes`,       `bill`.`num` AS `num`,       `bill`.`date` AS `date`,       `bill`.`clear` AS `clear` from `bill` , `customer`, `dishes` where (`bill`.`customer` = `customer`.`id`) and (`bill`.`dishes` = `dishes`.`id`)</code></pre></div><h3 id="java-代码">Java 代码</h3><h4 id="通用部分">通用部分</h4><blockquote><p>以下各包，客户端和服务端各自持有一份，存放在相同目录下。</p></blockquote><h5 id="com.melody.wmt.common">com.melody.wmt.common</h5><h6 id="message.java">Message.java</h6><blockquote><p><em>com.melody.wmt.common.Message.java</em></p><p>信息包。客户端、服务端的通讯依靠发送该包进行</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.wmt.common;<span class="hljs-keyword">import</span> java.io.Serializable;<span class="hljs-keyword">import</span> java.time.Instant;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Message</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;    <span class="hljs-keyword">private</span> String sender;<span class="hljs-comment">//发送者IP</span>    <span class="hljs-keyword">private</span> String receiver;<span class="hljs-comment">//接收者IP</span>    <span class="hljs-keyword">private</span> String word;<span class="hljs-comment">//信息标识</span>    <span class="hljs-keyword">private</span> Object object;<span class="hljs-comment">//信息数据</span>    <span class="hljs-keyword">private</span> Instant timeStamp;<span class="hljs-comment">//信息时间戳</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Message</span><span class="hljs-params">(String sender, String receiver, String word, Object object)</span> &#123;        <span class="hljs-built_in">this</span>.sender = sender;        <span class="hljs-built_in">this</span>.receiver = receiver;        <span class="hljs-built_in">this</span>.word = word;        <span class="hljs-built_in">this</span>.object = object;        timeStamp = Instant.now();    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSender</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> sender;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSender</span><span class="hljs-params">(String sender)</span> &#123;        <span class="hljs-built_in">this</span>.sender = sender;    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getReceiver</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> receiver;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setReceiver</span><span class="hljs-params">(String receiver)</span> &#123;        <span class="hljs-built_in">this</span>.receiver = receiver;    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getWord</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> word;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setWord</span><span class="hljs-params">(String word)</span> &#123;        <span class="hljs-built_in">this</span>.word = word;    &#125;    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getObject</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> object;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setObject</span><span class="hljs-params">(Object object)</span> &#123;        <span class="hljs-built_in">this</span>.object = object;    &#125;    <span class="hljs-keyword">public</span> Instant <span class="hljs-title function_">getTimeStamp</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> timeStamp;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTimeStamp</span><span class="hljs-params">()</span> &#123;        <span class="hljs-built_in">this</span>.timeStamp = Instant.now();    &#125;&#125;</code></pre></div><h6 id="messagetype.java">MessageType.java</h6><blockquote><p><em>com.melody.wmt.common.MessageType.java</em></p><p>信息标识包。通过该包来分析信息包的种类。该包没有方法。</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.wmt.common;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MessageType</span> &#123;    <span class="hljs-comment">/*以下是服务端发送*/</span>    <span class="hljs-type">String</span> <span class="hljs-variable">REJECT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;0&quot;</span>;<span class="hljs-comment">//拒绝请求</span>    <span class="hljs-type">String</span> <span class="hljs-variable">ACCEPT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;A&quot;</span>;<span class="hljs-comment">//通过请求</span>    <span class="hljs-type">String</span> <span class="hljs-variable">LOGIN_USER_NOT_EXIST</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;LUNE&quot;</span>;<span class="hljs-comment">//登录失败：用户不存在</span>    <span class="hljs-type">String</span> <span class="hljs-variable">LOGIN_WRONG_PW</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;LWP&quot;</span>;<span class="hljs-comment">//登陆失败：密码错误</span>    <span class="hljs-type">String</span> <span class="hljs-variable">WRONG_REQUEST</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;WR&quot;</span>;<span class="hljs-comment">//请求无效</span>    <span class="hljs-type">String</span> <span class="hljs-variable">TABLE_NOT_EXIST</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;TNE&quot;</span>;<span class="hljs-comment">//餐桌不存在</span>    <span class="hljs-type">String</span> <span class="hljs-variable">TABLE_OCCUPIED</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;TOP&quot;</span>;<span class="hljs-comment">//餐桌被占用（未点餐）</span>    <span class="hljs-type">String</span> <span class="hljs-variable">TABLE_DINNING</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;TOD&quot;</span>;<span class="hljs-comment">//餐桌被占用（已点餐）</span>    <span class="hljs-type">String</span> <span class="hljs-variable">TABLE_NOT_AVAILABLE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;TNA&quot;</span>;<span class="hljs-comment">//餐桌不可用</span>    <span class="hljs-type">String</span> <span class="hljs-variable">TABLE_AVAILABLE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;TIA&quot;</span>;<span class="hljs-comment">//餐桌为空</span>    <span class="hljs-type">String</span> <span class="hljs-variable">NOT_FOUND</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;NF&quot;</span>;<span class="hljs-comment">//没有找到目标</span>    <span class="hljs-comment">/*以下是客户端发送*/</span>    <span class="hljs-type">String</span> <span class="hljs-variable">LOGIN</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;LGI&quot;</span>;<span class="hljs-comment">//请求登录</span>    <span class="hljs-type">String</span> <span class="hljs-variable">SHOW_TABLES</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;RST&quot;</span>;<span class="hljs-comment">//请求返回餐桌列表</span>    <span class="hljs-type">String</span> <span class="hljs-variable">CHECK_TABLE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;RCT&quot;</span>;<span class="hljs-comment">//请求查询餐桌状态</span>    <span class="hljs-type">String</span> <span class="hljs-variable">ORDER_TABLE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ROT&quot;</span>;<span class="hljs-comment">//请求预定餐桌</span>    <span class="hljs-type">String</span> <span class="hljs-variable">SHOW_DISHES</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;RSD&quot;</span>;<span class="hljs-comment">//请求返回菜单列表</span>    <span class="hljs-type">String</span> <span class="hljs-variable">CHECK_DISHES</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;RCD&quot;</span>;<span class="hljs-comment">//请求查询菜单状态</span>    <span class="hljs-type">String</span> <span class="hljs-variable">ORDER_DISHES</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ROD&quot;</span>;<span class="hljs-comment">//请求订餐</span>    <span class="hljs-type">String</span> <span class="hljs-variable">SHOW_ALL_BILLS</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;RAB&quot;</span>;<span class="hljs-comment">//请求返回账单列表</span>    <span class="hljs-type">String</span> <span class="hljs-variable">CHECK_BILLS</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;RCB&quot;</span>;<span class="hljs-comment">//请求查询账单状态</span>    <span class="hljs-type">String</span> <span class="hljs-variable">FINISH_BILLS</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;RFB&quot;</span>;<span class="hljs-comment">//请求完成账单</span>    <span class="hljs-type">String</span> <span class="hljs-variable">LOGOUT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;LGO&quot;</span>;<span class="hljs-comment">//请求登出</span>&#125;</code></pre></div><h5 id="com.melody.wmt.sql">com.melody.wmt.sql</h5><h6 id="logindata.java">LoginData.java</h6><blockquote><p><em>com.melody.wmt.sql.LoginData.java</em></p><p>登录信息包。该包对应表 <code>login</code> 的记录。</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.wmt.sql;<span class="hljs-keyword">import</span> java.io.Serializable;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginData</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String password;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LoginData</span><span class="hljs-params">()</span>&#123;&#125;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LoginData</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String name, String password)</span> &#123;        <span class="hljs-built_in">this</span>.id = id;        <span class="hljs-built_in">this</span>.name = name;        <span class="hljs-built_in">this</span>.password = password;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;        <span class="hljs-built_in">this</span>.id = id;    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;        <span class="hljs-built_in">this</span>.name = name;    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPassword</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> password;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPassword</span><span class="hljs-params">(String password)</span> &#123;        <span class="hljs-built_in">this</span>.password = password;    &#125;&#125;</code></pre></div><h6 id="tabledata.java">TableData.java</h6><blockquote><p><em>com.melody.wmt.sql.TableData.java</em></p><p>餐桌信息包。该包对应表 <code>table</code> 的记录。</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.wmt.sql;<span class="hljs-keyword">import</span> java.io.Serializable;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TableData</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;    <span class="hljs-keyword">private</span> String order;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> customer;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> seat;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TableData</span><span class="hljs-params">()</span> &#123;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TableData</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String order, <span class="hljs-type">int</span> customer, <span class="hljs-type">int</span> seat)</span> &#123;        <span class="hljs-built_in">this</span>.id = id;        <span class="hljs-built_in">this</span>.order = order;        <span class="hljs-built_in">this</span>.customer = customer;        <span class="hljs-built_in">this</span>.seat = seat;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;        <span class="hljs-built_in">this</span>.id = id;    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getOrder</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> order;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setOrder</span><span class="hljs-params">(String order)</span> &#123;        <span class="hljs-built_in">this</span>.order = order;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCustomer</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> customer;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCustomer</span><span class="hljs-params">(<span class="hljs-type">int</span> customer)</span> &#123;        <span class="hljs-built_in">this</span>.customer = customer;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSeat</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> seat;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSeat</span><span class="hljs-params">(<span class="hljs-type">int</span> seat)</span> &#123;        <span class="hljs-built_in">this</span>.seat = seat;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> id + <span class="hljs-string">&quot;\t&quot;</span> + seat + <span class="hljs-string">&quot;\t&quot;</span> + order + <span class="hljs-string">&quot;\t&quot;</span> + (customer == <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;-&quot;</span> : customer);    &#125;&#125;</code></pre></div><h4 id="服务端部分">服务端部分</h4><h5 id="com.melody.wmt.library">com.melody.wmt.library</h5><blockquote><p>在目录 <em>com.melody.wmt.library</em> 下，配置以下 jar 包：</p><ul><li><p><code>druid-1.2.8.jar</code>：德鲁伊连接池</p></li><li><p><code>mysql-connector-java-8.0.27.jar</code>：MySQL数据库</p></li><li><p><code>commons-dbutils-1.7.jar</code>：Apache-DBUtils</p></li></ul></blockquote><h5 id="com.melody.wmt.server">com.melody.wmt.server</h5><h6 id="server.java">Server.java</h6><blockquote><p>服务端入口</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.wmt.server;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.net.InetAddress;<span class="hljs-keyword">import</span> java.net.ServerSocket;<span class="hljs-keyword">import</span> java.net.Socket;<span class="hljs-keyword">import</span> java.net.UnknownHostException;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String serverIP;    <span class="hljs-comment">/* 多此一举地初始化服务端 IP 地址。其实直接写正确地址也行的 */</span>    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-type">String</span> <span class="hljs-variable">tempIP</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">try</span> &#123;            tempIP = InetAddress.getLocalHost().getHostAddress();        &#125; <span class="hljs-keyword">catch</span> (UnknownHostException e) &#123;            System.out.println(e);            tempIP = <span class="hljs-string">&quot;192.168.3.16&quot;</span>;        &#125; <span class="hljs-keyword">finally</span> &#123;            serverIP = tempIP;        &#125;    &#125;    <span class="hljs-comment">/* 主方法</span><span class="hljs-comment">    持续监听端口，每当有接入时就丢给新的 RunningServer 线程 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">9000</span>);        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;            <span class="hljs-type">Socket</span> <span class="hljs-variable">accept</span> <span class="hljs-operator">=</span> serverSocket.accept();            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RunningServer</span>(accept)).start();        &#125;    &#125;&#125;</code></pre></div><h6 id="runningserver.java">RunningServer.java</h6><blockquote><p>服务端进程主体。由 <em>Server.java</em> 创建。</p><p>该进程能实现：用户登录验证、识别客户端请求</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.wmt.server;<span class="hljs-keyword">import</span> com.melody.wmt.common.Message;<span class="hljs-keyword">import</span> com.melody.wmt.common.MessageType;<span class="hljs-keyword">import</span> com.melody.wmt.sql.LoginData;<span class="hljs-keyword">import</span> java.io.*;<span class="hljs-keyword">import</span> java.net.Socket;<span class="hljs-keyword">import</span> java.time.LocalDateTime;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunningServer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;    <span class="hljs-keyword">private</span> Socket socket;    <span class="hljs-keyword">private</span> ObjectInputStream ois;<span class="hljs-comment">//通信的输入流</span>    <span class="hljs-keyword">private</span> ObjectOutputStream oos;<span class="hljs-comment">//通信的输出流</span>    <span class="hljs-keyword">private</span> String targetIP;<span class="hljs-comment">//通信对象的 IP</span>    <span class="hljs-keyword">private</span> LoginData loginData;<span class="hljs-comment">//通信对象声明的登录对象的信息。</span>    <span class="hljs-comment">//这个信息来自数据库，不一定和通信对象声明的信息匹配</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">running</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//线程运行中。false 的场合线程停止</span>    <span class="hljs-comment">/* 完成一些初始化 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RunningServer</span><span class="hljs-params">(Socket socket)</span> &#123;        <span class="hljs-built_in">this</span>.socket = socket;        <span class="hljs-keyword">try</span> &#123;            ois = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(socket.getInputStream());            oos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(socket.getOutputStream());        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            System.out.println(e);            closeAll();        &#125;        targetIP = socket.getLocalAddress().getHostAddress();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">/* 接收通信对象的登录请求 */</span>            <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> ServerUtils.receiveMessage(ois);            <span class="hljs-comment">/* 获得通信对象声明的登录对象信息。</span><span class="hljs-comment">            这里返回 null 的场合，登录失败 */</span>            loginData = ServerUtils.checkLogin(message);            System.out.println(targetIP + <span class="hljs-string">&quot; 请求登录 &lt;&quot;</span> + message.getObject()+<span class="hljs-string">&quot;&gt;&quot;</span>);            <span class="hljs-comment">/* 登录失败的场合，发送拒绝信息，并关闭所有流 */</span>            <span class="hljs-keyword">if</span> (loginData == <span class="hljs-literal">null</span>) &#123;                ServerUtils.sendRejection(targetIP, oos);                closeAll();                <span class="hljs-keyword">return</span>;            &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">/* 登录成功，发送登录对象信息 */</span>                ServerUtils.sendMessage(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(Server.serverIP, targetIP, MessageType.ACCEPT, loginData), oos);            &#125;            System.out.println(targetIP + <span class="hljs-string">&quot; 登录成功 &quot;</span> + loginData.getName() + LocalDateTime.now());                        <span class="hljs-comment">/* 直到这里，登录成功，正式开始监听客户端请求 */</span>            <span class="hljs-keyword">while</span> (running) &#123;                listeningRequest();            &#125;        <span class="hljs-comment">/* 如果发生任何连接异常，我们中断连接，并关闭所有流 */</span>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            System.out.println(targetIP + <span class="hljs-string">&quot; 连接中断 &quot;</span> + loginData.getName() + LocalDateTime.now());            closeAll();        &#125;    &#125;    <span class="hljs-comment">/* 这个方法是关闭所有流的方法。在关闭连接时会被调用 */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">closeAll</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (ois != <span class="hljs-literal">null</span>) &#123;                ois.close();            &#125;            <span class="hljs-keyword">if</span> (oos != <span class="hljs-literal">null</span>) &#123;                oos.close();            &#125;            <span class="hljs-keyword">if</span> (socket != <span class="hljs-literal">null</span>) &#123;                socket.close();            &#125;        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            System.out.println(e);        &#125;    &#125;    <span class="hljs-comment">/* 这个方法是监听客户端请求的方法。根据不同请求，做出不同反应 */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listeningRequest</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">/* 监听请求 */</span>        <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> ServerUtils.receiveMessage(ois);        <span class="hljs-comment">/* 检查收到的数据包的信息标识 */</span>        <span class="hljs-type">String</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> message.getWord();        <span class="hljs-comment">/* 创建将要发送的数据包。此时，该包还是空的 */</span>        <span class="hljs-type">Message</span> <span class="hljs-variable">toSend</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(Server.serverIP, targetIP, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);        <span class="hljs-comment">/* 检查一下接收的数据包的用户信息。有任何问题的话我们就发送请求错误包 */</span>        <span class="hljs-comment">/* ……在这里解释一下：客户发送的数据包里，主要包含以下信息：</span><span class="hljs-comment">        1. getWord() 返回数据包标识。客户端的任何请求会对应不同的标识</span><span class="hljs-comment">        2. getObject() 一定包含一条 String 语句。该语句被转义字符 \t 分为几个部分。</span><span class="hljs-comment">        第一部分一定是用户名、第二部分一定是用户密码。</span><span class="hljs-comment">        根据请求需要，也会有更多其他部分 */</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (!ServerUtils.checkUser((String) message.getObject(), loginData)) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            System.out.println(e);            toSend.setWord(MessageType.WRONG_REQUEST);            ServerUtils.sendMessage(toSend, oos);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">/* 下面，根据不同信息包标识，我们做出不同反应 */</span>        <span class="hljs-comment">/* 接收到返回餐桌列表的请求 */</span>        <span class="hljs-keyword">if</span> (request.equals(MessageType.SHOW_TABLES)) &#123;            ServerUtils.showTables(toSend, oos);        <span class="hljs-comment">/* 接收到检查餐桌的请求 */</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (request.equals(MessageType.CHECK_TABLE)) &#123;            ServerUtils.checkTable(message, toSend, oos);        <span class="hljs-comment">/* 接收到预定餐桌的请求 */</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (request.equals(MessageType.ORDER_TABLE)) &#123;            ServerUtils.orderTable(message, toSend, oos);        <span class="hljs-comment">/* 接收到返回菜单列表的请求 */</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (request.equals(MessageType.SHOW_DISHES)) &#123;            ServerUtils.showDishes(toSend, oos);        <span class="hljs-comment">/* 接收到检查菜单的请求 */</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (request.equals(MessageType.CHECK_DISHES)) &#123;            ServerUtils.checkDishes(message, toSend, oos);        <span class="hljs-comment">/* 接收到点餐的请求 */</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (request.equals(MessageType.ORDER_DISHES)) &#123;            ServerUtils.orderDishes(message, toSend, oos);        <span class="hljs-comment">/* 接收到返回账单列表的请求 */</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (request.equals(MessageType.SHOW_ALL_BILLS)) &#123;            ServerUtils.showBills(toSend, oos);        <span class="hljs-comment">/* 接收到检查账单的请求 */</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (request.equals(MessageType.CHECK_BILLS)) &#123;            ServerUtils.checkBills(message, toSend, oos);        <span class="hljs-comment">/* 接收到结账的请求 */</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (request.equals(MessageType.FINISH_BILLS)) &#123;            ServerUtils.finishBills(message, toSend, oos);        <span class="hljs-comment">/* 接收到登出的请求 */</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (request.equals(MessageType.LOGOUT)) &#123;            System.out.println(targetIP + <span class="hljs-string">&quot; 登出 &quot;</span> + loginData.getName() + LocalDateTime.now());            running = <span class="hljs-literal">false</span>;            closeAll();        &#125;    &#125;&#125;</code></pre></div><h6 id="serverutils.java">ServerUtils.java</h6><blockquote><p>服务端进程方法包。由 <em>RunningServer.java</em> 调用</p><p>该包实现：监听客户端数据包、发送数据包、处理（各种）客户端请求</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.wmt.server;<span class="hljs-keyword">import</span> com.melody.wmt.common.Message;<span class="hljs-keyword">import</span> com.melody.wmt.common.MessageType;<span class="hljs-keyword">import</span> com.melody.wmt.sql.*;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.ObjectInputStream;<span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerUtils</span> &#123;    <span class="hljs-comment">/* 监听客户端发送的数据包 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Message <span class="hljs-title function_">receiveMessage</span><span class="hljs-params">(ObjectInputStream ois)</span> &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> (Message) ois.readObject();            <span class="hljs-keyword">return</span> message;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            System.out.println(e);            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125;    &#125;    <span class="hljs-comment">/* 发送登录失败回执。这个方法其实可以优化掉 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">sendRejection</span><span class="hljs-params">(String target, ObjectOutputStream oos)</span> &#123;        <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(Server.serverIP, target, MessageType.REJECT, <span class="hljs-literal">null</span>);        <span class="hljs-keyword">try</span> &#123;            oos.writeObject(message);            oos.flush();            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            System.out.println(e);            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    &#125;    <span class="hljs-comment">/* 检查用户信息。实际上就是检查用户名 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkUser</span><span class="hljs-params">(String user, LoginData loginData)</span> &#123;        <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        String[] toCheck = user.split(<span class="hljs-string">&quot;\t&quot;</span>);        <span class="hljs-keyword">if</span> (toCheck[<span class="hljs-number">0</span>].equals(loginData.getName())) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginDAO</span>().checkLogin(toCheck[<span class="hljs-number">0</span>], toCheck[<span class="hljs-number">1</span>]) != <span class="hljs-literal">null</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    &#125;    <span class="hljs-comment">/* 检查登录信息。登录成功则返回从数据库得到的登录信息包，否则返回 null */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LoginData <span class="hljs-title function_">checkLogin</span><span class="hljs-params">(Message message)</span> &#123;        <span class="hljs-keyword">if</span> (message == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125;        <span class="hljs-type">String</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> message.getWord();        <span class="hljs-keyword">if</span> (word == <span class="hljs-literal">null</span> || !word.equals(MessageType.LOGIN)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125;        <span class="hljs-keyword">try</span> &#123;            word = (String) message.getObject();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            System.out.println(e);            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125;        String[] data = word.split(<span class="hljs-string">&quot;\t&quot;</span>);        <span class="hljs-keyword">if</span> (data.length != <span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginDAO</span>().checkLogin(data[<span class="hljs-number">0</span>], data[<span class="hljs-number">1</span>]);    &#125;    <span class="hljs-comment">/* 发送数据包给客户端。很多方法会调用这个方法。这个方法也会刷新数据包时间戳 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(Message toSend, ObjectOutputStream oos)</span> &#123;        <span class="hljs-keyword">try</span> &#123;            Thread.currentThread().sleep(<span class="hljs-number">300</span>);<span class="hljs-comment">//人为加入 0.3 秒发送延迟</span>            toSend.setTimeStamp();<span class="hljs-comment">//刷新数据包时间戳</span>            oos.writeObject(toSend);            oos.flush();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            System.out.println(e);        &#125;    &#125;    <span class="hljs-comment">/* 返回餐桌列表 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showTables</span><span class="hljs-params">(Message toSend, ObjectOutputStream oos)</span> &#123;        <span class="hljs-comment">/* 调用方法得到餐桌列表 */</span>        List&lt;TableData&gt; tableData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TableDAO</span>().queryAll();        <span class="hljs-comment">/* 将餐桌列表转化成字符串。发送时只发送这个字符串 */</span>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();        <span class="hljs-keyword">for</span> (TableData data : tableData) &#123;            sb.append(data);            sb.append(<span class="hljs-string">&quot;\n&quot;</span>);        &#125;        toSend.setObject(sb.toString());        <span class="hljs-comment">/* 设置数据包标识为请求通过 */</span>        toSend.setWord(MessageType.ACCEPT);        <span class="hljs-comment">/* 发送数据包 */</span>        sendMessage(toSend, oos);    &#125;    <span class="hljs-comment">/* 检查餐桌</span><span class="hljs-comment">    ……这是因为：用户点餐、预定餐桌等场合，需要验证输入的餐桌信息 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkTable</span><span class="hljs-params">(Message receive, Message toSend, ObjectOutputStream oos)</span> &#123;        <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">/* 检查用户请求的餐桌号 */</span>            <span class="hljs-type">int</span> <span class="hljs-variable">table</span> <span class="hljs-operator">=</span> Integer.parseInt(((String) receive.getObject()).split(<span class="hljs-string">&quot;\t&quot;</span>)[<span class="hljs-number">2</span>]);            <span class="hljs-type">TableData</span> <span class="hljs-variable">tableData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TableDAO</span>().queryTable(table);            <span class="hljs-comment">/* 下面是根据返回结果，为数据包添加标识语句，并装入查到的餐桌数据 */</span>            <span class="hljs-keyword">if</span> (tableData == <span class="hljs-literal">null</span>) &#123;                toSend.setWord(MessageType.TABLE_NOT_EXIST);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tableData.getOrder().equals(<span class="hljs-string">&quot;不可用&quot;</span>)) &#123;                toSend.setObject(tableData);                toSend.setWord(MessageType.TABLE_NOT_AVAILABLE);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tableData.getOrder().equals(<span class="hljs-string">&quot;已预定&quot;</span>)) &#123;                toSend.setObject(tableData);                toSend.setWord(MessageType.TABLE_OCCUPIED);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tableData.getOrder().equals(<span class="hljs-string">&quot;用餐&quot;</span>)) &#123;                toSend.setObject(tableData);                toSend.setWord(MessageType.TABLE_DINNING);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tableData.getOrder().equals(<span class="hljs-string">&quot;空&quot;</span>)) &#123;                toSend.setObject(tableData);                toSend.setWord(MessageType.TABLE_AVAILABLE);            &#125; <span class="hljs-keyword">else</span> &#123;                toSend.setWord(MessageType.REJECT);            &#125;        <span class="hljs-comment">/* 发生任何异常的场合，设置拒绝请求的标识语句 */</span>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            toSend.setWord(MessageType.REJECT);        <span class="hljs-comment">/* 最终一定发送数据包 */</span>        &#125; <span class="hljs-keyword">finally</span> &#123;            sendMessage(toSend, oos);        &#125;    &#125;    <span class="hljs-comment">/* 预定餐桌 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">orderTable</span><span class="hljs-params">(Message receive, Message toSend, ObjectOutputStream oos)</span> &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">/* 前面说过。接收数据包含有一条被 \t 分隔为不同部分的语句。</span><span class="hljs-comment">            这里：第三部分代表餐桌号，第四部分代表顾客名，第五部分代表顾客电话*/</span>            String[] mess = ((String) receive.getObject()).split(<span class="hljs-string">&quot;\t&quot;</span>);            <span class="hljs-type">int</span> <span class="hljs-variable">table</span> <span class="hljs-operator">=</span> Integer.parseInt(mess[<span class="hljs-number">2</span>]);            <span class="hljs-type">String</span> <span class="hljs-variable">customerName</span> <span class="hljs-operator">=</span> mess[<span class="hljs-number">3</span>];            <span class="hljs-type">String</span> <span class="hljs-variable">call</span> <span class="hljs-operator">=</span> mess[<span class="hljs-number">4</span>];            <span class="hljs-type">CustomerDAO</span> <span class="hljs-variable">customerDAO</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomerDAO</span>();            <span class="hljs-comment">/* 根据接收的顾客信息（姓名、电话）对数据库进行查询，看看有没有这个人</span><span class="hljs-comment">            这里，customer &gt; 0 的场合代表有这个人 */</span>            <span class="hljs-type">int</span> <span class="hljs-variable">customer</span> <span class="hljs-operator">=</span> customerDAO.searchCustomer(customerName, call);            <span class="hljs-comment">/* 没有这个信息的场合，创建这个顾客信息 */</span>            <span class="hljs-keyword">if</span> (customer &lt; <span class="hljs-number">0</span>) &#123;                customerDAO.createCustomer(customerName, call);                customer = customerDAO.searchCustomer(customerName, call);            &#125;            <span class="hljs-comment">/* 通常到这里不会出现查无此人的情况。如果出现，说明创建信息失败 */</span>            <span class="hljs-keyword">if</span> (customer &lt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();            &#125;            <span class="hljs-comment">/* 到这里，我们进行预定餐桌操作。返回 true 表示成功 */</span>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">TableDAO</span>().orderTable(table, customer)) &#123;                toSend.setWord(MessageType.ACCEPT);            &#125; <span class="hljs-keyword">else</span> &#123;                toSend.setWord(MessageType.REJECT);            &#125;        <span class="hljs-comment">/* 出现任何问题，我们设置请求拒绝标识符 */</span>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            toSend.setWord(MessageType.REJECT);        <span class="hljs-comment">/* 最终一定发送数据包 */</span>        &#125; <span class="hljs-keyword">finally</span> &#123;            sendMessage(toSend, oos);        &#125;    &#125;    <span class="hljs-comment">/* 返回菜单列表 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showDishes</span><span class="hljs-params">(Message toSend, ObjectOutputStream oos)</span> &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">/* 首先获取菜单列表 */</span>            List&lt;DishesData&gt; dishes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DishesDAO</span>().getDishes();            <span class="hljs-comment">/* 接下来，把菜单列表转化为字符串 */</span>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">staple</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">mainDishes</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">coldDishes</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">beverage</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">soup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sweetmeats</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();            <span class="hljs-keyword">for</span> (DishesData d : dishes) &#123;                <span class="hljs-keyword">if</span> (d.getAvailable().equals(<span class="hljs-string">&quot;n&quot;</span>)) &#123;                    <span class="hljs-keyword">continue</span>;                &#125;                <span class="hljs-type">String</span> <span class="hljs-variable">spec</span> <span class="hljs-operator">=</span> d.getSpecies();                <span class="hljs-keyword">if</span> (spec.equals(<span class="hljs-string">&quot;主食&quot;</span>)) &#123;                    staple.append(d);                    staple.append(<span class="hljs-string">&quot;\n&quot;</span>);                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (spec.equals(<span class="hljs-string">&quot;甜点&quot;</span>)) &#123;                    sweetmeats.append(d);                    sweetmeats.append(<span class="hljs-string">&quot;\n&quot;</span>);                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (spec.equals(<span class="hljs-string">&quot;汤品&quot;</span>)) &#123;                    soup.append(d);                    soup.append(<span class="hljs-string">&quot;\n&quot;</span>);                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (spec.equals(<span class="hljs-string">&quot;凉菜&quot;</span>)) &#123;                    coldDishes.append(d);                    coldDishes.append(<span class="hljs-string">&quot;\n&quot;</span>);                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (spec.equals(<span class="hljs-string">&quot;饮料&quot;</span>)) &#123;                    beverage.append(d);                    beverage.append(<span class="hljs-string">&quot;\n&quot;</span>);                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (spec.equals(<span class="hljs-string">&quot;主菜&quot;</span>)) &#123;                    mainDishes.append(d);                    mainDishes.append(<span class="hljs-string">&quot;\n&quot;</span>);                &#125;            &#125;            <span class="hljs-comment">/* 合并字符串，以 ### 间隔不同种类 */</span>            <span class="hljs-type">String</span> <span class="hljs-variable">allDishes</span> <span class="hljs-operator">=</span> String.join(<span class="hljs-string">&quot;###&quot;</span>, staple, mainDishes, coldDishes, soup, sweetmeats, beverage);            <span class="hljs-comment">/* 装填数据包 */</span>            toSend.setWord(MessageType.ACCEPT);            toSend.setObject(allDishes);        <span class="hljs-comment">/* 出了问题就设置拒绝请求标识符 */</span>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            toSend.setWord(MessageType.REJECT);        <span class="hljs-comment">/* 最终一定发送数据包 */</span>        &#125; <span class="hljs-keyword">finally</span> &#123;            sendMessage(toSend, oos);        &#125;    &#125;    <span class="hljs-comment">/* 检查菜单。和检查餐桌是一个道理 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkDishes</span><span class="hljs-params">(Message receive, Message toSend, ObjectOutputStream oos)</span> &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">/* 前面说过。接收数据包含有一条被 \t 分隔为不同部分的语句。</span><span class="hljs-comment">            这里：第三部分代表查询菜品的 ID */</span>            String[] mess = ((String) receive.getObject()).split(<span class="hljs-string">&quot;\t&quot;</span>);            <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> Integer.parseInt(mess[<span class="hljs-number">2</span>]);            <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DishesDAO</span>().checkDishes(id);            <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;                toSend.setWord(MessageType.NOT_FOUND);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> DishesData)) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();            &#125; <span class="hljs-keyword">else</span> &#123;                toSend.setWord(MessageType.ACCEPT);                toSend.setObject(o.toString());            &#125;        <span class="hljs-comment">/* 出现任何问题就设置请求拒绝标识符 */</span>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException e) &#123;            toSend.setWord(MessageType.REJECT);        <span class="hljs-comment">/* 最终一定发送数据包 */</span>        &#125; <span class="hljs-keyword">finally</span> &#123;            sendMessage(toSend, oos);        &#125;    &#125;    <span class="hljs-comment">/* 点餐 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">orderDishes</span><span class="hljs-params">(Message receive, Message toSend, ObjectOutputStream oos)</span> &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">/* 前面说过……反正前面说过这个 String 的事！</span><span class="hljs-comment">            这里：第三部分是菜品 ID，第四部分是数量，</span><span class="hljs-comment">            第五部分是桌号，第六部分是顾客号 */</span>            String[] mess = ((String) receive.getObject()).split(<span class="hljs-string">&quot;\t&quot;</span>);            <span class="hljs-type">int</span> <span class="hljs-variable">dishes</span> <span class="hljs-operator">=</span> Integer.parseInt(mess[<span class="hljs-number">2</span>]);            <span class="hljs-comment">/* 检查一下菜品是不是正确 */</span>            <span class="hljs-comment">/* 这里有一处疏忽。应该一并检查是否菜品可用（available） */</span>            <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DishesDAO</span>().checkDishes(dishes);            <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> DishesData)) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();            &#125;            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> Integer.parseInt(mess[<span class="hljs-number">3</span>]);            <span class="hljs-type">int</span> <span class="hljs-variable">table</span> <span class="hljs-operator">=</span> Integer.parseInt(mess[<span class="hljs-number">4</span>]);            <span class="hljs-type">int</span> <span class="hljs-variable">customer</span> <span class="hljs-operator">=</span> Integer.parseInt(mess[<span class="hljs-number">5</span>]);            <span class="hljs-comment">/* 尝试点餐 */</span>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">BillDAO</span>().order(dishes, num, table, customer)) &#123;                <span class="hljs-keyword">new</span> <span class="hljs-title class_">TableDAO</span>().updateTable(table, <span class="hljs-number">2</span>);                toSend.setWord(MessageType.ACCEPT);            &#125; <span class="hljs-keyword">else</span> &#123;                toSend.setWord(MessageType.REJECT);            &#125;        <span class="hljs-comment">/* 出现任何问题就设置请求拒绝标识符 */</span>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException e) &#123;            toSend.setWord(MessageType.REJECT);        <span class="hljs-comment">/* 最终一定发送数据包 */</span>        &#125; <span class="hljs-keyword">finally</span> &#123;            sendMessage(toSend, oos);        &#125;    &#125;    <span class="hljs-comment">/* 返回账单列表 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showBills</span><span class="hljs-params">(Message toSend, ObjectOutputStream oos)</span> &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">/* 和之前的方法一样。这里我们发送的是拼接起来的字符串 */</span>            List&lt;DetailBillData&gt; billData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BillDAO</span>().queryBills();            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">finished</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">unfinished</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();            <span class="hljs-keyword">for</span> (DetailBillData d : billData) &#123;                <span class="hljs-keyword">if</span> (d.getClear().equals(<span class="hljs-string">&quot;n&quot;</span>)) &#123;                    unfinished.append(d);                    unfinished.append(<span class="hljs-string">&quot;\n&quot;</span>);                &#125; <span class="hljs-keyword">else</span> &#123;                    finished.append(d);                    finished.append(<span class="hljs-string">&quot;\n&quot;</span>);                &#125;            &#125;            toSend.setWord(MessageType.ACCEPT);            toSend.setObject(String.join(<span class="hljs-string">&quot;###&quot;</span>, finished, unfinished));        <span class="hljs-comment">/* 出现任何问题就设置请求拒绝标识符 */</span>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            toSend.setWord(MessageType.REJECT);        <span class="hljs-comment">/* 最终一定发送数据包 */</span>        &#125; <span class="hljs-keyword">finally</span> &#123;            sendMessage(toSend, oos);        &#125;    &#125;    <span class="hljs-comment">/* 检查订单 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkBills</span><span class="hljs-params">(Message receive, Message toSend, ObjectOutputStream oos)</span> &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">/* ……这里：第三部分是一个标识符。T 表示按桌号查找</span><span class="hljs-comment">            第四部分是序号。按桌号查找的话，就代表桌号</span><span class="hljs-comment">            第五部分是一个布尔值句子。true 表示查询已付订单，</span><span class="hljs-comment">            false 是未付订单。为空表示查询所有订单 */</span>            String[] mess = ((String) receive.getObject()).split(<span class="hljs-string">&quot;\t&quot;</span>);            List&lt;DetailBillData&gt; billData = <span class="hljs-literal">null</span>;            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();            <span class="hljs-keyword">if</span> (mess[<span class="hljs-number">2</span>].equals(<span class="hljs-string">&quot;t&quot;</span>) || mess[<span class="hljs-number">2</span>].equals(<span class="hljs-string">&quot;T&quot;</span>)) &#123;                Boolean clear;                <span class="hljs-keyword">if</span> (mess.length &lt; <span class="hljs-number">5</span>) &#123;                    clear = <span class="hljs-literal">null</span>;                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mess[<span class="hljs-number">4</span>].equals(<span class="hljs-string">&quot;true&quot;</span>)) &#123;                    clear = <span class="hljs-literal">true</span>;                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mess[<span class="hljs-number">4</span>].equals(<span class="hljs-string">&quot;false&quot;</span>)) &#123;                    clear = <span class="hljs-literal">false</span>;                &#125; <span class="hljs-keyword">else</span> &#123;                    clear = <span class="hljs-literal">null</span>;                &#125;                billData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BillDAO</span>().queryBillsByTable(Integer.parseInt(mess[<span class="hljs-number">3</span>]), clear);            &#125;            <span class="hljs-comment">/* 同样的，还是返回字符串 */</span>            <span class="hljs-keyword">for</span> (DetailBillData data : billData) &#123;                sb.append(billData);                sb.append(<span class="hljs-string">&quot;\n&quot;</span>);            &#125;            toSend.setObject(sb.toString());            toSend.setWord(MessageType.ACCEPT);        <span class="hljs-comment">/* 出现任何问题就设置请求拒绝标识符 */</span>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            toSend.setWord(MessageType.REJECT);        <span class="hljs-comment">/* 最终一定发送数据包 */</span>        &#125; <span class="hljs-keyword">finally</span> &#123;            sendMessage(toSend, oos);        &#125;    &#125;    <span class="hljs-comment">/* 结算订单 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finishBills</span><span class="hljs-params">(Message receive, Message toSend, ObjectOutputStream oos)</span> &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">/* 第三位是桌号，第四位是结算方法 */</span>             String[] mess = ((String) receive.getObject()).split(<span class="hljs-string">&quot;\t&quot;</span>);            <span class="hljs-type">int</span> <span class="hljs-variable">table</span> <span class="hljs-operator">=</span> Integer.parseInt(mess[<span class="hljs-number">2</span>]);            <span class="hljs-type">int</span> <span class="hljs-variable">way</span> <span class="hljs-operator">=</span> Integer.parseInt(mess[<span class="hljs-number">3</span>]);            <span class="hljs-comment">/* 不光更新订单信息，也要把指定餐桌重置为空 */</span>            <span class="hljs-type">boolean</span> <span class="hljs-variable">finish</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BillDAO</span>().finishBill(table, way) &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">new</span> <span class="hljs-title class_">TableDAO</span>().clearTable(table);            toSend.setWord(finish ? MessageType.ACCEPT : MessageType.REJECT);        <span class="hljs-comment">/* 出现任何问题就设置请求拒绝标识符 */</span>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            toSend.setWord(MessageType.REJECT);        <span class="hljs-comment">/* 最终一定发送数据包 */</span>        &#125; <span class="hljs-keyword">finally</span> &#123;            sendMessage(toSend, oos);        &#125;    &#125;&#125;</code></pre></div><h5 id="com.melody.wmt.sql-1">com.melody.wmt.sql</h5><h6 id="wanminsql.properties">WanMinSQL.properties</h6><blockquote><p>数据库配置文件</p><p>里面的密码填自己的。另外，其实上一篇笔记里故意漏的密码是假的。</p></blockquote><div class="code-wrapper"><pre><code class="hljs java">driverClassName=com.mysql.cj.jdbc.Driverurl=jdbc:mysql:<span class="hljs-comment">//localhost:3306/wan_min</span>username=rootpassword=******initialSize=<span class="hljs-number">10</span>minIdle=<span class="hljs-number">5</span>maxActive=<span class="hljs-number">50</span>maxWait=<span class="hljs-number">5000</span></code></pre></div><h6 id="basicdao.java">BasicDAO.java</h6><blockquote><p><strong><em>——详见 [<ahref="../../../../../../2022/02/20/Java/入门阶段/23%20JDBC%20%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/#23-9-BasicDAO">23.9BasicDAO</a>]</em></strong></p><p>代码和上面说的是一样的……大概？</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.wmt.sql;<span class="hljs-keyword">import</span> org.apache.commons.dbutils.QueryRunner;<span class="hljs-keyword">import</span> org.apache.commons.dbutils.handlers.BeanHandler;<span class="hljs-keyword">import</span> org.apache.commons.dbutils.handlers.BeanListHandler;<span class="hljs-keyword">import</span> org.apache.commons.dbutils.handlers.ScalarHandler;<span class="hljs-keyword">import</span> java.sql.Connection;<span class="hljs-keyword">import</span> java.sql.SQLException;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicDAO</span>&lt;T&gt; &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">QueryRunner</span> <span class="hljs-variable">queryRunner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryRunner</span>();    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">update</span><span class="hljs-params">(String sql, Object... parameters)</span>&#123;        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">try</span> &#123;            connection = JDBCUtil.connect();            <span class="hljs-keyword">return</span> queryRunner.update(connection, sql, parameters);        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);        &#125; <span class="hljs-keyword">finally</span> &#123;            JDBCUtil.close(connection, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);        &#125;    &#125;    <span class="hljs-keyword">public</span> List&lt;T&gt; <span class="hljs-title function_">queryMulti</span><span class="hljs-params">(Class&lt;T&gt; tClass, String sql, Object... parameters)</span> &#123;        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">try</span> &#123;            connection = JDBCUtil.connect();            <span class="hljs-keyword">return</span> queryRunner.query(connection, sql, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanListHandler</span>&lt;&gt;(tClass), parameters);        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);        &#125; <span class="hljs-keyword">finally</span> &#123;            JDBCUtil.close(connection, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);        &#125;    &#125;    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">querySingle</span><span class="hljs-params">(Class&lt;T&gt; tClass, String sql, Object... parameters)</span> &#123;        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">try</span> &#123;            connection = JDBCUtil.connect();            <span class="hljs-keyword">return</span> queryRunner.query(connection, sql, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanHandler</span>&lt;&gt;(tClass), parameters);        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);        &#125; <span class="hljs-keyword">finally</span> &#123;            JDBCUtil.close(connection, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);        &#125;    &#125;    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">queryScalar</span><span class="hljs-params">(String sql, Object... parameters)</span> &#123;        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">try</span> &#123;            connection = JDBCUtil.connect();            <span class="hljs-keyword">return</span> queryRunner.query(connection, sql, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScalarHandler</span>&lt;&gt;(), parameters);        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);        &#125; <span class="hljs-keyword">finally</span> &#123;            JDBCUtil.close(connection, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);        &#125;    &#125;&#125;</code></pre></div><h6 id="jdbcutil.java">JDBCUtil.java</h6><blockquote><p><strong><em>——见 [<ahref="../../../../../../2022/02/20/Java/入门阶段/23%20JDBC%20%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/#23-7-2-Druid%EF%BC%88%E5%BE%B7%E9%B2%81%E4%BC%8A%EF%BC%89%E8%BF%9E%E6%8E%A5%E6%B1%A0">23.7.2Druid（德鲁伊）连接池</a> ]</em></strong></p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.wmt.sql;<span class="hljs-keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;<span class="hljs-keyword">import</span> javax.sql.DataSource;<span class="hljs-keyword">import</span> java.io.FileReader;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.sql.Connection;<span class="hljs-keyword">import</span> java.sql.ResultSet;<span class="hljs-keyword">import</span> java.sql.SQLException;<span class="hljs-keyword">import</span> java.sql.Statement;<span class="hljs-keyword">import</span> java.util.Properties;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JDBCUtil</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();        <span class="hljs-keyword">try</span> &#123;            properties.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;src\\com\\melody\\wmt\\sql\\WanMinSQL.properties&quot;</span>));            dataSource = DruidDataSourceFactory.createDataSource(properties);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">connect</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;        <span class="hljs-keyword">return</span> dataSource.getConnection();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">(Connection c, Statement s, ResultSet r)</span> &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span>) &#123;                c.close();            &#125;            <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>) &#123;                r.close();            &#125;            <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>) &#123;                s.close();            &#125;        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);        &#125;    &#125;&#125;</code></pre></div><h6 id="tabledao.javatabledata.java">TableDAO.java、TableData.java</h6><blockquote><p>对应数据库的 <em>table</em> 表</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.wmt.sql;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TableDAO</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BasicDAO</span>&#123;    <span class="hljs-comment">/* 返回全部的餐桌对象 */</span>    <span class="hljs-keyword">public</span> List&lt;TableData&gt; <span class="hljs-title function_">queryAll</span><span class="hljs-params">()</span>&#123;        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from `table`&quot;</span>;        List&lt;TableData&gt; list = queryMulti(TableData.class, sql);        <span class="hljs-keyword">return</span> list;    &#125;    <span class="hljs-comment">/* 返回 ID 指定的餐桌对象。没找到的场合返回 null */</span>    <span class="hljs-keyword">public</span> TableData <span class="hljs-title function_">queryTable</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from `table` where `id` = ?&quot;</span>;        <span class="hljs-type">TableData</span> <span class="hljs-variable">tableData</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">try</span> &#123;            tableData = (TableData) querySingle(TableData.class, sql, id);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125;        <span class="hljs-keyword">return</span> tableData;    &#125;    <span class="hljs-comment">/* 设置指定 ID 的餐桌对象的 order 和 customer */</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">orderTable</span><span class="hljs-params">(<span class="hljs-type">int</span> id, <span class="hljs-type">int</span> customer)</span> &#123;        <span class="hljs-type">TableData</span> <span class="hljs-variable">tableData</span> <span class="hljs-operator">=</span> queryTable(id);        <span class="hljs-keyword">if</span> (!tableData.getOrder().equals(<span class="hljs-string">&quot;空&quot;</span>))&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update `table` set `order` = &#x27;已预定&#x27;, `customer` = ? where `id` = ?&quot;</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">update</span> <span class="hljs-operator">=</span> update(sql, customer, id);        <span class="hljs-keyword">return</span> update &gt; <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">/* 更新指定 ID 餐桌对象的 order 状态。一般是把 已预定 状态改为 用餐 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">updateTable</span><span class="hljs-params">(<span class="hljs-type">int</span> id, <span class="hljs-type">int</span> n)</span> &#123;        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update `table` set `order` = ? where `id` = ?&quot;</span>;        <span class="hljs-type">String</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">switch</span> (n)&#123;            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:                order = <span class="hljs-string">&quot;已预定&quot;</span>;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:                order = <span class="hljs-string">&quot;用餐&quot;</span>;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:                order = <span class="hljs-string">&quot;空&quot;</span>;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:                order = <span class="hljs-string">&quot;不可用&quot;</span>;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">default</span>:                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">return</span> update(sql, order, id) &gt; <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">/* 清理指定 ID 的餐桌。通常是结账后调用这个方法 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">clearTable</span><span class="hljs-params">(<span class="hljs-type">int</span> table)</span> &#123;        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update `table` set `order` = &#x27;空&#x27;, `customer` = null where `id` = ?&quot;</span>;        <span class="hljs-keyword">return</span> update(sql, table) &gt; <span class="hljs-number">0</span>;    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.wmt.sql;<span class="hljs-keyword">import</span> java.io.Serializable;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TableData</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;    <span class="hljs-keyword">private</span> String order;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> customer;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> seat;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TableData</span><span class="hljs-params">()</span> &#123;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TableData</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String order, <span class="hljs-type">int</span> customer, <span class="hljs-type">int</span> seat)</span> &#123;        <span class="hljs-built_in">this</span>.id = id;        <span class="hljs-built_in">this</span>.order = order;        <span class="hljs-built_in">this</span>.customer = customer;        <span class="hljs-built_in">this</span>.seat = seat;    &#125;    <span class="hljs-comment">/* 省略了 getter 和 setter。实际代码里是有的 */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> id + <span class="hljs-string">&quot;\t&quot;</span> + seat + <span class="hljs-string">&quot;\t&quot;</span> + order + <span class="hljs-string">&quot;\t&quot;</span> + (customer == <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;-&quot;</span> : customer);    &#125;&#125;</code></pre></div><h6 id="logindao.javalogindata.java">LoginDAO.java、LoginData.java</h6><blockquote><p>对应数据库的 <em>Login</em> 表</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.wmt.sql;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginDAO</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BasicDAO</span>&#123;    <span class="hljs-comment">/* 返回指定 name 和 password 的对象。没有匹配项则返回 null */</span>    <span class="hljs-keyword">public</span> LoginData <span class="hljs-title function_">checkLogin</span><span class="hljs-params">(String name, String password)</span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">/* 这里体现出，密码是由 md5 方法加密的 */</span>            <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from login where name = ? and password = md5(?)&quot;</span>;            <span class="hljs-type">LoginData</span> <span class="hljs-variable">loginData</span> <span class="hljs-operator">=</span> (LoginData) querySingle(LoginData.class, sql, name, password);            <span class="hljs-keyword">return</span> loginData;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125;    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginData</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String password;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LoginData</span><span class="hljs-params">()</span>&#123;&#125;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LoginData</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String name, String password)</span> &#123;        <span class="hljs-built_in">this</span>.id = id;        <span class="hljs-built_in">this</span>.name = name;        <span class="hljs-built_in">this</span>.password = password;    &#125;    <span class="hljs-comment">/* 省略了 getter 和 setter。实际代码里是有的 */</span>&#125;</code></pre></div><h6id="dishesdao.javadishesdata.java">DishesDAO.java、DishesData.java</h6><blockquote><p>对应数据库的 <em>Dishes</em> 表</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.wmt.sql;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DishesDAO</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BasicDAO</span>&#123;    <span class="hljs-comment">/* 返回所有菜单 */</span>    <span class="hljs-keyword">public</span> List&lt;DishesData&gt; <span class="hljs-title function_">getDishes</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from `dishes`&quot;</span>;        <span class="hljs-keyword">return</span> queryMulti(DishesData.class, sql);    &#125;    <span class="hljs-comment">/* 返回 ID 指定的菜单。没有则返回 null */</span>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">checkDishes</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from `dishes` where `id` = ?&quot;</span>;        <span class="hljs-keyword">return</span> querySingle(DishesData.class, sql, id);    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DishesData</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> price;    <span class="hljs-keyword">private</span> String species;    <span class="hljs-keyword">private</span> String available;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DishesData</span><span class="hljs-params">()</span>&#123;&#125;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DishesData</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String name, <span class="hljs-type">int</span> price, String species, String available)</span> &#123;        <span class="hljs-built_in">this</span>.id = id;        <span class="hljs-built_in">this</span>.name = name;        <span class="hljs-built_in">this</span>.price = price;        <span class="hljs-built_in">this</span>.species = species;        <span class="hljs-built_in">this</span>.available = available;    &#125;    <span class="hljs-comment">/* 省略了 getter 和 setter。实际代码里是有的 */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> id + <span class="hljs-string">&quot;\t&quot;</span> + name + <span class="hljs-string">&quot;\t&quot;</span> + price;    &#125;&#125;</code></pre></div><h6id="customerdao.javacustomerdata.java">CustomerDAO.java、CustomerData.java</h6><blockquote><p>对应数据库的 <em>Customer</em> 表</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.wmt.sql;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomerDAO</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BasicDAO</span> &#123;    <span class="hljs-comment">/* 返回 name 和 call 指定的顾客信息。没有则返回 null */</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchCustomer</span><span class="hljs-params">(String name, String call)</span> &#123;        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from customer where `name` = ? and `call` = ?&quot;</span>;        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> querySingle(CustomerData.class, sql, name, call);        <span class="hljs-type">return</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span>= <span class="hljs-literal">null</span> ? -<span class="hljs-number">1</span> : ((CustomerData) o).getId();    &#125;    <span class="hljs-comment">/* 创建顾客信息，信息包含 name 和 call */</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">createCustomer</span><span class="hljs-params">(String name, String call)</span> &#123;        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;insert into customer (`name`, `call`) values(?, ?)&quot;</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">update</span> <span class="hljs-operator">=</span> update(sql, name, call);        <span class="hljs-keyword">return</span> update &gt; <span class="hljs-number">0</span>;    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.wmt.sql;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomerData</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String card_id;    <span class="hljs-keyword">private</span> String call;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CustomerData</span><span class="hljs-params">()</span>&#123;&#125;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CustomerData</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String name, String card_id, String call)</span> &#123;        <span class="hljs-built_in">this</span>.id = id;        <span class="hljs-built_in">this</span>.name = name;        <span class="hljs-built_in">this</span>.card_id = card_id;        <span class="hljs-built_in">this</span>.call = call;    &#125;    <span class="hljs-comment">/* 省略了 getter 和 setter。实际代码里是有的 */</span>&#125;</code></pre></div><h6id="billdao.javabilldata.javadetailbilldata.java">BillDAO.java、BillData.java、DetailBillData.java</h6><blockquote><p>对应数据库的 <em>Bill</em> 表，<em>Detail_Bill</em> 视图</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.wmt.sql;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BillDAO</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BasicDAO</span> &#123;    <span class="hljs-comment">/* 订餐。形参是 餐品号、数量、桌号、顾客号。成功的场合返回 true */</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">order</span><span class="hljs-params">(<span class="hljs-type">int</span> dishes, <span class="hljs-type">int</span> num, <span class="hljs-type">int</span> table, <span class="hljs-type">int</span> customer)</span> &#123;        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;insert into `bill` (`dishes`, `num`, `table`, `customer`) values(?, ?, ?, ?)&quot;</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">update</span> <span class="hljs-operator">=</span> update(sql, dishes, num, table, customer);        <span class="hljs-keyword">return</span> update &gt; <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">/* 返回账单列表 */</span>    <span class="hljs-keyword">public</span> List&lt;DetailBillData&gt; <span class="hljs-title function_">queryBills</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from detail_bill&quot;</span>;        <span class="hljs-keyword">return</span> (List&lt;DetailBillData&gt;) queryMulti(DetailBillData.class, sql);    &#125;    <span class="hljs-comment">/* 返回特定桌号的帐单列表</span><span class="hljs-comment">    Boolean 为 true 则返回未付账单；false 返回已结账单；null 返回全部 */</span>    <span class="hljs-keyword">public</span> List&lt;DetailBillData&gt; <span class="hljs-title function_">queryBillsByTable</span><span class="hljs-params">(<span class="hljs-type">int</span> table, Boolean clear)</span> &#123;        String sql;        <span class="hljs-keyword">if</span> (clear == <span class="hljs-literal">null</span>) &#123;            sql = <span class="hljs-string">&quot;select * from detail_bill where `table` = ?&quot;</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            sql = <span class="hljs-string">&quot;select * from detail_bill where `table` = ? and &quot;</span> + (clear ? <span class="hljs-string">&quot;&quot;</span> : <span class="hljs-string">&quot;not&quot;</span>) + <span class="hljs-string">&quot; `clear` = &#x27;n&#x27;&quot;</span>;        &#125;        <span class="hljs-keyword">return</span> (List&lt;DetailBillData&gt;) queryMulti(DetailBillData.class, sql, table);    &#125;    <span class="hljs-comment">/* 将指定桌号的所有未付账单结算，其结算方式为 way 指定的方式 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">finishBill</span><span class="hljs-params">(<span class="hljs-type">int</span> table, <span class="hljs-type">int</span> way)</span> &#123;        String clear;        <span class="hljs-keyword">if</span> (way == <span class="hljs-number">1</span>) &#123;            clear = <span class="hljs-string">&quot;y&quot;</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (way == <span class="hljs-number">2</span>) &#123;            clear = <span class="hljs-string">&quot;alipay&quot;</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (way == <span class="hljs-number">3</span>) &#123;            clear = <span class="hljs-string">&quot;wc_pay&quot;</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();        &#125;        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update bill set `clear` = ? where `table` = ? and `clear` = &#x27;n&#x27;&quot;</span>;        <span class="hljs-keyword">return</span> update(sql, clear, table);    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BillData</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;    <span class="hljs-keyword">private</span> Date date;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> customer;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> table;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> num;    <span class="hljs-keyword">private</span> String clear;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> dishes;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BillData</span><span class="hljs-params">()</span> &#123;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BillData</span><span class="hljs-params">(<span class="hljs-type">int</span> id, Date date, <span class="hljs-type">int</span> customer, <span class="hljs-type">int</span> table, <span class="hljs-type">int</span> num, String clear, <span class="hljs-type">int</span> dishes)</span> &#123;        <span class="hljs-built_in">this</span>.id = id;        <span class="hljs-built_in">this</span>.date = date;        <span class="hljs-built_in">this</span>.customer = customer;        <span class="hljs-built_in">this</span>.table = table;        <span class="hljs-built_in">this</span>.num = num;        <span class="hljs-built_in">this</span>.clear = clear;        <span class="hljs-built_in">this</span>.dishes = dishes;    &#125;    <span class="hljs-comment">/* 省略了 getter 和 setter。实际代码里是有的 */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> id + <span class="hljs-string">&quot;\t&quot;</span> + customer + <span class="hljs-string">&quot;\t&quot;</span> + table + <span class="hljs-string">&quot;\t&quot;</span> + num + <span class="hljs-string">&quot;\t&quot;</span> + clear + <span class="hljs-string">&quot;\t&quot;</span> + dishes + <span class="hljs-string">&quot;\t&quot;</span> + date;    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DetailBillData</span> &#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String call;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> table;    <span class="hljs-keyword">private</span> String dishes;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> num;    <span class="hljs-keyword">private</span> Date date;    <span class="hljs-keyword">private</span> String clear;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DetailBillData</span><span class="hljs-params">()</span> &#123;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DetailBillData</span><span class="hljs-params">(String name, String call, <span class="hljs-type">int</span> table, String dishes, <span class="hljs-type">int</span> num, Date date, String clear)</span> &#123;        <span class="hljs-built_in">this</span>.name = name;        <span class="hljs-built_in">this</span>.call = call;        <span class="hljs-built_in">this</span>.table = table;        <span class="hljs-built_in">this</span>.dishes = dishes;        <span class="hljs-built_in">this</span>.num = num;        <span class="hljs-built_in">this</span>.date = date;        <span class="hljs-built_in">this</span>.clear = clear;    &#125;    <span class="hljs-comment">/* 省略了 getter 和 setter。实际代码里是有的 */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> name + <span class="hljs-string">&quot;\t&quot;</span> + call + <span class="hljs-string">&quot;\t&quot;</span> + table + <span class="hljs-string">&quot;\t&quot;</span> + dishes + <span class="hljs-string">&quot;\t&quot;</span> + num + <span class="hljs-string">&quot;\t&quot;</span> + date + <span class="hljs-string">&quot;\t&quot;</span> + clear;    &#125;&#125;</code></pre></div><h4 id="客户端管理部分">客户端（管理）部分</h4><h5 id="com.melody.wmt.client">com.melody.wmt.client;</h5><h6 id="clinet.java">Clinet.java</h6><blockquote><p>客户端程序主体</p><p>该包实现：登录界面、菜单界面、选择菜单</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.wmt.client;<span class="hljs-keyword">import</span> com.melody.wmt.sql.LoginData;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.ObjectInputStream;<span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<span class="hljs-keyword">import</span> java.net.InetAddress;<span class="hljs-keyword">import</span> java.net.Socket;<span class="hljs-keyword">import</span> java.net.UnknownHostException;<span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String IP;<span class="hljs-comment">//自己的 IP</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">ServerIP</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;192.168.3.16&quot;</span>;<span class="hljs-comment">//服务端 IP</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);    <span class="hljs-keyword">private</span> Socket socket;    <span class="hljs-keyword">private</span> ObjectInputStream ois;<span class="hljs-comment">//输入流</span>    <span class="hljs-keyword">private</span> ObjectOutputStream oos;<span class="hljs-comment">//输出流</span>    <span class="hljs-comment">//以上三个属性会在 connect() 方法中被赋值</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">MenuUtility</span> <span class="hljs-variable">menuUtility</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MenuUtility</span>(<span class="hljs-built_in">this</span>);    <span class="hljs-comment">//方法类对象，传入形参 this，形成了互相持有的结构</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Listening</span> <span class="hljs-variable">listening</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Listening</span>(<span class="hljs-built_in">this</span>);    <span class="hljs-comment">//监听类对象，传入形参 this，形成了互相持有的结构</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">LoginData</span> <span class="hljs-variable">loginData</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-comment">//用户数据。登陆后服务端会发送一个该类对象过来</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">skipMenu</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;    <span class="hljs-comment">//跳过菜单显示。该属性没有投入使用</span>        <span class="hljs-comment">/* 多此一举地初始化自己的 IP 地址。其实可以直接写。 */</span>    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-keyword">try</span> &#123;            IP = InetAddress.getLocalHost().getHostAddress();        &#125; <span class="hljs-keyword">catch</span> (UnknownHostException e) &#123;            System.out.println(e);            IP = <span class="hljs-string">&quot;192.168.3.16&quot;</span>;        &#125;    &#125;<span class="hljs-comment">/* 展示主菜单 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mainMenu</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">char</span> read;        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;            System.out.println(<span class="hljs-string">&quot;====================================&quot;</span>);            System.out.println(<span class="hljs-string">&quot;\t\t1. 登 录 系 统&quot;</span>);            System.out.println(<span class="hljs-string">&quot;\t\t9. 退 出 系 统&quot;</span>);            System.out.print(<span class="hljs-string">&quot;请选择：&quot;</span>);            read = scanner.next().charAt(<span class="hljs-number">0</span>);            System.out.println();            System.out.println(<span class="hljs-string">&quot;------------------------------------&quot;</span>);            <span class="hljs-keyword">switch</span> (read) &#123;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;1&#x27;</span>:                    <span class="hljs-comment">/* 这里会先建立连接 connect()，然后调用登录方法 login() */</span>                    <span class="hljs-keyword">if</span> (connect() &amp;&amp; menuUtility.login()) &#123;                        <span class="hljs-keyword">try</span> &#123;                            menu_1();                        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                            System.out.println(e);                            <span class="hljs-comment">/* 有任何问题会执行 closeAll()，即关闭一切流 */</span>                            closeAll();                        &#125;                    &#125;                    closeAll();                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;9&#x27;</span>:                    <span class="hljs-keyword">if</span> (menuUtility.out()) &#123;                        <span class="hljs-keyword">return</span>;                    &#125;                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">default</span>:                    System.out.println(<span class="hljs-string">&quot;输入错误。&quot;</span>);                    <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-comment">/* 建立连接 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">connect</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">try</span> &#123;            socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(ServerIP, <span class="hljs-number">9000</span>);            oos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(socket.getOutputStream());            ois = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(socket.getInputStream());            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(listening).start();            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            System.out.println(e);            closeAll();            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    &#125;    <span class="hljs-comment">/* 关闭所有流。通常是登出、断线或报错后执行这个方法 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">closeAll</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (ois != <span class="hljs-literal">null</span>) &#123;                ois.close();            &#125;            <span class="hljs-keyword">if</span> (oos != <span class="hljs-literal">null</span>) &#123;                oos.close();            &#125;            <span class="hljs-keyword">if</span> (socket != <span class="hljs-literal">null</span>) &#123;                socket.close();            &#125;            listening.listening = <span class="hljs-literal">false</span>;        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            System.out.println(e);        &#125;    &#125;    <span class="hljs-comment">/* 显示（登录）菜单。这个类只是在屏幕上输出字符 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showMenu_1</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">/* 设置了跳过菜单显示的场合，仅一次菜单不显示 */</span>        <span class="hljs-keyword">if</span> (skipMenu)&#123;            skipMenu = <span class="hljs-literal">false</span>;            <span class="hljs-keyword">return</span>;        &#125;        System.out.println(<span class="hljs-string">&quot;================&quot;</span> + loginData.getName() + <span class="hljs-string">&quot;================&quot;</span>);        System.out.println(<span class="hljs-string">&quot;\t\t1. 餐 桌 状 态&quot;</span>);        System.out.println(<span class="hljs-string">&quot;\t\t2. 预 定 餐 桌&quot;</span>);        System.out.println(<span class="hljs-string">&quot;\t\t3. 菜 单&quot;</span>);        System.out.println(<span class="hljs-string">&quot;\t\t4. 点 餐&quot;</span>);        System.out.println(<span class="hljs-string">&quot;\t\t5. 账 单&quot;</span>);        System.out.println(<span class="hljs-string">&quot;\t\t6. 结 账&quot;</span>);        System.out.println(<span class="hljs-string">&quot;\t\t9. 登 出 系 统&quot;</span>);    &#125;    <span class="hljs-comment">/* 根据菜单选择执行的功能 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">menu_1</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">char</span> read;        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;            <span class="hljs-comment">/* 显示菜单。设置跳过的场合仅一次菜单不显示 */</span>            showMenu_1();            System.out.print(<span class="hljs-string">&quot;请选择：&quot;</span>);            read = scanner.next().charAt(<span class="hljs-number">0</span>);            System.out.println(<span class="hljs-string">&quot;------------------------------------&quot;</span>);            <span class="hljs-keyword">switch</span> (read) &#123;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;1&#x27;</span>:                    menuUtility.showTables();<span class="hljs-comment">//展示餐桌列表</span>                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;2&#x27;</span>:                    menuUtility.orderTable();<span class="hljs-comment">//预定餐桌</span>                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;3&#x27;</span>:                    menuUtility.showList();<span class="hljs-comment">//展示菜单列表</span>                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;4&#x27;</span>:                    menuUtility.orderDishes();<span class="hljs-comment">//订餐</span>                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;5&#x27;</span>:                    menuUtility.showBill();<span class="hljs-comment">//展示账单列表</span>                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;6&#x27;</span>:                    menuUtility.payBill();<span class="hljs-comment">//结账</span>                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;9&#x27;</span>:                    <span class="hljs-keyword">if</span> (menuUtility.logout()) &#123;<span class="hljs-comment">//登出</span>                        <span class="hljs-keyword">return</span>;                    &#125;                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">default</span>:                    System.out.println(<span class="hljs-string">&quot;输入错误。&quot;</span>);                    <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">public</span> Socket <span class="hljs-title function_">getSocket</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> socket;    &#125;    <span class="hljs-keyword">public</span> ObjectInputStream <span class="hljs-title function_">getOis</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> ois;    &#125;    <span class="hljs-keyword">public</span> ObjectOutputStream <span class="hljs-title function_">getOos</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> oos;    &#125;    <span class="hljs-comment">/* 抛出一个异常。这个方法用于抛出异常（听君一席话……） */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">throwException</span><span class="hljs-params">(String s)</span> &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(s);    &#125;&#125;</code></pre></div><h6 id="listening.java">Listening.java</h6><blockquote><p>监听服务端发送数据包的线程</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.wmt.client;<span class="hljs-keyword">import</span> com.melody.wmt.common.Message;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Listening</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;    <span class="hljs-keyword">private</span> Client client;<span class="hljs-comment">//和主程序相互持有，便于调用</span>    <span class="hljs-keyword">public</span> Message message;<span class="hljs-comment">//接收的数据包</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">listening</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//监听中。false 会停止线程</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">received</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//收到文件。</span>    <span class="hljs-comment">//这是实现某个方法的过渡办法，似乎已经可以弃用</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Listening</span><span class="hljs-params">(Client client)</span> &#123;        <span class="hljs-built_in">this</span>.client = client;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;        listening = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">while</span> (listening)&#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> client.getOis().readObject();                <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>)&#123;                    <span class="hljs-keyword">continue</span>;                &#125;                message = (Message) o;                received = <span class="hljs-literal">true</span>;            &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;                client.throwException(<span class="hljs-string">&quot;监听异常&quot;</span> + e);            &#125;        &#125;        System.out.println(<span class="hljs-string">&quot;监听停止&quot;</span>);    &#125;&#125;</code></pre></div><h6 id="menuutility.java">MenuUtility.java</h6><blockquote><p>客户端程序的方法包</p><p>该包实现：……大部分功能</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.wmt.client;<span class="hljs-keyword">import</span> com.melody.wmt.common.Message;<span class="hljs-keyword">import</span> com.melody.wmt.common.MessageType;<span class="hljs-keyword">import</span> com.melody.wmt.sql.LoginData;<span class="hljs-keyword">import</span> com.melody.wmt.sql.TableData;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MenuUtility</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);    <span class="hljs-keyword">private</span> Client client;<span class="hljs-comment">//和主程序互相持有，方便调用</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">userData</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//内容是：&quot;用户名\t密码&quot;。</span>    <span class="hljs-comment">//每个发送的数据包的 Object 开头都是这个</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MenuUtility</span><span class="hljs-params">(Client client)</span> &#123;        <span class="hljs-built_in">this</span>.client = client;    &#125;    <span class="hljs-comment">/* 发送数据包，并返回接收的数据包 */</span>    <span class="hljs-comment">/* 通常会返回接收到的数据包。也可能返回 null 代表失败 */</span>    <span class="hljs-keyword">public</span> Message <span class="hljs-title function_">sendAndReceive</span><span class="hljs-params">(Message message)</span> &#123;        <span class="hljs-comment">/* 发送包不能为 null。基本上不会出现这种情况 */</span>        <span class="hljs-keyword">if</span> (message == <span class="hljs-literal">null</span>) &#123;            System.out.println(<span class="hljs-string">&quot;错误：传递空包&quot;</span>);            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125;        <span class="hljs-comment">/* 刷新数据包时间戳 */</span>        message.setTimeStamp();        <span class="hljs-comment">/* 清空监听进程里已有的数据 */</span>        client.listening.received = <span class="hljs-literal">false</span>;        client.listening.message = <span class="hljs-literal">null</span>;        <span class="hljs-comment">/* 接收数据包对象 */</span>        <span class="hljs-type">Message</span> <span class="hljs-variable">receive</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">/* 发送数据包 */</span>            client.getOos().writeObject(message);            <span class="hljs-comment">/* 标记此时的时间 */</span>            <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> System.currentTimeMillis();            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;            <span class="hljs-comment">/* 在指定时间内持续试图接收服务端数据包 */</span>            <span class="hljs-comment">/* 经测试，在 while(true) 中如果只有单一的 if 语句，</span><span class="hljs-comment">            那么该 if 语句条件（或主体）只会执行一次。</span><span class="hljs-comment">            这会造成客户端接收不到服务端数据包。</span><span class="hljs-comment">            因此，加入了无关紧要的小动画，确保 if 语句总会重复执行。*/</span>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;                n++;                System.out.print(<span class="hljs-string">&quot;\r&quot;</span>);                <span class="hljs-comment">/* if 语句中的才是主体</span><span class="hljs-comment">                接收到数据包或者等待 5 秒以上后，拿取数据包并跳出该循环 */</span>                <span class="hljs-keyword">if</span> (System.currentTimeMillis() - time &gt;= <span class="hljs-number">5000</span> | client.listening.received) &#123;                    receive = client.listening.message;                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-comment">/* 下面是一个旋转线条的小动画。</span><span class="hljs-comment">                由于上面的 \r 存在，该动画在程序继续后会被其他字符覆盖 */</span>                <span class="hljs-keyword">switch</span> (n % <span class="hljs-number">4</span>) &#123;                    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:                        System.out.print(<span class="hljs-string">&quot;|&quot;</span>);                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:                        System.out.print(<span class="hljs-string">&quot;/&quot;</span>);                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:                        System.out.print(<span class="hljs-string">&quot;-&quot;</span>);                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">default</span>:                        System.out.print(<span class="hljs-string">&quot;\\&quot;</span>);                        <span class="hljs-keyword">break</span>;                &#125;            &#125;            <span class="hljs-keyword">return</span> receive;        <span class="hljs-comment">/* 有任何异常则返回 null */</span>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            System.out.println(e);            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125;    &#125;    <span class="hljs-comment">/* 实现登录验证 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">login</span><span class="hljs-params">()</span> &#123;        System.out.print(<span class="hljs-string">&quot;请输入用户名：&quot;</span>);        <span class="hljs-type">String</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> scanner.next();        System.out.print(<span class="hljs-string">&quot;请输入密码：&quot;</span>);        <span class="hljs-type">String</span> <span class="hljs-variable">pw</span> <span class="hljs-operator">=</span> scanner.next();        System.out.println();        <span class="hljs-comment">/* 这句字符串会被重复使用 */</span>        userData = (user + <span class="hljs-string">&quot;\t&quot;</span> + pw);        <span class="hljs-comment">/* 发送数据包。这里写得比较挤，后面我都分开写了 */</span>        <span class="hljs-type">Message</span> <span class="hljs-variable">receive</span> <span class="hljs-operator">=</span> sendAndReceive(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(Client.IP, Client.ServerIP, MessageType.LOGIN, userData));        <span class="hljs-comment">/* 根据返回包做出相应提示 */</span>        <span class="hljs-keyword">if</span> (receive == <span class="hljs-literal">null</span>) &#123;            System.out.println(<span class="hljs-string">&quot;错误：服务器无响应&quot;</span>);            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-type">String</span> <span class="hljs-variable">reply</span> <span class="hljs-operator">=</span> receive.getWord();        <span class="hljs-keyword">if</span> (reply.equals(MessageType.LOGIN_USER_NOT_EXIST)) &#123;            System.out.println(<span class="hljs-string">&quot;错误：用户名不存在&quot;</span>);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (reply.equals(MessageType.LOGIN_WRONG_PW)) &#123;            System.out.println(<span class="hljs-string">&quot;错误：密码错误&quot;</span>);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (reply.equals(MessageType.ACCEPT)) &#123;            <span class="hljs-keyword">try</span> &#123;                client.loginData = (LoginData) receive.getObject();            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                System.out.println(<span class="hljs-string">&quot;未知错误&quot;</span>);                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;            System.out.println(<span class="hljs-string">&quot;登录成功&quot;</span>);        &#125;        <span class="hljs-comment">/* 返回值。true 表示登陆成功 */</span>        <span class="hljs-keyword">return</span> receive.getWord().equals(MessageType.ACCEPT);    &#125;    <span class="hljs-comment">/* 退出确认。这是未登录时（即，登陆界面）的退出方法 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">out</span><span class="hljs-params">()</span> &#123;        System.out.print(<span class="hljs-string">&quot;确定退出吗？（Y/N）&quot;</span>);        <span class="hljs-type">char</span> <span class="hljs-variable">answer</span> <span class="hljs-operator">=</span> scanner.next().charAt(<span class="hljs-number">0</span>);        <span class="hljs-type">return</span> <span class="hljs-variable">answer</span> <span class="hljs-operator">=</span>= <span class="hljs-string">&#x27;Y&#x27;</span> || answer == <span class="hljs-string">&#x27;y&#x27;</span>;    &#125;    <span class="hljs-comment">/* 展示餐桌列表 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">showTables</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">/* 发送请求，接收服务端返回的数据包 */</span>        <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(Client.IP, Client.ServerIP, MessageType.SHOW_TABLES, userData);        <span class="hljs-type">Message</span> <span class="hljs-variable">receive</span> <span class="hljs-operator">=</span> sendAndReceive(message);        <span class="hljs-comment">/* 根据返回包的不同作出反应 */</span>        <span class="hljs-keyword">if</span> (receive == <span class="hljs-literal">null</span>) &#123;            System.out.println(<span class="hljs-string">&quot;错误：服务器无响应&quot;</span>);            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-type">String</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> receive.getWord();        <span class="hljs-keyword">if</span> (r.equals(MessageType.REJECT)) &#123;            System.out.println(<span class="hljs-string">&quot;错误：服务器拒绝了请求&quot;</span>);            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r.equals(MessageType.ACCEPT)) &#123;            System.out.println(<span class="hljs-string">&quot;ID\t座数\t状态\t顾客&quot;</span>);            System.out.println(receive.getObject());            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            System.out.println(<span class="hljs-string">&quot;错误：未知的回执&quot;</span> + r);            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    &#125;    <span class="hljs-comment">/* 检查餐桌状态 */</span>    <span class="hljs-comment">/* need：1不可用；2不存在；3占用未点餐；4占用已点餐；5未占用；6占用</span><span class="hljs-comment">    根据需要的餐桌状态 need 的不同，有不同的返回方法*/</span>    <span class="hljs-keyword">public</span> TableData <span class="hljs-title function_">checkTable</span><span class="hljs-params">(<span class="hljs-type">int</span> tableID, <span class="hljs-type">int</span> need)</span> &#123;        <span class="hljs-comment">/* 发送验证餐桌请求，接收返回包 */</span>        <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(client.IP, client.ServerIP, MessageType.CHECK_TABLE, userData + <span class="hljs-string">&quot;\t&quot;</span> + tableID);        <span class="hljs-type">Message</span> <span class="hljs-variable">receive</span> <span class="hljs-operator">=</span> sendAndReceive(message);        <span class="hljs-comment">/* 根据返回包做出不同反应 */</span>        <span class="hljs-keyword">if</span> (receive == <span class="hljs-literal">null</span>) &#123;            System.out.println(<span class="hljs-string">&quot;错误：服务器无响应&quot;</span>);            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125;        <span class="hljs-comment">/* 如果 need 和返回结果匹配，give 值会为 true */</span>        <span class="hljs-type">boolean</span> <span class="hljs-variable">give</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">if</span> (receive.getWord().equals(MessageType.REJECT)) &#123;            System.out.println(<span class="hljs-string">&quot;错误：请求被拒绝&quot;</span>);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (receive.getWord().equals(MessageType.TABLE_NOT_AVAILABLE)) &#123;            give = need == <span class="hljs-number">1</span>;            System.out.print(give ? <span class="hljs-string">&quot;&quot;</span> : <span class="hljs-string">&quot;餐桌不可用\n&quot;</span>);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (receive.getWord().equals(MessageType.TABLE_NOT_EXIST)) &#123;            give = need == <span class="hljs-number">2</span>;            System.out.print(give ? <span class="hljs-string">&quot;&quot;</span> : <span class="hljs-string">&quot;餐桌不存在\n&quot;</span>);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (receive.getWord().equals(MessageType.TABLE_OCCUPIED)) &#123;            give = need == <span class="hljs-number">3</span> || need == <span class="hljs-number">6</span>;            System.out.print(give ? <span class="hljs-string">&quot;&quot;</span> : <span class="hljs-string">&quot;餐桌被占用（未点餐）\n&quot;</span>);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (receive.getWord().equals(MessageType.TABLE_DINNING)) &#123;            give = need == <span class="hljs-number">4</span> || need == <span class="hljs-number">6</span>;            System.out.print(give ? <span class="hljs-string">&quot;&quot;</span> : <span class="hljs-string">&quot;餐桌被占用（已点餐）\n&quot;</span>);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (receive.getWord().equals(MessageType.TABLE_AVAILABLE)) &#123;            give = need == <span class="hljs-number">5</span>;            System.out.print(give ? <span class="hljs-string">&quot;&quot;</span> : <span class="hljs-string">&quot;餐桌为空\n&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            System.out.println(<span class="hljs-string">&quot;错误：未知错误&quot;</span>);        &#125;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">/* 只有匹配的结果才会返回餐桌数据 */</span>            <span class="hljs-keyword">return</span> give ? (TableData) receive.getObject() : <span class="hljs-literal">null</span>;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125;    &#125;    <span class="hljs-comment">/* 预定餐桌 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">orderTable</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">/* 首先会调用一次展示餐桌的方法 */</span>        showTables();        <span class="hljs-comment">/* 输入餐桌号 */</span>        System.out.println(<span class="hljs-string">&quot;------------------------------------&quot;</span>);        System.out.print(<span class="hljs-string">&quot;请输入预定的餐桌号码（-1取消）：&quot;</span>);        <span class="hljs-type">int</span> <span class="hljs-variable">tableID</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">try</span> &#123;            tableID = Integer.parseInt(scanner.next());            <span class="hljs-keyword">if</span> (tableID == -<span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">return</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tableID &lt;= <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            System.out.println(<span class="hljs-string">&quot;输入错误。&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">/* 检查一下上面输入的餐桌是否正确。这时的正确指的是餐桌为空 */</span>        <span class="hljs-type">TableData</span> <span class="hljs-variable">tableData</span> <span class="hljs-operator">=</span> checkTable(tableID, <span class="hljs-number">5</span>);        <span class="hljs-keyword">if</span> (tableData == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        System.out.print(<span class="hljs-string">&quot;请输入预定人名字：&quot;</span>);        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> scanner.next();        System.out.println(<span class="hljs-string">&quot;请输入预定人电话：&quot;</span>);        <span class="hljs-type">String</span> <span class="hljs-variable">call</span> <span class="hljs-operator">=</span> scanner.next();        System.out.println(<span class="hljs-string">&quot;请确认预定信息：&quot;</span>);        System.out.println(<span class="hljs-string">&quot;桌号：&quot;</span> + tableData.getId() + <span class="hljs-string">&quot;\t座数：&quot;</span> + tableData.getSeat() + <span class="hljs-string">&quot;\t预定人：&quot;</span> + name + <span class="hljs-string">&quot;\t电话：&quot;</span> + call);        System.out.print(<span class="hljs-string">&quot;确定吗？（Y/N）：&quot;</span>);        <span class="hljs-type">char</span> <span class="hljs-variable">confirm</span> <span class="hljs-operator">=</span> scanner.next().charAt(<span class="hljs-number">0</span>);        <span class="hljs-keyword">if</span> (confirm != <span class="hljs-string">&#x27;Y&#x27;</span> &amp;&amp; confirm != <span class="hljs-string">&#x27;y&#x27;</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">/* 发送请求预定餐桌。前面的顾客对象不存在的话，服务端会自动创建新的对象 */</span>        <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(client.IP, client.ServerIP, MessageType.ORDER_TABLE, userData + <span class="hljs-string">&quot;\t&quot;</span> + tableID + <span class="hljs-string">&quot;\t&quot;</span> + name + <span class="hljs-string">&quot;\t&quot;</span> + call);        <span class="hljs-type">Message</span> <span class="hljs-variable">receive</span> <span class="hljs-operator">=</span> sendAndReceive(message);        <span class="hljs-keyword">if</span> (receive.getWord().equals(MessageType.ACCEPT)) &#123;            System.out.println(<span class="hljs-string">&quot;预定成功！&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            System.out.println(<span class="hljs-string">&quot;预定失败&quot;</span>);        &#125;    &#125;    <span class="hljs-comment">/* 展示菜单 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showList</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">/* 发送展示菜单的请求 */</span>        <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(Client.IP, Client.ServerIP, MessageType.SHOW_DISHES, userData);        <span class="hljs-type">Message</span> <span class="hljs-variable">receive</span> <span class="hljs-operator">=</span> sendAndReceive(message);        <span class="hljs-keyword">if</span> (receive == <span class="hljs-literal">null</span>) &#123;            System.out.println(<span class="hljs-string">&quot;错误：服务器无响应&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!receive.getWord().equals(MessageType.ACCEPT)) &#123;            System.out.println(<span class="hljs-string">&quot;错误：请求被拒绝&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">/* 此时拿到了菜单。该菜单的不同类别是由 ### 分割的。我们再将其分开 */</span>        String[] dishes;        <span class="hljs-keyword">try</span> &#123;            dishes = ((String) receive.getObject()).split(<span class="hljs-string">&quot;###&quot;</span>);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            System.out.println(<span class="hljs-string">&quot;未知错误&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-type">char</span> in;        <span class="hljs-comment">/* 这其实又是一级菜单了。直到选择 9 前，该菜单会一直循环 */</span>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;            System.out.println(<span class="hljs-string">&quot;---------------------------------------&quot;</span>);            System.out.println(<span class="hljs-string">&quot;\t\t请选择要查看的类别&quot;</span>);            System.out.println(<span class="hljs-string">&quot;\t\t1. 主  食&quot;</span>);            System.out.println(<span class="hljs-string">&quot;\t\t2. 主  菜&quot;</span>);            System.out.println(<span class="hljs-string">&quot;\t\t3. 凉  菜&quot;</span>);            System.out.println(<span class="hljs-string">&quot;\t\t4. 汤  品&quot;</span>);            System.out.println(<span class="hljs-string">&quot;\t\t5. 甜  点&quot;</span>);            System.out.println(<span class="hljs-string">&quot;\t\t6. 饮  料&quot;</span>);            System.out.println(<span class="hljs-string">&quot;\t\t7. 点  餐&quot;</span>);            System.out.println(<span class="hljs-string">&quot;\t\t9. 返  回&quot;</span>);            System.out.print(<span class="hljs-string">&quot;请输入：&quot;</span>);            in = scanner.next().charAt(<span class="hljs-number">0</span>);            System.out.println(<span class="hljs-string">&quot;---------------------------------------&quot;</span>);            <span class="hljs-keyword">switch</span> (in) &#123;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;1&#x27;</span>:                    System.out.println(<span class="hljs-string">&quot;------------主  食------------&quot;</span>);                    System.out.println(<span class="hljs-string">&quot;ID\t名称  \t价格&quot;</span>);                    System.out.println(dishes[<span class="hljs-number">0</span>]);                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;2&#x27;</span>:                    System.out.println(<span class="hljs-string">&quot;------------主  菜------------&quot;</span>);                    System.out.println(<span class="hljs-string">&quot;ID\t名称  \t价格&quot;</span>);                    System.out.println(dishes[<span class="hljs-number">1</span>]);                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;3&#x27;</span>:                    System.out.println(<span class="hljs-string">&quot;------------凉  菜------------&quot;</span>);                    System.out.println(<span class="hljs-string">&quot;ID\t名称  \t价格&quot;</span>);                    System.out.println(dishes[<span class="hljs-number">2</span>]);                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;4&#x27;</span>:                    System.out.println(<span class="hljs-string">&quot;------------汤  品------------&quot;</span>);                    System.out.println(<span class="hljs-string">&quot;ID\t名称  \t价格&quot;</span>);                    System.out.println(dishes[<span class="hljs-number">3</span>]);                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;5&#x27;</span>:                    System.out.println(<span class="hljs-string">&quot;------------甜  点------------&quot;</span>);                    System.out.println(<span class="hljs-string">&quot;ID\t名称  \t价格&quot;</span>);                    System.out.println(dishes[<span class="hljs-number">4</span>]);                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;6&#x27;</span>:                    System.out.println(<span class="hljs-string">&quot;------------饮  料------------&quot;</span>);                    System.out.println(<span class="hljs-string">&quot;ID\t名称  \t价格&quot;</span>);                    System.out.println(dishes[<span class="hljs-number">5</span>]);                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;7&#x27;</span>:                    <span class="hljs-comment">/* 这时调用订餐的方法 */</span>                    orderDishes();                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;9&#x27;</span>:                    <span class="hljs-keyword">return</span>;                <span class="hljs-keyword">default</span>:                    System.out.println(<span class="hljs-string">&quot;输入错误&quot;</span>);                    <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-comment">/* 订餐 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">orderDishes</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;请输入菜品编号（数字，-1返回）：&quot;</span>);        <span class="hljs-type">int</span> dish;        <span class="hljs-keyword">try</span> &#123;            dish = Integer.parseInt(scanner.next());        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            System.out.println(<span class="hljs-string">&quot;输入错误&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (dish &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">/* 检查输入的餐品信息。这里把一部分代码封装成了一个新方法</span><span class="hljs-comment">        ……这是因为测试发现，不这样做会导致内存数据不更新，接收到的返回包总是不变 */</span>        <span class="hljs-type">String</span> <span class="hljs-variable">dishDetail</span> <span class="hljs-operator">=</span> orderDishesPart1(dish);        <span class="hljs-keyword">if</span> (dishDetail == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        System.out.println(<span class="hljs-string">&quot;请输入数量（数字，-1返回）：&quot;</span>);        <span class="hljs-type">int</span> num;        <span class="hljs-keyword">try</span> &#123;            num = Integer.parseInt(scanner.next());        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            System.out.println(<span class="hljs-string">&quot;输入错误&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        System.out.println(<span class="hljs-string">&quot;请输入订餐桌号（数字，-1返回）：&quot;</span>);        <span class="hljs-type">int</span> table;        <span class="hljs-keyword">try</span> &#123;            table = Integer.parseInt(scanner.next());        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            System.out.println(<span class="hljs-string">&quot;输入错误&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (table &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">/* 检查一下餐桌信息。这里，正确的状态是&#x27;已占用&#x27; */</span>        <span class="hljs-type">TableData</span> <span class="hljs-variable">tableData</span> <span class="hljs-operator">=</span> checkTable(table, <span class="hljs-number">6</span>);        <span class="hljs-keyword">if</span> (tableData == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">/* 展示一下信息 */</span>        System.out.println(<span class="hljs-string">&quot;ID\t名称  \t价格 \t数量\t桌号&quot;</span>);        System.out.println(dishDetail + <span class="hljs-string">&quot;\t&quot;</span> + num + <span class="hljs-string">&quot;\t&quot;</span> + tableData.getId());        System.out.print(<span class="hljs-string">&quot;确定吗？（Y/N）：&quot;</span>);        <span class="hljs-type">char</span> <span class="hljs-variable">confirm</span> <span class="hljs-operator">=</span> scanner.next().charAt(<span class="hljs-number">0</span>);        <span class="hljs-keyword">if</span> (confirm != <span class="hljs-string">&#x27;Y&#x27;</span> &amp;&amp; confirm != <span class="hljs-string">&#x27;y&#x27;</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">/* 发送订餐请求 */</span>        <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(Client.IP, Client.ServerIP, MessageType.ORDER_DISHES, <span class="hljs-literal">null</span>);        message.setObject(userData + <span class="hljs-string">&quot;\t&quot;</span> + dish + <span class="hljs-string">&quot;\t&quot;</span> + num + <span class="hljs-string">&quot;\t&quot;</span> + table + <span class="hljs-string">&quot;\t&quot;</span> + tableData.getCustomer());        <span class="hljs-type">Message</span> <span class="hljs-variable">receive</span> <span class="hljs-operator">=</span> sendAndReceive(message);        <span class="hljs-keyword">if</span> (receive == <span class="hljs-literal">null</span>) &#123;            System.out.println(<span class="hljs-string">&quot;错误：服务器无响应&quot;</span>);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (receive.getWord().equals(MessageType.REJECT)) &#123;            System.out.println(<span class="hljs-string">&quot;错误：请求被拒绝&quot;</span>);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (receive.getWord().equals(MessageType.ACCEPT)) &#123;            System.out.println(<span class="hljs-string">&quot;预定成功&quot;</span>);        &#125;    &#125;    <span class="hljs-comment">/* 订餐方法中，小部分代码封装成了这个方法 */</span>    <span class="hljs-comment">/* 如此做是因为测试发现，不这样做会导致内存数据不更新，</span><span class="hljs-comment">    接收到的服务端返回包内容总是和方法中第一次接收的返回包内容一样。</span><span class="hljs-comment">    测试过很多次，问题就是出在这里。解决方法就是这样。</span><span class="hljs-comment">        这样，这个方法执行完毕后，似乎会刷新内存。可能这就是垃圾处理机制吧 */</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">orderDishesPart1</span><span class="hljs-params">(<span class="hljs-type">int</span> dish)</span> &#123;        <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(Client.IP, Client.ServerIP, MessageType.CHECK_DISHES, userData + <span class="hljs-string">&quot;\t&quot;</span> + dish);        <span class="hljs-type">Message</span> <span class="hljs-variable">receive1</span> <span class="hljs-operator">=</span> sendAndReceive(message);        <span class="hljs-keyword">if</span> (receive1 == <span class="hljs-literal">null</span>) &#123;            System.out.println(<span class="hljs-string">&quot;错误：服务器无响应&quot;</span>);            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!receive1.getWord().equals(MessageType.ACCEPT)) &#123;            System.out.println(<span class="hljs-string">&quot;错误：请求被拒绝&quot;</span>);            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125;        System.out.println(<span class="hljs-string">&quot;ID\t名称  \t价格&quot;</span>);        <span class="hljs-type">String</span> <span class="hljs-variable">dishDetail</span> <span class="hljs-operator">=</span> receive1.getObject().toString();        System.out.println(dishDetail);        <span class="hljs-keyword">return</span> dishDetail;    &#125;<span class="hljs-comment">/* 展示账单列表 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showBill</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">/* 发送请求 */</span>        <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(Client.IP, Client.ServerIP, MessageType.SHOW_ALL_BILLS, userData);        <span class="hljs-type">Message</span> <span class="hljs-variable">receive</span> <span class="hljs-operator">=</span> sendAndReceive(message);        <span class="hljs-keyword">if</span> (receive == <span class="hljs-literal">null</span>) &#123;            System.out.println(<span class="hljs-string">&quot;错误：服务器无响应&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (receive.getWord().equals(MessageType.REJECT)) &#123;            System.out.println(<span class="hljs-string">&quot;错误：请求被拒绝&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">/* 同样的，账单列表也是以 ### 分隔的 */</span>        String[] bills;        <span class="hljs-keyword">try</span> &#123;            bills = ((String) receive.getObject()).split(<span class="hljs-string">&quot;###&quot;</span>);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            System.out.println(<span class="hljs-string">&quot;错误：未知错误&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">/* 另一个小菜单。选择 9 前会一直循环 */</span>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;            System.out.println(<span class="hljs-string">&quot;---------------------------------------&quot;</span>);            System.out.println(<span class="hljs-string">&quot;\t\t请选择要查看的类别&quot;</span>);            System.out.println(<span class="hljs-string">&quot;\t\t1. 已完成账单&quot;</span>);            System.out.println(<span class="hljs-string">&quot;\t\t2. 未完成账单&quot;</span>);            System.out.println(<span class="hljs-string">&quot;\t\t9. 返  回&quot;</span>);            System.out.print(<span class="hljs-string">&quot;请输入：&quot;</span>);            <span class="hljs-type">char</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> scanner.next().charAt(<span class="hljs-number">0</span>);            System.out.println(<span class="hljs-string">&quot;---------------------------------------&quot;</span>);<span class="hljs-comment">//            System.out.println(&quot;姓名 \t电话  \t桌号\t菜名   \t数量\t日期          \t结算状态&quot;);</span>            <span class="hljs-keyword">switch</span> (in) &#123;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;1&#x27;</span>:                    System.out.println(bills[<span class="hljs-number">0</span>].length() == <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;---无---&quot;</span> : bills[<span class="hljs-number">0</span>]);                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;2&#x27;</span>:                    System.out.println((bills.length &lt; <span class="hljs-number">2</span> || bills[<span class="hljs-number">1</span>].length() == <span class="hljs-number">0</span>) ? <span class="hljs-string">&quot;---无---&quot;</span> : bills[<span class="hljs-number">1</span>]);                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;9&#x27;</span>:                    <span class="hljs-keyword">return</span>;                <span class="hljs-keyword">default</span>:                    System.out.println(<span class="hljs-string">&quot;输入错误&quot;</span>);                    <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-comment">/* 按桌号检查账单 */</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">checkBillByTable</span><span class="hljs-params">(<span class="hljs-type">int</span> table)</span> &#123;        <span class="hljs-comment">/* 发送请求</span><span class="hljs-comment">        特别一提：后面的 &quot;\t&quot; + &#x27;t&#x27; + &quot;\t&quot; + table + &quot;\t&quot; + &quot;true&quot; </span><span class="hljs-comment">        代表 按桌号查询(t)，号码是 table，展示未结账账单(true) */</span>        <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(Client.IP, Client.ServerIP, MessageType.CHECK_BILLS, userData + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&#x27;t&#x27;</span> + <span class="hljs-string">&quot;\t&quot;</span> + table + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;true&quot;</span>);        <span class="hljs-type">Message</span> <span class="hljs-variable">receive</span> <span class="hljs-operator">=</span> sendAndReceive(message);        <span class="hljs-keyword">if</span> (receive == <span class="hljs-literal">null</span>) &#123;            System.out.println(<span class="hljs-string">&quot;错误：服务器无响应&quot;</span>);            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (receive.getWord().equals(MessageType.ACCEPT)) &#123;            <span class="hljs-keyword">return</span> receive.getObject().toString();        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (receive.getWord().equals(MessageType.REJECT)) &#123;            System.out.println(<span class="hljs-string">&quot;错误：请求被拒绝&quot;</span>);            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            System.out.println(<span class="hljs-string">&quot;错误：未知错误&quot;</span>);            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125;    &#125;    <span class="hljs-comment">/* 结账 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">payBill</span><span class="hljs-params">()</span> &#123;        showTables();        System.out.print(<span class="hljs-string">&quot;请输入结账的桌号（-1返回）：&quot;</span>);        <span class="hljs-type">int</span> <span class="hljs-variable">table</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">try</span> &#123;            table = Integer.parseInt(scanner.next());        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            System.out.println(<span class="hljs-string">&quot;输入错误&quot;</span>);        &#125;        <span class="hljs-keyword">if</span> (table &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">/* 检查一下桌号 */</span>        <span class="hljs-type">TableData</span> <span class="hljs-variable">tableData</span> <span class="hljs-operator">=</span> checkTable(table, <span class="hljs-number">4</span>);        <span class="hljs-keyword">if</span> (tableData == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">/* 检查并展示那个桌号的未结账单 */</span>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> checkBillByTable(table);        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        System.out.println(s);        System.out.println(<span class="hljs-string">&quot;请确认以上信息（Y/N）：&quot;</span>);        <span class="hljs-type">char</span> <span class="hljs-variable">confirm</span> <span class="hljs-operator">=</span> scanner.next().charAt(<span class="hljs-number">0</span>);        <span class="hljs-keyword">if</span> (confirm != <span class="hljs-string">&#x27;Y&#x27;</span> &amp;&amp; confirm != <span class="hljs-string">&#x27;y&#x27;</span>)&#123;            <span class="hljs-keyword">return</span>;        &#125;        System.out.println(<span class="hljs-string">&quot;请输入结算方式（1现金；2支付宝；3微信；-1返回）：&quot;</span>);        <span class="hljs-type">int</span> <span class="hljs-variable">way</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;        <span class="hljs-keyword">try</span> &#123;            way = Integer.parseInt(scanner.next());            <span class="hljs-keyword">if</span> (way &lt; -<span class="hljs-number">1</span> || way &gt; <span class="hljs-number">3</span>)&#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            System.out.println(<span class="hljs-string">&quot;输入错误&quot;</span>);        &#125;        <span class="hljs-keyword">if</span> (way == -<span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">/* 发送结账请求 */</span>        <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(Client.IP, Client.ServerIP, MessageType.FINISH_BILLS, userData + <span class="hljs-string">&quot;\t&quot;</span> +  table + <span class="hljs-string">&quot;\t&quot;</span> + way);        <span class="hljs-type">Message</span> <span class="hljs-variable">receive</span> <span class="hljs-operator">=</span> sendAndReceive(message);        <span class="hljs-keyword">if</span> (receive == <span class="hljs-literal">null</span>) &#123;            System.out.println(<span class="hljs-string">&quot;错误：服务器无响应&quot;</span>);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (receive.getWord().equals(MessageType.REJECT)) &#123;            System.out.println(<span class="hljs-string">&quot;错误：请求被拒绝&quot;</span>);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (receive.getWord().equals(MessageType.ACCEPT)) &#123;            System.out.println(<span class="hljs-string">&quot;结算成功&quot;</span>);        &#125;    &#125;    <span class="hljs-comment">/* 登出 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">logout</span><span class="hljs-params">()</span> &#123;        System.out.print(<span class="hljs-string">&quot;确定登出吗？（Y/N）：&quot;</span>);        <span class="hljs-type">char</span> confirm;        <span class="hljs-keyword">try</span> &#123;            confirm = scanner.next().charAt(<span class="hljs-number">0</span>);            <span class="hljs-keyword">if</span> (confirm != <span class="hljs-string">&#x27;y&#x27;</span> &amp;&amp; confirm != <span class="hljs-string">&#x27;Y&#x27;</span>)&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;            <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(Client.IP, Client.ServerIP, MessageType.LOGOUT, userData);            client.getOos().writeObject(message);            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            System.out.println(<span class="hljs-string">&quot;传输异常&quot;</span>);            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>程序</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日记本</title>
    <link href="/2022/02/21/%E6%97%A5%E8%AE%B0/%E6%97%A5%E8%AE%B0%E6%9C%AC/"/>
    <url>/2022/02/21/%E6%97%A5%E8%AE%B0/%E6%97%A5%E8%AE%B0%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="日记本">日记本</h1><p>[HIDE：那天]</p><h3 id="年">2022 年</h3><ul><li><ahref="../../../../../2022/02/21/日记/%E6%97%A5%E8%AE%B020220221/"><strong>2022- 2 - 21 —— 九命</strong></a></li><li><strong>2022 - 3 - 8 —— 新世界</strong></li><li><strong>2022 - 3 - 12 —— 时间胶囊 [HIDE]</strong></li><li><ahref="../../../../../2022/03/15/日记/%E6%97%A5%E8%AE%B020220315/"><strong>2022- 3 - 15 —— 命运</strong></a></li><li><strong>2022 - 3 - 22 —— 红房子 [HIDE]</strong></li><li><strong><ahref="../../../../../2022/03/28/日记/%E6%97%A5%E8%AE%B020220328/">2022 -3 - 28 —— 烟雾</a></strong></li><li><strong><ahref="../../../../../2022/04/01/日记/%E6%97%A5%E8%AE%B020220401/">2022 -4 - 1 —— 塔罗牌</a></strong></li><li><strong>2022 - 4 - 2 —— 心音 [HIDE]</strong></li><li><strong>2022 - 4 - 9 —— 明日之前 [HIDE]</strong></li><li><strong><ahref="../../../../../2022/04/17/日记/%E6%97%A5%E8%AE%B020220417/">2022 -4 - 17 —— 无题</a></strong></li><li><strong>2022 - 4 - 29 —— 无期 [HIDE]</strong></li><li><strong><ahref="../../../../../2022/05/05/%E6%97%A5%E8%AE%B0/%E6%97%A5%E8%AE%B020220505/">2022- 5 - 5 —— 环</a></strong></li><li><strong><ahref="../../../../../2022/05/06/%E6%97%A5%E8%AE%B0/%E6%97%A5%E8%AE%B020220506/">2022- 5 - 6 —— 早安，晚安</a></strong></li><li><strong><ahref="../../../../../2022/05/08/%E6%97%A5%E8%AE%B0/%E6%97%A5%E8%AE%B020220508/">2022- 5 - 8 —— 蛋糕</a></strong></li><li><ahref="../../../../../2022/05/20/%E6%97%A5%E8%AE%B0/%E6%97%A5%E8%AE%B020220520/"><strong>2022- 5 - 20 —— 延期</strong></a></li><li><ahref="../../../../../2022/05/23/%E6%97%A5%E8%AE%B0/%E6%97%A5%E8%AE%B020220523/"><strong>2022- 5 - 23 —— 风</strong></a></li><li><ahref="../../../../../2022/05/29/%E6%97%A5%E8%AE%B0/%E6%97%A5%E8%AE%B020220529/"><strong>2022- 5 - 23 —— 雨夜</strong></a></li><li><strong><ahref="../../../../../2022/06/10/%E6%97%A5%E8%AE%B0/%E6%97%A5%E8%AE%B020220610/">2022- 6 - 10 —— 云霞</a></strong></li><li><strong><ahref="../../../../../2022/06/12/%E6%97%A5%E8%AE%B0/%E6%97%A5%E8%AE%B020220612/">2022- 6 - 12 —— 蜘蛛</a></strong></li><li><strong><ahref="../../../../../2022/06/24/%E6%97%A5%E8%AE%B0/%E6%97%A5%E8%AE%B020220624/">2022- 6 - 24 —— 桥</a></strong></li><li><strong><ahref="../../../../../2022/07/20/%E6%97%A5%E8%AE%B0/%E6%97%A5%E8%AE%B020220720/">2022- 7 - 20 —— 游鱼</a></strong></li><li><strong>2022 - 7 - 28 —— 雨燕 [HIDE]</strong></li><li><strong>2022 - 8 - 10 —— 内外 [HIDE]</strong></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt;23 JDBC 和数据库连接池</title>
    <link href="/2022/02/20/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/23%20JDBC%20%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    <url>/2022/02/20/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/23%20JDBC%20%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="jdbc-和数据库连接池">23 JDBC 和数据库连接池</h1><blockquote><p>JDBC：Java 提供的一套用于操作数据库的接口 API。Java程序员只需要面向该接口即可连接任何提供了 JDBC驱动程序的数据库，完成对数据库的各种操作。不同的数据库厂商，需要针对这套接口提供不同的实现。</p></blockquote><p><strong>JDBC 程序编写步骤（示范）：</strong></p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/* [0] 前置操作 */</span><span class="hljs-comment">/* [1] 注册驱动 */</span><span class="hljs-type">Driver</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">com</span>.mysql.cj.jdbc.Driver();<span class="hljs-comment">/* [2] 获取连接 */</span><span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/melody&quot;</span>;<span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();properties.setProperty(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>);properties.setProperty(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;******&quot;</span>);<span class="hljs-type">Connection</span> <span class="hljs-variable">connect</span> <span class="hljs-operator">=</span> driver.connect(url, properties);<span class="hljs-comment">/* [3] 执行语句 */</span><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;insert into customer (customer_id,name,card_id) values(0004,&#x27;赫尔&#x27;,&#x27;00000000000000000O&#x27;)&quot;</span>;<span class="hljs-type">Statement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> connect.createStatement();<span class="hljs-type">int</span> <span class="hljs-variable">rows</span> <span class="hljs-operator">=</span> statement.executeUpdate(sql);System.out.println(rows);<span class="hljs-comment">/* [4] 释放资源 */</span>statement.close();connect.close();</code></pre></div><ol start="0" type="1"><li><p>前置操作：将 <code>mysql-connector-java-8.0.27.jar</code>该文件拷贝到项目目录下，选中后右键选择<code>Add as library</code></p></li><li><p>注册驱动：加载 <code>Driver</code> 类</p><p>这里我导入了 <code>com.mysql.cj.jdbc.Driver</code>。根据前面的<code>jar</code> 包的版本不同，应该导入的路径也会不同。</p><p>旧版本的 <code>jar</code> 包可能应该导入<code>com.mysql.jdbc.Driver</code> 这个包。</p></li><li><p>获取连接：得到 <code>Connection</code></p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/melody&quot;</span>;</code></pre></div><p>这里表示进入 <code>melody</code> 这个数据库。</p></blockquote></li><li><p>执行语句：发送 SQL 命令给 MySQL 执行</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">rows</span> <span class="hljs-operator">=</span> statement.executeUpdate(sql);</code></pre></div><p>如果是 dml 语句，这里返回的 rows 是影响的行数。返回 0 表示失败。</p></blockquote></li><li><p>释放资源：关闭相关连接<strong>（切记！）</strong></p></li></ol></blockquote><h2 id="连接数据库的-5-种方式">23.1 连接数据库的 5 种方式</h2><ul><li><p>方式 1：直接创建 <code>Driver</code>，调用<code>driver.connet(url, properties);</code></p><p>这个方法就是 [23.0] 示范的方法</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Driver</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">com</span>.mysql.cj.jdbc.Driver();<span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/melody&quot;</span>;<span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();properties.setProperty(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>);properties.setProperty(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;******&quot;</span>);<span class="hljs-type">Connection</span> <span class="hljs-variable">connect</span> <span class="hljs-operator">=</span> driver.connect(url, properties);</code></pre></div></blockquote></li><li><p>方式 2：使用反射加载 <code>Driver</code> 类</p><p>这个方式是动态加载，更加灵活。</p><blockquote><div class="code-wrapper"><pre><code class="hljs java">Class&lt;?&gt; aClass = Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<span class="hljs-type">Driver</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> (Driver) aClass.newInstance();<span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();properties.setProperty(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>);properties.setProperty(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;******&quot;</span>);<span class="hljs-type">Connection</span> <span class="hljs-variable">connect</span> <span class="hljs-operator">=</span> driver.connect(url, properties);</code></pre></div></blockquote></li><li><p>方式 3：使用 <code>DriverManager</code> 替代 <code>Driver</code>进行统一管理</p><p>这个方式扩展性更好，更加清晰</p><blockquote><div class="code-wrapper"><pre><code class="hljs java">Class&lt;?&gt; aClass = Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<span class="hljs-type">Driver</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> (Driver) aClass.newInstance();<span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/melody&quot;</span>;<span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;<span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;******&quot;</span>;DriverManager.registerDriver(driver);<span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, name, password);</code></pre></div><p>这里，<code>DriverManager.getConnetion()</code>有三种方法。分别是：</p><ul><li><code>getConnetion(url);</code></li><li><code>getConnetion(url, properties);</code></li><li><code>getConnetion(url, name, password);</code></li></ul></blockquote></li><li><p>方式 4：使用 <code>Class.forName()</code> 自动完成注册驱动</p><blockquote><p><div class="code-wrapper"><pre><code class="hljs java">Class&lt;?&gt; aClass = Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/melody&quot;</span>;<span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;<span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;******&quot;</span>;<span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, name, password);</code></pre></div></p><p><code>Class.forName()</code> 在加载 <code>Driver</code>类时，会自动完成注册。</p></blockquote><p>原理：</p><blockquote><p><code>Driver</code> 类的源码中有这样一段</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &#123;     <span class="hljs-keyword">try</span> &#123;         DriverManager.registerDriver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Driver</span>());     &#125; <span class="hljs-keyword">catch</span> (SQLException var1) &#123;         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Can&#x27;t register driver!&quot;</span>);     &#125;&#125;</code></pre></div><p>这个静态代码块在类加载时会被执行。</p></blockquote><blockquote><p>另外，其实不执行 <code>Class.forName(...);</code>语句的场合，也能正确获取 <code>Connection</code>。</p><p>这是因为 JDK 1.5 以后使用了 jdbc4。这个场合，系统会自动调用 jar 包下<code>META-INF\services\java.sql.Driver</code>这个文件中的类名称去注册。</p><p>……打开上述文件看看，里面赫然写着：<code>com.mysql.cj.jdbc.Driver</code></p><p>即使如此，还是建议写上 <code>Class.forName(...)</code> 语句！</p></blockquote></li><li><p>方式 5（推荐）：在方式 4的基础上，使用配置文件，连接数据库更灵活。</p><p>这种方式是实际开发最常用的方式。</p><blockquote><p>配置文件（创建 src.properties）：</p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/melody</span><span class="hljs-attr">user</span>=<span class="hljs-string">root</span><span class="hljs-attr">password</span>=<span class="hljs-string">******</span><span class="hljs-attr">driver</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span></code></pre></div><p>代码：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Properties</span> <span class="hljs-variable">pro</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();pro.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;src\\mysql.properties&quot;</span>))<span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> pro.getProperties(<span class="hljs-string">&quot;url&quot;</span>);<span class="hljs-type">String</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> pro.getProperties(<span class="hljs-string">&quot;user&quot;</span>);<span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> pro.getProperties(<span class="hljs-string">&quot;password&quot;</span>);<span class="hljs-type">String</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> pro.getProperties(<span class="hljs-string">&quot;driver&quot;</span>);Class&lt;?&gt; aClass = Class.forName(driver);<span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, user, password);</code></pre></div></blockquote></li></ul><h2 id="reaultset-结果集">23.2 <code>ReaultSet</code> 结果集</h2><blockquote><p>ResultSet：表示数据库结果集的数据表。通常通过执行查询数据库的语句生成。</p><p>ResultSet对象保持一个光标指向其当前的数据行。该光标的初始位置在第一行之前。调用next 方法将光标下移，移动到末端的场合会返回 false。</p></blockquote><p><strong>如何取出数据（示例）：</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from customer&quot;</span>;<span class="hljs-type">ResultSet</span> <span class="hljs-variable">resset</span> <span class="hljs-operator">=</span> statement.executeQuery(sql);<span class="hljs-keyword">while</span> (resset.next()) &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> resset.getInt(<span class="hljs-number">1</span>);    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> resset.getString(<span class="hljs-number">2</span>);    <span class="hljs-type">String</span> <span class="hljs-variable">sex</span> <span class="hljs-operator">=</span> resset.getString(<span class="hljs-number">5</span>);    <span class="hljs-type">String</span> <span class="hljs-variable">card_id</span> <span class="hljs-operator">=</span> resset.getString(<span class="hljs-number">6</span>);    System.out.println(id + <span class="hljs-string">&quot;\t&quot;</span> + name + <span class="hljs-string">&quot;\t&quot;</span> + sex + <span class="hljs-string">&quot;\t&quot;</span> + card_id);&#125;</code></pre></div><p>其中 <code>String sex = resset.getString(5);</code>表示取出该行数据的第 5 列的字符串数据。</p><p>ResultSet的数据是以类似二维数组的形式保存在对象中。这不难理解，毕竟表格是二维的嘛。</p><h2 id="statement">23.3 <code>Statement</code></h2><blockquote><p><code>Statment</code> 对象用于执行静态 SQL语句，并返回其生成的结果的对象</p><p>在连接建立后，需要访问数据库、执行命名或 SQL 语句，有如下方式：</p><ul><li><code>Statment</code>（存在 SQL注入问题，在实际开发中基本不使用）</li><li><code>PerparedStatement</code>（预处理）</li><li><code>CallableStatement</code>（存储过程）</li></ul><p>SQL注入：利用某些系统没有对用户输入的数据进行充分的检查，故意注入非法的 SQL语句段或命令，恶意攻击数据库。</p><p>使用 <code>PreparedStatement</code> 可以防范 SQL 注入</p></blockquote><h3 id="preparedstatement-预处理">23.3.1 <code>PreparedStatement</code>预处理</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/* [1] */</span><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from customer where customer_id = ? and name = ?&quot;</span>;<span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> connection.prepareStatement(sql);<span class="hljs-comment">/* [2] */</span>ps.setInt(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);ps.setString(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;萝茵&quot;</span>);<span class="hljs-comment">/* [3] */</span><span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> ps.executeQuery();</code></pre></div><ol type="1"><li><p><code>PreparedStatement</code> 执行的 SQL 语句的参数用<code>?</code> 表示。</p></li><li><p>调用方法设置 SQL 语句中的参数。</p><p>这些方法的两个参数中，第一个是设置的参数的索引，第二个是设置值</p></li><li><p>调用 <code>executeQuery()</code> 返回 <code>ResultSet</code>对象。或者调用 <code>executeUpdate()</code> 执行增删改</p><p>这里，调用的方法不需要再传入参数</p></li></ol><p><strong>预处理的好处</strong></p><ol type="1"><li>不再使用拼接语句，增加代码可读性，减少语法错误</li><li>解决了 SQL 注入问题</li><li>大大减少了编译次数，效率提高</li></ol><table><thead><tr class="header"><th>类 / 接口</th><th>方法</th></tr></thead><tbody><tr class="odd"><td>DriverManager 驱动管理类</td><td>getConnection(url, user, pwd) 获取连接</td></tr><tr class="even"><td>Connection 接口</td><td>createStatement() 创建 Statement 对象</td></tr><tr class="odd"><td></td><td>preparedStatement(sql) 生成预处理 PreparedStatement 对象</td></tr><tr class="even"><td>Statement 接口</td><td>executeUpdate(sql) 执行 dml 语句，返回影响行数</td></tr><tr class="odd"><td></td><td>executeQuery(sql) 执行查询语句，返回 ResultSet</td></tr><tr class="even"><td></td><td>execute(sql) 执行任意 SQL 语句，返回布尔值</td></tr><tr class="odd"><td>PreparedStatement 接口</td><td>executeUpdate() 执行 dml 语句，返回影响行数</td></tr><tr class="even"><td></td><td>executeQuery() 执行查询语句，返回 ResultSet</td></tr><tr class="odd"><td></td><td>execute() 执行任意 SQL 语句，返回布尔值</td></tr><tr class="even"><td></td><td>setXXX(int, xxx) 设置 SQL 语句中占位符的值</td></tr><tr class="odd"><td></td><td>setObject(int, xxx) 设置 SQL 语句中占位符的值</td></tr><tr class="even"><td>ResultSet 结果集</td><td>next() 向下移动一行。没有下一行的场合返回 false</td></tr><tr class="odd"><td></td><td>previous() 向上移动一行。没有上一行的场合返回 false</td></tr><tr class="even"><td></td><td>getXXX(int)、getXXX(name) 返回 int 列 / name 列的值</td></tr><tr class="odd"><td></td><td>getObject(int)、getObject(name) 返回 int 列 / name 列的值</td></tr></tbody></table><h2 id="jdbcutils">23.4 JDBCUtils</h2><blockquote><p>实际操作中，获取连接 和 释放资源操作经常使用。可以把这些操作封装成工具类 JDBCUtils</p></blockquote><p><strong>JDCUtils.java</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody;<span class="hljs-keyword">import</span> java.io.FileInputStream;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.sql.*;<span class="hljs-keyword">import</span> java.util.Properties;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JDBCUtils</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String url;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String user;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String pw;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String driver;    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();            properties.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;src/com/melody/mysql.properties&quot;</span>));            url = properties.getProperty(<span class="hljs-string">&quot;url&quot;</span>);            user = properties.getProperty(<span class="hljs-string">&quot;user&quot;</span>);            pw = properties.getProperty(<span class="hljs-string">&quot;password&quot;</span>);            driver = properties.getProperty(<span class="hljs-string">&quot;driver&quot;</span>);            Class&lt;?&gt; aClass = Class.forName(driver);        &#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<span class="hljs-comment">//[1]</span>        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;        <span class="hljs-keyword">return</span> DriverManager.getConnection(url, user, pw);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">close</span><span class="hljs-params">(Connection c, Statement s, ResultSet r)</span> &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (!(c == <span class="hljs-literal">null</span>))&#123;                c.close();            &#125;            <span class="hljs-keyword">if</span> (!(s == <span class="hljs-literal">null</span>))&#123;                s.close();            &#125;            <span class="hljs-keyword">if</span> (!(r == <span class="hljs-literal">null</span>))&#123;                r.close();            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<span class="hljs-comment">//[1]</span>        &#125;    &#125;&#125;</code></pre></div><ol type="1"><li>实际开发中，可以把编译异常转换为运行异常。这样，调用者可以自行选择捕获异常还是默认处理。</li></ol><h2 id="事务">23.5 事务</h2><blockquote><p>事务：JDBC 程序中，当一个 <code>Connection</code>对象创建时，默认情况下会自动提交事务。为了让多个 SQL语句一体执行，需要使用事务。</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-keyword">try</span> &#123;    connection = JDBCUtils.getConnection();    connection.setAutoCommit(<span class="hljs-literal">false</span>);<span class="hljs-comment">//[1] 取消自动提交事务</span>    <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;insert into actor values(9, &#x27;赫尔萝茵&#x27;)&quot;</span>;    <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> connection.prepareStatement(sql);    preparedStatement.executeUpdate();    sql = <span class="hljs-string">&quot;delete from actor where name = &#x27;萝茵&#x27; and id &gt; (select * from (select min(id) from actor where name = &#x27;萝茵&#x27;) a)&quot;</span>;    <span class="hljs-comment">//[2]</span>    preparedStatement = connection.prepareStatement(sql);    preparedStatement.executeUpdate();    connection.commit();<span class="hljs-comment">//[3] 提交事务</span>    System.out.println(<span class="hljs-string">&quot;complete&quot;</span>);&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;    System.out.println(<span class="hljs-string">&quot;fail&quot;</span>);    System.out.println(e);    connection.rollback();<span class="hljs-comment">//[4] 回滚事务</span>&#125; <span class="hljs-keyword">finally</span> &#123;    connection.close();<span class="hljs-comment">//[5] 关闭连接</span>&#125;</code></pre></div><ol type="1"><li><p>取消自动提交事务：</p><div class="code-wrapper"><pre><code class="hljs java">connection.setAutoCommit(<span class="hljs-literal">false</span>);</code></pre></div></li><li><p>这是一个 SQL 语句。表示在 name = 萝茵 的数据中只保留 id最小的一条。</p><div class="code-wrapper"><pre><code class="hljs mysql">delete from actor where name = &#x27;萝茵&#x27; and id &gt; (select * from (select min(id) from actor where name = &#x27;萝茵&#x27;) a)</code></pre></div><p>正常写法会提示不能同表查询（在 MySQL 中，不能在同一语句中先 select出同一表中的某些值，再 update 这个表）。使用一个额外的 select过渡就解决了这个问题。特此记录。</p></li><li><p>提交事务：</p><div class="code-wrapper"><pre><code class="hljs java">connection.commit();</code></pre></div></li><li><p>回滚事务：</p><div class="code-wrapper"><pre><code class="hljs java">connection.rollback();</code></pre></div><p>写在 catch 里。这样，语句错误抛出异常的场合会执行到这句话。</p></li><li><p>关闭连接：</p><div class="code-wrapper"><pre><code class="hljs java">connection.close();</code></pre></div><p>写在 finally 里。这样，执行完语句总会关闭连接。这很好。</p></li></ol><h2 id="批处理">23.6 批处理</h2><blockquote><p>批处理：把多条语句一次性提交给数据库进行批量处理。这样做比单独提交更有效率。</p></blockquote><p>要使用批处理功能，需要在 url 中加入<code>?rewriteBatchedStatements=true</code>，即在配置文件中写成：</p><blockquote><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true</span></code></pre></div></blockquote><p>批处理往往和 PerparedStatement搭配使用，既减少编译次数，又减少运行次数，岂不美哉？</p><p><strong>示例：</strong></p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//[0] 事前准备</span><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> JDBCUtils.getConnection();<span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;insert into test1 values(?)&quot;</span>;<span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> connection.prepareStatement(sql);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;ps.setInt(<span class="hljs-number">1</span>,i);ps.addBatch();<span class="hljs-comment">//[1]</span>&#125;ps.executeBatch();<span class="hljs-comment">//[2]</span>JDBCUtils.close(connection, ps, <span class="hljs-literal">null</span>);</code></pre></div><ol start="0" type="1"><li><p>修改配置文件</p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true</span><span class="hljs-attr">...</span></code></pre></div></li><li><p>添加需要批量处理的 SQL 语句</p><div class="code-wrapper"><pre><code class="hljs java">preparedStatement.addBatch();</code></pre></div></li><li><p>执行批量处理语句</p><div class="code-wrapper"><pre><code class="hljs java">preparedStatement.executeBatch();</code></pre></div></li><li><p>（前面的例子里没有这句）清空批处理包的语句</p><div class="code-wrapper"><pre><code class="hljs java">preparedStatement.clearBatch();</code></pre></div></li></ol></blockquote><h3 id="说明">23.6.1 说明</h3><ol type="1"><li><p>第一次添加批处理语句时，创建一个 ArrayList。</p><blockquote><div class="code-wrapper"><pre><code class="hljs java">...<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.batchedArgs == <span class="hljs-literal">null</span>) &#123;    <span class="hljs-built_in">this</span>.batchedArgs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();&#125;...</code></pre></div></blockquote><p>……会在其中放置批处理语句（指令的数据）</p></li><li><p>该数组满后，按照 1.5 倍扩容</p></li><li><p>达到指定的值后，执行 executeBatch 吧</p></li><li><p>批处理能减少编译次数，也能减少发送 SQL 语句的网络开销。</p></li></ol><h2 id="数据库连接池">23.7 数据库连接池</h2><blockquote><p><strong>传统获取 Connection 方法的问题：</strong></p><ol type="1"><li>传统的 JDBC 数据库连接使用 DriverManager 获取，每次建立连接都会把Connection载入内存，再进行身份验证。每次连接都会重复验证请求，这样会占用过多系统资源，容易造成服务器崩溃。</li><li>每次连接，使用完毕后必须断开。如果不断开操作，会致使数据库内存泄漏，最终不得不重启数据库。</li><li>传统连接方式不能控制创建的连接数量。连接数量过多的场合，也可能导致内存泄漏，MySQL崩溃</li></ol></blockquote><p><strong>因此，需要使用连接池技术：</strong></p><ol type="1"><li>预先在缓冲池放入一定数量的连接。需要建立数据库连接时，从缓冲池中取出一个连接。使用完后，把该连接放回缓冲池。</li><li>数据库连接池负责分配、管理和释放数据库连接。其允许应用程序重复使用一个现有的数据库连接，而非建立新的连接。</li><li>当请求连接的数量超过最大数量，这些连接请求会被加入等待队列。</li></ol><p><strong>数据库连接池种类：</strong></p><p>JDBC 数据库连接池使用 javax.sql.DataSource 表示。DataSource是一个接口，通常由第三方提供实现（提供 jar 包）</p><ul><li>C3P0：速度稍慢，稳定性好……但是速度再慢也不是传统 JDBC能比得上的，不自量力！</li><li>DBCP：速度稍快，稳定性差</li><li>Proxool：可以监控连接池状态，稳定性稍差</li><li>BoneCP：速度快</li><li>Druid：阿里提供的数据库连接池，集 DBCP、C3P0、Proxool优点于一身</li></ul><h3 id="c3p0">23.7.1 C3P0</h3><p>写在前面：C3P0 连接时跳一堆红字，不一定是报错……他就这样。</p><p><strong>使用 C3P0 的前置工作：</strong></p><ol type="1"><li><p><ahref="https://sourceforge.net/projects/c3p0/?source=navbar">C3P0 jar包下载</a></p></li><li><p>……和前面一样，把 jar 包装载好。</p><p>为了正常运行程序，这里（上面连接下载的） jar 包（似乎）至少是：</p><p><code>mchange-commons-java-0.2.19.jar</code></p><p><code>c3p0-0.9.5.5.jar</code></p></li></ol><ul><li><p>方式一：在程序中指定相关参数 &gt; &gt; <div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/* [1] */</span><span class="hljs-type">ComboPooledDataSource</span> <span class="hljs-variable">cpds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComboPooledDataSource</span>();<span class="hljs-comment">/* [2] */</span>cpds.setDriverClass(dirver);cpds.setUser(user);cpds.setPassword(password);cpds.serJdbcUrl(url);<span class="hljs-comment">/* [3] */</span>cpds.setInitialPoolSize(<span class="hljs-number">10</span>);<span class="hljs-comment">/* [4] */</span>cpds.setMaxPoolSize(<span class="hljs-number">50</span>);<span class="hljs-comment">/* [5] */</span><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> cpds.getConnection();...connection.close();</code></pre></div> &gt; &gt;1. 创建数据源对象 &gt;<br />&gt; <div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">ComboPooledDataSource</span> <span class="hljs-variable">cpds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComboPooledDataSource</span>();</code></pre></div> &gt;<br />&gt; 2. 设置参数 &gt; &gt; <div class="code-wrapper"><pre><code class="hljs java">cpds.setDriverClass(String dirver);cpds.setUser(String user);cpds.setPassword(String password);cpds.serJdbcUrl(String url);</code></pre></div> &gt; &gt; ……上面输入的形参<code>user</code> 是字符串 <code>"root"</code>。其他同理。 &gt; &gt; 3.设置初始化连接数 &gt;<br />&gt; <div class="code-wrapper"><pre><code class="hljs java">cpds.setInitialPoolSize(<span class="hljs-number">10</span>);</code></pre></div> &gt;<br />&gt; 初始化连接数，就是指连接池创建时，初始持有的连接数 &gt;<br />&gt; 4. 设置最大连接数 &gt; &gt; <div class="code-wrapper"><pre><code class="hljs java">cpds.setMaxPoolSize(<span class="hljs-number">50</span>);</code></pre></div> &gt; &gt; 5.获取一个连接 &gt;<br />&gt; <div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> cpds.getConnection();</code></pre></div> &gt;</p></li><li><p>方式二：使用配置文件模板完成</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/* [0] 前置操作 */</span> <span class="hljs-comment">/* [1] 获取数据源对象 */</span> <span class="hljs-type">ComboPooledDataSource</span> <span class="hljs-variable">cpds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComboPooledDataSource</span>(<span class="hljs-string">&quot;Heruin&quot;</span>);<span class="hljs-comment">/* [2] 获取连接 */</span> <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> cpds.getConnection();...connection.close();</code></pre></div><ol start="0" type="1"><li><p>加入配置文件</p><p><strong>c3p0-config.xml：</strong>配置文件，文件名固定，放在<code>src/c3p0-config.xml</code> 这个位置</p><p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">c3p0-config</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 数据源（连接池）名称 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">named-config</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Heruin&quot;</span>&gt;</span>            <span class="hljs-comment">&lt;!-- 驱动类 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClass&quot;</span>&gt;</span>com.mysql.cj.jdbc.Driver<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>            <span class="hljs-comment">&lt;!-- url --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcUrl&quot;</span>&gt;</span>jdbc:mysql://localhost:3306/test<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>            <span class="hljs-comment">&lt;!-- 用户名 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>            <span class="hljs-comment">&lt;!-- 密码 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span>******<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>            <span class="hljs-comment">&lt;!-- 初始化连接数 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;initialPoolSize&quot;</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>            <span class="hljs-comment">&lt;!-- 最大空闲时间 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxIdleTime&quot;</span>&gt;</span>30<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>            <span class="hljs-comment">&lt;!-- 最大连接数 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxPoolSize&quot;</span>&gt;</span>100<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>            <span class="hljs-comment">&lt;!-- 最小连接数 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;minPoolSize&quot;</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>            <span class="hljs-comment">&lt;!-- 每次增长的连接数 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;acquireIncrement&quot;</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>            <span class="hljs-comment">&lt;!-- 可连接的最多的命令对象数 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxStatements&quot;</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>            <span class="hljs-comment">&lt;!-- 每个连接可连接的最多的命令对象数 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxStatementsPerConnection&quot;</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">named-config</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">c3p0-config</span>&gt;</span></code></pre></div></p></li><li><p>获取数据源对象</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">ComboPooledDataSource</span> <span class="hljs-variable">cpds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComboPooledDataSource</span>(String name);</code></pre></div><p>这里的 <code>name</code> 就是配置文件中的<code>数据源名称</code></p></li><li><p>获取连接</p></li></ol></blockquote></li></ul><h3 id="druid德鲁伊连接池">23.7.2 Druid（德鲁伊）连接池</h3><p><sub>有的人因为看见而相信，有的人因为相信而看见！</sub></p><p><strong>使用 Druid 的前置工作：</strong></p><ol type="1"><li><p><a href="https://github.com/alibaba/druid">Druid jar包下载</a></p><p>……这个链接打不开的话，试试 <ahref="https://repo1.maven.org/maven2/com/alibaba/druid/">这个</a></p></li><li><p>配置 jar 包</p></li><li><p>加入配置文件</p><blockquote><p><strong>durid.properties：</strong>配置文件，文件名任意，放在<code>src/druid.properties</code></p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">driverClassName</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><span class="hljs-attr">url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true</span><span class="hljs-attr">username</span>=<span class="hljs-string">root</span><span class="hljs-attr">password</span>=<span class="hljs-string">720mel\im</span><span class="hljs-attr">initialSize</span>=<span class="hljs-string">10</span><span class="hljs-attr">minIdle</span>=<span class="hljs-string">5</span><span class="hljs-attr">maxActive</span>=<span class="hljs-string">20</span><span class="hljs-attr">maxWait</span>=<span class="hljs-string">5000</span></code></pre></div></blockquote></li></ol><ul><li><p>使用 Druid：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/* [1] 加载配置文件 */</span><span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();properties.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;src\\Druid.properties&quot;</span>));<span class="hljs-comment">/* [2] 初始化数据池 */</span><span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> DruidDataSourceFactory.createDataSource(properties);<span class="hljs-comment">/* [3] 获取连接 */</span><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> dataSource.getConnection();...connection.close();</code></pre></div><ol start="2" type="1"><li><p>初始化数据池</p><p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> DruidDataSourceFactory.createDataSource(properties);</code></pre></div></p></li><li><p>……没什么好说的，但要说一下这个：</p><p><div class="code-wrapper"><pre><code class="hljs java">connection.close();</code></pre></div></p><p><code>Connection</code> 是一个接口，对于方法<code>close()</code>，不同供应商有不同实现方法。</p><p>原生的 <code>MySQL</code>的实现方法是关闭连接，而这些连接池的实现方法是取消引用（放回连接池）。</p></li></ol></li></ul><h2 id="apache---dbutils">23.8 Apache - DbUtils</h2><blockquote><p><code>commons-DbUtils</code>：是 Apache 组织提供的一个开源的 JDBC工具库。它是对 JDBC 的封装。使用 dbutils 能极大简化 JDBC编码的工作量</p><p><strong>DbUtils 的常用类：</strong></p><ul><li><code>QueryRunner</code> 类：封装了 SQL的执行。是线程安全的，可以实现增、删、改、查、批处理操作</li><li><code>ResultSetHandler</code> 接口：用于处理<code>ResultSet</code>，按照需求将数据转化为其他形式</li></ul></blockquote><p>JDBC 传统方法的不足：</p><ol type="1"><li>结果集和连接是关联的。在连接关闭后，就不能使用结果集。</li><li>结果集只能使用一次，这样不便于数据管理</li><li>使用返回信息不方便</li></ol><p>解决方案：</p><ul><li><p>土方法：创建一个类，其属性与表格的列一一对应。将数据遍历并读取到一个个类对象中，再将这些类对象放置到集合中。这样，就得到了一个与表格数据关联的数据集合。</p><blockquote><p>数据类，根据需要创建：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SQL_Data</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;    <span class="hljs-keyword">private</span> Date date;    <span class="hljs-keyword">private</span> String name;            <span class="hljs-comment">/* 一定要有无参构造器。这是因为后面会用到反射 */</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SQL_Data</span><span class="hljs-params">()</span>&#123;&#125;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SQL_Data</span><span class="hljs-params">(<span class="hljs-type">int</span> id, Date date, String name)</span> &#123;        <span class="hljs-built_in">this</span>.id = id;        <span class="hljs-built_in">this</span>.date = date;        <span class="hljs-built_in">this</span>.name = name;    &#125;           <span class="hljs-comment">/* Geter &amp; Seter 笔记里就省略不记了。光占地方又没技术含量 */</span>    ...&#125;</code></pre></div><p>……然后遍历 ResultSet，存放。就不写了。</p></blockquote></li><li><p>使用 <code>DbUtils</code>：</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/* [0] 前置操作 */</span><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from account where ? = ?&quot;</span>;<span class="hljs-comment">/* [1] 创建 QueryRunner */</span><span class="hljs-type">QueryRunner</span> <span class="hljs-variable">qr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryRunner</span>();<span class="hljs-comment">/* [2] 执行相关方法 */</span>List&lt;SQL_Data&gt; list = qr.query(connection, sql, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanListHandler</span>&lt;&gt;(SQL_Data.class), <span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-number">1</span>);...<span class="hljs-comment">/* [3] 释放资源*/</span>connection.close();</code></pre></div><ol start="0" type="1"><li><p>前置操作：</p><p><ahref="https://commons.apache.org/proper/commons-dbutils/download_dbutils.cgi">获取jar 包</a>，并完成配置</p><p>得到连接 <code>Connection connection</code>，创建数据类（这里是<code>SQL_Data</code>）</p></li><li><p>执行相关方法，返回结果集</p><div class="code-wrapper"><pre><code class="hljs java">List&lt;SQL_Data&gt; list =     queryRunner.query(connection, sql, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanListHandler</span>&lt;&gt;(SQL_Data.class), ...);</code></pre></div><ul><li><p><code>queryRunner.query</code> 方法：执行 SQL 语句，把得到的<code>ResultSet</code> 封装到 List 集合。这个方法会自动关闭获得的<code>ResultSet</code>，所以不会造成资源泄漏</p></li><li><p><code>connection</code>：前置操作中得到的连接</p></li><li><p><code>sql</code>：SQL 语句</p></li><li><p><code>new BeanListHander&lt;&gt;(SQL_Data.class)</code>：利用反射机制，将数据封装到<code>SQL_Data</code> 对象中</p></li><li><p><code>"id", 1</code>：给 SQL 语句中的 <code>?</code>赋值。因为是可变参数，可以写多个，如：<code>queryRunner.query(connection, sql, new BeanListHandler&lt;&gt;(SQL_Data.class), "id", 1, "name", "识之律者");</code></p><p>……这里，可变参数也包含列名的场合，筛选似乎会失效。还不知道原理。特此记录。</p></li></ul></li><li><p>此时只需要关闭 <code>Connection</code></p><p><code>query()</code> 方法已经关闭了 <code>ResultSet</code> 和<code>PreparedStatement</code></p></li></ol></blockquote></li></ul><h3 id="apache-dbutils-常用方法">23.8.1 Apache-DbUtils 常用方法</h3><ul><li><p><code>queryRunner.update(connection, sql, ...)</code>：DML语句。增删改。</p><p>后面传入可变参数，用于给 SQL 语句中的 <code>?</code> 赋值</p><p>返回值 int 代表被影响的行数。</p></li><li><p><code>queryRunner.query(connection, sql, ResultSetHandler, ...)</code>：查询。</p><p>后面传入可变参数，用于给 SQL 语句中的 <code>?</code> 赋值</p><p>关于 <code>ResultSetHandler</code>：</p><ul><li>传入<code>new BeanListHander&lt;&gt;(SQL_Data.class)</code>：返回多行多列。这个场合，用<code>List</code> 接收返回值。</li><li>传入<code>new BeanHandler&lt;&gt;(SQL_Data.class)</code>：返回单行。这个场合，用<code>SQL_Data data</code> 接收返回值。</li><li>传入<code>new ScalarHander&lt;&gt;()</code>：返回单行单列。这个场合，用<code>Object</code> 接收返回值。</li></ul></li></ul><h3 id="表和-javabean-的对应关系">23.8.2 表和 JavaBean 的对应关系</h3><table><thead><tr class="header"><th>表类型</th><th>JavaBean类型</th></tr></thead><tbody><tr class="odd"><td>int、samllint……</td><td>Integer</td></tr><tr class="even"><td>char、varchar……</td><td>String</td></tr><tr class="odd"><td>double</td><td>Double</td></tr><tr class="even"><td>date</td><td>java.util.Date</td></tr></tbody></table><h2 id="basicdao">23.9 BasicDAO</h2><blockquote><p>Apache - DbUtils + Druid 简化了 JDBC 开发，但还有不足。</p><ol type="1"><li>SQL 语句固定，不能通过传入参数控制，通用性不好。</li><li>select 操作的返回类型未知，需要使用泛型。</li><li>将来的表很多，业务需求复杂，不可能只靠一个 Java 类完成</li></ol></blockquote><p>DAO：数据访问对象（data access object）</p><ol type="1"><li><p>我们把通用的和数据库交互的操作封装到一个通用类中，称为BasicDAO。</p></li><li><p>在 BasicDAO 基础上，每张表对应一个特化的 DAO（继承BasicDAO），从而更好地完成功能。</p><p>比如：Data 表 -&gt; Data.java 类（JavaBean）-&gt;DataDAO.java</p></li></ol><p><strong>BasicDAO.java（示例）</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicDAO</span>&lt;T&gt; &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">QueryRunner</span> <span class="hljs-variable">qr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryRunner</span>();    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">update</span><span class="hljs-params">(String sql, Object... parameters)</span>&#123;        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">try</span> &#123;            connection = JDBCUtils.getConnection();            <span class="hljs-keyword">return</span> qr.update(connection, sql, parameters);        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);        &#125; <span class="hljs-keyword">finally</span> &#123;            JDBCUtils.close(connection, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);        &#125;    &#125;    <span class="hljs-keyword">public</span> List&lt;T&gt; <span class="hljs-title function_">queryMulti</span><span class="hljs-params">(String sql, Class&lt;T&gt; tClass, Object... parameters)</span>&#123;        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">try</span> &#123;            connection = JDBCUtils.getConnection();            <span class="hljs-keyword">return</span> qr.query(connection, sql, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanListHandler</span>&lt;T&gt;(tClass), parameters);        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);        &#125; <span class="hljs-keyword">finally</span> &#123;            JDBCUtils.close(connection, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);        &#125;    &#125;    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">querySingle</span><span class="hljs-params">(String sql, Class&lt;T&gt; tClass, Object... parameters)</span>&#123;        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">try</span> &#123;            connection = JDBCUtils.getConnection();            <span class="hljs-keyword">return</span> qr.query(connection, sql, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanHandler</span>&lt;T&gt;(tClass), parameters);        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);        &#125; <span class="hljs-keyword">finally</span> &#123;            JDBCUtils.close(connection, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);        &#125;    &#125;    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">queryScalar</span><span class="hljs-params">(String sql, Object... parameters)</span>&#123;        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">try</span> &#123;            connection = JDBCUtils.getConnection();            <span class="hljs-keyword">return</span> qr.query(connection, sql, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScalarHandler</span>&lt;&gt;(), parameters);        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);        &#125; <span class="hljs-keyword">finally</span> &#123;            JDBCUtils.close(connection, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt;22 MySQL</title>
    <link href="/2022/01/22/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/22%20MySQL/"/>
    <url>/2022/01/22/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/22%20MySQL/</url>
    
    <content type="html"><![CDATA[<h1 id="mysql">22 MySQL</h1><h2 id="数据库">22.1 数据库</h2><blockquote><p>安装数据库，就是在主机安装一个数据库管理系统。该系统可以管理多个数据库。</p><p>一个数据库中可以拥有多张表，以保存数据（信息）。这些表的本质仍是文件</p><p>表的一行称为一条记录。在 Java 中，一行记录往往用对象表示</p><p><ahref="http://dev.mysql.com/get/Downloads/MySQL-5.7.19-winx64.zip">下载地址</a></p><p><ahref="https://www.bilibili.com/video/BV1fh411y7R8?p=732&amp;t=0.5">安装方法</a></p></blockquote><p>可视化 MySQL 管理软件：<strong><ahref="http://www.navicat.com.cn/products">Navicat</a></strong></p><p>连接到 MySQL服务的指令：<code>mysql -h 主机名 -P 端口 -u 用户名 -p密码</code></p><ol type="1"><li>-p密码 不要有空格</li><li>-p 后面不写密码，回车会要求输入密码</li><li>如果不写 -h 默认是本机</li><li>如果不写 -p 默认是 3306</li></ol><p>SQL 语句分类</p><ul><li>DDL（数据定义语句）：[create 表，库]</li><li>DML（数据操作语句）：[增加 insert]、[修改 update]、[删除delete]</li><li>DQL（数据查询语句）：[select]</li><li>DCL（数据控制语句）：[管理数据库：如用户权限 revoke grant]</li></ul><p><strong><em>关于数据库的详细说明，见本章附录</em></strong></p><h3 id="创建数据库">22.1.1 创建数据库</h3><div class="code-wrapper"><pre><code class="hljs mysql">CREATE DATABASE IF NOT EXISTS `Melody` CHARACTER SET &#x27;utf8&#x27; COLLATE &#x27;utf8_bin&#x27;;</code></pre></div><ol type="1"><li><p><code>CHARACTER SET</code>：指定数据库采用的字符集。</p><p>不指定的场合，默认 UTF-8</p></li><li><p><code>COLLATE</code>：指定数据库字符集校对规则</p><ul><li><code>utf8_bin</code> [区分大小写]（常用）</li><li><code>utf8_general_ci</code> [不区分大小写]（默认）</li></ul></li><li><p>在创建数据库 · 表时，为了规避关键字，可以使用反引号``<code></code></p></li><li><p>创建表时，不指定字符集 ·校对规则的场合，默认和数据库相同</p></li></ol><h3 id="查看-删除数据库">22.1.2 查看 · 删除数据库</h3><div class="code-wrapper"><pre><code class="hljs mysql">SHOW DATABASES;#1SHOW CREATE DATABASE `Melody`;#2DROP DATABASE [IF EXISTS] `Melody`;#3USE `sys`#4</code></pre></div><ol type="1"><li>显示数据库语句</li><li>显示数据库创建语句（当初创建时的语句）</li><li>数据库删除语句（必须慎用）</li><li>切换数据库</li></ol><h3 id="备份-恢复数据库">22.1.3 备份 · 恢复数据库</h3><p>备份（DOS）：<code>mysqldump -u 用户名 -p -B 数据库1 数据库2 &gt; 路径\文件名.sql</code></p><p>恢复（DOS，进入mysql）：<code>Source 文件名.sql;</code></p><p>备份库的表：<code>mysqldunp -u 用户名 -p 数据库 表1 表2 &gt; 路径\文件名.sql</code></p><h2 id="mysql-常用数据类型列类型">22.2 MySQL 常用数据类型（列类型）</h2><p><strong>数值类型</strong></p><ul><li>整形<ul><li>bit(M) [M 指定位数，默认1，范围 1 ~ 64]</li><li>tinyint [1 byte]</li><li>smallint [2 byte]</li><li>mediumint [3 byte]</li><li>int [4 byte]（常用）</li><li>bigint [8 byte]</li></ul></li><li>小数类型<ul><li>float [4 byte 单精度]</li><li>double [8 byte 双精度]（常用）</li><li>decimal(M,D) [大小不确定]（常用）</li></ul></li></ul><p><strong>文本类型（字符串）</strong></p><ul><li>char [0 ~ 255]（常用）</li><li>carchar [0 ~ 65535]（常用）</li><li>text [0 ~ 2<sup>16</sup> - 1]（常用）</li><li>longtext [ 0 ~ 2<sup>32</sup> - 1]</li></ul><p><strong>二进制数据类型</strong></p><ul><li>blob [0 ~ 2<sup>16</sup> - 1]</li><li>longblob [0 ~ 2<sup>32</sup> - 1]</li></ul><p><strong>时间日期类型</strong></p><ul><li>date [YYYY-MM-DD]</li><li>time [HH:mm:SS]</li><li>datetime [YYYY-MM-DD HH:mm:SS]（常用）</li><li>timestamp [时间戳]（常用）</li><li>year [年]</li></ul><h3 id="数组类型">22.2.1 数组类型</h3><h4 id="整形">22.2.1.1 整形</h4><ol type="1"><li><p>使用规范：在满足需求的情况下，尽量使用占用空间小的类型</p></li><li><p>如何定义一个无符号整数：在后面加入 <code>unsigned</code></p><div class="code-wrapper"><pre><code class="hljs mysql">CREATE TABLE `T1` (`ID` INT UNSIGNED);</code></pre></div><p>无符号是咋呢？以 tinyint 为例，有符号的范围是 [-128,127]，无符号范围是 [0, 255]</p></li></ol><h4 id="bit位类型">22.2.1.2 bit（位类型）</h4><ol type="1"><li><code>bit(m)</code> 中 m 的范围在 [1, 64]</li><li>添加数据的范围按照给定的位数（m）来确定。m = 8的场合表示一个字节，范围是 255</li><li>显示时，按照 bit 格式（<code>bit(8)</code> 的场合 <code>7</code>就显示为 <code>00000111</code>）</li><li>查询时，仍能按照十进制数查询</li></ol><h4 id="小数类型">22.2.1.3 小数类型</h4><ol type="1"><li><p><code>float</code> 单精度，<code>double</code> 双精度</p></li><li><p><code>decimal(M,D)</code> 可以支持更加精确的小数位。其中 M是小数位数的总数（精度），D 是小数点后的位数（标度）。</p><p>D = 0 的场合，值没有小数部分。M 最大值是 65，D 最大值是 30</p><p>D 省略的场合，默认为 0；M 省略的场合，默认为 10</p><p>希望小数精度高的场合，推荐使用 <code>decimal(M,D)</code></p></li></ol><h3 id="文本类型">22.2.2 文本类型</h3><ol type="1"><li><p><code>char(size)</code>：固定长度字符串，size 范围 [0, 255]，最大255 <strong>字符</strong>。</p></li><li><p><code>varchar(size)</code>：可变长度字符串，（UTF-8）size 范围[0, 21844]，最大 65532 <strong>字节</strong>（1 ~ 3字节要用于记录大小；UTF8 最大为 (65535 - 3) / 3 = 21844<strong>字符</strong>）</p></li><li><p>size 表示字符数，不是字节数。无论中文英文，都最多存放 size个字符</p></li><li><p><code>char(4)</code> 是定长。这个场合，不管输入什么（如'a'）都会占用 4 个字符的空间</p><p>相对的，<code>varchar(4)</code>是变长。实际占用空间取决于输入的字符（实际数据大小 + 额外的 1 ~ 3字节）</p></li><li><p>存放文本时，也可以使用 <code>text</code> 数据类型。可以把<code>text</code> 列视为 <code>varchar</code> 列。<code>text</code>不能有默认值，最大 2<sup>16</sup> 字节</p><p>希望存放更多字符，还能选择 <code>mediumtext</code>（最大2<sup>24</sup> 字节）或 <code>longtext</code>（最大 2<sup>32</sup>字节）</p></li></ol><h3 id="时间日期类型">22.2.3 时间日期类型</h3><div class="code-wrapper"><pre><code class="hljs mysql">CREATE TABLE `T2` (T1 DATETIME,       T2 TIMESTAMP       NOT NULL DEFAULT CURRENT_TIMESTAMP       ON UPDATE CURRENT_TIMESTAMP);</code></pre></div><p>后面一坨意为：默认时间戳为当前时间戳</p><h2 id="表">22.3 表</h2><h3 id="创建表">22.2.1 创建表</h3><div class="code-wrapper"><pre><code class="hljs mysql">CREATE TABLE `table_yuheng` (`name` VARCHAR(255), `id` INT, `age` INT) CHARACTER SET &#x27;utf8&#x27; COLLATE &#x27;utf8_bin&#x27; ENGINE INNODB;</code></pre></div><p>field：指定列名</p><p>datatype：指定列类型</p><p>character set：字符集</p><p>collate：校对规则</p><p>engine：引擎</p><div class="code-wrapper"><pre><code class="hljs mysql">CREATE TABLE genshin2 LIKE genshin;</code></pre></div><p>这个意思是：以 genshin 的结构创建一个表 genshin2</p><h3 id="删除-修改表">22.2.2 删除 · 修改表</h3><ul><li><p><strong>添加列</strong></p><div class="code-wrapper"><pre><code class="hljs mysql">ALTER TABLE `表名` ADD `列名` NOT NULL 列类型 DEFAULT 默认值 AFTER 某列名;</code></pre></div><p>在 <code>表名</code> 的 <code>某列名</code> 后面加入一个<code>列名</code> 列，类型是 <code>列类型</code> 默认值为<code>默认值</code></p></li><li><p><strong>修改列</strong></p><div class="code-wrapper"><pre><code class="hljs mysql">ALTER TABLE `表名` MODIFY `列名` 列类型 NOT NULL DEFAULT 默认值;</code></pre></div><blockquote><p>把 <code>表名</code> 的 <code>列名</code> 列修改为<code>列类型</code> ，默认值改为 <code>默认值</code></p></blockquote><div class="code-wrapper"><pre><code class="hljs mysql">ALTER TABLE `表名` CHANGE `列名` `新列名` 列类型 NOT NULL DEFAULT 默认值;</code></pre></div><p>把 <code>表名</code> 的 <code>列名</code> 列修改为<code>新列名</code> ，类型是 <code>列类型</code> 默认值为<code>默认值</code></p></li><li><p><strong>删除列</strong></p><div class="code-wrapper"><pre><code class="hljs mysql">ALTER TABLE `表名` DROP `列名`;</code></pre></div><p>删除 <code>表名</code> 的 <code>列名</code> 列</p></li><li><p><strong>查看表的结构</strong></p><div class="code-wrapper"><pre><code class="hljs mysql">DESC `表名`;</code></pre></div></li><li><p><strong>修改表名</strong></p><div class="code-wrapper"><pre><code class="hljs mysql">RENAME TABLE `表名` TO `新表名`;</code></pre></div></li><li><p><strong>修改表字符集</strong></p><div class="code-wrapper"><pre><code class="hljs mysql">ALTER TABLE `表名` CHARACTER SET &#x27;字符集&#x27;;</code></pre></div></li><li><p><strong>修改存储引擎</strong></p><div class="code-wrapper"><pre><code class="hljs mysql">ALTER TABLE `表名` ENGINE = 引擎;</code></pre></div></li></ul><h2 id="数据库的增删改查">22.4 数据库的增删改查</h2><blockquote><p>C（create 创建）R（read 查找）U（update 修改）D（delete 删除）</p></blockquote><h3 id="insert-语句">22.4.1 INSERT 语句</h3><div class="code-wrapper"><pre><code class="hljs mysql">INSERT INTO `表名` (列名1, 列名2, 列名3)VALUES (值1, 值2, 值3), (值1a, 值2a, 值3a);</code></pre></div><ol type="1"><li><p>当不给某个字段值时，如有默认值会添加默认值，否则会报错。</p></li><li><p>另外，给表中 所有字段 添加数据的场合，也能不写列名：</p><div class="code-wrapper"><pre><code class="hljs mysql">INSERT INTO `表名` VALUES (值1, 值2, 值3);</code></pre></div></li></ol><h3 id="update-语句">22.4.2 UPDATE 语句</h3><div class="code-wrapper"><pre><code class="hljs mysql">UPDATE `表名` SET `列名` = 值, `列名2` = 值2 WHERE `条件列` = 条件值;</code></pre></div><ol type="1"><li>对于所有 <code>条件列</code> = <code>条件值</code> 的记录，将<code>列名</code> 列改为 <code>值</code></li><li>SET 子句指示要修改哪些列和给予哪些值</li><li><strong>如果不带 where 条件，会修改所有记录</strong></li></ol><h3 id="delete-语句">22.4.3 DELETE 语句</h3><div class="code-wrapper"><pre><code class="hljs mysql">DELETE FROM `表名` WHERE `条件列` = 条件值;</code></pre></div><ol type="1"><li>不能删除一列的值。若要如此做，可以使用 update 语句将一列置空</li><li>delete 语句仅能删除记录，不能删除表本身。要如此做，可以使用 [22.2.2]中的 drop 语句</li><li><strong>如果不带 where 条件，会删除所有记录</strong></li></ol><h3 id="select-语句单表">22.4.4 SELECT 语句（单表）</h3><div class="code-wrapper"><pre><code class="hljs mysql">SELECT DISTINCT `列1`, `列2` FROM `表名` WHERE 条件;SELECT * FROM `表名2`;</code></pre></div><ol type="1"><li>DISTINCT是可选的。表示显示结果时，是否去掉重复数据（查询记录的所有字段都相同才会去重）</li><li>SELECT 指定查询哪些列的数据。</li><li>SELECT * 的场合代表查询所有列</li><li>FROM 指定查询哪张表</li></ol><ul><li><p><strong>使用表达式对查询的列进行运算</strong></p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT `name`, (chinese + math + english) FROM `student`;</code></pre></div><p>这个场合，显示的时候是 <code>name</code> 和<code>chinese + math + english</code> 两列</p></li><li><p><strong><code>AS</code> 语句</strong></p><p>可以用 AS 语句起个别名</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT `name`, (chinese + math + english) AS `all` FROM `student`;</code></pre></div><p>这个场合，显示的时候是 <code>name</code> 和 <code>all</code>两列</p></li><li><p><strong>用 <code>ORDER BY</code> 语句排序查询结果</strong></p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT * FROM `student` ORDER BY `math` DESC;</code></pre></div><p>以 <code>math</code> 降序排列</p><ul><li>降序：DESC</li><li>升序：ASC（不写也是默认升序）</li></ul><div class="code-wrapper"><pre><code class="hljs mysql">SELECT * FROM `genshin` ORDER BY `age` ASC, `salary` DESC;</code></pre></div><p>以 <code>age</code> 升序并以 <code>salary</code> 降序排列</p></li><li><p><strong>统计函数 <code>COUNT</code></strong></p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT COUNT(*) FROM `student`;</code></pre></div><p>统计表中有多少记录</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT COUNT(*) FROM `student` WHERE `math` &gt; 60;</code></pre></div><p>统计表中 <code>math &gt; 60</code> 的数目</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT COUNT(`name`) FROM `student`;</code></pre></div><p>统计表中有多少记录，排除 <code>name</code> 为空的数目</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT COUNT(name), sum(`age`), sum(`salary`) / COUNT(*) FROM `genshin`;</code></pre></div><p>这样也是可以的</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT COUNT(IF (`name` IS NULL, 1, NULL)) FROM `genshin`;SELECT COUNT(DISTINCT `name`) FROM `genshin`;</code></pre></div><p>还有很多方式</p></li><li><p><strong>分组语句 <code>GROUP BY</code></strong></p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT AVG(`salary`), `age` FROM `genshin` group by `age`;</code></pre></div><p>按 <code>age</code> 分组统计</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT MAX(`salary`) FROM `genshin` group by `age`, `name`;</code></pre></div><p>按 <code>age</code> 和 <code>name</code> 分组统计</p></li><li><p><strong>用 <code>HAVING</code> 语句过滤</strong></p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT AVG(salary) FROM genshin GROUP BY country HAVING AVG(age) &gt; 18;</code></pre></div><p>按 <code>country</code> 分组统计，显示其中<code>AVG(age) &gt; 18</code> 的组</p></li><li><p><strong><code>WHERE</code> 语句</strong></p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT * FROM `genshin` WHERE `create_time` &gt; &#x27;2011-01-01&#x27;;</code></pre></div><p>日期可以直接比较</p><p>比起 <code>HAVING</code>，<code>WHERE</code> 是在分组前过滤</p></li><li><p><strong><code>LIKE</code> 字符</strong></p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT * FROM `genshin` WHERE `name` LIKE &#x27;_E%&#x27;;</code></pre></div><p>下划线 <code>_</code> 代表一个任意字符</p><p>百分号 <code>%</code> 代表任意个任意字符</p></li><li><p><strong>分页查询</strong></p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT * FROM `genshin` LIMIT num, rows;</code></pre></div><p>从 num + 1 行开始取，取出 rows 行。num 从 0 开始计数</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT * FROM `genshin` LIMIT 0, 3;SELECT * FROM `genshin` LIMIT 3, 3;SELECT * FROM `genshin` LIMIT 6, 3;...</code></pre></div></li></ul><p><strong>总结：</strong></p><p><code>SELECT</code> 语句顺序是 <code>GROUP BY</code> &gt;&gt;<code>HAVING</code> &gt;&gt; <code>ORDER BY</code> &gt;&gt;<code>LIMIT</code></p><h3 id="常用的运算符">22.4.5 常用的运算符</h3><table style="width:100%;"><thead><tr class="header"><th></th><th>运算符</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>比较运算符</td><td><code>&gt;</code> <code>&lt;</code> <code>&lt;=</code><code>&gt;=</code> <code>=</code> <code>!=</code><code>&lt;&gt;</code></td><td>大于、小于、大于等于、不等于</td></tr><tr class="even"><td></td><td><code>BETWWEEN ... AND ...</code></td><td>显示某一区间的值</td></tr><tr class="odd"><td></td><td><code>IN(值1, 值2, 值3)</code></td><td>显示在 <code>IN</code> 列表中的值</td></tr><tr class="even"><td></td><td><code>LIKE '值'</code> <code>NOT LIKE '值'</code></td><td>模糊查询（<code>LIKE 'A%'</code> 即 A 开头就行）</td></tr><tr class="odd"><td></td><td><code>IS NULL</code></td><td>判断是否为空</td></tr><tr class="even"><td>逻辑运算符</td><td><code>AND</code></td><td>多个条件同时成立</td></tr><tr class="odd"><td></td><td><code>OR</code></td><td>多个条件任一成立</td></tr><tr class="even"><td></td><td><code>NOT</code></td><td>不成立</td></tr></tbody></table><h2 id="函数">22.5 函数</h2><h3 id="统计函数">22.5.1 统计函数</h3><ul><li>计数：<code>COUNT(列)</code></li><li>平均值：<code>AVG(列)</code></li><li>合计值：<code>SUM(列)</code></li><li>最大 · 最小值：<code>MAX(列)</code> <code>MIN(列)</code></li></ul><h3 id="字符串函数">22.5.2 字符串函数</h3><ul><li><p><code>CHARSET(str)</code>：返回字串字符集</p><p>举个栗子：</p><div class="code-wrapper"><pre><code class="hljs mysql">select charset(name) from genshin;</code></pre></div><p>输出这个：</p><div class="code-wrapper"><pre><code class="hljs mysql">+---------------+| charset(name) |+---------------+| utf8          || utf8          || utf8          |+---------------+</code></pre></div></li><li><p><code>CONCAT(str1, str2, ...)</code>：连接字串</p><p>举个花生：</p><div class="code-wrapper"><pre><code class="hljs mysql">select concat (&#x27;我是 &#x27;, name, &#x27; 我来自 &#x27;, country) from genshin;</code></pre></div><p>输出这个：</p><div class="code-wrapper"><pre><code class="hljs mysql">+-------------------------------------------+| concat (&#x27;我是 &#x27;, name, &#x27; 我来自 &#x27;, country) |+-------------------------------------------+| 我是 Amber 我来自 蒙德                      || 我是 QiQi 我来自 保底                       || 我是 KeQing 我来自 璃月                     |+-------------------------------------------+</code></pre></div></li><li><p><code>UCASE(str)</code>：转成大写</p></li><li><p><code>LCASE(str)</code>：转成小写</p></li><li><p><code>LENGTH(str)</code>：字符串长度</p><p>返回时是按<strong>字节</strong>返回</p></li><li><p><code>REPLACE(str, str1, str2)</code>：在 str 中用 str2 替换str1</p></li><li><p><code>SUBSTRING(str, po, len)</code>：从 str 的 po 位取 len个字符</p><p>这里 po 是从 1 开始计数的</p></li><li><p><code>LEFT(str, len)</code>：从 str 左边取 len 个字符</p><p><code>RIGHT(str, len)</code>：从 str 右边取 len 个字符</p></li><li><p><code>INSTR(str, sub)</code>：返回 sub 在 str出现的位置（没有就返回 0）</p></li><li><p><code>STRCMP(str1, str2)</code>：逐字符比较两字串大小</p></li><li><p><code>LTRIM(str)</code>：去除前端空格</p><p><code>RTRIM(str)</code>：去除后端空格</p><p><code>TRIM(str)</code>：去除左右空格</p></li></ul><h3 id="数学函数">22.5.3 数学函数</h3><ul><li><p><code>ABS(num)</code>：绝对值</p></li><li><p><code>BIN(num)</code>：十进制转为二进制</p></li><li><p><code>CEILING(num)</code>：向上取整</p></li><li><p><code>CONV(num, from_base, to_base)</code>：进制转换</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT CONV(5, 10, 2) FROM genshin;</code></pre></div><p>把 5 从（当作） 10 进制转换成 2 进制</p></li><li><p><code>FLOOR(num)</code>：向下取整</p></li><li><p><code>FORMAT(num, decimal_places)</code>：保留小数位数</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT FORMAT(3.1415926535897932384626, 2) FROM genshin;</code></pre></div><p>这个数字四舍五入保留 2 位</p></li><li><p><code>HEX(num)</code>：转十六进制</p></li><li><p><code>LEAST(num1, num2, num3, ...)</code>：最小值</p></li><li><p><code>MOD(num, num2)</code>：求余</p></li><li><p><code>RAND([seed])</code>：返回随机数（范围 [0, 1]）。如果 seed不变，返回的随机数也不变</p><p><code>RAND()</code>：每次返回不同随机数</p></li></ul><h3 id="时间和日期函数">22.5.4 时间和日期函数</h3><ul><li><p><code>CURRENT_DATE()</code>：当前日期</p></li><li><p><code>CURRENT_TIME()</code>：当前时间</p></li><li><p><code>CURRENT_TIMESTAMP()</code>：当前时间戳</p><div class="code-wrapper"><pre><code class="hljs mysql">CREATE TABLE `T1` (&#x27;date&#x27; TIMESTAMP               NOT NULL DEFAULT CURRENT_TIMESTAMP               ON UPDATE CURRENT_TIMESTAMP);</code></pre></div><p>这一列内容是自动更新的时间戳</p></li><li><p><code>DATE(datetime)</code>：返回 datetime 的日期部分</p></li><li><p><code>DATE_ADD(date, INTERVAL D_VALUE D_TYPE)</code>：在 date中加上日期或时间</p><p><code>D_VALUE</code>：时间的数值</p><p><code>D_TYPE</code>：时间类型。可以是 YEAR、MINUTE、HOUR、DAY、SECOND等</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT * FROM genshin WHERE DATE_ADD(`date`, INTERVAL 10 MINUTE) &gt;= NOW();</code></pre></div><p>显示那些 date 列加上 10 分钟，比现在时间大的记录</p></li><li><p><code>DATE_SUB(date, INTERVAL D_VALUE D_TYPE)</code>：在 date上减去一个时间</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT * FROM genshin WHERE `date` &gt;= DATE_SUB(NOW(), interval 10 minute);</code></pre></div><p>显示那些现在时间减去 10 分钟，比 date 小的记录</p></li><li><p><code>DATEDIFF(date1, date2)</code>：两个日期差（天数）</p><p>是 date1 - date2 的结果，因此结果可能是负数</p></li><li><p><code>TIMEDIFF(date1, date2)</code>：两个时间差（多少小时、分钟、秒）</p></li><li><p><code>NOW()</code>：当前日期 + 时间</p></li><li><p><code>YEAR(datetime)</code>：返回日期的年份</p><p><code>MONTH(datetime)</code>：返回日期的月份</p><p><code>DAY(datetime)</code>：返回日期的日数</p></li><li><p><code>UNIX_TIMESTAMP()</code>：返回 1970-1-1到现在的毫秒数</p></li><li><p><code>FROM_UNIXTIME(num)</code>：把一个 UNIX_TIMESTAMP转换为时间</p><p><code>FROM_UNIXTIME(num, format)</code>：含有格式</p><div class="code-wrapper"><pre><code class="hljs mysql">select distinct from_unixtime(100, &#x27;%Y-%m-%d %H:%i:%s&#x27;) from genshin;</code></pre></div><p>这个会输出 1970-01-01 08:01:40</p><p>在实际开发中，经常使用 int 保留一个UNIX_TMIESTAMP。使用时转换为时间</p></li><li><p><code>LAST_DAY(date)</code>：返回该日期所在月份的最后一天的日期</p></li></ul><h3 id="加密和系统函数">22.5.5 加密和系统函数</h3><ul><li><p><code>USER()</code>：查看用户</p><p>可以查看登录到 MySQL 的右哪些用户，及其 IP</p></li><li><p><code>DATABASE()</code>：查询当前使用的数据库名称</p></li><li><p><code>MD5(str)</code>：为字符串计算出一个 MD5 32的字符串</p></li><li><p><code>PASSWORD(str)</code>：（另一个）加密函数，常用于对 MySQL数据库的用户密码加密</p></li></ul><h3 id="流程控制函数">22.5.6 流程控制函数</h3><ul><li><p><code>IF(expr1, expr2, expr3)</code>：如果 expr1 为 true 则返回expr2，否则返回 expr3</p></li><li><p><code>IFNULL(expr1, expr2)</code>：如果 expr1 为 NULL 则返回expr2，否则返回 expr1</p></li><li><p>```mysql ... SELECT CASE WHEN expr1 THEN expr2 WHEN expr3 THENexpr4 ELSE expr5 END ... <div class="code-wrapper"><pre><code class="hljs n1ql">多重分支。若 expr1 则 expr2，否则若 expr3 则 expr4，否则 expr5举个蚕豆：```mysql<span class="hljs-keyword">SELECT</span> <span class="hljs-symbol">`name`</span>, (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">CASE</span>             <span class="hljs-keyword">WHEN</span> <span class="hljs-symbol">`age`</span> &gt; <span class="hljs-number">100</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;?&#x27;</span>             <span class="hljs-keyword">WHEN</span> <span class="hljs-symbol">`age`</span> &lt; <span class="hljs-number">18</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;!&#x27;</span>             <span class="hljs-keyword">ELSE</span> <span class="hljs-symbol">`age`</span> <span class="hljs-keyword">END</span>) <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-symbol">`country`</span>, <span class="hljs-symbol">`sex`</span> <span class="hljs-keyword">FROM</span> <span class="hljs-symbol">`genshin`</span>;</code></pre></div></p><p>输出这个</p><div class="code-wrapper"><pre><code class="hljs mysql">+------+-----+---------+-----+| name | age | country | sex |+------+-----+---------+-----+| 刻晴 | 23  | 璃月    | 女  || 凝光 | 28  | 璃月    | 女  || 胡桃 | 20  | 璃月    | 女  || 甘雨 | ?   | 璃月    | 否  || 影   | ?   | 稻妻    | 女  || 八重 | ?   | 稻妻    | 女  || 温迪 | ?   | 蒙德    | 男  || 莫娜 | 22  | 蒙德    | 女  || 申鹤 | 25  | 璃月    | 女  || 可莉 | !   | 蒙德    | 女  |+------+-----+---------+-----+</code></pre></div></li></ul><h2 id="mysql-多表查询">22.6 MySQL 多表查询</h2><p>多表查询是基于两个和两个以上的表查询。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT * FROM `honkai3`, `genshin`;</code></pre></div><p>这个场合，输出的是两个表相乘（即：取出第一张表的每一行，与第二张表的每一行进行组合）</p><p>……这样，就需要加入筛选条件，比如</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT * FROM `honkai3`, `genshin` WHERE honkai3.group = genshin.country;</code></pre></div><p><strong>多表查询的条件不能少于 表的个数 -1，否则会出现笛卡尔集</strong></p><h3 id="自连接">22.6.1 自连接</h3><p>自连接：指在同一张表连接查询（将同一表视为两张表）</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT * FROM genshin g1, genshin g2WHERE g1.name = g2.name;</code></pre></div><p>这样，表 genshin 获得了 g1、g2 的别名，就能自连接了</p><p>这里取别名，也可以加上<code>AS</code>。另外，列名不明确的场合，也也要特别指定</p><h3 id="子查询">22.6.2 子查询</h3><p>子查询：指嵌入在其他 SQL 语句中的 select 语句。也叫嵌套查询</p><ul><li><p><strong>单行子查询</strong>：指只返回一行数据的子查询语句</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT * FROM genshin WHERE age &gt; (SELECT age FROM genshin WHERE name = &#x27;可莉&#x27;);</code></pre></div></li><li><p><strong>多行子查询</strong>：返回多行数据的子查询语句。使用关键字<code>IN</code></p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT * FROM genshin WHERE country IN (SELECT DISTINCT country FROM genshin WHERE age &lt; 30);</code></pre></div><p>子查询也可以当作临时表使用。</p></li><li><p><strong><code>ALL</code> 操作符</strong></p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT * FROM genshin WHERE age &gt; ALL(SELECT age FROM genshin WHERE country = &#x27;蒙德&#x27;);</code></pre></div><p>上面的代码相当于这个：</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT * FROM genshin WHERE age &gt; (SELECT MAX(age) FROM genshin WHERE country = &#x27;蒙德&#x27;);</code></pre></div></li><li><p><strong><code>ANY</code> 操作符</strong></p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT * FROM genshin WHERE age &gt; ANY(SELECT age FROM genshin WHERE country = &#x27;蒙德&#x27;);</code></pre></div><p>上面的代码相当于这个：</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT * FROM genshin WHERE age &gt; (SELECT MIN(age) FROM genshin WHERE country = &#x27;蒙德&#x27;);</code></pre></div></li><li><p><strong>多列子查询</strong>：指返回多个列数据的子查询语句</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT * FROM honkai3 WHERE (age, sex) = (SELECT age, sex FROM genshin WHERE name = &#x27;凝光&#x27;);</code></pre></div><p>子查询列数要和条件列数相等，顺序对应</p></li><li><p><strong>表的复制</strong></p><div class="code-wrapper"><pre><code class="hljs mysql">INSERT INTO genshin_copy (name, age, sex, country)SELECT name, age, sex, country FROM genshin;</code></pre></div></li><li><p><strong>合并查询</strong>：把两个（结构相同的）查询结果合并。</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT * FROM genshinUNION ALLSELECT * FROM genshin2;</code></pre></div><p>这个方法（<code>UINON ALL</code>）不会去重</p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT * FROM genshinUNIONSELECT * FROM genshin2;</code></pre></div><p>这个方法（<code>UINON</code>）会去重</p></li></ul><h2 id="外连接">22.7 外连接</h2><blockquote><p>左外连接：左侧的表完全显示（即使没有匹配的记录，也会把左侧表完全显示）</p><p>右外连接：右侧的表完全显示</p></blockquote><p><strong>原来的代码：</strong></p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT genshin.name, genshin.age, honkai3.nameFROM genshin, honkai3 WHERE genshin.age = honkai3.age;</code></pre></div><p>无匹配记录的项不会显示。</p><p><strong>左外连接：</strong></p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT genshin.name, genshin.age, honkai3.nameFROM genshin LEFT JOIN honkai3 ON genshin.age = honkai3.age;</code></pre></div><p>这个场合，genshin 中无匹配记录的项也会显示</p><p><strong>右外连接：</strong></p><div class="code-wrapper"><pre><code class="hljs mysql">SELECT genshin.name, honkai3.age, honkai3.nameFROM genshin RIGHT JOIN honkai3 ON genshin.age = honkai3.age;</code></pre></div><p>这个场合，honkai3 中无匹配记录的项也会显示</p><h2 id="约束">22.8 约束</h2><blockquote><p>约束：用于确保数据库的数据满足特定的商业规则</p><p>约束包括：</p><ul><li>not null</li><li>unique</li><li>primary key</li><li>foreign key</li><li>check</li></ul></blockquote><h3 id="primary-key主键">22.8.1 primary key（主键）</h3><div class="code-wrapper"><pre><code class="hljs mysql">...字段名 字段类型 primary key...</code></pre></div><p><strong>主键</strong>：用于唯一的表示表行的数据。当定义主键约束后，<strong>该列不能重复</strong></p><h4 id="使用细节">22.8.1.1 使用细节</h4><ol type="1"><li><p>主键不能重复，也不能为 NULL</p></li><li><p>一张表只能有一个主键。但，可以是复合主键</p><div class="code-wrapper"><pre><code class="hljs mysql">CREATE TABLE `temp1` (`id` INT, `name` CHAR(5), `location` varchar(32), PRIMARY KEY(`id`, `name`));</code></pre></div><p>这里，<code>(id, name)</code> 构成复合主键。id 和 name都相同的，不能重复</p></li><li><p>主键的指定方式有两种：</p><ul><li><code>字段名 字段类型 primary key</code></li><li>（在表定义的最后写）<code>PRIMARY KEY(列名)</code></li></ul></li><li><p>在实际开发中，每个表往往都会设置一个主键</p></li></ol><h3 id="not-null非空">22.8.2 not null（非空）</h3><p><strong>非空</strong>：定义非空约束后，插入数据时，必须为该列提供数据。</p><h3 id="unique唯一">22.8.3 unique（唯一）</h3><div class="code-wrapper"><pre><code class="hljs mysql">...字段名 字段类型 unique...</code></pre></div><p><strong>唯一</strong>：定义了唯一约束后，该列值是不能重复的。</p><p>……但是如果没有 not null 约束，则可以有多个 null 值</p><h3 id="foreign-key外键">22.8.4 foreign key（外键）</h3><div class="code-wrapper"><pre><code class="hljs mysql"># 从表...foreign key (从表列名) references 主表名(列名)...</code></pre></div><p><strong>外键</strong>：用于定义主表和从表间的关系。外键约束要定义在从表上，主表必须有主键或唯一约束。定义外键约束后，要求外键列数据必须在主表的主键列存在或为null</p><h4 id="使用细节-1">22.8.4.1 使用细节</h4><ol type="1"><li><p>外键指向的表的字段，要求是 primary key 或 unique</p></li><li><p>表的类型是 innodb，这样的表才支持外键</p></li><li><p>外键字段的类型要和主子段类型一致（可以长度不同）</p></li><li><p>外键字段的值，必须在主键字段中出现过，或（在外键字段允许的情况下）为null</p></li><li><p>一旦确立主外键关系，数据就不能随意删除了（有任意记录指向主表某记录，该主表记录就不能删除）</p></li><li><p>如何删除外键：</p><div class="code-wrapper"><pre><code class="hljs mysql">SHOW CREATE TABLE 表名;#1ALTER TABLE 表名 DROP FOREIGN KEY 外键名;#2</code></pre></div><ol type="1"><li>查看该表创建语句，获取外键名称</li><li>删除外键</li></ol></li></ol><h3 id="check">22.8.5 check</h3><div class="code-wrapper"><pre><code class="hljs mysql">...字段名 字段类型 check (条件)...</code></pre></div><p><strong>check</strong>：用于强制行数据必须满足的条件。（特别的，MySQL5.7 中有 check 语法校验，但实际不生效）</p><h3 id="自增长">22.8.6 自增长</h3><div class="code-wrapper"><pre><code class="hljs mysql">...字段名 字段类型 primary key auto_increment...</code></pre></div><h4 id="使用细节-2">22.8.6.1 使用细节</h4><ol type="1"><li><p>如果希望自增长，插入数据时该列插入 null</p></li><li><p>一般来说自增长是配合 primary key 使用的</p></li><li><p>自增长也能（配合 unique）单独使用</p></li><li><p>自增长修饰的字段是整数型的（小数类型也可以，但很少这样用）</p></li><li><p>自增长从 1 开始。</p><div class="code-wrapper"><pre><code class="hljs mysql">alter table 表名 auto_increment = 新的开始值;</code></pre></div><p>这样，能修改这个自增长的默认值</p></li><li><p>如果添加数据时，给自增长字段指定了具体的值，则以指定的值为准</p><p>一般来说，指定了自增长，就按自增长的规则添加顺序</p></li></ol><h2 id="索引">22.9 索引</h2><p>索引：提高数据库性能，增加查询速度</p><div class="code-wrapper"><pre><code class="hljs mysql">CREATE INDEX 索引名 ON 表名 (列名);</code></pre></div><ul><li><p>没有索引时：</p><p>查询的场合总是会进行全表扫描</p></li><li><p>有索引时：</p><p>形成一个索引的数据结构（如二叉树），根据该结构进行查找</p><p>会造成磁盘的占用，且对 update delete insert语句的效率产生影响</p></li></ul><p><strong>索引的类型</strong></p><ol type="1"><li><p>主键索引：primary key。主键自动为主索引</p></li><li><p>唯一索引：unique</p></li><li><p>普通索引：index</p></li><li><p>全文索引：fulltext</p><p>一般开发不用 MySQL自带的全文索引，而是使用全文搜索（Solr）和ElasticSearch（ES）</p></li></ol><h3 id="索引的操作">22.9.1 索引的操作</h3><ol type="1"><li><p>查询索引：</p><div class="code-wrapper"><pre><code class="hljs mysql">SHOW INDEXES FROM 表名;SHOW INDEX FROM 表名;SHOW KEYS FROM 表名;</code></pre></div></li><li><p>添加唯一索引：</p><div class="code-wrapper"><pre><code class="hljs mysql">CREATE UNIQUE INDEX 索引名 ON 表名(列名);</code></pre></div></li><li><p>添加普通索引：</p><div class="code-wrapper"><pre><code class="hljs mysql">CREATE INDEX 索引名 ON 表名(列名);ALTER TABLE 表名 ADD INDEX 索引名(列名);</code></pre></div><blockquote><p>如果某列的值是不会重复的，则优先考虑唯一索引。否则用普通索引。</p></blockquote></li><li><p>添加主键索引（添加主键）：</p><div class="code-wrapper"><pre><code class="hljs mysql">ALTER TABLE 表名 ADD PRIMARY KEY (列名);</code></pre></div></li><li><p>删除索引：</p><div class="code-wrapper"><pre><code class="hljs mysql">DROP INDEX 索引名 ON 表名;</code></pre></div></li><li><p>删除主键索引：</p><div class="code-wrapper"><pre><code class="hljs mysql">ALTER TABLE 表名 DROP PRIMARY KEY;</code></pre></div><blockquote><p>因为主键索引只有一个，所以不用指定列名</p></blockquote></li><li><p>修改索引：</p><p>先删除，再添加新的索引 <code>(●'◡'●)</code></p></li></ol><h3 id="创建规则">22.9.2 创建规则</h3><ol type="1"><li>较频繁地作为查询条件字段 <strong>适合</strong> 作为索引</li><li>唯一性太差的字段（即使频繁作为查询条件）<strong>不适合</strong>单独创建索引</li><li>更新非常频繁的字段 <strong>不适合</strong> 创建索引</li><li>不会出现在 WHERE 子句的字段 <strong>不应该</strong> 创建索引</li></ol><h2 id="事务">22.10 事务</h2><blockquote><p>事务：用于保证数据的一致性，由一组相关的 dml语句（update、insert、delete 语句）组成。该组 dml语句要么全部成功，要么全部失败。比如转账就要用事务处理，以保证数据的一致性。</p><p>锁：执行事务操作时，MySQL会在表上加锁，防止其他用户修改表的数据。这对用户来讲是非常重要的。</p></blockquote><h3 id="事务的操作">22.10.1 事务的操作</h3><ul><li><p><code>start transaction</code>：开始一个事务</p></li><li><p><code>savepoint 保存点名</code>：设置保存点</p></li><li><p><code>rollback to 保存点名</code>：回退事务到特定保存点</p></li><li><p><code>rollback</code>：回退所有事务</p></li><li><p><code>commit</code>：提交事务，让所有操作生效。</p><p>执行该语句后，会确认事务的变化、删除保存点、释放锁，并让数据生效。</p><p>该语句不能回退。使用该语句后，其它会话（其他连接）将可以查看到事务变化后的新数据。</p></li></ul><h3 id="使用细节-3">22.10.2 使用细节</h3><ol type="1"><li><p>如果不提交事务，默认情况下，dml操作是自动提交的，不能回滚。</p></li><li><p>开始一个事务，没有创建保存点的场合，可以执行rollback，默认回退到事务开始时的状态</p></li><li><p>可以在这个事务中创建多个保存点</p></li><li><p>可以在事务没有提交前选择回退到哪个保存点</p></li><li><p>MySQL 需要 innoDB 的存储引擎才可以使用。MyISAM 不行</p></li><li><p>开始事务：<code>start transaction</code></p><p>关闭默认自动提交事务：<code>set autocommit = off;</code></p></li></ol><h3 id="隔离级别">22.10.3 隔离级别</h3><blockquote><p>隔离：多个连接开启各自事务操作数据库中数据时，数据库系统要负责隔离操作，以保证各个连接在获取数据时的准确性</p><p>隔离级别：定义了事务与事务之间的隔离程度。隔离级别是和事务相关的。</p><p>查看当前会话隔离级别：<code>select @@tx_isolation;</code></p></blockquote><p>如果不考虑隔离性，可能引发问题，如：</p><ul><li><p><strong>脏读（dirty read）</strong>：</p><p>当一个事务读取另一个事务尚未提交的修改时，产生脏读</p></li><li><p><strong>不可重复读（nonreapeatable read）</strong>：</p><p>同一查询在同一事务中多次进行，由于其他提交事务所做的修改或删除，每次返回不同的结果集，此时发生不可重复读</p></li><li><p><strong>幻读（phantom read）</strong>：</p><p>同一查询在同一事务中多次进行，由于其他提交事务所做的插入操作，每次返回不同的结果集，此时发生幻读</p></li></ul><table><thead><tr class="header"><th>MySQL 隔离级别（4种）</th><th>脏读</th><th>不可重复读</th><th>幻读</th><th>加锁读</th></tr></thead><tbody><tr class="odd"><td>读未提交（Read uncommitted）</td><td>√</td><td>√</td><td>√</td><td>不加锁</td></tr><tr class="even"><td>读已提交（Read committed）</td><td>×</td><td>√</td><td>√</td><td>不加锁</td></tr><tr class="odd"><td>可重复读（Reapeatable read）</td><td>×</td><td>×</td><td>×</td><td>不加锁</td></tr><tr class="even"><td>可串行化（Serializable）</td><td>×</td><td>×</td><td>×</td><td>加锁</td></tr></tbody></table><p>MySQL 的默认隔离级别是 Reapeatable read，一般情况下不需要修改</p><h4 id="隔离级别的操作">22.10.3.1 隔离级别的操作</h4><ol type="1"><li><p>查看当前会话隔离级别：</p><div class="code-wrapper"><pre><code class="hljs mysql">select @@tx_isolation;</code></pre></div></li><li><p>查看系统隔离级别：</p><div class="code-wrapper"><pre><code class="hljs mysql">select @@global.tx_isolation;</code></pre></div></li><li><p>设置当前会话隔离级别：</p><div class="code-wrapper"><pre><code class="hljs mysql">set session transaction isolation level 隔离级别</code></pre></div></li><li><p>设置系统隔离级别：</p><div class="code-wrapper"><pre><code class="hljs mysql">set global transacion isolation level 隔离级别</code></pre></div></li><li><p>全局修改：修改 mysql.ini 配置文件。</p><p>在 mysql.ini 文件的末尾加上：</p><div class="code-wrapper"><pre><code class="hljs pgsql">#设置默认隔离级别<span class="hljs-keyword">transaction</span>-<span class="hljs-keyword">isolation</span> = <span class="hljs-keyword">REPEATABLE</span>-<span class="hljs-keyword">READ</span></code></pre></div><p>可选参数有：<code>READ-UNCOMMITTED</code>、<code>READ-COMMITTED</code>、<code>REPEATABLE-READ</code>、<code>SERIALIZABLE</code></p></li></ol><h3 id="事务的-acid-特性">22.10.4 事务的 ACID 特性</h3><ol type="1"><li><p><strong>原子性（Atomicity）</strong>：</p><p>事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生</p></li><li><p><strong>一致性（Consistency）</strong>：</p><p>事务必须使数据库从一个一致性状态变换到另外一个一致性状态</p></li><li><p><strong>隔离性（Isolation）</strong>：</p><p>多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰。多个并发事务之间相互隔离</p></li><li><p><strong>持久性（Durability）</strong>：</p><p>一个事务一旦被提交，它对数据库中数据的改变就是永久性的。接下来即使数据库发生故障也不应该对其有任何影响。</p></li></ol><h2 id="mysql-表类型和存储引擎">22.11 MySQL 表类型和存储引擎</h2><p>MySQL 的表类型由存储引擎（StorageEngines）决定，主要支持六种类型：CSV、Memory（常用）、ARCHIVE、MRG_MYISAM、MyISAM（常用）、InnoDB（常用）</p><p>这六类又分为两类：</p><ul><li>事务安全型（transaction-safe）：InnoDB</li><li>非事务安全型（non-transaction-safe）：其他类型都是非事务安全型</li></ul><table><thead><tr class="header"><th>特点</th><th>MyISAM</th><th>InnoDB</th><th>Memory</th><th>Archive</th></tr></thead><tbody><tr class="odd"><td>批量插入速度</td><td>高</td><td>低</td><td>高</td><td>非常高</td></tr><tr class="even"><td>事务安全</td><td></td><td>支持</td><td></td><td></td></tr><tr class="odd"><td>全文索引</td><td>支持</td><td></td><td></td><td></td></tr><tr class="even"><td>锁机制</td><td>表锁</td><td>行锁</td><td>表锁</td><td>行锁</td></tr><tr class="odd"><td>存储限制</td><td>无</td><td>64TB</td><td>有（内存）</td><td>无</td></tr><tr class="even"><td>B树索引</td><td>支持</td><td>支持</td><td>支持</td><td></td></tr><tr class="odd"><td>哈希索引</td><td></td><td>支持</td><td>支持</td><td></td></tr><tr class="even"><td>集群索引</td><td></td><td>支持</td><td></td><td></td></tr><tr class="odd"><td>数据缓存</td><td></td><td>支持</td><td>支持</td><td></td></tr><tr class="even"><td>索引缓存</td><td>支持</td><td>支持</td><td>支持</td><td></td></tr><tr class="odd"><td>数据可压缩</td><td>支持</td><td></td><td></td><td>支持</td></tr><tr class="even"><td>空间使用</td><td>低</td><td>高</td><td>无</td><td>非常低</td></tr><tr class="odd"><td>内存使用</td><td>低</td><td>高</td><td>中等</td><td>低</td></tr><tr class="even"><td>支持外键</td><td></td><td>支持</td><td></td><td></td></tr></tbody></table><ol type="1"><li>MyISAM存储引擎不支持事务，也不支持外键。但其访问速度快，对事务完整性没有要求</li><li>InnoDB 存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但比起MyISAM，InnoDB写入的处理效率差一些，并且会占用更多磁盘空间以保留数据和索引。</li><li>Memory 存储引擎使用存在内存中的内容来创建表。每个 Memory表只实际对应一个磁盘文件。Memory类型的表访问得非常快，因为它的数据是放在内存中的，并且默认使用 HASH索引。但是一旦 MySQL 服务关闭，表中的数据就会丢掉（表的结构还在）。</li></ol><h3 id="如何选择存储引擎">22.11.1 如何选择存储引擎</h3><blockquote><ul><li>InnoDB：支持事务、支持外键、支持行级锁</li><li>MyISAM：添加速度快、不支持事务和外键、支持表级锁</li><li>Memory：数据存储在内存中、执行速度很快、默认支持索引（HASH 表）</li></ul></blockquote><ol type="1"><li>如果你的应用不需要事务，处理的只是基本的 CRUD 操作，那么 MyISAM速度最快</li><li>如果需要支持事务，选择 InnoDB</li><li>Memory 数据存储在内存中，没有 I/O操作故而速度极快。但内存存储使得其任何修改都会在服务器重启后消失</li></ol><h2 id="视图">22.12 视图</h2><blockquote><p>视图：一个虚拟表。其内容由查询定义。和其他表一样，视图含有列，其数据来源于真实的表（基表）</p></blockquote><ol type="1"><li>视图是根据基表来创建的。视图是虚拟的表</li><li>视图也有列，其中数据来自基表</li><li>通过视图可以改变基表的数据，基表的改变也会影响视图数据。</li></ol><h3 id="基本使用">22.12.1 基本使用</h3><ul><li><p>创建视图：</p><div class="code-wrapper"><pre><code class="hljs mysql">CREATE VIEW 视图名 AS SELECT语句;</code></pre></div></li><li><p>修改视图：</p><div class="code-wrapper"><pre><code class="hljs mysql">ALTER VIEW 视图名 AS SELECT语句;</code></pre></div></li><li><p>显示创建视图的指令：</p><div class="code-wrapper"><pre><code class="hljs mysql">SHOW CREATE VIEW 视图名;</code></pre></div></li><li><p>删除视图：</p><div class="code-wrapper"><pre><code class="hljs mysql">DROP VIEW  视图名1,视图名2;</code></pre></div></li></ul><h3 id="使用细节-4">22.12.2 使用细节</h3><ol type="1"><li>创建视图后，数据库中只有一个视图结构文件，没有视图数据</li><li>视图的数据变化会影响基表，基表数据变化也会影响视图</li><li>视图中可以再使用视图</li></ol><h3 id="视图最佳实践">22.12.3 视图最佳实践</h3><ul><li><p><strong>安全</strong>：</p><p>一些数据有不能让用户看到的重要信息。藉由建立一个视图，用户可以查询自己需要的字段，而不能查看保密的字段。</p></li><li><p><strong>性能</strong>：</p><p>关系数据库的数据常常分表存储，通过外键建立这些表之间的联系。此时，查询数据库会使用低效的连接（JOIN）。藉由建立一个视图，可以避免使用JOIN 查询数据。</p></li><li><p><strong>灵活</strong>：</p><p>系统中有一张采用过时设计，即将废弃的旧表，但这张旧表不能轻易修改。藉由建立一个视图，把数据映射到新表，少做很多改动的同时达到了升级数据表的目的。</p></li></ul><h2 id="mysql-管理">22.13 MySQL 管理</h2><h3 id="用户管理">22.13.1 用户管理</h3><blockquote><p>MySQL 的用户数据都储存在系统数据库 <code>mysql</code> 的表<code>user</code> 中</p><p>不同的数据库用户登录到 DBMS后，根据相应权限，可以操作的数据库和数据对象各不相同</p></blockquote><ol type="1"><li><p><code>user</code> 表的重要字段：</p><ul><li><p><code>host</code>：允许登录的位置。<code>localhost</code>的场合表示该用户只允许本机登录。</p><p>也可以指定 ip 地址，如 <code>912.168.3.16</code></p></li><li><p><code>user</code>：用户名</p></li><li><p><code>authentication_string</code>：（通过<code>password()</code> 函数加密后的）密码</p></li></ul></li><li><p>创建用户：</p><div class="code-wrapper"><pre><code class="hljs mysql">CREATE USER &#x27;用户名&#x27;@&#x27;允许登录位置&#x27; identified by &#x27;密码&#x27;;</code></pre></div><p>创建用户，同时指定密码。</p><ul><li><p><code>@</code> 后面不能加空格</p></li><li><p>创建用户时，如果不指定 Host，默认为 <code>%</code>。</p><p><code>%</code> 表示所有 IP 都有连接权限</p></li><li><p>创建用户也可以这样：</p><div class="code-wrapper"><pre><code class="hljs mysql">CREATE USER &#x27;puppet&#x27;@&#x27;192.168.3.%&#x27;</code></pre></div><p>表示 192.168.3.* 的 IP 都可以登录用户</p></li></ul></li><li><p>删除用户：</p><div class="code-wrapper"><pre><code class="hljs mysql">DROP USER &#x27;用户名&#x27;@&#x27;允许登录位置&#x27;;</code></pre></div><p>删除用户时，如果 host 不是 <code>%</code>，需要明确指定<code>'用户'@'host'</code></p></li><li><p>用户修改密码：</p><div class="code-wrapper"><pre><code class="hljs mysql">SET PASSWORD = PASSWORD(&#x27;密码&#x27;);#修改自己密码SET PASSWORD FOR &#x27;用户名&#x27;@&#x27;登录位置&#x27; = PASSWORD(&#x27;密码&#x27;);#修改任意用户密码</code></pre></div><p>修改其他用户密码，需要拥有相应权限</p></li></ol><h3 id="权限管理">22.13.2 权限管理</h3><ol type="1"><li><p>授予权限</p><div class="code-wrapper"><pre><code class="hljs mysql">GRANT 权限列表 ON 库.对象名 TO &#x27;用户名&#x27;@&#x27;登录位置&#x27; identified by &#x27;密码&#x27;;</code></pre></div><p><code>库.对象名</code> 是 <code>*.*</code>的场合，代表本系统所有库的所有对象</p><p><code>identified by '密码'</code>可省略。若写出，则用户存在即修改密码，不存在即创建用户。</p></li><li><p>回收用户权限：</p><div class="code-wrapper"><pre><code class="hljs mysql">REVOKE 权限列表 ON 库.对象名 FROM &#x27;用户名&#x27;@&#x27;登录位置&#x27;;</code></pre></div></li><li><p>权限生效指令：</p><div class="code-wrapper"><pre><code class="hljs mysql">FLUSH PRIVILEGES;</code></pre></div><p>如果权限没有生效，执行这个指令。</p></li></ol><p><strong>权限列表：</strong></p><table><thead><tr class="header"><th>权限</th><th>意义</th></tr></thead><tbody><tr class="odd"><td>ALL</td><td>设置除 GRANT OPTION 外所有权限</td></tr><tr class="even"><td>ALTER</td><td>允许使用 <code>ALTER TABLE</code></td></tr><tr class="odd"><td>ALTER ROUTINE</td><td>更改或取消已存储的子程序</td></tr><tr class="even"><td>CREATE</td><td>允许使用 <code>CREATE TABLE</code></td></tr><tr class="odd"><td>CREATE ROUTINE</td><td>创建已存储的子程序</td></tr><tr class="even"><td>CREATE TEMPORARY TABLES</td><td>允许使用 <code>CREATE TEMPORARY TABLE</code></td></tr><tr class="odd"><td>CREATE USER</td><td>允许使用<code>CREATE USER</code>、<code>DROP USER</code>、<code>RENAME USER</code>、<code>REVOKE ALL PRIVILEGES</code></td></tr><tr class="even"><td>CREATE VIEW</td><td>允许使用 <code>CREATE VIEW</code></td></tr><tr class="odd"><td>DELETE</td><td>允许使用 <code>DELETE</code></td></tr><tr class="even"><td>DROP</td><td>允许使用 <code>DROP TABLE</code></td></tr><tr class="odd"><td>EXECUTE</td><td>允许用户运行已存储的子程序</td></tr><tr class="even"><td>FILE</td><td>允许使用<code>SELECT…INTO OUTFILE</code>、<code>LOAD DATA INFILE</code></td></tr><tr class="odd"><td>INDEX</td><td>允许使用 <code>CREATE INDEX</code>、<code>DROP INDEX</code></td></tr><tr class="even"><td>INSERT</td><td>允许使用 <code>INSERT</code></td></tr><tr class="odd"><td>LOCK TABLES</td><td>允许对拥有 SELECT 权限的表使用 <code>LOCK TABLES</code></td></tr><tr class="even"><td>PROCESS</td><td>允许使用 <code>SHOW FULL PROCESSLIST</code></td></tr><tr class="odd"><td>REFERENCES</td><td>-</td></tr><tr class="even"><td>RELOAD</td><td>允许使用 <code>FLUSH</code></td></tr><tr class="odd"><td>REPLICATION CLIENT</td><td>允许用户询问从属服务器或主服务器的地址</td></tr><tr class="even"><td>REPLICATION SLAVE</td><td>用于复制星从属服务器（从主服务器中读取二进制日志事件）</td></tr><tr class="odd"><td>SHOW DATABASE</td><td>允许使用 <code>SHOW DATABASE</code></td></tr><tr class="even"><td>SHOW VIEW</td><td>允许使用 <code>SHOW CREATE VIEW</code></td></tr><tr class="odd"><td>SHUTDOWN</td><td>允许使用 <code>mysqladmin shutdown</code></td></tr><tr class="even"><td>SUPER</td><td>允许使用<code>CHANGE MASTER</code>、<code>KILL</code>、<code>PURGE MASTER LOGS</code>、<code>SET GLOBAL</code>语句，<code>mysqladmin debug</code> 命令。允许连接（一次），即使达到max_connetions</td></tr><tr class="odd"><td>UPDATE</td><td>允许使用 <code>UPDATE</code></td></tr><tr class="even"><td>USAGE</td><td>无权限</td></tr><tr class="odd"><td>GRANT OPTION</td><td>允许授予权限</td></tr></tbody></table><h1 id="附录">附录</h1><h2 id="f1-数据库">F1 数据库</h2><p>数据、数据库、数据库管理系统、数据库系统 是数据库中最常用的 4个基本概念。</p><p><strong>数据（Data）</strong>：数据是描述事物的符号记录，是信息存在的一种形式。只有通过解释或处理的数据才能称为有用的信息。</p><p><strong>数据库（Database）</strong>：数据按照一定格式存储在数据库内。数据库中存储的数据具有永久存储、有组织、可共享这 3 个基本特点。</p><p><strong>数据库管理系统（Database ManageSystem，DBMS）</strong>：专门用于建立和管理数据库的一套软件。实现对数据有效的管理和维护。其主要功能包括：</p><ul><li>数据定义功能：通过数据库管理系统提供的数据定义语言（Data DefinitionLanguage，DDL）定义数据库中的数据对象（表、视图、存储过程、触发器等）。</li><li>数据操作功能：通过数据库管理系统提供的数据操作语言（DataManipulation Language，DML）实现对数据的增删改查</li><li>数据库的运行管理功能：数据库的数据是可供多个用户同时使用的共享数据。DBMS提供了统一的控制管理机制，保证并发使用的安全性，并在发生故障时能对数据库进行正确的恢复</li><li>数据库的建立维护功能：数据空间的维护、数据库的备份与恢复功能、数据库的重组织功能、性能监视、分析等</li><li>数据组织、存储、管理功能：数据库能对数据进行分类存储和管理以提高存取效率。例如索引查找、顺序查找等</li><li>其他功能：主要包括与其他软件的网络通信功能、不同数据库管理系统之间的数据传输及互相访问功能等</li></ul><p><strong>数据库系统（DatabaseSystem）</strong>：在计算机中引入数据库技术之后的系统。一个完整的数据库系统包括数据库、数据库管理系统、相关实用工具、应用程序、数据库管理员和用户。其中数据库管理员最终通过DBMS维护数据库，用户（程序员和数据库终端用户）则是数据库的服务对象。</p><h3 id="f1.1-数据库的三级模式结构">F1.1 数据库的三级模式结构</h3><p>不同的数据库管理系统基本上都遵循三级模式结构，即：用户级、概念级、物理级</p><p>具体而言，数据库系统的三级模式是指数据库系统是由：概念模式（Schema）、外模式（ExterrnalSchema）、内模式（Internal Schema）三级构成的</p><pre><code class=" mermaid">graph BTA(数据库) --- B[内模式] --模式/内模式映像--- C[概念模式]C --外模式/模式映像--- C1[外模式1]C --外模式/模式映像--- C2[外模式2]C --外模式/模式映像--- C3[外模式3]C1 --- C1A[应用A]C1 --- C1B[应用B]C2 --- C2C[应用C]C3 --- C3D[应用D]C3 --- C3E[应用E]</code></pre><h4 id="概念模式">概念模式</h4><p>模式也称为概念模式或逻辑模式，它是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图</p><p>模式实际上是数据库数据在逻辑级上的视图，即概念视图。其形式比数据的物理存储方式更为抽象。它不包含数据库的实现细节，仅定义数据的逻辑结构、数据间关系，以及数据相关的安全性、完整性等要求。</p><p>数据库按外模式的描述向用户提供数据，按内模式的描述存储数据。而模式是这两者的中间层。</p><p>模式不涉及物理存储细节和硬件环境，也无关于具体应用程序和开发语言。</p><p>一个数据库只有一个模式，且相对稳定。数据库管理系统提供了模式描述语言（SchemaDDL），以严格定义模式。</p><h4 id="外模式">外模式</h4><p>外模式也称为子模式或用户模式，它是数据库用户能看见和使用的局部数据的逻辑结构和特征的描述。</p><p>外模式是用户视图，通常是模式的子集，是对数据库整体数据结构的局部重构。如果不同用户在应用需求、看待数据的方式、对数据保密的要求方面存在差异，则外模式描述就不相同。模式中同样的数据，在外模式的表现可以不同。</p><p>一个数据库可以有多个不同外模式，且允许彼此间有重叠。一个外模式也可以被多个应用程序共享。</p><p>外模式简化了数据库系统的用户接口，便于用户使用，并有效支持了数据独立性和共享性。</p><p>数据库管理系统提供了子模式描述语言（SubschemaDDL），以严格定义子模式。</p><h4 id="内模式">内模式</h4><p>内模式也称为存储模式，是对数据库中数据物理结构和存储方式的描述，是数据库在内部的表示形式。</p><p>内模式是整个数据库的最底层表示。不同于物理层，是数据库管理员看到的，特定数据库管理系统所处理的数据库的内部结构，即内部视图或存储视图</p><p>一个数据库只有一个内模式。内模式不是最底层的物理层。数据库管理系统提供了内模式描述语言，以严格定义内模式。</p><h3 id="f1.2-映像与数据独立性">F1.2 映像与数据独立性</h3><p>构成数据库系统的三级模式分别是对数据的三级抽象。它们彼此间具有以下特点</p><ul><li>一个数据库的整体逻辑结构和特征的描述（概念模式）独立于数据库其他层次结构（内/外模式）。概念模式是数据库的核心，也是数据库设计的关键</li><li>一个数据库的内部存储模式依赖于概念模式，但独立于外模式，也独立于具体的存储设备。</li><li>外模式是在全局逻辑结构基础上定义的，其面向具体的应用程序，特定的应用程序依赖于特定的外模式。外模式独立于概念模式和内模式。</li></ul><p>数据库管理系统通过在内部提供三级模式间的两层映像，实现三级抽象和它们间的联系与转换。</p><p>这两层映像是：外模式/模式映像、模式/内模式映像</p><p>由于这两层映像的存在，使得数据库系统中的数据能具有较高<strong>逻辑独立性</strong> 和<strong>物理独立性</strong>。数据的定义和描述从应用程序中分离，从而简化了程序开发，也降低了维护难度。</p><h4 id="外模式模式映像">外模式/模式映像</h4><p>所谓映像，即是一种对应规则。外模式/模式映像定义了各个外模式和概念模式间的关系，这些映像通常在各自的外模式中加以描述。对于每个外模式，都会有一个外模式/模式映像</p><p>数据库系统的概念模式改变时，外模式/模式映像都要相应改变，以使外模式保持不变。由于 外模式/模式映像的存在，数据库管理员不必修改依赖外模式的应用程序本身。这样，就实现了外模式不受概念模式变化的影响，也保证了数据与程序的逻辑独立性。</p><h4 id="模式内模式映像">模式/内模式映像</h4><p>模式/内模式映像定义了数据库全局逻辑结构和物理存储间的关系。这种映像定义通常是在概念模式中加以描述的。数据库只有一个概念模式，也就只有一个模式/内模式映像。</p><p>数据库系统的物理存储改变时，数据库管理员要对 模式/内模式映像进行调整，以使概念模式保持不变。如此也实现了概念模式不受内模式变化的影响，并保证了数据与程序的物理独立性。</p><h3 id="f1.3-数据模型">F1.3 数据模型</h3><p>一般而言，数据具有动态、静态两种特征。</p><ul><li>数据的静态特征：数据的基本结构、数据间的联系、对数据取值范围的约束</li><li>数据的动态特征：对数据可以进行符合一定规则的操作</li></ul><p>数据模型是一组概念和定义，用来描述数据的结构、定义、在结构上的操纵以及数据间的约束</p><h4 id="数据模型的三个要素">数据模型的三个要素</h4><p>数据模型通常有三个要素：数据结构、数据操作、数据约束</p><ul><li><p>数据结构</p><p>数据结构描述系统的静态特性。其反映了数据模型最基本的特征。</p><p>常按照数据结构类型来命名数据模型。如：层次模型、网状模型、关系模型、面向对象模型</p></li><li><p>数据操作</p><p>数据操作描述系统的动态特性，是对对象实例允许执行的操作的集合。</p><p>数据操作分为两类：更新（插入、删除、修改）、检索</p></li><li><p>数据约束</p><p>数据约束描述数据结构中数据间的语法和语义关联，以保证数据的正确性、有效性和相容性</p><p>数据约束包括：完整性约束、数据安全性约束、并发控制约束</p></li></ul><h4 id="数据模型的分类">数据模型的分类</h4><pre><code class=" mermaid">graph LRA(现实世界) --抽象--&gt; B(概念模型) --转换/组织--&gt; C(逻辑模型/物理模型)</code></pre><ul><li><p>概念层数据模型</p><p>概念层是数据抽象级别的最高层。概念层数据模型也称 概念模型 或信息模型。</p><p>概念模型描述现实世界的事物，而与具体计算机系统无关。</p></li><li><p>逻辑层数据模型</p><p>逻辑层是数据抽象的中间层，也称为数据的逻辑模型</p><p>逻辑模型描述数据整体的逻辑结构，既要考虑用户理解，也要照顾具体实现</p><p>任何数据库都是基于某种逻辑数据模型。</p><ul><li><p>层次模型</p><p>是数据库最早使用的一种类型。其数据结构是一棵有向树，每个结点对应一个记录集。</p><p>现实中的组织结构就是层次结构。但层次模型难以表达现实中实体间的复杂联系。</p></li><li><p>网状模型</p><p>是层次模型的扩展，以网状结构表示实体间的联系。</p><p>网状模型可以方便地表示实体间的联系，但结构复杂，难以规范化地实现。</p></li><li><p>关系模型</p><p>是层次模型的扩展，用二维表来表示实体及实体间联系。</p><p>关系模型建立在严格的数学概念之上。其概念单一，数据结构简单，便于理解。而且，关系模型的存取路径对用户透明，具有更高的数据独立性和安全性，也便于程序员开发和管理。</p></li><li><p>面向对象模型</p><p>面向对象方法与数据库结合所构成的数据模型称为面向对象模型。</p><p>面向对象模型既是概念模型又是逻辑模型。其表达能力丰富，对象复用性强，维护方便，是数据库的发展方向之一。</p></li></ul></li><li><p>物理层数据模型</p><p>也称为数据的物理模型。</p><p>物理模型描述数据在存储介质上的组织结构，是逻辑模型的物理实现。每种逻辑模型都有对应的物理模型。</p><p>物理模型的设计目标是提高数据库性能和有效利用空间。其不仅由数据库设计决定，也与操作系统、计算机硬件密切相关。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt;21 反射</title>
    <link href="/2022/01/20/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/21%20%E5%8F%8D%E5%B0%84/"/>
    <url>/2022/01/20/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/21%20%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1 id="反射">21 反射</h1><blockquote><ol type="1"><li>反射机制（Reflection）允许程序在执行期借助于 Reflection API取得任何类的内部信息（如成员变量、成员方法等），并能操作对象的属性及方法。反射在设计模式和框架底层都会用到。</li><li>加载完类之后，在堆中就产生了一个 <code>Class</code>类型的对象（一个类只有一个 <code>Class</code>对象），这个对象包含了类的完整结构信息。通过这个对象得到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构。所以，形象地称之为：反射</li></ol><p>ocp 原则（开闭原则）：不修改源码来扩展功能</p></blockquote><p><strong>计算机的三个阶段</strong></p><ol type="1"><li><p>代码阶段 / 编译阶段</p><blockquote><p>编写代码 ——（Javac 编译）——&gt; .class 字节码文件</p></blockquote></li><li><p>Class 类阶段 / 加载阶段</p><blockquote><p>字节码文件 ——（ClassLoader 类加载器）——&gt; <code>Class</code>类对象（堆中）· 字节码二进制数据 / 元数据（方法区）</p><p><code>Class</code> 类对象包含：成员变量<code>Field[] fields</code>、构造器<code>Constructor[] cons</code>、成员方法 <code>Methord[] ms</code></p></blockquote></li><li><p>Runtime 运行阶段</p><blockquote><p>创建对象，该对象知道其属于哪个 <code>Class</code> 对象</p></blockquote></li></ol><p><strong>反射机制可以完成</strong></p><ol type="1"><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时得到任意一个类所具有的成员变量和方法</li><li>在运行时调用任意一个对象的成员变量和方法</li><li>生成动态代理</li></ol><h2 id="反射相关的常用类">21.1 反射相关的常用类</h2><ol type="1"><li><p><code>java.lang.Class</code>：代表一个类。<code>Class</code>对象表示某个类加载后在堆中的对象</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> Class.forName(classFullPath);<span class="hljs-comment">//[1]</span><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> cls.newInstance();<span class="hljs-comment">//[2]</span></code></pre></div><ol type="1"><li>通过完整类名得到一个类的 Class 对象</li><li>通过该 Class 对象创建一个该类的 对象实例</li></ol></blockquote></li><li><p><code>java.lang.reflect.Method</code>：代表类的方法。<code>Method</code>对象表示某个类的某个方法</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> cls.getMethod(methodName);<span class="hljs-comment">//[1]</span>method.invoke(o);<span class="hljs-comment">//[2]</span></code></pre></div><ol type="1"><li>通过该 Class 对象得到一个 方法对象</li><li>方法对象.invoke：调用该方法</li></ol></blockquote></li><li><p><code>java.lang.reflect.Field</code>：代表类的成员变量</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> cls.getField(fieldName);<span class="hljs-comment">//[1]</span></code></pre></div><ol type="1"><li>该方法只能得到非私有对象</li></ol></blockquote></li><li><p><code>java.lang.reflect.Constructor</code>：代表类的构造方法</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> cls.getConstructor();<span class="hljs-comment">//[1]</span><span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor2</span> <span class="hljs-operator">=</span> cls.getConstructor(String.class)    <span class="hljs-comment">//[2]</span></code></pre></div><ol type="1"><li>得到一个无参构造器</li><li>得到一个形参是 <code>(String str)</code> 的构造器</li></ol></blockquote></li></ol><p><strong>反射的优点和缺点</strong></p><ul><li>优点：可以动态地创建和使用对象（也是框架底层核心），使用灵活。没有反射机制，框架技术就失去底层支撑</li><li>缺点：使用反射基本是解释执行。这对执行速度有影响。</li></ul><p><strong>反射调用优化 - 关闭访问检查</strong></p><ol type="1"><li><p><code>Method</code> 和<code>Field</code>、<code>Constructor</code> 对象都有<code>setAccessible()</code> 方法</p></li><li><p><code>setAccessible()</code>作用是启动和禁用访问安全检查的开关</p></li><li><p>参数值为true，表示反射对象在使用时取消访问检查，这样能提高反射效率。</p><p>为 false 表示执行访问检查</p></li></ol><h2 id="class-类">21.2 <code>Class</code> 类</h2><ol type="1"><li><code>Class</code> 也是类，因此也继承 <code>Object</code> 类</li><li><code>Class</code> 类不是 new 出来的，而是系统创建的</li><li>对于某个类的 <code>Class</code>类对象，在内存中只有一份，因为类只加载一次</li><li>每个类的实例都会记得自己是由哪个 <code>Class</code> 实例生成</li><li>通过 <code>Class</code> 可以完整地得到一个类的完整结构，通过一系列API</li><li><code>Class</code> 对象是存放在堆的</li><li>类的字节码二进制数据，是放在方法区的。有的地方称为类的元数据（包括方法代码、变量名、方法名、访问权限 等）</li></ol><h3 id="class-类的常用方法">21.2.1 <code>Class</code> 类的常用方法</h3><ul><li><p><code>Class.forName(String)</code>：返回指定类名的<code>Class</code> 对象</p></li><li><p><code>newInstance()</code>：返回一个无参构造器创建的实例</p></li><li><p><code>getName()</code>：返回该 <code>Class</code>对象表示的实体的全类名</p></li><li><p><code>getClass()</code>：返回该 <code>Class</code> 对象的运行类型<code>java.lang.Class</code></p></li><li><p><code>getPackage()</code>：返回该 <code>Class</code>对象所在的包</p></li><li><p><code>getSuperClass()</code>：返回该 <code>Class</code>对象的父类 <code>Class</code> 对象</p></li><li><p><code>getInterface()</code>：返回该 <code>Class</code>对象的接口（数组）</p></li><li><p><code>getAnnotations()</code>：返回注解信息（<code>Annotation[]</code>）</p></li><li><p><code>getClassLoader()</code>：返回该 <code>Class</code>对象的加载器（<code>ClassLoader</code> 类型）</p></li><li><p><code>getSuperclass()</code>：返回该 <code>Class</code>对象实体的超类的 <code>Class</code></p></li><li><p><code>getConstructors()</code>：返回本类所有包含<code>public</code> 修饰的构造器的 <code>Constructor</code> 对象数组</p><p>该方法返回的构造器不含父类构造器！</p></li><li><p><code>getDeclaredConstructer()</code>：返回本类所有构造器的<code>Constructor</code> 对象数组</p></li><li><p><code>getFileds()</code>：返回一个包含 <code>public</code>修饰的属性的 <code>Field</code> 对象的数组</p><p><code>getFiled(String name)</code>：返回指定的<code>Field</code></p></li><li><p><code>getDeclaredFields()</code>：获取本类中所有属性</p></li><li><p><code>field.get(instance)</code>：返回指定实例的指定属性</p></li><li><p><code>field.set(instance, ..)</code>：给指定实例的指定属性赋值</p></li><li><p><code>getMethod()</code>：获得所有 <code>public</code>修饰的方法的 <code>Method</code> 对象</p></li><li><p><code>getMethod(String name, Class paramTypes, ...)</code>：返回一个<code>Method</code> 对象，其形参类型为 paramType</p></li><li><p><code>getDeclaredMethod()</code>：获取本类中所有方法</p></li></ul><h3 id="获取-class-对象">21.2.2 获取 <code>Class</code> 对象</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.note;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;&#125;</code></pre></div><ol type="1"><li><p>（编译阶段）已知一个类的全类名，且该类在类路径下：</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">cls1</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.melody.note.Test&quot;</span>);</code></pre></div><p>应用场景：配置文件，读取类全路径，加载类。</p><p>可能抛出 <code>ClassNotFoundExcption</code></p></blockquote></li><li><p>（加载阶段）已知具体的类：</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">cls2</span> <span class="hljs-operator">=</span> Test.class;</code></pre></div><p>应用场景：参数传递。</p><p>该方法最为安全</p></blockquote></li><li><p>（运行阶段）已知某个类的实例：</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">cls3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>().getClass();</code></pre></div><p>应用场景：通过创建好的对象获取 <code>Class</code> 对象</p></blockquote></li><li><p>通过类加载器：</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">ClassLoader</span> <span class="hljs-variable">cll</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>().getClass().getClassLoader();<span class="hljs-type">Class</span> <span class="hljs-variable">cls4</span> <span class="hljs-operator">=</span> cll.loadClass(<span class="hljs-string">&quot;com.melody.note.Test&quot;</span>);</code></pre></div></blockquote></li><li><p>基本数据类型：</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clsB1</span> <span class="hljs-operator">=</span> <span class="hljs-type">int</span>.class;Class&lt;Boolean&gt; clsB2 = <span class="hljs-type">boolean</span>.class;</code></pre></div></blockquote></li><li><p>基本数据类型包装类：</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clsB3</span> <span class="hljs-operator">=</span> Character.TYPE;Class&lt;Long&gt; clsB4 = Long.TYPE;</code></pre></div></blockquote></li></ol><h3 id="哪些类有-class-对象">21.2.3 哪些类有 <code>Class</code>对象</h3><ol type="1"><li>外部类、成员内部类、静态内部类、局部内部类、匿名内部类</li><li>接口（interface）</li><li>数组</li><li>枚举（enum）</li><li>注解</li><li>基本数据类型</li><li>void</li></ol><h2 id="类的加载">21.3 类的加载</h2><p><strong>基本说明</strong></p><blockquote><p>反射机制是 Java 实现动态语言的关键，也就是通过反射实现类动态加载</p></blockquote><ol type="1"><li>静态加载：编译时加载相关的类，如果没有则报错。依赖性强</li><li>静态加载：运行时加载需要的类，如果运行时不用该类，则不报错。降低了依赖性</li></ol><p><strong>类加载时机</strong></p><ol type="1"><li>创建对象时（new） [静态加载]</li><li>子类被加载时，父类也被加载 [静态加载]</li><li>调用类中的静态成员 [静态加载]</li><li>通过反射 [动态加载]</li></ol><p><img src="/img/Java_InputImage/类加载图_21.3.png" /></p><p><em>（类加载图_21.3）</em></p><ul><li><p>加载（Loading）：</p><p>将类的 .class 文件读入内存，并为之创建一个 java.lang.Class对象。此过程由类加载器完成</p></li><li><p>连接（Linking）：</p><p>将类的二进制数据合并进 JRE 中</p></li><li><p>初始化（initialization）：</p><p>JVM 负责对类进行初始化。这里主要是静态成员</p></li></ul><h3 id="类加载的五个阶段">21.3.1 类加载的五个阶段</h3><ul><li><p><strong>加载阶段</strong></p><p>JVM 在该阶段的主要目的是将字节码从不同数据源（.class 文件、jar包、网络等）转化为二进制字节流加载到内存中，并生成一个代表该类的<code>java.lang.Class</code> 对象</p></li><li><p><strong>连接阶段 - 验证</strong></p><p>目的是确保 <code>Class</code>文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p>包括：文件格式验证（是否以魔数 0xcafebabe开头）、元数据验证、字节码验证、符号引用验证</p><p>可以考虑使用 <code>-Xverify:none</code>参数来关闭大部分的类验证措施，以缩短虚拟机加载的时间</p></li><li><p><strong>连接阶段 - 准备</strong></p><p>JVM 会在该阶段对 静态变量分配内存并执行默认初始化。这些变量使用的内存都将在方法区中进行分配</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//实例属性，非静态变量，此阶段不分配内存</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<span class="hljs-comment">//静态变量，默认初始化为 0</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">n3</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<span class="hljs-comment">//static final 常量，静态初始化为 3</span></code></pre></div></li><li><p><strong>连接阶段 - 解析</strong></p><p>JVM 将常量池内符号引用替换为直接引用的过程</p></li><li><p><strong>初始化</strong></p><p>到初始化阶段，才真正开始执行类中定义的 Java 程序代码。此阶段是执行<code>&lt;clinit&gt;()</code> 方法的过程</p><p><code>&lt;clinit&gt;()</code>方法是由编译器按语句在文件中出现的顺序，依次自动收集类中所有静态变量的赋值动作和静态代码块中的语句，并进行合并</p><p>JVM 会保证一个类的 <code>&lt;clinit&gt;()</code>方法在多线程环境中被正确地加锁、同步。如果多个线程去初始化一个类，那么只会有一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都需要阻塞等待，直到活动线程执行<code>&lt;clinit&gt;()</code> 方法完毕</p></li></ul><h2 id="通过反射获取类的结构信息">21.4 通过反射获取类的结构信息</h2><p><strong><code>java.lang.Class</code>类（与前面的的重复）</strong></p><blockquote><ul><li><p><code>getSuperClass()</code>：返回该 <code>Class</code>对象的父类 <code>Class</code> 对象</p></li><li><p><code>getInterface()</code>：返回该 <code>Class</code>对象的接口（数组）</p></li><li><p><code>getAnnotations()</code>：返回注解信息（<code>Annotation[]</code>）</p></li><li><p><code>getClassLoader()</code>：返回该 <code>Class</code>对象的加载器（<code>ClassLoader</code> 类型）</p></li><li><p><code>getSuperclass()</code>：返回该 <code>Class</code>对象实体的超类的 <code>Class</code></p></li><li><p><code>getConstructors()</code>：返回本类所有包含<code>public</code> 修饰的构造器的 <code>Constructor</code> 对象数组</p><p>该方法返回的构造器不含父类构造器！</p></li><li><p><code>getDeclaredConstructer()</code>：返回本类所有构造器的<code>Constructor</code> 对象数组</p></li><li><p><code>getFileds()</code>：返回一个包含 <code>public</code>修饰的属性的 <code>Field</code> 对象的数组</p><p><code>getFiled(String name)</code>：返回指定的<code>Field</code></p></li><li><p><code>getDeclaredFields()</code>：获取本类中所有属性</p></li><li><p><code>field.get(instance)</code>：返回指定实例的指定属性</p></li><li><p><code>field.set(instance, ..)</code>：给指定实例的指定属性赋值</p></li><li><p><code>getMethod()</code>：获得所有 <code>public</code>修饰的方法的 <code>Method</code> 对象</p></li><li><p><code>getMethod(String name, Class paramTypes, ...)</code>：返回一个<code>Method</code> 对象，其形参类型为 paramType</p></li><li><p><code>getDeclaredMethod()</code>：获取本类中所有方法</p></li></ul></blockquote><p><strong><code>java.lang.reflect.Field</code> 类</strong></p><blockquote><ul><li><p><code>getModifiers()</code>：以 int 形式返回修饰符</p><p>默认修饰符 [0]、public [1]、private [2]、protected [4]、static[8]、final [16]</p><p>示例：</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;</code></pre></div><p>这个变量的修饰符的 int 表示 = 1 + 8 + 16 = 25</p></blockquote></li><li><p><code>getType()</code>：以 <code>Class</code> 形式返回类型</p><blockquote><p>上例变量的 <code>getType()</code> 等同于<code>Integer.getClass()</code></p></blockquote></li><li><p><code>getName()</code>：返回属性名</p></li></ul></blockquote><p><strong><code>java.lang.reflect.Method</code> 类</strong></p><blockquote><ul><li><code>getModifiers()</code>：以 int 形式返回修饰符（同上）</li><li><code>getName()</code>：返回方法名</li><li><code>getReturnType()</code>：以 <code>Class</code>形式返回返回类型</li><li><code>getParameterTypes()</code>：以 <code>Class[]</code>形式返回形参类型数组</li></ul></blockquote><p><strong><code>java.lang.reflect.Constructer</code> 类</strong></p><blockquote><ul><li><code>getModifiers()</code>：以 int 形式返回修饰符</li><li><code>getName()</code>：返回构造器名（和全类名相等）</li><li><code>getParameterTypes()</code>：以 <code>Class[]</code>形式返回形参类型数组</li></ul></blockquote><h2 id="通过反射创建对象">21.5 通过反射创建对象</h2><ol type="1"><li><p>调用类中的 public 修饰的无参构造器</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj1</span> <span class="hljs-operator">=</span> cls.newInstance();</code></pre></div></blockquote></li><li><p>调用类中指定的构造器</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Constructer</span> <span class="hljs-variable">cons</span> <span class="hljs-operator">=</span> cls.getConstructer(<span class="hljs-type">int</span>.class, String.class, ...);<span class="hljs-type">Object</span> <span class="hljs-variable">obj2</span> <span class="hljs-operator">=</span> cons.newInstance(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;nnn&quot;</span>, ...);</code></pre></div></blockquote></li><li><p><code>setAccessible(true)</code>：爆破（暴力破解）。使用反射可以访问private 构造器</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Constructer</span> <span class="hljs-variable">cons2</span> <span class="hljs-operator">=</span> cls.getDeclaredConstructer(<span class="hljs-type">boolean</span>.class ...);cons2.setAccessible(<span class="hljs-literal">true</span>);<span class="hljs-type">Object</span> <span class="hljs-variable">obj3</span> <span class="hljs-operator">=</span> cons.newInstance(<span class="hljs-literal">false</span>, ...);</code></pre></div></blockquote></li></ol><h2 id="通过反射访问成员">21.6 通过反射访问成员</h2><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> cla.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);field.setAccessible(<span class="hljs-literal">true</span>);field.set(o, <span class="hljs-string">&quot;111&quot;</span>);<span class="hljs-comment">//[1]</span></code></pre></div><ol type="1"><li><p>o 表示一个类的实例</p><p>如果该属性是静态属性，则对象 o 可以是 null</p></li></ol></blockquote><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> cls.getDeclaredMethod(<span class="hljs-string">&quot;m1&quot;</span>);method.setAccessible(<span class="hljs-literal">true</span>);<span class="hljs-type">Object</span> <span class="hljs-variable">returnObj</span> <span class="hljs-operator">=</span> method.invoke(o, <span class="hljs-string">&#x27;c&#x27;</span>, ...);<span class="hljs-comment">//[1]</span></code></pre></div><ol type="1"><li><p>o 表示一个类的实例，后面是实参列表</p><p>同理，静态方法的场合，对象 o 可以是 null</p></li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt;20 项目（多用户通讯系统）</title>
    <link href="/2022/01/16/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/20%20%E9%A1%B9%E7%9B%AE%EF%BC%9A%E5%A4%9A%E7%94%A8%E6%88%B7%E9%80%9A%E8%AE%AF%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/01/16/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/20%20%E9%A1%B9%E7%9B%AE%EF%BC%9A%E5%A4%9A%E7%94%A8%E6%88%B7%E9%80%9A%E8%AE%AF%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="项目多用户通讯系统">20 项目：多用户通讯系统</h1><blockquote><p><strong>项目见（多用户通讯系统）</strong></p><p>服务端启动位置（多用户通讯系统：通讯系统（服务端）.java）</p><p>客户端启动位置（项目：通讯系统（客户端）1.java）</p></blockquote><h2 id="需求分析">20.1 需求分析</h2><ol type="1"><li>用户登录</li><li>拉取在线用户列表</li><li>无异常退出（客户端、服务端）</li><li>私聊</li><li>群聊</li><li>发文件</li><li>服务器推送新闻</li></ol><h3 id="登录">20.1.1 登录</h3><p><strong>服务端</strong></p><ol type="1"><li>客户端连接到服务器后，会得到一个 <code>Socket</code></li><li>启动一个线程，该线程持有该 <code>Socket</code> 对象</li><li>为了更好地管理线程，需要使用集合来管理</li></ol><p><strong>客户端</strong></p><ol type="1"><li>和服务端通信时，使用对象方式，可以使用对象流来读写</li><li>客户端连接到服务端后，也会得到 <code>Socket</code></li><li>启动一个线程，该线程持有该 <code>Socket</code> 对象</li><li>为了更好地管理线程，需要使用集合来管理</li></ol><h3 id="无异常退出">20.1.2 无异常退出</h3><blockquote><p>写下面内容的之前，我已经把代码都完成了。</p><p><ahref="https://www.bilibili.com/video/BV1fh411y7R8?p=688&amp;t=0.8">韩老师的思路</a>都是最基本的思路，这些其实应该不参考笔记自己去想。</p><p>想不通的地方才看答案（笔记），我认为是比较好的方法。</p></blockquote><p><strong>服务端</strong></p><ol type="1"><li>服务器端和某个客户端通信的线程接到一个退出请求后，关闭 socket并退出线程</li></ol><p><strong>客户端</strong></p><ol type="1"><li>调用方法，向服务端发送登出请求，之后客户端调用方法正常退出</li></ol><h3 id="下略">下略</h3><blockquote><p>没记</p></blockquote><h2 id="附录">附录</h2><h3 id="多用户通讯系统">多用户通讯系统</h3><p>开始写的时候思路没整理好，最后乱七八糟的</p><p>又没什么注释，所以别往下翻了</p><h4 id="通用部分客户端-服务端">通用部分（客户端 &amp; 服务端）</h4><blockquote><p>MyTools.java：工具类</p><p>UserData.java：用户数据类，包含完整的用户信息。这些信息存储在服务端。每个客户端只可能在验证通过的场合，持有最多一个来自服务端的属于客户自己的该类对象</p><p>User.java：简易的用户类。只是用以传递一组账号和密码。一般由客户端发送往服务端。这些账号和密码未必是正确的。</p><p>Message.java：数据包。客户端和服务端的所有通信都以传递该数据包的形式进行。</p><p>MessageType.java：代码表。客户端和服务端各自持有一份相同的该表，用以对数据包进行识别。</p></blockquote><ul><li><p><strong>MyTools.java</strong></p><p>精简了一下放上来</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com;<span class="hljs-keyword">import</span> java.io.*;<span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTools</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Scanner</span> <span class="hljs-variable">inp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);    <span class="hljs-comment">//这个方法能读取一个 输入流 的内容</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] whatInputIs(InputStream is) <span class="hljs-keyword">throws</span> IOException &#123;        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];        <span class="hljs-keyword">while</span> ((len = is.read(bytes, <span class="hljs-number">0</span>, bytes.length)) != -<span class="hljs-number">1</span>) &#123;            bis.write(bytes, <span class="hljs-number">0</span>, len);        &#125;        <span class="hljs-keyword">return</span> bis.toByteArray();    &#125;&#125;</code></pre></div></li><li><p><strong>User.java</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.transmission.common;<span class="hljs-keyword">import</span> java.io.Serializable;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;    <span class="hljs-keyword">private</span> String id;    <span class="hljs-keyword">private</span> String pw;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String id, String pw)</span> &#123;        <span class="hljs-built_in">this</span>.id = id;        <span class="hljs-built_in">this</span>.pw = pw;    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(String id)</span> &#123;        <span class="hljs-built_in">this</span>.id = id;    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPw</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> pw;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPw</span><span class="hljs-params">(String pw)</span> &#123;        <span class="hljs-built_in">this</span>.pw = pw;    &#125;&#125;</code></pre></div></li><li><p><strong>UserData.java</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.transmission.common;<span class="hljs-keyword">import</span> java.io.Serializable;<span class="hljs-keyword">import</span> java.util.Objects;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserData</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String ID;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String pw;    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">online</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">private</span> String[] friendID;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">leftMessage</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();    UserData(String name, String pw, String ID) &#123;        <span class="hljs-built_in">this</span>.name = name;        <span class="hljs-built_in">this</span>.pw = pw;        <span class="hljs-built_in">this</span>.ID = ID;    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> ID;    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;        <span class="hljs-built_in">this</span>.name = name;    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPw</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> pw;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPw</span><span class="hljs-params">(String pw)</span> &#123;        <span class="hljs-built_in">this</span>.pw = pw;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isOnline</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> online;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setOnline</span><span class="hljs-params">(<span class="hljs-type">boolean</span> online)</span> &#123;        <span class="hljs-built_in">this</span>.online = online;    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">listed</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> ((online ? <span class="hljs-string">&quot;·在线&quot;</span> : <span class="hljs-string">&quot;离线中&quot;</span>) + <span class="hljs-string">&quot;\t用户名：（&quot;</span> + ID + <span class="hljs-string">&quot;）&quot;</span> + name);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-type">UserData</span> <span class="hljs-variable">userData</span> <span class="hljs-operator">=</span> (UserData) o;        <span class="hljs-type">return</span> <span class="hljs-variable">online</span> <span class="hljs-operator">=</span>= userData.online &amp;&amp; Objects.equals(ID, userData.ID) &amp;&amp; Objects.equals(name, userData.name) &amp;&amp; Objects.equals(pw, userData.pw);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> Objects.hash(ID, name, pw, online);    &#125;&#125;</code></pre></div></li><li><p><strong>Message.java</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.transmission.common;<span class="hljs-keyword">import</span> java.io.Serializable;<span class="hljs-keyword">import</span> java.time.LocalDateTime;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Message</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span>, MessageType &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;    <span class="hljs-keyword">private</span> String message;    <span class="hljs-keyword">private</span> String time;    <span class="hljs-keyword">private</span> String sender;    <span class="hljs-keyword">private</span> String receiver;    <span class="hljs-keyword">private</span> String messageType;    <span class="hljs-keyword">private</span> Object object;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Message</span><span class="hljs-params">(String message, String sender, String receiver, String messageType)</span> &#123;        <span class="hljs-built_in">this</span>.message = message;        <span class="hljs-built_in">this</span>.time = getDateTime();        <span class="hljs-built_in">this</span>.sender = sender;        <span class="hljs-built_in">this</span>.receiver = receiver;        <span class="hljs-built_in">this</span>.messageType = messageType;    &#125;    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getObject</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> object;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setObject</span><span class="hljs-params">(Object object)</span> &#123;        <span class="hljs-built_in">this</span>.object = object;    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMessage</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> message;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMessage</span><span class="hljs-params">(String message)</span> &#123;        <span class="hljs-built_in">this</span>.message = message;    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getTime</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> time;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTime</span><span class="hljs-params">(String time)</span> &#123;        <span class="hljs-built_in">this</span>.time = time;    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSender</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> sender;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSender</span><span class="hljs-params">(String sender)</span> &#123;        <span class="hljs-built_in">this</span>.sender = sender;    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getReceiver</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> receiver;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setReceiver</span><span class="hljs-params">(String receiver)</span> &#123;        <span class="hljs-built_in">this</span>.receiver = receiver;    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMessageType</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> messageType;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMessageType</span><span class="hljs-params">(String messageType)</span> &#123;        <span class="hljs-built_in">this</span>.messageType = messageType;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getDate</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> getDate(LocalDateTime.now());    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getDate</span><span class="hljs-params">(LocalDateTime ldt)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">mon</span> <span class="hljs-operator">=</span> ldt.getMonthValue();        <span class="hljs-type">int</span> <span class="hljs-variable">day</span> <span class="hljs-operator">=</span> ldt.getDayOfMonth();        <span class="hljs-keyword">return</span> ldt.getYear() + <span class="hljs-string">&quot;.&quot;</span> + (mon &lt; <span class="hljs-number">10</span> ? <span class="hljs-string">&quot;0&quot;</span> + mon : mon) + <span class="hljs-string">&quot;.&quot;</span> + (day &lt; <span class="hljs-number">10</span> ? <span class="hljs-string">&quot;0&quot;</span> + day : day);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">time</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> time(LocalDateTime.now());    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">time</span><span class="hljs-params">(LocalDateTime ldt)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">hour</span> <span class="hljs-operator">=</span> ldt.getHour();        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> ldt.getMinute();        <span class="hljs-type">int</span> <span class="hljs-variable">sec</span> <span class="hljs-operator">=</span> ldt.getSecond();        <span class="hljs-keyword">return</span> (hour &lt; <span class="hljs-number">10</span> ? <span class="hljs-string">&quot;0&quot;</span> + hour : hour) + <span class="hljs-string">&quot;:&quot;</span> + (min &lt; <span class="hljs-number">10</span> ? <span class="hljs-string">&quot;0&quot;</span> + min : min) + <span class="hljs-string">&quot;:&quot;</span> + (sec &lt; <span class="hljs-number">10</span> ? <span class="hljs-string">&quot;0&quot;</span> + sec : sec);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getDateTime</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">ldt</span> <span class="hljs-operator">=</span> LocalDateTime.now();        <span class="hljs-keyword">return</span> getDate(ldt) + <span class="hljs-string">&quot;  &quot;</span> + time();    &#125;&#125;</code></pre></div></li><li><p><strong>MessageType.java</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.transmission.common;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MessageType</span> &#123;    <span class="hljs-type">String</span> <span class="hljs-variable">LOGIN_SUCCESS</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lS&quot;</span>;    <span class="hljs-type">String</span> <span class="hljs-variable">LOGIN_FAILED</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lF&quot;</span>;    <span class="hljs-type">String</span> <span class="hljs-variable">LOGIN_USER_NOT_EXIST</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lU&quot;</span>;    <span class="hljs-type">String</span> <span class="hljs-variable">LOGIN_WRONG_PW</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lP&quot;</span>;    <span class="hljs-type">String</span> <span class="hljs-variable">LOGGED_SHOW_LIST</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;11SL&quot;</span>;    <span class="hljs-type">String</span> <span class="hljs-variable">LOGGED_SHOW_ONLINE_LIST</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;11SO&quot;</span>;    <span class="hljs-type">String</span> <span class="hljs-variable">CHAT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;CM&quot;</span>;    <span class="hljs-type">String</span> <span class="hljs-variable">GROUP_CHAT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;GM&quot;</span>;    <span class="hljs-type">String</span> <span class="hljs-variable">FILE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;CF&quot;</span>;    <span class="hljs-type">String</span> <span class="hljs-variable">LOGGED_CHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;15CN&quot;</span>;    <span class="hljs-type">String</span> <span class="hljs-variable">LOGGED_CHANGE_PW</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;16CP&quot;</span>;    <span class="hljs-type">String</span> <span class="hljs-variable">LOGGED_CHANGE_HIDE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;17CH&quot;</span>;    <span class="hljs-type">String</span> <span class="hljs-variable">LOGGED_LOGOUT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;19OT&quot;</span>;    <span class="hljs-type">String</span> <span class="hljs-variable">REQUEST_ALLOWED</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;RE&quot;</span>;    <span class="hljs-type">String</span> <span class="hljs-variable">REQUEST_REJECTED</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;RR&quot;</span>;    <span class="hljs-type">String</span> <span class="hljs-variable">REPEAT_LOGIN</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;EXC_RL&quot;</span>;&#125;</code></pre></div></li></ul><h4 id="服务端">服务端</h4><blockquote><p>ClientConnet.java：入口</p><p>ClientLogin.java：管理所有登录活动。该线程将持续监听用户登录。用户登录成功后启动一个专用的会话线程。</p><p>Serve.java：这就是那个专用会话线程。会持续监听用户请求，并作出反应。</p><p>ServeCollection.java：该类收集所有活动中的 Serve 线程。</p><p>UserDataEnum.java：记录所有用户数据的枚举类。数据库的替代方法（还没学数据库）</p></blockquote><ul><li><p><strong>ClientConnet.java（入口）</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.transmission.common;<span class="hljs-keyword">import</span> com.melody.transmission.login.ClientLogin;<span class="hljs-keyword">import</span> java.net.Socket;<span class="hljs-keyword">import</span> java.util.HashMap;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientConnect</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">thisIP</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;192.168.3.16&quot;</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> HashMap&lt;String, UserData&gt; data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> HashMap&lt;String, Socket&gt; sockets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-keyword">for</span> (UserDataEnum userData : UserDataEnum.values()) &#123;            data.put(userData.user.getId(), userData.user);        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientLogin</span>()).start();    &#125;&#125;</code></pre></div></li><li><p><strong>ClientLogin.java</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.transmission.login;<span class="hljs-keyword">import</span> com.melody.transmission.common.*;<span class="hljs-keyword">import</span> com.melody.transmission.connected.Serve;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.ObjectInputStream;<span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<span class="hljs-keyword">import</span> java.net.InetAddress;<span class="hljs-keyword">import</span> java.net.ServerSocket;<span class="hljs-keyword">import</span> java.net.Socket;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientLogin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">try</span> &#123;            serverSocket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">9000</span>);            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;                login(serverSocket);            &#125;        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">login</span><span class="hljs-params">(ServerSocket serverSocket)</span> <span class="hljs-keyword">throws</span> IOException &#123;        <span class="hljs-type">Socket</span> <span class="hljs-variable">clientSocket</span> <span class="hljs-operator">=</span> serverSocket.accept();        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(clientSocket.getInputStream());        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(clientSocket.getOutputStream());        String checkRes;        <span class="hljs-type">User</span> <span class="hljs-variable">clientUser</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-type">Message</span> <span class="hljs-variable">toSend</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-literal">null</span>, InetAddress.getLocalHost().getHostAddress(), clientSocket.getInetAddress().getHostAddress(), <span class="hljs-literal">null</span>);        toSend.setObject(<span class="hljs-literal">null</span>);        <span class="hljs-keyword">try</span> &#123;            clientUser = (User) ois.readObject();            checkRes = checkUserData(clientUser);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            checkRes = MessageType.LOGIN_FAILED;        &#125;        toSend.setMessageType(checkRes);        <span class="hljs-keyword">if</span> (checkRes.equals(MessageType.LOGIN_SUCCESS)) &#123;            ClientConnect.data.get(clientUser.getId()).setOnline(<span class="hljs-literal">true</span>);            toSend.setObject(ClientConnect.data.get(clientUser.getId()));            oos.writeObject(toSend);            <span class="hljs-type">Serve</span> <span class="hljs-variable">serve</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Serve</span>(clientSocket, oos, ois, clientUser.getId());            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(serve).start();<span class="hljs-comment">//            ClientSocketsCollection.addSocket(clientUser.getId(), clientSocket);</span>            ServeCollection.add(clientUser.getId(), serve);        &#125; <span class="hljs-keyword">else</span> &#123;            oos.writeObject(toSend);            oos.close();            ois.close();            clientSocket.close();        &#125;    &#125;    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">checkUserData</span><span class="hljs-params">(User inp)</span> &#123;        <span class="hljs-type">UserData</span> <span class="hljs-variable">inpIDUser</span> <span class="hljs-operator">=</span> ClientConnect.data.get(inp.getId());        <span class="hljs-keyword">if</span> (inpIDUser == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">return</span> MessageType.LOGIN_USER_NOT_EXIST;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!inpIDUser.getPw().equals(inp.getPw())) &#123;            <span class="hljs-keyword">return</span> MessageType.LOGIN_WRONG_PW;        &#125;        <span class="hljs-type">Serve</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> ServeCollection.get(inpIDUser.getId());        <span class="hljs-keyword">if</span> (temp != <span class="hljs-literal">null</span>)&#123;            <span class="hljs-keyword">try</span> &#123;                temp.sendRepeatLoginException();                System.out.println(Message.getDateTime() + <span class="hljs-string">&quot; &quot;</span> + temp.id + <span class="hljs-string">&quot; 重复登陆&quot;</span>);                temp.forceLogout();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                <span class="hljs-keyword">return</span> MessageType.LOGIN_FAILED;            &#125;        &#125;        <span class="hljs-keyword">return</span> MessageType.LOGIN_SUCCESS;    &#125;&#125;</code></pre></div></li><li><p><strong>Serve.java（主干）</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.transmission.connected;<span class="hljs-keyword">import</span> com.melody.transmission.common.*;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.ObjectInputStream;<span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<span class="hljs-keyword">import</span> java.net.Socket;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Serve</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;    <span class="hljs-keyword">private</span> Socket clientSocket;    <span class="hljs-keyword">private</span> ObjectOutputStream oos;    <span class="hljs-keyword">private</span> ObjectInputStream ois;    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">connecting</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String id;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Serve</span><span class="hljs-params">(Socket clientSocket, ObjectOutputStream oos, ObjectInputStream ois, String id)</span> &#123;        <span class="hljs-built_in">this</span>.clientSocket = clientSocket;        <span class="hljs-built_in">this</span>.oos = oos;        <span class="hljs-built_in">this</span>.ois = ois;        <span class="hljs-built_in">this</span>.id = id;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;        System.out.println(Message.getDateTime() + <span class="hljs-string">&quot; &quot;</span> + id + <span class="hljs-string">&quot; 登录 &quot;</span> + clientSocket.getLocalAddress().getHostName());        ClientConnect.data.get(id).setOnline(<span class="hljs-literal">true</span>);        <span class="hljs-keyword">while</span> (connecting) &#123;            <span class="hljs-keyword">try</span> &#123;                serve();            &#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;                <span class="hljs-keyword">try</span> &#123;                    forceLogout();                    System.out.println(Message.getDateTime() + <span class="hljs-string">&quot; &quot;</span> + id + <span class="hljs-string">&quot; 系统强行登出 &quot;</span> + e.toString());                &#125; <span class="hljs-keyword">catch</span> (IOException ex) &#123;                    ex.printStackTrace();                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serve</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;        <span class="hljs-type">Message</span> <span class="hljs-variable">inp</span> <span class="hljs-operator">=</span> (Message) ois.readObject();        <span class="hljs-type">Message</span> <span class="hljs-variable">toSend</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-literal">null</span>, ClientConnect.thisIP, clientSocket.getInetAddress().getHostAddress(), <span class="hljs-literal">null</span>);        <span class="hljs-keyword">if</span> (inp == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (inp.getMessageType().equals(MessageType.LOGGED_SHOW_LIST)) &#123;            sendList(inp, toSend);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (inp.getMessageType().equals(MessageType.LOGGED_CHANGE_NAME)) &#123;            setNewName(inp, toSend);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (inp.getMessageType().equals(MessageType.LOGGED_CHANGE_HIDE)) &#123;            changeHide(inp, toSend);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (inp.getMessageType().equals(MessageType.LOGGED_CHANGE_PW)) &#123;            changPw(inp, toSend);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (inp.getMessageType().equals(MessageType.LOGGED_SHOW_ONLINE_LIST)) &#123;            sendOnlineList(inp, toSend);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (inp.getMessageType().equals(MessageType.CHAT)) &#123;            chat(inp, toSend);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (inp.getMessageType().equals(MessageType.GROUP_CHAT)) &#123;            groupChat(inp, toSend);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (inp.getMessageType().equals(MessageType.LOGGED_LOGOUT)) &#123;            logout(inp);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (inp.getMessageType().equals(MessageType.FILE)) &#123;            sendFile(inp, toSend);        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendList</span><span class="hljs-params">(Message inp, Message toSend)</span> <span class="hljs-keyword">throws</span> IOException &#123;        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();        <span class="hljs-keyword">for</span> (UserData userData : ClientConnect.data.values()) &#123;            sb.append(userData.listed());            sb.append(<span class="hljs-string">&quot;\n&quot;</span>);        &#125;        toSend.setMessage(sb.toString());        toSend.setMessageType(MessageType.REQUEST_ALLOWED);        oos.writeObject(toSend);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendOnlineList</span><span class="hljs-params">(Message inp, Message toSend)</span> <span class="hljs-keyword">throws</span> IOException &#123;        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();        <span class="hljs-keyword">for</span> (UserData userData : ClientConnect.data.values()) &#123;            <span class="hljs-keyword">if</span> (userData.isOnline()) &#123;                sb.append(userData.listed());                sb.append(<span class="hljs-string">&quot;\n&quot;</span>);            &#125;        &#125;        toSend.setMessage(sb.toString());        toSend.setMessageType(MessageType.REQUEST_ALLOWED);        oos.writeObject(toSend);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNewName</span><span class="hljs-params">(Message inp, Message toSend)</span> <span class="hljs-keyword">throws</span> IOException &#123;        <span class="hljs-type">String</span> <span class="hljs-variable">newName</span> <span class="hljs-operator">=</span> inp.getMessage();        <span class="hljs-type">UserData</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> (UserData) inp.getObject();        <span class="hljs-keyword">if</span> (!temp.getId().equals(id) || !temp.equals(ClientConnect.data.get(id))) &#123;            toSend.setMessageType(MessageType.REQUEST_REJECTED);        &#125; <span class="hljs-keyword">else</span> &#123;            temp.setName(newName);            ClientConnect.data.put(id, temp);            toSend.setObject(ClientConnect.data.get(temp.getId()));            toSend.setMessageType(MessageType.REQUEST_ALLOWED);        &#125;        oos.writeObject(toSend);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">changPw</span><span class="hljs-params">(Message inp, Message toSend)</span> <span class="hljs-keyword">throws</span> IOException &#123;        <span class="hljs-type">String</span> <span class="hljs-variable">newPw</span> <span class="hljs-operator">=</span> inp.getMessage();        <span class="hljs-type">UserData</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> (UserData) inp.getObject();        <span class="hljs-keyword">if</span> (!temp.getId().equals(id) || !temp.equals(ClientConnect.data.get(id))) &#123;            toSend.setMessageType(MessageType.REQUEST_REJECTED);        &#125; <span class="hljs-keyword">else</span> &#123;            temp.setPw(newPw);            ClientConnect.data.put(id, temp);            toSend.setObject(ClientConnect.data.get(id));            toSend.setMessageType(MessageType.REQUEST_ALLOWED);        &#125;        oos.writeObject(toSend);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">changeHide</span><span class="hljs-params">(Message inp, Message toSend)</span> <span class="hljs-keyword">throws</span> IOException &#123;        <span class="hljs-type">UserData</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> (UserData) inp.getObject();        <span class="hljs-keyword">if</span> (!temp.getId().equals(id) || !temp.equals(ClientConnect.data.get(id))) &#123;            toSend.setMessageType(MessageType.REQUEST_REJECTED);        &#125; <span class="hljs-keyword">else</span> &#123;            temp.setOnline(!temp.isOnline());            ClientConnect.data.put(id, temp);            toSend.setObject(ClientConnect.data.get(temp.getId()));            toSend.setMessageType(MessageType.REQUEST_ALLOWED);        &#125;        oos.writeObject(toSend);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">chat</span><span class="hljs-params">(Message inp, Message toSend)</span> <span class="hljs-keyword">throws</span> IOException &#123;        User[] users = (User[]) inp.getObject();        <span class="hljs-keyword">if</span> (!users[<span class="hljs-number">0</span>].getId().equals(id) || !users[<span class="hljs-number">0</span>].getPw().equals(ClientConnect.data.get(id).getPw())) &#123;            toSend.setMessageType(MessageType.REQUEST_REJECTED);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (users[<span class="hljs-number">1</span>].getId().equals(id) || ClientConnect.data.get(users[<span class="hljs-number">1</span>].getId()) == <span class="hljs-literal">null</span>) &#123;            toSend.setMessageType(MessageType.REQUEST_REJECTED);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-type">UserData</span> <span class="hljs-variable">tar</span> <span class="hljs-operator">=</span> ClientConnect.data.get(users[<span class="hljs-number">1</span>].getId());            <span class="hljs-type">UserData</span> <span class="hljs-variable">form</span> <span class="hljs-operator">=</span> ClientConnect.data.get(id);            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">send</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();            toSend.setMessageType(MessageType.CHAT);            send.append(inp.getTime()).append(<span class="hljs-string">&quot; &quot;</span>).append(form.getName()).append(<span class="hljs-string">&quot; 对 你 说：&quot;</span>).append(inp.getMessage());            <span class="hljs-keyword">if</span> (ServeCollection.get(tar.getId()) != <span class="hljs-literal">null</span>) &#123;                toSend.setMessage(send.toString());                ServeCollection.get(tar.getId()).oos.writeObject(toSend);            &#125; <span class="hljs-keyword">else</span> &#123;                ClientConnect.data.get(tar.getId()).leftMessage.append(send).append(<span class="hljs-string">&quot;\n&quot;</span>);            &#125;            toSend.setObject(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(tar.getName(), <span class="hljs-literal">null</span>));            toSend.setMessageType(MessageType.REQUEST_ALLOWED);        &#125;        oos.writeObject(toSend);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">groupChat</span><span class="hljs-params">(Message inp, Message toSend)</span> <span class="hljs-keyword">throws</span> IOException &#123;        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User) inp.getObject();        <span class="hljs-keyword">if</span> (!user.getId().equals(id) || !user.getPw().equals(ClientConnect.data.get(id).getPw())) &#123;            toSend.setMessageType(MessageType.REQUEST_REJECTED);        &#125; <span class="hljs-keyword">else</span> &#123;            toSend.setMessageType(MessageType.GROUP_CHAT);            <span class="hljs-type">String</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;[群发]&quot;</span> + inp.getTime() + <span class="hljs-string">&quot; &quot;</span> + ClientConnect.data.get(id).getName() +                    <span class="hljs-string">&quot; 说：&quot;</span> + inp.getMessage();            toSend.setMessage(word);            <span class="hljs-keyword">for</span> (Serve serve : ServeCollection.toValue()) &#123;                serve.oos.writeObject(toSend);            &#125;            toSend.setMessageType(MessageType.REQUEST_ALLOWED);        &#125;        oos.writeObject(toSend);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendFile</span><span class="hljs-params">(Message inp, Message toSend)</span> <span class="hljs-keyword">throws</span> IOException &#123;        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(id, inp.getSender());        <span class="hljs-keyword">if</span> (!user.getPw().equals(ClientConnect.data.get(id).getPw())) &#123;            toSend.setMessageType(MessageType.REQUEST_REJECTED);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (inp.getReceiver().equals(id) || ClientConnect.data.get(inp.getReceiver()) == <span class="hljs-literal">null</span>) &#123;            toSend.setMessageType(MessageType.REQUEST_REJECTED);        &#125; <span class="hljs-keyword">else</span> &#123;            toSend.setMessageType(MessageType.FILE);            toSend.setMessage(inp.getMessage());            toSend.setSender(id);            toSend.setReceiver(inp.getReceiver());            toSend.setObject(inp.getObject());            <span class="hljs-keyword">try</span> &#123;                ServeCollection.get(inp.getReceiver()).oos.writeObject(toSend);                toSend.setMessageType(MessageType.REQUEST_ALLOWED);            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                toSend.setMessageType(MessageType.REQUEST_REJECTED);            &#125;            toSend.setObject(<span class="hljs-literal">null</span>);        &#125;        oos.writeObject(toSend);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logout</span><span class="hljs-params">(Message inp)</span> <span class="hljs-keyword">throws</span> IOException &#123;        <span class="hljs-type">UserData</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> (UserData) inp.getObject();        <span class="hljs-keyword">if</span> (!temp.getId().equals(id) || !temp.equals(ClientConnect.data.get(id))) &#123;            <span class="hljs-keyword">return</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            ClientConnect.data.get(id).setOnline(<span class="hljs-literal">false</span>);            ois.close();            oos.close();            clientSocket.close();            connecting = <span class="hljs-literal">false</span>;            ServeCollection.remove(id);            System.out.println(Message.getDateTime() + <span class="hljs-string">&quot; &quot;</span> + id + <span class="hljs-string">&quot; 用户登出 &quot;</span> + clientSocket.getInetAddress().getHostName());        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forceLogout</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;        ClientConnect.data.get(id).setOnline(<span class="hljs-literal">false</span>);        ois.close();        oos.close();        clientSocket.close();        connecting = <span class="hljs-literal">false</span>;        ServeCollection.remove(id);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendRepeatLoginException</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;        oos.writeObject(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, MessageType.REPEAT_LOGIN));    &#125;&#125;</code></pre></div></li><li><p><strong>ServeCollection.java</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.transmission.common;<span class="hljs-keyword">import</span> com.melody.transmission.connected.Serve;<span class="hljs-keyword">import</span> java.net.Socket;<span class="hljs-keyword">import</span> java.util.Collection;<span class="hljs-keyword">import</span> java.util.HashMap;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServeCollection</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> HashMap&lt;String, Serve&gt; serves = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(String id, Serve serve)</span>&#123;        serves.put(id, serve);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Serve <span class="hljs-title function_">get</span><span class="hljs-params">(String id)</span> &#123;        <span class="hljs-keyword">return</span> serves.get(id);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Collection&lt;Serve&gt; <span class="hljs-title function_">toValue</span><span class="hljs-params">()</span>&#123;        <span class="hljs-keyword">return</span> serves.values();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(String id)</span>&#123;        serves.remove(id);    &#125;&#125;</code></pre></div></li><li><p><strong>UserDataEnum.java</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.transmission.common;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">UserDataEnum</span> &#123;    USER01(<span class="hljs-string">&quot;申鹤&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>, <span class="hljs-string">&quot;0001&quot;</span>),    USER02(<span class="hljs-string">&quot;胡桃&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>, <span class="hljs-string">&quot;0002&quot;</span>),    USER03(<span class="hljs-string">&quot;甘雨&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>, <span class="hljs-string">&quot;0003&quot;</span>),    USER04(<span class="hljs-string">&quot;刻晴&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>, <span class="hljs-string">&quot;0004&quot;</span>),    USER05(<span class="hljs-string">&quot;香菱&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>, <span class="hljs-string">&quot;0005&quot;</span>),    USER06(<span class="hljs-string">&quot;凝光&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>, <span class="hljs-string">&quot;0006&quot;</span>),    USER07(<span class="hljs-string">&quot;云堇&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>, <span class="hljs-string">&quot;0007&quot;</span>),    USER08(<span class="hljs-string">&quot;留云借风真君&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>, <span class="hljs-string">&quot;0008&quot;</span>),    USER09(<span class="hljs-string">&quot;降魔大圣&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>, <span class="hljs-string">&quot;0009&quot;</span>),    USER10(<span class="hljs-string">&quot;歌尘浪市真君&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>, <span class="hljs-string">&quot;0010&quot;</span>),    USER11(<span class="hljs-string">&quot;理水叠山真君&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>, <span class="hljs-string">&quot;0011&quot;</span>),    USER12(<span class="hljs-string">&quot;摩拉克斯&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>, <span class="hljs-string">&quot;0012&quot;</span>),    USER13(<span class="hljs-string">&quot;救苦渡厄真君&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>, <span class="hljs-string">&quot;0013&quot;</span>);    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> UserData user;    UserDataEnum(String name, String pw, String ID) &#123;        user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserData</span>(name, pw, ID);    &#125;&#125;</code></pre></div></li></ul><h4 id="客户端">客户端</h4><blockquote><p>Test1.java：程序入口</p><p>ClientInterface.java：程序的主干</p><p>ClientThread.java：由这个线程收集服务端发来的数据，并记录</p><p>ClientThreadCollection.java：思路混乱的产物。现在我也不知道这是干嘛的（好在没几行代码）</p><p>Utility.java：工具类</p></blockquote><ul><li><p><strong>Test1.java（入口）</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.transmission;<span class="hljs-keyword">import</span> com.melody.transmission.common.ClientInterface;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientInterface</span>().menu_0();    &#125;&#125;</code></pre></div></li><li><p><strong>ClientInterface.java（主干）</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.transmission.common;<span class="hljs-keyword">import</span> java.io.File;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.ObjectInputStream;<span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<span class="hljs-keyword">import</span> java.net.InetAddress;<span class="hljs-keyword">import</span> java.net.Socket;<span class="hljs-keyword">import</span> java.time.LocalDateTime;<span class="hljs-keyword">import</span> java.util.Date;<span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientInterface</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">thisIP</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;192.168.3.16&quot;</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">serverIP</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;192.168.3.16&quot;</span>;    <span class="hljs-keyword">private</span> <span class="hljs-type">UserData</span> <span class="hljs-variable">loggedUser</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-keyword">private</span> <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-keyword">private</span> ClientThread ct;    <span class="hljs-keyword">private</span> Socket socket;    <span class="hljs-keyword">private</span> Message message;    ObjectOutputStream oos;    ObjectInputStream ois;    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">running</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">cancelMenu</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">public</span> <span class="hljs-type">File</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;d:\\&quot;</span>);    <span class="hljs-comment">//一级菜单、登录</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">menu_0</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">boolean</span> <span class="hljs-variable">running0</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">while</span> (running0) &#123;            System.out.println(<span class="hljs-string">&quot;===========欢迎使用通讯系统（试做版）===========&quot;</span>);            System.out.println(<span class="hljs-string">&quot;\t\t\t1. 用户登录&quot;</span>);            System.out.println(<span class="hljs-string">&quot;\t\t\t9. 退出系统&quot;</span>);            System.out.print(<span class="hljs-string">&quot;请输入：&quot;</span>);            <span class="hljs-type">String</span> <span class="hljs-variable">inpString</span> <span class="hljs-operator">=</span> Utility.readKeyBoard(<span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);            System.out.println(<span class="hljs-string">&quot;--------------------------------------------&quot;</span>);            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">if</span> (inpString.equals(<span class="hljs-string">&quot;1&quot;</span>)) &#123;                    menuLogin_0_1();                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (inpString.equals(<span class="hljs-string">&quot;9&quot;</span>)) &#123;                    running0 = <span class="hljs-literal">false</span>;                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();                &#125;            &#125; <span class="hljs-keyword">catch</span> (RuntimeException | ClassNotFoundException e) &#123;                System.out.println(<span class="hljs-string">&quot;错误&quot;</span>);            &#125; <span class="hljs-keyword">catch</span> (IOException d) &#123;                System.out.println(<span class="hljs-string">&quot;链接失败！&quot;</span>);            &#125; <span class="hljs-keyword">finally</span> &#123;                System.out.println(<span class="hljs-string">&quot;--------------------------------------------&quot;</span>);            &#125;        &#125;        System.out.println(<span class="hljs-string">&quot;再见~&quot;</span>);    &#125;    <span class="hljs-comment">//一级菜单、登录</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">menuLogin_0_1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;        System.out.println(<span class="hljs-string">&quot;-----------------用户登录-------------------&quot;</span>);        System.out.print(<span class="hljs-string">&quot;请输入用户ID（4位）：&quot;</span>);        <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> Utility.readKeyBoard(<span class="hljs-number">4</span>, <span class="hljs-literal">false</span>);        System.out.print(<span class="hljs-string">&quot;请输入密码（6位）：&quot;</span>);        <span class="hljs-type">String</span> <span class="hljs-variable">pw</span> <span class="hljs-operator">=</span> Utility.readKeyBoard(<span class="hljs-number">6</span>, <span class="hljs-literal">false</span>);        System.out.println();        System.out.println(<span class="hljs-string">&quot;--------------------------------------------&quot;</span>);        user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(id, pw);        loggedUser = tryLogin_0_1_1(user);        <span class="hljs-keyword">if</span> (loggedUser == <span class="hljs-literal">null</span>) &#123;            System.out.println(<span class="hljs-string">&quot;登录失败&quot;</span>);            oos.close();            ois.close();            socket.close();        &#125; <span class="hljs-keyword">else</span> &#123;            System.out.println(<span class="hljs-string">&quot;欢迎回来，&quot;</span> + loggedUser.getName());            isLoggedIn_1();        &#125;    &#125;    <span class="hljs-keyword">private</span> UserData <span class="hljs-title function_">tryLogin_0_1_1</span><span class="hljs-params">(User user)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;        socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(InetAddress.getByName(serverIP), <span class="hljs-number">9000</span>);        oos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(socket.getOutputStream());        ois = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(socket.getInputStream());        oos.writeObject(user);        <span class="hljs-type">Message</span> <span class="hljs-variable">received</span> <span class="hljs-operator">=</span> (Message) ois.readObject();        <span class="hljs-type">String</span> <span class="hljs-variable">reply</span> <span class="hljs-operator">=</span> received.getMessageType();        <span class="hljs-keyword">if</span> (reply.equals(MessageType.LOGIN_WRONG_PW)) &#123;            System.out.println(<span class="hljs-string">&quot;密码错误&quot;</span>);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (reply.equals(MessageType.LOGIN_USER_NOT_EXIST)) &#123;            System.out.println(<span class="hljs-string">&quot;用户名不存在&quot;</span>);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (reply.equals(MessageType.LOGIN_SUCCESS)) &#123;            <span class="hljs-keyword">return</span> (UserData) received.getObject();        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (reply.equals(MessageType.LOGIN_FAILED)) &#123;            System.out.println(<span class="hljs-string">&quot;错误&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-comment">//二级菜单</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">isLoggedIn_1</span><span class="hljs-params">()</span> &#123;        ct = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientThread</span>(socket, oos, ois, <span class="hljs-built_in">this</span>);        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(ct).start();        running = <span class="hljs-literal">true</span>;        showBasicMenu_1_();        System.out.println(loggedUser.leftMessage);        cancelMenu = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">if</span> (loggedUser.leftMessage.length() != <span class="hljs-number">0</span>) &#123;            System.out.println(<span class="hljs-string">&quot;----------------以上是留言----------------&quot;</span>);        &#125;        <span class="hljs-keyword">while</span> (running) &#123;            showBasicMenu_1_();            System.out.print(<span class="hljs-string">&quot;请选择：&quot;</span>);            <span class="hljs-type">char</span> <span class="hljs-variable">inp</span> <span class="hljs-operator">=</span> Utility.readChar();            System.out.println(<span class="hljs-string">&quot;--------------------------------------------&quot;</span>);            <span class="hljs-keyword">switch</span> (inp) &#123;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;1&#x27;</span>:                    loggedGetList_1_1();                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;2&#x27;</span>:                    loggedChat_1_2();                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;3&#x27;</span>:                    loggedGroupChat_1_3();                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;4&#x27;</span>:                    loggedSendFile_1_4();                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;5&#x27;</span>:                    loggedChangeName_1_5();                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;6&#x27;</span>:                    loggedChangePw_1_6();                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;7&#x27;</span>:                    loggedChangeHide_1_7();                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;8&#x27;</span>:                    showOthersMenu_1_();                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;9&#x27;</span>:                    <span class="hljs-keyword">try</span> &#123;                        loggedLogout_1_9();                    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                        System.out.println(<span class="hljs-string">&quot;复位&quot;</span>);                    &#125;                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;M&#x27;</span>:                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;m&#x27;</span>:                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;L&#x27;</span>:                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;l&#x27;</span>:                    loggedShowLeftMessage_1_L();                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;H&#x27;</span>:                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;h&#x27;</span>:                    loggedShowChatMessage_1_H();                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;C&#x27;</span>:                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;c&#x27;</span>:                    loggedClearMessage_1_C();                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;D&#x27;</span>:                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;d&#x27;</span>:                    loggedFileDeal_1_D();                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;F&#x27;</span>:                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;f&#x27;</span>:                    loggedShowFilePath_1_F();                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;N&#x27;</span>:                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;n&#x27;</span>:                    loggedChangeFilePath_1_N();                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">default</span>:                    System.out.println(<span class="hljs-string">&quot;错误：请检查输入内容&quot;</span>);                    <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showBasicMenu_1_</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (cancelMenu) &#123;            cancelMenu = <span class="hljs-literal">false</span>;            <span class="hljs-keyword">return</span>;        &#125;        System.out.println(<span class="hljs-string">&quot;================&quot;</span> + loggedUser.getName() + <span class="hljs-string">&quot;（&quot;</span> + loggedUser.getID() + <span class="hljs-string">&quot;）================&quot;</span>);        System.out.println(<span class="hljs-string">&quot;\t\t\t1. 获取用户列表&quot;</span>);        System.out.println(<span class="hljs-string">&quot;\t\t\t2. 聊天&quot;</span>);        System.out.println(<span class="hljs-string">&quot;\t\t\t3. 群聊&quot;</span>);        System.out.println(<span class="hljs-string">&quot;\t\t\t4. 发送文件&quot;</span>);        System.out.println(<span class="hljs-string">&quot;\t\t\t5. 修改昵称&quot;</span>);        System.out.println(<span class="hljs-string">&quot;\t\t\t6. 修改密码&quot;</span>);        System.out.println(<span class="hljs-string">&quot;\t\t\t7. 切换隐身状态（目前：&quot;</span> + (loggedUser.isOnline() ? <span class="hljs-string">&quot;非隐身）&quot;</span> : <span class="hljs-string">&quot;隐身★~）&quot;</span>));        System.out.println(<span class="hljs-string">&quot;\t\t\t8. 其他&quot;</span>);        System.out.println(<span class="hljs-string">&quot;\t\t\t9. 退出&quot;</span>);        System.out.println(<span class="hljs-string">&quot;--------------------------------------------&quot;</span>);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showOthersMenu_1_</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;================&quot;</span> + loggedUser.getName() + <span class="hljs-string">&quot;（&quot;</span> + loggedUser.getID() + <span class="hljs-string">&quot;）================&quot;</span>);        System.out.println(<span class="hljs-string">&quot;\t\t\tC. 清空在线消息&quot;</span>);        System.out.println(<span class="hljs-string">&quot;\t\t\tD. 查看文件&quot;</span>);        System.out.println(<span class="hljs-string">&quot;\t\t\tH. 在线消息记录&quot;</span>);        System.out.println(<span class="hljs-string">&quot;\t\t\tL. 查看离线留言&quot;</span>);        System.out.println(<span class="hljs-string">&quot;\t\t\tF. 查看文件存放目录&quot;</span>);        System.out.println(<span class="hljs-string">&quot;\t\t\tN. 更改文件存放目录&quot;</span>);        System.out.println(<span class="hljs-string">&quot;\t\t\tM. 返回（显示一级菜单）&quot;</span>);        cancelMenu = <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loggedGetList_1_1</span><span class="hljs-params">()</span> &#123;        message = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-literal">null</span>, loggedUser.getID(), serverIP, MessageType.LOGGED_SHOW_LIST);        sendAndReceive();        <span class="hljs-keyword">if</span> (message == <span class="hljs-literal">null</span>) &#123;            System.out.println(<span class="hljs-string">&quot;获取列表失败&quot;</span>);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (message.getMessageType().equals(MessageType.REQUEST_ALLOWED)) &#123;            ct.messageReceived = <span class="hljs-literal">false</span>;            System.out.println(<span class="hljs-string">&quot;----------------成员列表如下----------------&quot;</span>);            System.out.println(message.getMessage());        &#125; <span class="hljs-keyword">else</span> &#123;            System.out.println(<span class="hljs-string">&quot;获取列表失败&quot;</span>);        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loggedGetActiveList_1_1A</span><span class="hljs-params">()</span> &#123;        message = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-literal">null</span>, loggedUser.getID(), serverIP, MessageType.LOGGED_SHOW_ONLINE_LIST);        sendAndReceive();        <span class="hljs-keyword">if</span> (message == <span class="hljs-literal">null</span>) &#123;            System.out.println(<span class="hljs-string">&quot;获取在线成员列表失败&quot;</span>);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (message.getMessageType().equals(MessageType.REQUEST_ALLOWED)) &#123;            ct.messageReceived = <span class="hljs-literal">false</span>;            System.out.println(<span class="hljs-string">&quot;--------------在线成员列表如下--------------&quot;</span>);            System.out.println(message.getMessage());        &#125; <span class="hljs-keyword">else</span> &#123;            System.out.println(<span class="hljs-string">&quot;获取在线成员列表失败&quot;</span>);        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loggedChat_1_2</span><span class="hljs-params">()</span> &#123;        loggedGetActiveList_1_1A();        message = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-literal">null</span>, loggedUser.getID(), serverIP, MessageType.CHAT);        System.out.print(<span class="hljs-string">&quot;请输入私聊对象：&quot;</span>);        <span class="hljs-type">String</span> <span class="hljs-variable">tarId</span> <span class="hljs-operator">=</span> Utility.readKeyBoard(<span class="hljs-number">10</span>, <span class="hljs-literal">true</span>);        <span class="hljs-keyword">if</span> (tarId == <span class="hljs-literal">null</span> || tarId.equals(<span class="hljs-string">&quot;&quot;</span>)) &#123;            System.out.println(<span class="hljs-string">&quot;取消&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tarId.equals(loggedUser.getID())) &#123;            System.out.println(<span class="hljs-string">&quot;不能私聊自己&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        System.out.print(<span class="hljs-string">&quot;发送内容：&quot;</span>);        <span class="hljs-type">String</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> Utility.readKeyBoard(<span class="hljs-number">100</span>, <span class="hljs-literal">true</span>);        <span class="hljs-keyword">if</span> (word == <span class="hljs-literal">null</span> || word.equals(<span class="hljs-string">&quot;&quot;</span>)) &#123;            System.out.println(<span class="hljs-string">&quot;取消&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        User[] temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>[<span class="hljs-number">2</span>];        temp[<span class="hljs-number">0</span>] = user;        temp[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(tarId, <span class="hljs-literal">null</span>);        message.setObject(temp);        message.setMessage(word);        showBasicMenu_1_();        sendAndReceive();        <span class="hljs-keyword">if</span> (message == <span class="hljs-literal">null</span>) &#123;            System.out.println(<span class="hljs-string">&quot;\r访问失败&quot;</span>);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (message.getMessageType().equals(MessageType.REQUEST_ALLOWED)) &#123;            ct.sb.append(<span class="hljs-string">&quot;\n&quot;</span>).append(message.getTime()).append(<span class="hljs-string">&quot; 你对 &quot;</span>).append(((User) message.getObject()).getId()).append(<span class="hljs-string">&quot; 说：&quot;</span>).append(word);            System.out.println(ct.sb);            System.out.println(<span class="hljs-string">&quot;\r发送成功&quot;</span>);            cancelMenu = <span class="hljs-literal">true</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (message.getMessageType().equals(MessageType.REQUEST_REJECTED)) &#123;            System.out.println(<span class="hljs-string">&quot;\r请求被拒绝&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            System.out.println(<span class="hljs-string">&quot;\r发送失败&quot;</span>);        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loggedGroupChat_1_3</span><span class="hljs-params">()</span> &#123;        message = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-literal">null</span>, loggedUser.getID(), serverIP, MessageType.GROUP_CHAT);        System.out.print(<span class="hljs-string">&quot;发送内容：&quot;</span>);        <span class="hljs-type">String</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> Utility.readKeyBoard(<span class="hljs-number">100</span>, <span class="hljs-literal">true</span>);        <span class="hljs-keyword">if</span> (word == <span class="hljs-literal">null</span> || word.equals(<span class="hljs-string">&quot;&quot;</span>)) &#123;            System.out.println(<span class="hljs-string">&quot;取消&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        message.setObject(user);        message.setMessage(word);        showBasicMenu_1_();        sendAndReceive();        <span class="hljs-keyword">if</span> (message == <span class="hljs-literal">null</span>) &#123;            System.out.println(<span class="hljs-string">&quot;\r访问失败&quot;</span>);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (message.getMessageType().equals(MessageType.REQUEST_ALLOWED)) &#123;            System.out.println(<span class="hljs-string">&quot;\r发送成功&quot;</span>);            cancelMenu = <span class="hljs-literal">true</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (message.getMessageType().equals(MessageType.REQUEST_REJECTED)) &#123;            System.out.println(<span class="hljs-string">&quot;\r请求被拒绝&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            System.out.println(<span class="hljs-string">&quot;\r发送失败&quot;</span>);        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loggedSendFile_1_4</span><span class="hljs-params">()</span> &#123;        loggedGetActiveList_1_1A();        message = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-literal">null</span>, loggedUser.getID(), serverIP, MessageType.FILE);        System.out.println(<span class="hljs-string">&quot;请输入要发送的用户：&quot;</span>);        <span class="hljs-type">String</span> <span class="hljs-variable">tar</span> <span class="hljs-operator">=</span> Utility.readKeyBoard(<span class="hljs-number">4</span>, <span class="hljs-literal">true</span>);        message.setReceiver(tar);        <span class="hljs-keyword">if</span> (tar == <span class="hljs-literal">null</span> || tar.equals(<span class="hljs-string">&quot;&quot;</span>)) &#123;            System.out.println(<span class="hljs-string">&quot;取消&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tar.equals(loggedUser.getID())) &#123;            System.out.println(<span class="hljs-string">&quot;错误：不能发给自己&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tar.length() &lt; <span class="hljs-number">4</span>) &#123;            System.out.println(<span class="hljs-string">&quot;错误：用户 ID 是 4 位字符&quot;</span>);        &#125;        System.out.print(<span class="hljs-string">&quot;请输入文件完整路径：&quot;</span>);        <span class="hljs-type">String</span> <span class="hljs-variable">file_Str</span> <span class="hljs-operator">=</span> Utility.readKeyBoard(<span class="hljs-number">500</span>, <span class="hljs-literal">true</span>);        <span class="hljs-keyword">if</span> (file_Str == <span class="hljs-literal">null</span> || file_Str.equals(<span class="hljs-string">&quot;&quot;</span>)) &#123;            System.out.println(<span class="hljs-string">&quot;取消&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        cancelMenu = <span class="hljs-literal">true</span>;        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-type">byte</span>[] data = <span class="hljs-literal">null</span>;        <span class="hljs-keyword">try</span> &#123;            file = <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(file_Str);            <span class="hljs-keyword">if</span> (!file.isFile()) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();            &#125;            data = Utility.loadFile(file);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            showBasicMenu_1_();            System.out.println(<span class="hljs-string">&quot;错误：文件路径错误&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        message.setSender(loggedUser.getPw());        message.setObject(data);        message.setMessage(file.getName());        sendAndReceive();        <span class="hljs-keyword">if</span> (message == <span class="hljs-literal">null</span>) &#123;            System.out.println(<span class="hljs-string">&quot;发送失败&quot;</span>);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (message.getMessageType().equals(MessageType.REQUEST_ALLOWED)) &#123;            ct.messageReceived = <span class="hljs-literal">false</span>;            System.out.println(<span class="hljs-string">&quot;文件发送成功&quot;</span>);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (message.getMessageType().equals(MessageType.REQUEST_REJECTED)) &#123;            System.out.println(<span class="hljs-string">&quot;请求被拒绝&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            System.out.println(<span class="hljs-string">&quot;请求失败&quot;</span>);        &#125;        cancelMenu = <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loggedChangeName_1_5</span><span class="hljs-params">()</span> &#123;        message = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-literal">null</span>, loggedUser.getID(), serverIP, MessageType.LOGGED_CHANGE_NAME);        System.out.print(<span class="hljs-string">&quot;请输入一个新名字（不超过10位）：&quot;</span>);        <span class="hljs-type">String</span> <span class="hljs-variable">newName</span> <span class="hljs-operator">=</span> Utility.readKeyBoard(<span class="hljs-number">10</span>, <span class="hljs-literal">true</span>);        <span class="hljs-keyword">if</span> (newName == <span class="hljs-literal">null</span> || newName.equals(<span class="hljs-string">&quot;&quot;</span>)) &#123;            System.out.println(<span class="hljs-string">&quot;取消&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        message.setMessage(newName);        message.setObject(loggedUser);        loggedUser = <span class="hljs-literal">null</span>;        sendAndReceive();        <span class="hljs-keyword">if</span> (message == <span class="hljs-literal">null</span>) &#123;            System.out.println(<span class="hljs-string">&quot;访问失败&quot;</span>);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (message.getMessageType().equals(MessageType.REQUEST_ALLOWED)) &#123;            ct.messageReceived = <span class="hljs-literal">false</span>;            loggedUser = (UserData) message.getObject();            System.out.println(<span class="hljs-string">&quot;修改完毕：（&quot;</span> + loggedUser.getID() + <span class="hljs-string">&quot;）&quot;</span> + loggedUser.getName());        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (message.getMessageType().equals(MessageType.REQUEST_REJECTED)) &#123;            System.out.println(<span class="hljs-string">&quot;请求被拒绝&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            System.out.println(<span class="hljs-string">&quot;请求失败&quot;</span>);        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loggedChangePw_1_6</span><span class="hljs-params">()</span> &#123;        message = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-literal">null</span>, loggedUser.getID(), serverIP, MessageType.LOGGED_CHANGE_PW);        System.out.print(<span class="hljs-string">&quot;请输入原密码：&quot;</span>);        <span class="hljs-type">String</span> <span class="hljs-variable">pw</span> <span class="hljs-operator">=</span> Utility.readKeyBoard(<span class="hljs-number">20</span>, <span class="hljs-literal">true</span>);        <span class="hljs-keyword">if</span> (pw == <span class="hljs-literal">null</span> || pw.equals(<span class="hljs-string">&quot;&quot;</span>)) &#123;            System.out.println(<span class="hljs-string">&quot;取消&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!pw.equals(loggedUser.getPw())) &#123;            System.out.println(<span class="hljs-string">&quot;错误：密码错误&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        System.out.print(<span class="hljs-string">&quot;请输入新密码（6位）：&quot;</span>);        pw = Utility.readKeyBoard(<span class="hljs-number">6</span>, <span class="hljs-literal">true</span>);        <span class="hljs-keyword">if</span> (pw == <span class="hljs-literal">null</span> || pw.equals(<span class="hljs-string">&quot;&quot;</span>)) &#123;            System.out.println(<span class="hljs-string">&quot;取消&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pw.length() != <span class="hljs-number">6</span>) &#123;            System.out.println(<span class="hljs-string">&quot;错误：密码长度应该是 6 位&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        message.setMessage(pw);        message.setObject(loggedUser);        sendAndReceive();        <span class="hljs-keyword">if</span> (message == <span class="hljs-literal">null</span>) &#123;            System.out.println(<span class="hljs-string">&quot;访问失败&quot;</span>);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (message.getMessageType().equals(MessageType.REQUEST_ALLOWED)) &#123;            ct.messageReceived = <span class="hljs-literal">false</span>;            System.out.println(<span class="hljs-string">&quot;密码修改成功&quot;</span>);            loggedUser = (UserData) message.getObject();        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (message.getMessageType().equals(MessageType.REQUEST_REJECTED)) &#123;            System.out.println(<span class="hljs-string">&quot;请求被拒绝&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            System.out.println(<span class="hljs-string">&quot;请求失败&quot;</span>);        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loggedChangeHide_1_7</span><span class="hljs-params">()</span> &#123;        message = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-literal">null</span>, loggedUser.getID(), serverIP, MessageType.LOGGED_CHANGE_HIDE);        message.setObject(loggedUser);<span class="hljs-comment">//        loggedUser = null;</span>        sendAndReceive();        <span class="hljs-keyword">if</span> (message == <span class="hljs-literal">null</span>) &#123;            System.out.println(<span class="hljs-string">&quot;访问失败&quot;</span>);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (message.getMessageType().equals(MessageType.REQUEST_ALLOWED)) &#123;            loggedUser = (UserData) message.getObject();        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (message.getMessageType().equals(MessageType.REQUEST_REJECTED)) &#123;            System.out.println(<span class="hljs-string">&quot;请求被拒绝&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            System.out.println(<span class="hljs-string">&quot;请求失败&quot;</span>);        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loggedLogout_1_9</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;        System.out.println(<span class="hljs-string">&quot;确认退出吗？（Y/N）&quot;</span>);        <span class="hljs-keyword">if</span> (Utility.readConfirmSelection() == <span class="hljs-string">&#x27;Y&#x27;</span>) &#123;            message = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-literal">null</span>, loggedUser.getID(), serverIP, MessageType.LOGGED_LOGOUT);            message.setObject(loggedUser);            oos.writeObject(message);            loggedUser = <span class="hljs-literal">null</span>;            socket.close();            ct.running = <span class="hljs-literal">false</span>;            running = <span class="hljs-literal">false</span>;        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loggedShowChatMessage_1_H</span><span class="hljs-params">()</span> &#123;        System.out.println(ct.sb);        cancelMenu = <span class="hljs-literal">true</span>;        System.out.println(<span class="hljs-string">&quot;----------------没有更多了----------------&quot;</span>);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loggedShowLeftMessage_1_L</span><span class="hljs-params">()</span> &#123;        System.out.println(loggedUser.leftMessage);        cancelMenu = <span class="hljs-literal">true</span>;        System.out.println(<span class="hljs-string">&quot;----------------没有更多了----------------&quot;</span>);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loggedClearMessage_1_C</span><span class="hljs-params">()</span> &#123;        ct.sb.delete(<span class="hljs-number">0</span>, ct.sb.length());        System.out.println(<span class="hljs-string">&quot;完成&quot;</span>);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loggedFileDeal_1_D</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">boolean</span> <span class="hljs-variable">fileMenuRunning</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">while</span> (fileMenuRunning) &#123;            showFileDealMenu_1_D_();            System.out.print(<span class="hljs-string">&quot;请选择：&quot;</span>);            <span class="hljs-type">char</span> <span class="hljs-variable">inp</span> <span class="hljs-operator">=</span> Utility.readChar();            System.out.println(<span class="hljs-string">&quot;--------------------------------------------&quot;</span>);            <span class="hljs-keyword">switch</span> (inp) &#123;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;1&#x27;</span>:                    fileShowAllName_1_D_1();                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;2&#x27;</span>:                    fileShowNewestName_1_D_2();                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;3&#x27;</span>:                    fileDeleteNewestOne_1_D_3();                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;4&#x27;</span>:                    fileDownloadNewestOne_1_D_4();                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;5&#x27;</span>:                    fileDownloadAll_1_D_5();                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;6&#x27;</span>:                    loggedChangeFilePath_1_N();                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;9&#x27;</span>:                    fileMenuRunning = <span class="hljs-literal">false</span>;                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">default</span>:                    System.out.println(<span class="hljs-string">&quot;错误：请检查输入内容&quot;</span>);                    <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showFileDealMenu_1_D_</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (cancelMenu) &#123;            cancelMenu = <span class="hljs-literal">false</span>;            <span class="hljs-keyword">return</span>;        &#125;        System.out.println(<span class="hljs-string">&quot;---------------文件管理----------------&quot;</span>);        ct.showFilesRemain();        loggedShowFilePath_1_F();        System.out.println(<span class="hljs-string">&quot;-------------------------------------&quot;</span>);        System.out.println(<span class="hljs-string">&quot;\t\t\t1. 查看所有文件&quot;</span>);        System.out.println(<span class="hljs-string">&quot;\t\t\t2. 查看最新文件&quot;</span>);        System.out.println(<span class="hljs-string">&quot;\t\t\t3. 删除最新的文件&quot;</span>);        System.out.println(<span class="hljs-string">&quot;\t\t\t4. 下载最新的文件&quot;</span>);        System.out.println(<span class="hljs-string">&quot;\t\t\t5. 全部下载&quot;</span>);        System.out.println(<span class="hljs-string">&quot;\t\t\t6. 修改存放路径&quot;</span>);        System.out.println(<span class="hljs-string">&quot;\t\t\t9. 返回上级目录&quot;</span>);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fileShowAllName_1_D_1</span><span class="hljs-params">()</span> &#123;        showFileDealMenu_1_D_();        cancelMenu = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">if</span> (ct.filesToDeal.length == <span class="hljs-number">0</span>) &#123;            System.out.println(<span class="hljs-string">&quot;没有未处理的文件了★~~&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">do</span> &#123;            System.out.println((n + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;. &quot;</span> + ct.fileName[n]);        &#125; <span class="hljs-keyword">while</span> (++n &lt; ct.fileName.length);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fileShowNewestName_1_D_2</span><span class="hljs-params">()</span> &#123;        showFileDealMenu_1_D_();        cancelMenu = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">if</span> (ct.filesToDeal.length == <span class="hljs-number">0</span>) &#123;            System.out.println(<span class="hljs-string">&quot;没有未处理的文件了★~~&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            System.out.println(ct.fileName.length + <span class="hljs-string">&quot;. &quot;</span> + ct.fileName[ct.fileName.length - <span class="hljs-number">1</span>]);        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fileDeleteNewestOne_1_D_3</span><span class="hljs-params">()</span> &#123;        showFileDealMenu_1_D_();        cancelMenu = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">if</span> (ct.filesToDeal.length == <span class="hljs-number">0</span>) &#123;            System.out.println(<span class="hljs-string">&quot;没有未处理的文件了★~~&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        System.out.println(ct.fileName.length + <span class="hljs-string">&quot;. &quot;</span> + ct.fileName[ct.fileName.length - <span class="hljs-number">1</span>]);        System.out.println(<span class="hljs-string">&quot;确定删除吗？&quot;</span>);        System.out.println(<span class="hljs-string">&quot;确认退出吗？（Y/N）&quot;</span>);        <span class="hljs-keyword">if</span> (Utility.readConfirmSelection() == <span class="hljs-string">&#x27;N&#x27;</span>) &#123;            System.out.println(<span class="hljs-string">&quot;取消&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (ct.deleteNewestFile()) &#123;            System.out.println(<span class="hljs-string">&quot;删除成功&quot;</span>);        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fileDownloadNewestOne_1_D_4</span><span class="hljs-params">()</span> &#123;        showFileDealMenu_1_D_();        cancelMenu = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">if</span> (ct.filesToDeal.length == <span class="hljs-number">0</span>) &#123;            System.out.println(<span class="hljs-string">&quot;没有未处理的文件了★~~&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> ct.fileName[ct.fileName.length - <span class="hljs-number">1</span>];        <span class="hljs-keyword">if</span> (ct.downloadNewestFile()) &#123;            System.out.println(str + <span class="hljs-string">&quot; 下载成功&quot;</span>);        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fileDownloadAll_1_D_5</span><span class="hljs-params">()</span> &#123;        showFileDealMenu_1_D_();        cancelMenu = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">if</span> (ct.filesToDeal.length == <span class="hljs-number">0</span>) &#123;            System.out.println(<span class="hljs-string">&quot;没有未处理的文件了★~~&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">do</span> &#123;            fileDownloadNewestOne_1_D_4();        &#125; <span class="hljs-keyword">while</span> (ct.filesToDeal.length &gt; <span class="hljs-number">0</span>);        cancelMenu = <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loggedShowFilePath_1_F</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;文件保存目录如下：&quot;</span> + filePath);        cancelMenu = <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loggedChangeFilePath_1_N</span><span class="hljs-params">()</span> &#123;        loggedShowFilePath_1_F();        System.out.print(<span class="hljs-string">&quot;请输入一个新的路径&quot;</span>);        <span class="hljs-type">String</span> <span class="hljs-variable">newPath</span> <span class="hljs-operator">=</span> Utility.readKeyBoard(<span class="hljs-number">500</span>, <span class="hljs-literal">true</span>);        <span class="hljs-keyword">if</span> (newPath == <span class="hljs-literal">null</span> || newPath.equals(<span class="hljs-string">&quot;&quot;</span>)) &#123;            System.out.println(<span class="hljs-string">&quot;取消&quot;</span>);            cancelMenu = <span class="hljs-literal">false</span>;            <span class="hljs-keyword">return</span>;        &#125;        File path;        <span class="hljs-keyword">try</span> &#123;            path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(newPath);            path.mkdir();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            System.out.println(<span class="hljs-string">&quot;错误：路径输入错误&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        filePath = path;        cancelMenu = <span class="hljs-literal">false</span>;        showBasicMenu_1_();        System.out.println(<span class="hljs-string">&quot;成功&quot;</span>);        loggedShowFilePath_1_F();    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendAndReceive</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()).getTime();        ct.messageReceived = <span class="hljs-literal">false</span>;        <span class="hljs-keyword">try</span> &#123;            oos.writeObject(message);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            System.out.println(<span class="hljs-string">&quot;异常&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">do</span> &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().getTime() - now &gt;= <span class="hljs-number">5000</span>) &#123;                System.out.println(<span class="hljs-string">&quot;超时&quot;</span>);                message = <span class="hljs-literal">null</span>;                <span class="hljs-keyword">break</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ct.messageReceived) &#123;                message = ct.message;                <span class="hljs-keyword">break</span>;            &#125;        &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);        ct.messageReceived = <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getDate</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> getDate(LocalDateTime.now());    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getDate</span><span class="hljs-params">(LocalDateTime ldt)</span> &#123;        <span class="hljs-keyword">return</span> ldt.getYear() + <span class="hljs-string">&quot;.&quot;</span> + ldt.getMonthValue() + <span class="hljs-string">&quot;.&quot;</span> + ldt.getDayOfMonth();    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getTime</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> getTime(LocalDateTime.now());    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getTime</span><span class="hljs-params">(LocalDateTime ldt)</span> &#123;        <span class="hljs-keyword">return</span> ldt.getHour() + <span class="hljs-string">&quot;:&quot;</span> + ldt.getMinute() + <span class="hljs-string">&quot;:&quot;</span> + ldt.getSecond();    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getDateTime</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">ldt</span> <span class="hljs-operator">=</span> LocalDateTime.now();        <span class="hljs-keyword">return</span> getDate(ldt) + <span class="hljs-string">&quot;  &quot;</span> + getTime();    &#125;<span class="hljs-comment">//    private Message packageMessage(String str) &#123;</span><span class="hljs-comment">//        return new Message(str, thisIP, serverIP, &quot;0&quot;);</span><span class="hljs-comment">//    &#125;</span>&#125;</code></pre></div></li><li><p><strong>ClientThread.java</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.transmission.common;<span class="hljs-keyword">import</span> java.io.File;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.ObjectInputStream;<span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<span class="hljs-keyword">import</span> java.net.Socket;<span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;    <span class="hljs-keyword">private</span> Socket socket;    <span class="hljs-keyword">private</span> ObjectOutputStream oos;    <span class="hljs-keyword">private</span> ObjectInputStream ois;    <span class="hljs-keyword">public</span> <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">messageReceived</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">running</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();    <span class="hljs-keyword">private</span> ClientInterface ci;    <span class="hljs-comment">//    public byte[] fileToDeal;</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">receivedFileDealt</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[][] filesToDeal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">0</span>][];<span class="hljs-comment">//这里改为创建一个本地缓存，在内存里存放路径更好</span>    <span class="hljs-comment">//但我懒得改了</span>    <span class="hljs-keyword">public</span> String[] fileName = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">0</span>];    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">while</span> (running) &#123;                message = (Message) ois.readObject();                <span class="hljs-keyword">if</span> (message.getMessageType().equals(MessageType.CHAT) || message.getMessageType().equals(MessageType.GROUP_CHAT)) &#123;                    chatReceived();                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (message.getMessageType().equals(MessageType.FILE)) &#123;                    filesReceived();                &#125;                messageReceived = <span class="hljs-literal">true</span>;            &#125;        &#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;            ci.running = <span class="hljs-literal">false</span>;            System.out.print(<span class="hljs-string">&quot;\r已离线：&quot;</span>);        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ClientThread</span><span class="hljs-params">(Socket socket, ObjectOutputStream oos, ObjectInputStream ois, ClientInterface ci)</span> &#123;        <span class="hljs-built_in">this</span>.socket = socket;        <span class="hljs-built_in">this</span>.oos = oos;        <span class="hljs-built_in">this</span>.ois = ois;        <span class="hljs-built_in">this</span>.ci = ci;    &#125;    <span class="hljs-keyword">public</span> Socket <span class="hljs-title function_">getSocket</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> socket;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">chatReceived</span><span class="hljs-params">()</span> &#123;        sb.append(<span class="hljs-string">&quot;\n&quot;</span>);        sb.append(message.getMessage());        System.out.println(<span class="hljs-string">&quot;\r&quot;</span>);        ci.showBasicMenu_1_();        System.out.print(<span class="hljs-string">&quot;\r          &quot;</span>);        System.out.print(<span class="hljs-string">&quot;\r&quot;</span> + sb);        System.out.print(<span class="hljs-string">&quot;\n请选择：&quot;</span>);        message.setMessageType(MessageType.REQUEST_ALLOWED);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">filesReceived</span><span class="hljs-params">()</span> &#123;        filesToDeal = Arrays.copyOf(filesToDeal, filesToDeal.length + <span class="hljs-number">1</span>);        filesToDeal[filesToDeal.length - <span class="hljs-number">1</span>] = (<span class="hljs-type">byte</span>[]) message.getObject();        fileName = Arrays.copyOf(fileName, fileName.length + <span class="hljs-number">1</span>);        fileName[fileName.length - <span class="hljs-number">1</span>] = message.getMessage();        receivedFileDealt = <span class="hljs-literal">false</span>;        showFilesRemain();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showFilesRemain</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;\r★您有 &quot;</span> + filesToDeal.length + <span class="hljs-string">&quot; 个文件等待处理★&quot;</span>);<span class="hljs-comment">//        System.out.println(&quot;\r★按 D 键处理★&quot;);</span>        <span class="hljs-keyword">if</span> (filesToDeal.length == <span class="hljs-number">0</span>)&#123;            receivedFileDealt = <span class="hljs-literal">true</span>;        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">deleteNewestFile</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">try</span> &#123;            filesToDeal = Arrays.copyOf(filesToDeal, filesToDeal.length - <span class="hljs-number">1</span>);            fileName = Arrays.copyOf(fileName, fileName.length - <span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span> (fileName.length != filesToDeal.length)&#123;                fileName = Arrays.copyOf(fileName, filesToDeal.length - <span class="hljs-number">1</span>);                System.out.println(<span class="hljs-string">&quot;错误：文件或文件名丢失&quot;</span>);                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125; <span class="hljs-keyword">finally</span> &#123;            showFilesRemain();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">downloadNewestFile</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">File</span> <span class="hljs-variable">savePath</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(ci.filePath, fileName[fileName.length - <span class="hljs-number">1</span>]);        <span class="hljs-keyword">if</span> (Utility.saveFile(filesToDeal[filesToDeal.length -<span class="hljs-number">1</span>], savePath))&#123;            <span class="hljs-keyword">return</span> deleteNewestFile();        &#125; <span class="hljs-keyword">else</span> &#123;            System.out.println(<span class="hljs-string">&quot;错误：文件存储失败&quot;</span>);            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    &#125;&#125;</code></pre></div></li><li><p><strong>ClientThreadCollection.java</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.transmission.common;<span class="hljs-keyword">import</span> java.util.HashMap;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientThreadCollection</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> HashMap&lt;String, ClientThread&gt; threads = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSocket</span><span class="hljs-params">(String ip, ClientThread ct)</span> &#123;        threads.put(ip, ct);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ClientThread <span class="hljs-title function_">get</span><span class="hljs-params">(String ip)</span> &#123;        <span class="hljs-keyword">return</span> threads.get(ip);    &#125;&#125;</code></pre></div></li><li><p><strong>Utility.java（工具类，不是我写的）</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.transmission.common;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 韩顺平</span><span class="hljs-comment"> * 工具类的作用:</span><span class="hljs-comment"> * 处理各种情况的用户输入，并且能够按照程序员的需求，得到用户的控制台输入。</span><span class="hljs-comment"> */</span><span class="hljs-keyword">import</span> javax.imageio.IIOException;<span class="hljs-keyword">import</span> java.io.*;<span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-comment">/**</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Utility</span> &#123;    <span class="hljs-comment">//静态属性。。。</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 功能：读取键盘输入的一个菜单选项，值：1——5的范围</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 1——5</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">char</span> <span class="hljs-title function_">readMenuSelection</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">char</span> c;        <span class="hljs-keyword">for</span> (; ; ) &#123;            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> readKeyBoard(<span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);<span class="hljs-comment">//包含一个字符的字符串</span>            c = str.charAt(<span class="hljs-number">0</span>);<span class="hljs-comment">//将字符串转换成字符char类型</span>            <span class="hljs-keyword">if</span> (c != <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; c != <span class="hljs-string">&#x27;2&#x27;</span> &amp;&amp;                    c != <span class="hljs-string">&#x27;3&#x27;</span> &amp;&amp; c != <span class="hljs-string">&#x27;4&#x27;</span> &amp;&amp; c != <span class="hljs-string">&#x27;5&#x27;</span>) &#123;                System.out.print(<span class="hljs-string">&quot;选择错误，请重新输入：&quot;</span>);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">return</span> c;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 功能：读取键盘输入的一个字符</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 一个字符</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">char</span> <span class="hljs-title function_">readChar</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> readKeyBoard(<span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);<span class="hljs-comment">//就是一个字符</span>        <span class="hljs-keyword">return</span> str.charAt(<span class="hljs-number">0</span>);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 功能：读取键盘输入的一个字符，如果直接按回车，则返回指定的默认值；否则返回输入的那个字符</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> defaultValue 指定的默认值</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 默认值或输入的字符</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">char</span> <span class="hljs-title function_">readChar</span><span class="hljs-params">(<span class="hljs-type">char</span> defaultValue)</span> &#123;        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> readKeyBoard(<span class="hljs-number">1</span>, <span class="hljs-literal">true</span>);<span class="hljs-comment">//要么是空字符串，要么是一个字符</span>        <span class="hljs-keyword">return</span> (str.length() == <span class="hljs-number">0</span>) ? defaultValue : str.charAt(<span class="hljs-number">0</span>);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 功能：读取键盘输入的整型，长度小于2位</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 整数</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">readInt</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">int</span> n;        <span class="hljs-keyword">for</span> (; ; ) &#123;            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> readKeyBoard(<span class="hljs-number">10</span>, <span class="hljs-literal">false</span>);<span class="hljs-comment">//一个整数，长度&lt;=10位</span>            <span class="hljs-keyword">try</span> &#123;                n = Integer.parseInt(str);<span class="hljs-comment">//将字符串转换成整数</span>                <span class="hljs-keyword">break</span>;            &#125; <span class="hljs-keyword">catch</span> (NumberFormatException e) &#123;                System.out.print(<span class="hljs-string">&quot;数字输入错误，请重新输入：&quot;</span>);            &#125;        &#125;        <span class="hljs-keyword">return</span> n;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 功能：读取键盘输入的 整数或默认值，如果直接回车，则返回默认值，否则返回输入的整数</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> defaultValue 指定的默认值</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 整数或默认值</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">readInt</span><span class="hljs-params">(<span class="hljs-type">int</span> defaultValue)</span> &#123;        <span class="hljs-type">int</span> n;        <span class="hljs-keyword">for</span> (; ; ) &#123;            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> readKeyBoard(<span class="hljs-number">10</span>, <span class="hljs-literal">true</span>);            <span class="hljs-keyword">if</span> (str.equals(<span class="hljs-string">&quot;&quot;</span>)) &#123;                <span class="hljs-keyword">return</span> defaultValue;            &#125;            <span class="hljs-comment">//异常处理...</span>            <span class="hljs-keyword">try</span> &#123;                n = Integer.parseInt(str);                <span class="hljs-keyword">break</span>;            &#125; <span class="hljs-keyword">catch</span> (NumberFormatException e) &#123;                System.out.print(<span class="hljs-string">&quot;数字输入错误，请重新输入：&quot;</span>);            &#125;        &#125;        <span class="hljs-keyword">return</span> n;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 功能：读取键盘输入的指定长度的字符串</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> limit 限制的长度</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 指定长度的字符串</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">readString</span><span class="hljs-params">(<span class="hljs-type">int</span> limit)</span> &#123;        <span class="hljs-keyword">return</span> readKeyBoard(limit, <span class="hljs-literal">false</span>);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 功能：读取键盘输入的指定长度的字符串或默认值，如果直接回车，返回默认值，否则返回字符串</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> limit        限制的长度</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> defaultValue 指定的默认值</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 指定长度的字符串</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">readString</span><span class="hljs-params">(<span class="hljs-type">int</span> limit, String defaultValue)</span> &#123;        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> readKeyBoard(limit, <span class="hljs-literal">true</span>);        <span class="hljs-keyword">return</span> str.equals(<span class="hljs-string">&quot;&quot;</span>) ? defaultValue : str;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 功能：读取键盘输入的确认选项，Y或N</span><span class="hljs-comment">     * 将小的功能，封装到一个方法中.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Y或N</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">char</span> <span class="hljs-title function_">readConfirmSelection</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">//        System.out.println(&quot;请输入你的选择(Y/N): 请小心选择&quot;);</span>        <span class="hljs-type">char</span> c;        <span class="hljs-keyword">for</span> (; ; ) &#123;<span class="hljs-comment">//无限循环</span>            <span class="hljs-comment">//在这里，将接受到字符，转成了大写字母</span>            <span class="hljs-comment">//y =&gt; Y n=&gt;N</span>            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> readKeyBoard(<span class="hljs-number">1</span>, <span class="hljs-literal">false</span>).toUpperCase();            c = str.charAt(<span class="hljs-number">0</span>);            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;Y&#x27;</span> || c == <span class="hljs-string">&#x27;N&#x27;</span>) &#123;                <span class="hljs-keyword">break</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                System.out.print(<span class="hljs-string">&quot;请重新输入（输入 Y/N）：&quot;</span>);            &#125;        &#125;        <span class="hljs-keyword">return</span> c;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 功能： 读取一个字符串</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> limit       读取的长度</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> blankReturn 如果为true ,表示 可以读空字符串。</span><span class="hljs-comment">     *                    如果为false表示 不能读空字符串。</span><span class="hljs-comment">     *                    &lt;p&gt;</span><span class="hljs-comment">     *                    如果输入为空，或者输入大于limit的长度，就会提示重新输入。</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">readKeyBoard</span><span class="hljs-params">(<span class="hljs-type">int</span> limit, <span class="hljs-type">boolean</span> blankReturn)</span> &#123;        <span class="hljs-comment">//定义了字符串</span>        <span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;        <span class="hljs-comment">//scanner.hasNextLine() 判断有没有下一行</span>        <span class="hljs-keyword">while</span> (scanner.hasNextLine()) &#123;            line = scanner.nextLine();<span class="hljs-comment">//读取这一行</span>            <span class="hljs-comment">//如果line.length=0, 即用户没有输入任何内容，直接回车</span>            <span class="hljs-keyword">if</span> (line.length() == <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">if</span> (blankReturn) <span class="hljs-keyword">return</span> line;<span class="hljs-comment">//如果blankReturn=true,可以返回空串</span>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//如果blankReturn=false,不接受空串，必须输入内容</span>            &#125;            <span class="hljs-comment">//如果用户输入的内容大于了 limit，就提示重写输入</span>            <span class="hljs-comment">//0 &lt; 如果用户如的内容  &lt;= limit ,我就接受</span>            <span class="hljs-keyword">if</span> (line.length() &lt; <span class="hljs-number">1</span> || line.length() &gt; limit) &#123;                System.out.print(<span class="hljs-string">&quot;输入长度（不能大于&quot;</span> + limit + <span class="hljs-string">&quot;）错误，请重新输入：&quot;</span>);                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">return</span> line;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] receiveFile(InputStream is) <span class="hljs-keyword">throws</span> IOException &#123;        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];        <span class="hljs-keyword">while</span> ((len = is.read(bytes, <span class="hljs-number">0</span>, bytes.length)) != -<span class="hljs-number">1</span>) &#123;            bis.write(bytes, <span class="hljs-number">0</span>, len);        &#125;        <span class="hljs-keyword">return</span> bis.toByteArray();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] loadFile(File path) <span class="hljs-keyword">throws</span> IOException &#123;        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(path);        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];        <span class="hljs-keyword">while</span> ((len = is.read(bytes, <span class="hljs-number">0</span>, bytes.length)) != -<span class="hljs-number">1</span>) &#123;            bis.write(bytes, <span class="hljs-number">0</span>, len);        &#125;        bytes = bis.toByteArray();        bis.close();        <span class="hljs-keyword">return</span> bytes;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">saveFile</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] data, File path)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;        <span class="hljs-type">File</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> path;        <span class="hljs-keyword">while</span> (temp.isFile()) &#123;            temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path.getParent(), <span class="hljs-string">&quot;（拷贝&quot;</span> + n++ + <span class="hljs-string">&quot;）&quot;</span> + path.getName());        &#125;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(temp);            is.write(data);            is.close();        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;&#125;</code></pre></div></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>程序</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt;19 网络编程</title>
    <link href="/2022/01/12/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/19%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/01/12/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/19%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="网络编程">19 网络编程</h1><p>网络通信：两台设备之间通过网络实现数据传输。</p><p><code>java.net</code>包下提供了一系列类或接口，供程序员使用，完成网络通信</p><h2 id="网络的相关概念">19.1 网络的相关概念</h2><p><strong>网络</strong></p><p>网络：两台或多台设备通过一定物理设备连接起来构成了网络</p><p>根据网络覆盖范围的不同，对网络进行分类：</p><ul><li>局域网：覆盖范围最小，仅覆盖一个教室·机房</li><li>城域网：覆盖范围较大，可覆盖一个城市</li><li>广域网：覆盖范围最大，可以覆盖全国，甚至全球。万维网是广域网的代表</li></ul><p><strong>IP 地址</strong></p><p>IP 地址：用于唯一标识网络中的每台计算机 / 主机</p><p>查看 IP 地址：<code>ipconfig</code></p><p>IPv4 是 4 个字节（32位）表示。每个字节范围是 [0,255]</p><p>IP 地址的表示形式：点分十进制（xx.xx.xx.xx），每个十进制数范围是[0,255]</p><p>IP 地址的组成 = 网络地址 + 主机地址</p><ul><li>A类：0 + 7 位网络号 + 24 位主机号（0.0.0.0 ~ 127.255.255.255）</li><li>B类：1 + 0 + 14 位网络号 + 16 位主机号（128.0.0.0 ~191.255.255.255）</li><li>C类：1 + 1 + 0 + 21 位网络号 + 8 位主机号（192.0.0.0 ~223.255.255.255）</li><li>D类：1 + 1 + 1 + 0 + 28 位多播组号（224.0.0.0 ~239.255.255.255）</li><li>E类：1 + 1 + 1 + 1 + 0 + 27 位（留待后用）（240.0.0.0 ~247.255.255.255）</li></ul><p>IPv6 是互联网工程任务组设计的用于替代 IPv4 的下一代 IP协议。其地址数量可以为全世界每一粒沙子编上一个地址</p><p>IPv4最大的问题在于网络地址资源有限，严重制约了互联网的应用和发展。IPv6的使用，不仅能解决网络地址资源数量的问题，也解决了多种接入设备接入互联网的障碍</p><p>IPv6 使用 16 个字节（128 位）表示地址。</p><p>表示形式有：</p><ul><li><p>冒分十六进制表示法： （X:X:X:X:X:X:X:X）</p><p><code>:</code> 之间的部分，出现 0 开头的场合，那些 0可以省略</p></li><li><p>0 位压缩表示法：把连续的 <code>0</code> 压缩为<code>::</code>，这个压缩只能出现一次（X::X:X）</p></li><li><p>内嵌 IPv4 地址表示法：前 96位 用冒分十六进制表示，后面 32位 用IPv4 的点分十进制（X:X:X:X:X:XX:d.d.d.d）</p></li></ul><p><strong>子网掩码</strong></p><p>只用一个 IP地址，无法分辨网络部分与主机部分的分界线。因此，使用子网掩码来表示分界线。</p><p>这个场合，对应的网络部分的子网掩码的二进制数字设为 1</p><p><img src="/img/Java_InputImage/子网掩码图_19.1.png" /><em>(子网掩码图_19.1)</em></p><p>此外，还能把子网掩码与 IP 地址组合</p><ul><li>在 IP地址后加斜线及网络部分二进制数字数（IPV4）：192.168.15.1/16</li><li>IPv6：X:X:X:X:X:X:X:X/64</li></ul><p>通过更改子网掩码，可以细分网络为多个子网。</p><p><img src="/img/Java_InputImage/子网图_19.1.png" /><em>(子网图_19.1)</em></p><p><strong>私有地址</strong></p><p>私有地址：与 IP地址（全局地址）相比，在不同的网络中可以重复的地址。</p><p>私有地址是以下范围中的地址。这些地址不能作为全局地址使用：</p><ul><li>10.0.0.0 ~ 10.255.255.255</li><li>172.16.0.0 ~ 172.31.255.255</li><li>192.168.0.0 ~ 192.168.255.255</li></ul><p>将私有地址连接到全局地址的方法：</p><ul><li>NAT：一种私有地址与全局地址一一对应的机制</li><li>NAPT：一种用一个全局地址连接多个计算机的机制</li></ul><p><strong>域名</strong></p><p>示例：http://bbs.tianya.cn/post-house-252774-1.shtml</p><p>为了方便记忆，解决记忆 IP 的困难</p><p>IP 地址根据 HTTP 协议 映射成域名</p><p>通过 DNS（Domain Name System）服务将域名转化为 IP 地址</p><p><strong>端口号</strong></p><p>用于标识计算机上某个特定的网络程序</p><p>表示形式：以整数形式，范围 [0,65535]</p><p>0 ~ 1024 已经被占用，不要使用。比如 ssh 22、ftp 21、smtp 25、http80</p><p>常见的网络程序端口号：</p><ul><li>tomcat：8080</li><li>mysql：3306</li><li>oracle：1521</li><li>sqlserver：1433</li></ul><p><strong>网络通信协议</strong></p><p>协议（TCP/IP）</p><p>TCP/IP：传输控制协议 / 因特网互联协议（Transmission Control Protocol/ Internet Protocol），又叫 网络通讯协议。这个协议是 Internet最基本的协议、Internet 国际互联网络的基础。简单来讲，就是由 网络层的 IP协议 和传输层的 TCP 协议 组成</p><p><img src="/img/Java_InputImage/数据封装图_19.1.png" /></p><p><em>(数据封装图_19.1)</em></p><table><thead><tr class="header"><th>OSI 模型（理论）</th><th>TCP/IP 模型（实际使用）</th><th>TCP/IP 模型各层对应协议</th></tr></thead><tbody><tr class="odd"><td>应用层</td><td>应用层</td><td>HTTP、ftp、telent、DNS……</td></tr><tr class="even"><td>表示层</td><td>应用层</td><td>同上</td></tr><tr class="odd"><td>会话层</td><td>应用层</td><td>同上</td></tr><tr class="even"><td>传输层</td><td>传输层（TCP）</td><td>TCP、UDP……</td></tr><tr class="odd"><td>网络层</td><td>网络层（IP）</td><td>IP、ICMP、ARP……</td></tr><tr class="even"><td>数据链路层</td><td>物理 + 数据链路层</td><td>Link</td></tr><tr class="odd"><td>物理层</td><td>物理 + 数据链路层</td><td>同上</td></tr></tbody></table><h3 id="tcp-和-udp">19.1.1 TCP 和 UDP</h3><p><strong>TCP</strong></p><p>传输控制协议</p><ol type="1"><li>使用 TCP 协议前，须先建立 TCP 连接，形成传输数据通道。TCP通信是一对一通信</li><li>传输前，采用 “三次握手” 方式，是可靠的</li><li>TCP 协议进行通信的两个应用进程：客户端、服务端</li><li>在连接中可进行大数据量的传输。传输前，先确认要交流的数据量。那个数据量、数据窗口取较小方的数值。</li><li>发送方没有收到接收方的确认应答时，（在一定次数内）会再次发送数据包</li><li>传输完毕，需释放已建立的连接，效率低</li></ol><p><strong>UDP</strong></p><p>用户数据协议</p><ol type="1"><li>将 数据、源、目的封装成数据包，不需要建立连接。可以同时向多个接收方发送</li><li>每个数据包大小限制在 64K 以内，不适合传输大量数据</li><li>因无需连接，所以是不可靠的</li><li>接收方无需发送确认应答</li><li>发送数据结束时无需释放资源（因为不是面向连接的），速度快</li></ol><h2 id="inetaddress-类">19.2 <code>InetAddress</code> 类</h2><p><strong>相关方法</strong></p><ul><li><code>getLocalHost</code>：获取本机 <code>InetAddress</code>对象</li><li><code>getByName</code>：根据指定主机名 / 域名获取 IP 地址对象</li><li><code>getHostName</code>：获取 <code>InetAddress</code>对象的主机名</li><li><code>getHostAddress</code>：获取 <code>InetAddress</code>对象的地址</li></ul><h2 id="socket">19.3 Socket</h2><ol type="1"><li>套接字（Socket）开发网络应用程序被广泛采用，以至于成为了事实上的标准</li><li>通信的两端都要有 Socket，是两台机器间通信的端点</li><li>网络通信其实就是 Socket 间的通信</li><li>Socket 允许程序把网络连接当成一个流，数据在两个 Socket 间通过 IO传输</li><li>一般主动发起通信的应用程序属于客户端，等待通信请求的为服务端</li></ol><h3 id="tcp-网络通信编程">19.3.1 TCP 网络通信编程</h3><ol type="1"><li>基于客户端——服务端的网络通信</li><li>底层使用的是 TCP / IP 协议</li><li>应用场景距离：客户端发送数据，服务端接收并显示</li><li>基于 Socket 的 TCP 编程</li></ol><p><strong>下面，示范一个 服务端</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">server</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException&#123; <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">9000</span>);<span class="hljs-comment">//[1]</span> <span class="hljs-type">Socket</span> <span class="hljs-variable">clientSocket</span> <span class="hljs-operator">=</span> serverSocket.accept();   <span class="hljs-comment">//[2]</span> <span class="hljs-comment">//下面是输入流，不解释了</span> <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> clientSocket.getInputStream(); System.out.println(clientSocket.getInetAddress()); <span class="hljs-type">int</span> n; <span class="hljs-type">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>]; <span class="hljs-type">byte</span>[] B = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">0</span>]; <span class="hljs-keyword">while</span> ((n = inputStream.read(b, <span class="hljs-number">0</span>, <span class="hljs-number">1024</span>)) != -<span class="hljs-number">1</span>) &#123;     B = Arrays.copyOf(B, B.length + n);     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;         B[B.length - n + i] = b[i];     &#125; &#125; serverSocket.close();<span class="hljs-comment">//[3]</span> System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(B));&#125;</code></pre></div><ol type="1"><li><p><code>ServerSocket serverSocket = new ServerSocket(9000);</code></p><p>这个语句用以监听 9000 这个端口</p><p>细节：这里要求该端口没有被其他服务占用。</p></li><li><p><code>Socket clientSocket = serverSocket.accept();</code></p><p>这个语句用以接收连接的<code>Socket</code>。没有连接时，程序会阻滞在这里</p><p>细节：此处 <code>accept()</code> 可以返回多个<code>Socket</code>，即多并发</p></li><li><p><code>serverSocket.close();</code></p><p>结束后，务必关闭！</p></li></ol><p><strong>下面，示范一个客户端</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">client</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException&#123; <span class="hljs-type">String</span> <span class="hljs-variable">serverIP</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;192.168.3.16&quot;</span>;<span class="hljs-comment">//[1]</span> <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(serverIP, <span class="hljs-number">9000</span>);<span class="hljs-comment">//[2]</span> <span class="hljs-type">OutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> socket.getOutputStream(); outputStream.write(<span class="hljs-string">&quot;hello,Server!&quot;</span>.getBytes(StandardCharsets.UTF_8)); socket.shutdownOutput();<span class="hljs-comment">//[3]</span> outputStream.close(); socket.close();&#125;</code></pre></div><ol type="1"><li><p>这个 IP 是我的本机地址。代表的是 服务端 地址</p></li><li><p><code>Socket socket = new Socket(serverIP, 9000);</code></p><p>表示访问指定 IP 的 9000 端口</p></li><li><p><code>socket.shutdownOutput();</code></p><p>这里是输出一个结束标记。若不如此做，socket就不知道是否数据发送完成</p><p>特别的，由 字节流 输出的场合，<code>writer.newLine()</code>可以替代结束标记。但是这个场合，接收必须是<code>reader.readLine()</code></p></li></ol><h4 id="netstat-指令">19.3.1.1 netstat 指令</h4><ol type="1"><li><p><code>netstat -an</code>可以查看当前主机网络情况，包括端口监听情况和网络连接情况</p></li><li><p><code>netstat -an | more</code> 可以分页显示</p></li><li><p><code>netstat -anb</code> 可以显示占用端口的应用</p></li><li><p>要求在 dos 控制台下执行</p></li><li><p>Listening 表示某个端口在监听。</p><p>如果有一个外部程序连接到该端口，就会显示一条连接信息Established</p></li></ol><h4 id="tcp-连接秘密">19.3.1.2 TCP 连接秘密</h4><p><strong>当客户端连接到服务端后，实际上客户端也是通过一个端口和服务端进行通讯的。这个端口由TCP/IP 来分配，是不确定的，随机的。</strong></p><h3 id="udp-网络通信编程">19.3.2 UDP 网络通信编程</h3><ol type="1"><li>类 <code>DatagramSocket</code> 和 <code>DatagramPacket</code>实现了基于 UDP 协议网络程序</li><li>没有明确的服务端和客户端，演变成数据的发送端和接收端</li><li>UDP 数据报通过数据报套接字 <code>DatagramSocket</code>发送和接收。系统不保证 UDP数据报一定能安全送到目的地，也不能确定什么时候能抵达</li><li><code>DatagramPacket</code> 对象封装了 UDP数据报，在数据报中包含了发送端的 IP 地址和端口号以及接收端的 IP地址和端口号</li><li>接收到 <code>DtagramPacket</code>对象时，需要进行拆包，取出数据</li><li><code>DatagramSocket</code> 可以指定在哪个端口接收数据</li><li>UDP协议中每个数据报都给出了完整的地址信息，因此无需发送方和接收方的连接</li></ol><p><strong>下面，示范一个接收端</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>(<span class="hljs-number">9000</span>);<span class="hljs-comment">//[1]</span><span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">dp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(bytes, bytes.length);<span class="hljs-comment">//[2]</span>System.out.println(<span class="hljs-string">&quot;萝茵 聆听中……&quot;</span>);ds.receive(dp);<span class="hljs-comment">//[3]</span><span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> dp.getLength();bytes = dp.getData();System.out.println(<span class="hljs-string">&quot;萝茵听到了如下内容：\n&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes, <span class="hljs-number">0</span>, len));ds.close();<span class="hljs-comment">//[4]</span></code></pre></div><ol type="1"><li><p><code>DatagramSocket ds = new DatagramSocket(9000);</code></p><p>以 9000 这个端口作为监听端口</p></li><li><p><code>DatagramPacket dp = new DatagramPacket(bytes, bytes.length);</code></p><p>构建 <code>DatagramPacket</code> 对象，准备接收数据</p></li><li><p><code>ds.receive(dp);</code></p><p>监听信息，放到刚刚创建的 <code>DatagramPacket</code> 对象</p></li><li><p><code>ds.close()</code></p><p>要记得关闭呦 ★ ~</p></li></ol><p><strong>下面，示范一个发送端</strong></p><div class="code-wrapper"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;萝茵，大声喊道：你好，世界！&quot;</span>);<span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>(<span class="hljs-number">8000</span>);<span class="hljs-comment">//[1]</span><span class="hljs-type">InetAddress</span> <span class="hljs-variable">ia</span> <span class="hljs-operator">=</span> InetAddress.getByName(serverIP);<span class="hljs-type">byte</span>[] bytes = <span class="hljs-string">&quot;你好，世界&quot;</span>.getBytes(StandardCharsets.UTF_8);<span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">dp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(bytes, bytes.length, ia, <span class="hljs-number">9001</span>);<span class="hljs-comment">//[2]</span>ds.send(dp);<span class="hljs-comment">//[3]</span>System.out.println(<span class="hljs-string">&quot;声音在虚无中回荡着……&quot;</span>);ds.close();<span class="hljs-comment">//[4]</span></code></pre></div><ol type="1"><li><p><code>DatagramSocket ds = new DatagramSocket(8000);</code></p><p>以 8000 这个端口作为发送端口</p></li><li><p><code>DatagramPacket dp = new DatagramPacket(bytes, bytes.length, ia, 9001);</code></p><p>把要发送的数据、数据长度、对象地址、对象端口 放到包里</p></li><li><p><code>ds.send(dp);</code></p><p>走你 ★ ~</p></li><li><p><code>ds.close();</code></p><p>鸟尽弓藏</p></li></ol><h2 id="附录">附录</h2><h3 id="项目开发流程">项目开发流程</h3><h4 id="需求分析">1 需求分析</h4><p><strong>需求分析师（懂技术 + 懂行业）</strong></p><ol type="1"><li>需求分析报告<ul><li>项目功能</li><li>客户要求</li></ul></li></ol><h4 id="设计阶段">2 设计阶段</h4><p><strong>架构师 / 项目经理</strong></p><ol type="1"><li>设计工作<ul><li>UML 类图</li><li>流程图</li><li>模块设计</li><li>数据库设计</li><li>架构</li></ul></li><li>原型开发</li><li>组建团队</li></ol><h4 id="实现阶段">3 实现阶段</h4><p><strong>程序员 / 码农</strong></p><ol type="1"><li>完成架构师的模块功能</li><li>测试自己的模块</li></ol><h4 id="测试阶段">4 测试阶段</h4><p><strong>测试工程师</strong></p><ol type="1"><li>单元测试</li><li>测试用例</li><li>白盒测试</li><li>黑盒测试</li><li>集成测试</li></ol><h4 id="实施阶段">5 实施阶段</h4><p><strong>实施工程师（开发能力 / 环境配置部署能力）</strong></p><ol type="1"><li>把项目正确地部署到客户的平台，并保证运行正常</li><li>身体好</li></ol><h4 id="维护阶段">6 维护阶段</h4><ol type="1"><li>发现 bug 并解决</li><li>项目升级</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt;18 项目（坦克大战）</title>
    <link href="/2022/01/11/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/18%20%E9%A1%B9%E7%9B%AE%EF%BC%9A%E5%9D%A6%E5%85%8B%E5%A4%A7%E6%88%98/"/>
    <url>/2022/01/11/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/18%20%E9%A1%B9%E7%9B%AE%EF%BC%9A%E5%9D%A6%E5%85%8B%E5%A4%A7%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h1 id="项目坦克大战">18 项目：坦克大战</h1><p>还有很多细节、优化方法没实现，但困难的已经没有了。</p><p>先不打磨了，还是以学习 Java 为主。</p><h3 id="二阶段毕业">二阶段毕业</h3><blockquote><p>关于 数量的注释可能不对。那些注释是早些时候添加的。后来添加了新功能，这些注释没有及时更新</p><p>TankGame.java：程序的入口</p><p>MyPanel.java：窗口、图像的绘制。这是该项目的主干</p><p>Player.java、Enemy.java：己方、敌方的坦克类。Tank.java是他们的父类</p><p>Vehicle.java：记录了所有坦克预设的枚举类。该包下还有另一个记录了所有子弹类型的枚举类Bullet</p><p>Map.java：记录了地图数据的枚举类，包含不同关卡。但我没设计关卡</p><p>InputImage.java：所有导入的图片。是我准备的素材</p><p>Timing.java：一个计时器。当时能力有限，用这个作为某个计时功能的代替方案</p></blockquote><ul><li><p><strong>TankGame.java（入口）</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.tank_game;<span class="hljs-keyword">import</span> javax.swing.*;<span class="hljs-keyword">import</span> java.io.*;<span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0.ష</span><span class="hljs-comment"> * &lt;p&gt;</span><span class="hljs-comment"> * 小派蒙会开坦克吗？</span><span class="hljs-comment"> * &lt;p&gt;</span><span class="hljs-comment"> * ⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⠴⠒⠛⠲⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀</span><span class="hljs-comment"> * ⠀⠀⠀⠀   ⠀⢻⡄⣠⠶⣆⠀⣸⣀⣀⠀⠀</span><span class="hljs-comment"> * ⠀⠀⠀ ⠀⠀⢀⡠⠬⠛⢓⣏⠉⣾⣉⣀⠉⢹⡀⠀⠀⠀⠀⠀⠀⠀</span><span class="hljs-comment"> * ⠀⠀ ⠀⢀⡖⠋⣠⠴⠛⠙⢹⠞⢳⢀⣨⡵⠚⠀⠀⠀</span><span class="hljs-comment"> * ⠀⠀⠀⣰⠋⡠⠎⠁⣀⠤⠒⠚⠛⠙⠒⠳⠤⣄⡀⠀</span><span class="hljs-comment"> * ⠀⠀⠀⠘⠐⢼⠖⠋⠀⠀⢀⠀⠀⠀⠀⠀⠀⠘⣌⡒⠲⢹⠀⠀⠀⠀</span><span class="hljs-comment"> * ⠀⠀ ⠀⡸⠁⠀⠀⠀⠀⡆⠀⠀⠐⠀⠢⣄⠀⡽⡙⡲⠑⠒⠒⡒⠁</span><span class="hljs-comment"> * ⢀⡠⠴⠚⠀⠀⠀⠀⠀⣕⠝⣄⡀⢀⠀⠀⡇⠵⢍⠚⢾⡀⢠⠖⠁⠀       ___________________</span><span class="hljs-comment"> * ⠈⠦⣄⣀⠀⡔⠀⠀⢁⡞⠀⠉⠲⣄⡀⢲⢼⠀⢀⠳⡄⠁⠀⢣⠀⠀     /  坦克？是新游戏喔。   \</span><span class="hljs-comment"> * ⠀⠀⣠⠃⢐⠄⠀⠀⠴⠅⠠⡊⡢⠀⠉⠉⠁⠀⢆⠕⠹⡀⠀⠈⡆⠀  &lt;   开玩笑，我超勇的好不好   \</span><span class="hljs-comment"> * ⠀⠠⡇⠀⡸⠀⠀⠀⠨⡅⠀⠒⠈⠀⢄⠠⠠⠔⠀⠀⠀⢻⠀⠀⢣⠀     \     我超会玩的啦 ~     /</span><span class="hljs-comment"> * ⠀⢸⠅⠀⡕⠀⠀⠀⠀⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⡤⡏⠀⠀⢸⠀       \____________________/</span><span class="hljs-comment"> * ⠀⠈⡇⠀⣣⠀⠀⠈⠀⠸⡦⠴⠲⢚⢚⠙⠝⠙⠍⠝⣱⠏⢠⠀⢸⠅</span><span class="hljs-comment"> * ⠀⠀⠙⣆⠘⣄⠀⠠⣄⠀⠹⣌⠌⠀⠂⠐⢈⠄⡁⢌⠳⣺⠏⢀⡞⠀</span><span class="hljs-comment"> * ⠀⠀⠀⠀⠙⠺⠛⣲⠜⠟⡓⡚⣏⣔⡀⡌⣀⢂⣔⠴⠋⢏⠒⠁⠀⠀</span><span class="hljs-comment"> * &lt;p&gt;</span><span class="hljs-comment"> * 什么新游戏，比游戏还刺激！还可以教你 学 Ja va 哦 ~</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TankGame</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JFrame</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MyPanel mp;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Thread thread;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">File</span> <span class="hljs-variable">savePath</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;d:\\Program\\Melody\\TankGame\\saveData.sav&quot;</span>);    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> abandoned;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">width</span> <span class="hljs-operator">=</span> <span class="hljs-number">1200</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> <span class="hljs-number">800</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">enemyNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);        <span class="hljs-type">char</span> <span class="hljs-variable">inpChar</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27; &#x27;</span>;        mp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPanel</span>(width, height, enemyNum);        <span class="hljs-keyword">if</span> (savePath.isFile()) &#123;            System.out.println(<span class="hljs-string">&quot;开始新游戏？（Y新游戏/N读档）&quot;</span>);            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;                inpChar = scanner.next().charAt(<span class="hljs-number">0</span>);                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-keyword">if</span> (inpChar == <span class="hljs-string">&#x27;Y&#x27;</span> || inpChar == <span class="hljs-string">&#x27;y&#x27;</span>) &#123;                        <span class="hljs-keyword">break</span>;                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (inpChar == <span class="hljs-string">&#x27;N&#x27;</span> || inpChar == <span class="hljs-string">&#x27;n&#x27;</span>) &#123;                        mp.pause = <span class="hljs-literal">true</span>;                        mp.toLoad = <span class="hljs-literal">true</span>;                    &#125; <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();                    &#125;                    <span class="hljs-keyword">break</span>;                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                    System.out.println(<span class="hljs-string">&quot;错误！请重新输入（Y新游戏/N读档）&quot;</span>);                &#125;            &#125;        &#125;        <span class="hljs-type">TankGame</span> <span class="hljs-variable">game</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TankGame</span>(Math.abs(width), Math.abs(height), Math.abs(enemyNum));        thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(game.mp);        thread.start();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TankGame</span><span class="hljs-params">(<span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height, <span class="hljs-type">int</span> enemyNum)</span> &#123;        width = Math.max(width, <span class="hljs-number">800</span>);        height = Math.max(height, <span class="hljs-number">600</span>);        <span class="hljs-built_in">this</span>.add(mp);        <span class="hljs-built_in">this</span>.setSize(width + <span class="hljs-number">20</span>, height + <span class="hljs-number">240</span>);        <span class="hljs-built_in">this</span>.addKeyListener(mp);        <span class="hljs-built_in">this</span>.setVisible(<span class="hljs-literal">true</span>);        <span class="hljs-built_in">this</span>.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);    &#125;&#125;</code></pre></div></li><li><p><strong>MyPanel.java</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.tank_game;<span class="hljs-keyword">import</span> javax.swing.*;<span class="hljs-keyword">import</span> java.awt.*;<span class="hljs-keyword">import</span> java.awt.event.KeyEvent;<span class="hljs-keyword">import</span> java.awt.event.KeyListener;<span class="hljs-keyword">import</span> java.io.*;<span class="hljs-keyword">import</span> java.util.Iterator;<span class="hljs-keyword">import</span> java.util.LinkedHashMap;<span class="hljs-keyword">import</span> java.util.Vector;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * ！！！！！！！！！！！！！！！该类需要重新整理！！！！！！！！！！！！！！！！</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPanel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JPanel</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">KeyListener</span>, Runnable, Serializable &#123;    <span class="hljs-comment">//5 个静态变量依次是：允许的同屏最大敌人数量的上限、战斗区域宽度、战斗区域高度、玩家、是否通关</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ENEMY_MAX</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">width</span> <span class="hljs-operator">=</span> <span class="hljs-number">1200</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Player</span> <span class="hljs-variable">player</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Player</span>(<span class="hljs-number">640</span>, <span class="hljs-number">640</span>);    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">gameSuspend</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][][] mapData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[width][height][<span class="hljs-number">2</span>];                        <span class="hljs-comment">//*****此处需要修改*****</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;    <span class="hljs-comment">//12 个成员变量，依次是：所有敌人坦克、所有被摧毁的敌人坦克、同屏最大敌人数量（用户设定）、敌人初始位置集（含坐标、占用情况）、</span>    <span class="hljs-comment">//          敌人初始位置集（仅坐标）、关卡敌人总数、W键是否正被按下、A键是否正被按下、S键是否正被按下、D键是否正被按下、开火键是否正被按下、</span>    <span class="hljs-comment">//          导入图片媒介、地图集、关卡数</span>    <span class="hljs-keyword">private</span> Vector&lt;Tank&gt; enemy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>&lt;&gt;();    <span class="hljs-keyword">private</span> Vector&lt;Tank&gt; deadEnemy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>&lt;&gt;();    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> enemyMax;    <span class="hljs-keyword">private</span> LinkedHashMap&lt;<span class="hljs-type">int</span>[], Boolean&gt; enemyPositions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[][] enemyPosition;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">isPressingW</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">isPressingA</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">isPressingS</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">isPressingD</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">isFiring</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">Image</span> <span class="hljs-variable">image</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-keyword">private</span> Map[] maps = Map.values();    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">level</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;    <span class="hljs-keyword">private</span> Tank boss;    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">bossActive</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;    <span class="hljs-type">boolean</span> <span class="hljs-variable">pause</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">transient</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">saved</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;    <span class="hljs-type">boolean</span> <span class="hljs-variable">loaded</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">transient</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">toLoad</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">toSave</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">transient</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">abandoned</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;    <span class="hljs-comment">//构造器</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyPanel</span><span class="hljs-params">(<span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height, <span class="hljs-type">int</span> enemyNum)</span> &#123;        <span class="hljs-built_in">this</span>.width = (<span class="hljs-type">int</span>) (width / <span class="hljs-number">40</span>) * <span class="hljs-number">40</span>;        <span class="hljs-built_in">this</span>.height = (<span class="hljs-type">int</span>) (height / <span class="hljs-number">40</span>) * <span class="hljs-number">40</span>;               <span class="hljs-comment">//设置长宽</span>        enemyNum = Math.max(enemyNum, <span class="hljs-number">0</span>);        enemyMax = Math.min(enemyNum, ENEMY_MAX);           <span class="hljs-comment">//设置同屏最大敌人数量</span>        enemyPosition = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[enemyMax][<span class="hljs-number">2</span>];                <span class="hljs-comment">//已经确定了要生成的敌人位置数量，生成位置数组（空）</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; enemyMax; i++) &#123;                <span class="hljs-comment">//生成敌人初始位置。</span>            <span class="hljs-type">int</span>[] tempPosition = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];            tempPosition[<span class="hljs-number">0</span>] = i * <span class="hljs-number">150</span> + <span class="hljs-number">50</span>;            tempPosition[<span class="hljs-number">1</span>] = <span class="hljs-number">50</span>;            <span class="hljs-keyword">while</span> (tempPosition[<span class="hljs-number">0</span>] &gt; (width - <span class="hljs-number">100</span>)) &#123;                tempPosition[<span class="hljs-number">1</span>] += <span class="hljs-number">120</span>;                tempPosition[<span class="hljs-number">0</span>] -= (width - <span class="hljs-number">150</span>);                <span class="hljs-keyword">if</span> (tempPosition[<span class="hljs-number">1</span>] &gt; height - <span class="hljs-number">100</span>) &#123;                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();                &#125;            &#125;            enemyPosition[i][<span class="hljs-number">0</span>] = tempPosition[<span class="hljs-number">0</span>];            enemyPosition[i][<span class="hljs-number">1</span>] = tempPosition[<span class="hljs-number">1</span>];        &#125;                                                    <span class="hljs-comment">//此时 敌人初始位置数组 生成完毕。</span>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] ints : enemyPosition) &#123;            enemyPositions.put(ints, <span class="hljs-literal">false</span>);                 <span class="hljs-comment">//装满 敌人初始位置集 默认全部是未占用</span>        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;        nextLevel();        player.start();             <span class="hljs-comment">//启动玩家线程</span>        <span class="hljs-keyword">while</span> (!abandoned) &#123;            creatEnemy();            gameSuspend = <span class="hljs-literal">false</span>;<span class="hljs-comment">//创建敌人坦克。这个方法同时会启动敌人坦克线程</span>            <span class="hljs-keyword">while</span> (!gameSuspend) &#123;                repaint();              <span class="hljs-comment">//刷新</span>                checkLevelClear();                <span class="hljs-keyword">if</span>(toSave)&#123;                    saveData();                    toSave  = <span class="hljs-literal">false</span>;                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(toLoad)&#123;                    loadData();                    toLoad  = <span class="hljs-literal">false</span>;                &#125;            &#125;            pauseBetweenLevels(<span class="hljs-number">1200</span> + (bossActive ? <span class="hljs-number">2000</span> : <span class="hljs-number">0</span>));            <span class="hljs-keyword">while</span> (!gameSuspend) &#123;                repaint();            &#125;            nextLevel();        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">paint</span><span class="hljs-params">(Graphics g)</span> &#123;        drawUI(g);                      <span class="hljs-comment">//画出 UI</span>        drawPlayer(g);                  <span class="hljs-comment">//画出 玩家坦克（包含子弹）</span>        drawEnemy(g);                   <span class="hljs-comment">//画出 所有敌人坦克（包含子弹）</span>        drawDeadTank(g);                <span class="hljs-comment">//画出 被破坏坦克的残留动画和残留子弹</span>    &#125;    <span class="hljs-comment">//画出 UI</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawUI</span><span class="hljs-params">(Graphics g)</span> &#123;        g.setColor(Color.BLACK);        g.fillRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);        g.setColor(Color.GRAY);        g.fillRect(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, width - <span class="hljs-number">4</span>, height - <span class="hljs-number">4</span>);        <span class="hljs-comment">//以上 4 行，画出了战斗场地</span>        g.setColor(Color.WHITE);        g.fillRect(<span class="hljs-number">0</span>, height, width, <span class="hljs-number">200</span>);        drawHp(g);                                                      <span class="hljs-comment">//画 HP 槽</span>        drawFireCD(g);                                                  <span class="hljs-comment">//画 开火 槽</span>        drawEnemyNum(g);                                                <span class="hljs-comment">//画 雷达 槽</span>        drawStars(g);                                                   <span class="hljs-comment">//画 经验值 星星</span>        <span class="hljs-keyword">if</span> (pause) &#123;            drawPause(g);        &#125;    &#125;    <span class="hljs-comment">//画 HP 槽</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawHp</span><span class="hljs-params">(Graphics g)</span> &#123;        <span class="hljs-comment">//下面画出 绿色 HP 槽。随着 HP 减少，槽会变空</span>        g.setFont(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Font</span>(<span class="hljs-string">&quot;等线&quot;</span>, Font.ITALIC + Font.BOLD, <span class="hljs-number">50</span>));        g.setColor(Color.BLACK);        g.fillRect(<span class="hljs-number">50</span>, height + <span class="hljs-number">60</span>, (<span class="hljs-type">int</span>) (<span class="hljs-number">20</span> * player.vehicle.LIFE) + <span class="hljs-number">4</span>, <span class="hljs-number">30</span>);        g.setColor(player.lifeRemains / player.vehicle.LIFE &gt; <span class="hljs-number">0.2</span> ? Color.GREEN : Color.RED);        g.fill3DRect(<span class="hljs-number">52</span>, height + <span class="hljs-number">62</span>, (<span class="hljs-type">int</span>) (<span class="hljs-number">20</span> * Math.max(player.lifeRemains, <span class="hljs-number">0</span>)), <span class="hljs-number">26</span>, <span class="hljs-literal">true</span>);        g.fill3DRect(<span class="hljs-number">52</span>, height + <span class="hljs-number">80</span>, (<span class="hljs-type">int</span>) (<span class="hljs-number">20</span> * Math.max(player.lifeRemains, <span class="hljs-number">0</span>) - <span class="hljs-number">1</span>), <span class="hljs-number">6</span>, <span class="hljs-literal">false</span>);        <span class="hljs-comment">//下面画出一段说明文</span>        g.setColor(Color.GRAY);        <span class="hljs-keyword">if</span> (player.vehicle == Vehicle.Basic) &#123;            g.drawString(<span class="hljs-string">&quot;防弹衣&quot;</span>, <span class="hljs-number">50</span>, height + <span class="hljs-number">140</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            g.drawString(player.vehicle == Vehicle.Tank_Special ? <span class="hljs-string">&quot;复合装甲&quot;</span> : <span class="hljs-string">&quot;装甲&quot;</span>, <span class="hljs-number">50</span>, height + <span class="hljs-number">140</span>);        &#125;    &#125;    <span class="hljs-comment">//画 开火 槽</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawFireCD</span><span class="hljs-params">(Graphics g)</span> &#123;        <span class="hljs-comment">//以下画出 橙色 开火槽。随着装弹，槽会填满</span>        g.setFont(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Font</span>(<span class="hljs-string">&quot;等线&quot;</span>, Font.ITALIC + Font.BOLD, <span class="hljs-number">50</span>));        g.setColor(Color.BLACK);        g.fillRect((<span class="hljs-type">int</span>) ((width / <span class="hljs-number">2</span>) + <span class="hljs-number">60</span>), height + <span class="hljs-number">60</span>, <span class="hljs-number">205</span>, <span class="hljs-number">30</span>);        g.setColor(player.vehicle == Vehicle.Tank_Special ? Color.cyan : Color.ORANGE);        g.fill3DRect((<span class="hljs-type">int</span>) ((width / <span class="hljs-number">2</span>) + <span class="hljs-number">62</span>), height + <span class="hljs-number">62</span>,                (<span class="hljs-type">int</span>) (player.getAtkSpeed() * (player.fireCD - Math.max(player.fireCount, <span class="hljs-number">0</span>)) + <span class="hljs-number">1</span>), <span class="hljs-number">26</span>, <span class="hljs-literal">true</span>);        g.fill3DRect((<span class="hljs-type">int</span>) ((width / <span class="hljs-number">2</span>) + <span class="hljs-number">62</span>), height + <span class="hljs-number">80</span>,                (<span class="hljs-type">int</span>) (player.getAtkSpeed() * (player.fireCD - Math.max(player.fireCount, <span class="hljs-number">0</span>))), <span class="hljs-number">6</span>, <span class="hljs-literal">false</span>);        <span class="hljs-comment">//以下画出一段说明文字</span>        g.setColor(Color.GRAY);        <span class="hljs-keyword">if</span> (player.vehicle == Vehicle.Basic) &#123;            g.drawString(player.fireCount &lt;= <span class="hljs-number">10</span> ? <span class="hljs-string">&quot;哒哒哒哒哒……&quot;</span> : player.fireCount == player.fireCD ? <span class="hljs-string">&quot;加特林停了&quot;</span> : <span class="hljs-string">&quot;加特林转啊！&quot;</span>,                    width / <span class="hljs-number">2</span> + <span class="hljs-number">60</span>, height + <span class="hljs-number">140</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            g.drawString(player.fireCount &lt;= <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;弹药装填完毕&quot;</span> : <span class="hljs-string">&quot;装填中…&quot;</span>, width / <span class="hljs-number">2</span> + <span class="hljs-number">60</span>, height + <span class="hljs-number">140</span>);        &#125;    &#125;    <span class="hljs-comment">//画出 敌人数量（这个方法是UI的一部分，统计数量，而不是画坦克）</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawEnemyNum</span><span class="hljs-params">(Graphics g)</span> &#123;        g.setFont(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Font</span>(<span class="hljs-string">&quot;等线&quot;</span>, Font.ITALIC + Font.BOLD, <span class="hljs-number">20</span>));        g.setColor(Color.BLACK);        g.drawString(<span class="hljs-string">&quot;雷达发现敌人数量：&quot;</span> + (maps[level].levelEnemyNum - deadEnemy.size()), (<span class="hljs-type">int</span>) (width * <span class="hljs-number">0.77</span>), height + <span class="hljs-number">22</span>);    &#125;    <span class="hljs-comment">//画出 经验值。有几点就有几颗红星被点亮。</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawStars</span><span class="hljs-params">(Graphics g)</span> &#123;        <span class="hljs-keyword">switch</span> (player.vehicle.LEVEL_UP_REQUIRED) &#123;            <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:                g.drawImage(player.enhance &gt;= <span class="hljs-number">10</span> ? InputImage.star : InputImage.nStar,                        <span class="hljs-number">280</span>, height + <span class="hljs-number">10</span>, <span class="hljs-number">30</span>, <span class="hljs-number">30</span>, <span class="hljs-built_in">this</span>);                g.drawImage(player.enhance &gt;= <span class="hljs-number">9</span> ? InputImage.star : InputImage.nStar,                        <span class="hljs-number">250</span>, height + <span class="hljs-number">10</span>, <span class="hljs-number">30</span>, <span class="hljs-number">30</span>, <span class="hljs-built_in">this</span>);                g.drawImage(player.enhance &gt;= <span class="hljs-number">8</span> ? InputImage.star : InputImage.nStar,                        <span class="hljs-number">220</span>, height + <span class="hljs-number">10</span>, <span class="hljs-number">30</span>, <span class="hljs-number">30</span>, <span class="hljs-built_in">this</span>);                g.drawImage(player.enhance &gt;= <span class="hljs-number">7</span> ? InputImage.star : InputImage.nStar,                        <span class="hljs-number">190</span>, height + <span class="hljs-number">10</span>, <span class="hljs-number">30</span>, <span class="hljs-number">30</span>, <span class="hljs-built_in">this</span>);                g.drawImage(player.enhance &gt;= <span class="hljs-number">6</span> ? InputImage.star : InputImage.nStar,                        <span class="hljs-number">160</span>, height + <span class="hljs-number">10</span>, <span class="hljs-number">30</span>, <span class="hljs-number">30</span>, <span class="hljs-built_in">this</span>);            <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:                g.drawImage(player.enhance &gt;= <span class="hljs-number">5</span> ? InputImage.star : InputImage.nStar,                        <span class="hljs-number">130</span>, height + <span class="hljs-number">10</span>, <span class="hljs-number">30</span>, <span class="hljs-number">30</span>, <span class="hljs-built_in">this</span>);            <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:                g.drawImage(player.enhance &gt;= <span class="hljs-number">4</span> ? InputImage.star : InputImage.nStar,                        <span class="hljs-number">100</span>, height + <span class="hljs-number">10</span>, <span class="hljs-number">30</span>, <span class="hljs-number">30</span>, <span class="hljs-built_in">this</span>);            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:                g.drawImage(player.enhance &gt;= <span class="hljs-number">3</span> ? InputImage.star : InputImage.nStar,                        <span class="hljs-number">70</span>, height + <span class="hljs-number">10</span>, <span class="hljs-number">30</span>, <span class="hljs-number">30</span>, <span class="hljs-built_in">this</span>);            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:                g.drawImage(player.enhance &gt;= <span class="hljs-number">2</span> ? InputImage.star : InputImage.nStar,                        <span class="hljs-number">40</span>, height + <span class="hljs-number">10</span>, <span class="hljs-number">30</span>, <span class="hljs-number">30</span>, <span class="hljs-built_in">this</span>);            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:                g.drawImage(player.enhance &gt;= <span class="hljs-number">1</span> ? InputImage.star : InputImage.nStar,                        <span class="hljs-number">10</span>, height + <span class="hljs-number">10</span>, <span class="hljs-number">30</span>, <span class="hljs-number">30</span>, <span class="hljs-built_in">this</span>);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">default</span>:                g.setColor(Color.GRAY);             <span class="hljs-comment">//不能升级的坦克，画一个小小的圆</span>                g.fillOval(<span class="hljs-number">40</span>, height + <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>);                <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawPause</span><span class="hljs-params">(Graphics g)</span> &#123;        g.setFont(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Font</span>(<span class="hljs-string">&quot;等线&quot;</span>, Font.ITALIC + Font.BOLD, <span class="hljs-number">70</span>));        g.setColor(Color.DARK_GRAY);        g.drawString(<span class="hljs-string">&quot;游戏暂停中，按 P 键继续游戏&quot;</span>, (<span class="hljs-type">int</span>) ((width / <span class="hljs-number">2</span>) * <span class="hljs-number">0.2</span>), (height / <span class="hljs-number">2</span> - <span class="hljs-number">100</span>));        <span class="hljs-keyword">if</span> (saved)&#123;            g.setFont(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Font</span>(<span class="hljs-string">&quot;等线&quot;</span>, Font.ITALIC + Font.BOLD, <span class="hljs-number">50</span>));            g.setColor(Color.DARK_GRAY);            g.drawString(<span class="hljs-string">&quot;存档成功！&quot;</span>, (<span class="hljs-type">int</span>) ((width / <span class="hljs-number">2</span>) * <span class="hljs-number">0.8</span>), (height / <span class="hljs-number">2</span>));        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(loaded)&#123;            g.setFont(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Font</span>(<span class="hljs-string">&quot;等线&quot;</span>, Font.ITALIC + Font.BOLD, <span class="hljs-number">50</span>));            g.setColor(Color.DARK_GRAY);            g.drawString(<span class="hljs-string">&quot;读档成功！&quot;</span>, (<span class="hljs-type">int</span>) ((width / <span class="hljs-number">2</span>) * <span class="hljs-number">0.8</span>), (height / <span class="hljs-number">2</span>));        &#125;        <span class="hljs-keyword">if</span> (deadEnemy.size() &gt;= maps[level].levelEnemyNum &amp;&amp; (!bossActive || !boss.alive))&#123;            g.setFont(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Font</span>(<span class="hljs-string">&quot;黑体&quot;</span>, Font.ITALIC + Font.BOLD, <span class="hljs-number">70</span>));            g.setColor(Color.ORANGE);            g.drawString(<span class="hljs-string">&quot;下一波敌人接近中！&quot;</span>, (<span class="hljs-type">int</span>) ((width / <span class="hljs-number">2</span>) * <span class="hljs-number">0.5</span>), (<span class="hljs-type">int</span>)(height * <span class="hljs-number">0.8</span>));                                                                                        <span class="hljs-comment">//*****此处需要修改*****</span>        &#125;    &#125;    <span class="hljs-comment">//画出 玩家坦克</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawPlayer</span><span class="hljs-params">(Graphics g)</span> &#123;        player.pause = <span class="hljs-built_in">this</span>.pause;        drawLivingTank(g, player);    &#125;    <span class="hljs-comment">//画出敌人坦克</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawEnemy</span><span class="hljs-params">(Graphics g)</span> &#123;        Iterator&lt;Tank&gt; iterator = enemy.iterator();        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;            <span class="hljs-type">Tank</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> iterator.next();            <span class="hljs-keyword">if</span> (!temp.alive) &#123;                              <span class="hljs-comment">//这个分支，坦克已被摧毁</span>                temp.releaseCollisionSize();                <span class="hljs-comment">//消除其碰撞体积</span>                iterator.remove();                deadEnemy.add(temp);                        <span class="hljs-comment">//从 敌人集 把该坦克删除，加入 破坏坦克集</span>                player.enhanced(temp.vehicle);              <span class="hljs-comment">//给玩家结算经验</span>                enemyPositions.put(enemyPosition[n], <span class="hljs-literal">false</span>);<span class="hljs-comment">//该坦克占用的位置被解放</span>            &#125;            n++;        &#125;        creatEnemy();                       <span class="hljs-comment">//尝试生成新的坦克</span>        iterator = enemy.iterator();        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;            <span class="hljs-type">Tank</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> iterator.next();            t.pause = <span class="hljs-built_in">this</span>.pause;                <span class="hljs-comment">//暂停设置</span><span class="hljs-comment">//            if (t.specialCount &gt; 0) &#123;</span><span class="hljs-comment">//                t.specialCount--;                                     //*****此处需要修改*****</span><span class="hljs-comment">//            &#125; else &#123;</span>            drawLivingTank(g, t);       <span class="hljs-comment">//画出所有（敌人的）坦克</span><span class="hljs-comment">//            &#125;</span>        &#125;        <span class="hljs-keyword">if</span> (bossActive) &#123;            boss.pause = <span class="hljs-built_in">this</span>.pause;            drawBoss(g);        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawBoss</span><span class="hljs-params">(Graphics g)</span> &#123;        <span class="hljs-keyword">if</span> (boss.alive) &#123;            drawTank(g, boss);        &#125; <span class="hljs-keyword">else</span> &#123;            drawExplosion(g, boss);        &#125;        drawBullet(g, boss);    &#125;    <span class="hljs-comment">//画出被摧毁的坦克的残留特效及其所有残留子弹</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawDeadTank</span><span class="hljs-params">(Graphics g)</span> &#123;        Iterator&lt;Tank&gt; iterator = deadEnemy.iterator();        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;            <span class="hljs-type">Tank</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> iterator.next();            temp.pause = <span class="hljs-built_in">this</span>.pause;            <span class="hljs-keyword">if</span> (temp.specialCount &gt; <span class="hljs-number">0</span>) &#123;          <span class="hljs-comment">//敌人的特殊计数残留时，画出其爆炸效果</span>                temp.specialCount--;                                        <span class="hljs-comment">//*****此处需要修改*****</span>                drawExplosion(g, temp);            &#125;            <span class="hljs-keyword">if</span> (temp.bullets.size() &gt; <span class="hljs-number">0</span>) &#123;          <span class="hljs-comment">//敌人的子弹有残留时，画出该子弹</span>                drawBullet(g, temp);            &#125;        &#125;    &#125;    <span class="hljs-comment">//画出存活的坦克及其所有子弹</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawLivingTank</span><span class="hljs-params">(Graphics g, Tank tank)</span> &#123;        <span class="hljs-comment">//以下部分画出坦克</span>        <span class="hljs-keyword">if</span> (tank.alive) &#123;            drawTank(g, tank);       <span class="hljs-comment">//存活的场合，画出坦克</span>            drawBullet(g, tank);                <span class="hljs-comment">//画出子弹</span>        &#125;    &#125;    <span class="hljs-comment">//画坦克。这个方法能画出朝向正确的坦克。</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawTank</span><span class="hljs-params">(Graphics g, Tank tank)</span> &#123;        <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> dirState2(tank.dir);        <span class="hljs-keyword">switch</span> (tank.vehicle) &#123;            <span class="hljs-keyword">case</span> Tank_Lv1:                image = dirState(tank.dir) ? InputImage.tank1 : InputImage.tank1r;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> Tank_Lv2:                image = dirState(tank.dir) ? InputImage.tank2 : InputImage.tank2r;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> Tank_Lv3:                image = dirState(tank.dir) ? InputImage.tank3 : InputImage.tank3r;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> Tank_E1:                image = dirState(tank.dir) ? InputImage.tankE1 : InputImage.tankE1r;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> Tank_E2:                image = dirState(tank.dir) ? InputImage.tankE2 : InputImage.tankE2r;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> Tank_E3:                image = dirState(tank.dir) ? InputImage.tankE3 : InputImage.tankE3r;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> Tank_Special:                image = dirState(tank.dir) ? InputImage.tankSp : InputImage.tankSpr;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> Basic:                <span class="hljs-keyword">if</span> (tank.fireCount &lt;= <span class="hljs-number">3</span>) &#123;                    image = dirState(tank.dir) ? InputImage.basicL : InputImage.basicLR;                &#125; <span class="hljs-keyword">else</span> &#123;                    image = dirState(tank.dir) ? InputImage.basic : InputImage.basicR;                &#125;                <span class="hljs-keyword">break</span>;        &#125;        g.drawImage(image, b ? tank.x + <span class="hljs-number">80</span> : tank.x, b ? tank.y + <span class="hljs-number">80</span> : tank.y, b ? -<span class="hljs-number">80</span> : <span class="hljs-number">80</span>, b ? -<span class="hljs-number">80</span> : <span class="hljs-number">80</span>, <span class="hljs-built_in">this</span>);        <span class="hljs-keyword">if</span> (tank.invincible &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">switch</span> (tank.vehicle) &#123;             <span class="hljs-comment">//无敌持续中的场合，画出护盾</span>                <span class="hljs-keyword">case</span> Tank_Special:                <span class="hljs-keyword">case</span> Basic:                    image = dirState(tank.dir) ? InputImage.bubble : InputImage.bubbleR;                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">default</span>:                    image = dirState(tank.dir) ? InputImage.bubbleE : InputImage.bubbleER;                    <span class="hljs-keyword">break</span>;            &#125;            g.drawImage(image, tank.x - <span class="hljs-number">5</span>, tank.y - <span class="hljs-number">5</span>, <span class="hljs-number">90</span>, <span class="hljs-number">90</span>, <span class="hljs-built_in">this</span>);        &#125;    &#125;    <span class="hljs-comment">//画出子弹。这个方法也会判断子弹的状态（是否存活）</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawBullet</span><span class="hljs-params">(Graphics g, Tank tank)</span> &#123;        Iterator&lt;Bullet&gt; iterator = tank.bullets.iterator();        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;            <span class="hljs-type">Bullet</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> iterator.next();            temp.pause = pause;            <span class="hljs-keyword">if</span> (!temp.active) &#123;                 <span class="hljs-comment">//子弹消亡的场合，移除子弹</span>                iterator.remove();            &#125; <span class="hljs-keyword">else</span> &#123;                            <span class="hljs-comment">//走到这里，说明子弹存活。</span>                <span class="hljs-keyword">switch</span> (tank.party) &#123;           <span class="hljs-comment">//看看是哪个阵营发出的子弹，去判定别的阵营的坦克</span>                    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:                        <span class="hljs-keyword">if</span> (bossActive &amp;&amp; checkHit(boss, temp, tank)) &#123;                            <span class="hljs-keyword">break</span>;                        &#125;                        <span class="hljs-keyword">for</span> (Tank t : enemy) &#123;                            <span class="hljs-keyword">if</span> (checkHit(t, temp, tank)) &#123;      <span class="hljs-comment">//遍历敌坦克，看看打中了谁。打中则停止判定</span>                                <span class="hljs-keyword">break</span>;                            &#125;                        &#125;                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:                        checkHit(player, temp, tank);           <span class="hljs-comment">//看看有没有击中玩家</span>                    <span class="hljs-keyword">default</span>:                &#125;                drawBullet(g, tank.vehicle, temp.getDir(), temp.getX(), temp.getY());       <span class="hljs-comment">//画出子弹</span>            &#125;        &#125;    &#125;    <span class="hljs-comment">//画出子弹。这个方法通常由上个方法调用，能画出朝向正确的子弹</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawBullet</span><span class="hljs-params">(Graphics g, Vehicle vehicle, <span class="hljs-type">char</span> dir, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;        <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> dirState2(dir);        <span class="hljs-keyword">switch</span> (vehicle.BULLET) &#123;            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;n&#x27;</span>:                image = dirState(dir) ? InputImage.nBullet : InputImage.nBulletR;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;e&#x27;</span>:                image = dirState(dir) ? InputImage.eBullet : InputImage.eBulletR;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;g&#x27;</span>:                image = dirState(dir) ? InputImage.gBullet : InputImage.gBulletR;                <span class="hljs-keyword">break</span>;        &#125;        g.drawImage(image, b ? x + <span class="hljs-number">10</span> : x, b ? y + <span class="hljs-number">10</span> : y, b ? -<span class="hljs-number">10</span> : <span class="hljs-number">10</span>, b ? -<span class="hljs-number">10</span> : <span class="hljs-number">10</span>, <span class="hljs-built_in">this</span>);    &#125;    <span class="hljs-comment">//画出爆炸。爆炸分为几个阶段，而且不同坦克也有不同爆炸特效</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawExplosion</span><span class="hljs-params">(Graphics g, Tank tank)</span> &#123;        <span class="hljs-keyword">if</span> (tank.specialCount &gt; <span class="hljs-number">350</span>) &#123;            drawTank(g, tank);        &#125;        <span class="hljs-keyword">switch</span> (tank.vehicle) &#123;            <span class="hljs-keyword">case</span> Tank_E3:                <span class="hljs-keyword">if</span> (tank.specialCount &lt; <span class="hljs-number">600</span> &amp;&amp; tank.specialCount &gt;= <span class="hljs-number">100</span>) &#123;                    <span class="hljs-keyword">if</span> (tank.specialCount &gt;= <span class="hljs-number">500</span>) &#123;                        image = InputImage.explosion1;                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tank.specialCount &gt;= <span class="hljs-number">400</span>) &#123;                        image = InputImage.explosion2;                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tank.specialCount &gt;= <span class="hljs-number">300</span>) &#123;                        image = InputImage.explosion3;                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tank.specialCount &gt;= <span class="hljs-number">200</span>) &#123;                        image = InputImage.explosion4;                    &#125; <span class="hljs-keyword">else</span> &#123;                        image = InputImage.explosion5;                    &#125;                    g.drawImage(image, tank.x, tank.y, <span class="hljs-number">80</span>, <span class="hljs-number">80</span>, <span class="hljs-built_in">this</span>);                &#125;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> Tank_E1:            <span class="hljs-keyword">case</span> Tank_E2:            <span class="hljs-keyword">default</span>:                <span class="hljs-keyword">if</span> (tank.specialCount &lt; <span class="hljs-number">450</span> &amp;&amp; tank.specialCount &gt;= <span class="hljs-number">50</span>) &#123;                    <span class="hljs-keyword">if</span> (tank.specialCount &gt;= <span class="hljs-number">250</span>) &#123;                        image = InputImage.explosion1;                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tank.specialCount &gt; <span class="hljs-number">100</span>) &#123;                        image = InputImage.explosion2;                    &#125; <span class="hljs-keyword">else</span> &#123;                        image = InputImage.explosion3;                    &#125;                    g.drawImage(image, tank.x, tank.y, <span class="hljs-number">80</span>, <span class="hljs-number">80</span>, <span class="hljs-built_in">this</span>);                &#125;        &#125;        tank.specialCount = Math.max(tank.specialCount, <span class="hljs-number">0</span>);    &#125;    <span class="hljs-comment">//下面这两个方法可以帮助其他方法画出正确朝向的对象</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dirState</span><span class="hljs-params">(<span class="hljs-type">char</span> dir)</span> &#123;        <span class="hljs-type">return</span> <span class="hljs-variable">dir</span> <span class="hljs-operator">=</span>= <span class="hljs-string">&#x27;u&#x27;</span> || dir == <span class="hljs-string">&#x27;d&#x27;</span>;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dirState2</span><span class="hljs-params">(<span class="hljs-type">char</span> dir)</span> &#123;        <span class="hljs-type">return</span> <span class="hljs-variable">dir</span> <span class="hljs-operator">=</span>= <span class="hljs-string">&#x27;l&#x27;</span> || dir == <span class="hljs-string">&#x27;d&#x27;</span>;    &#125;    <span class="hljs-comment">//检查子弹是否击中目标</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkHit</span><span class="hljs-params">(Tank tank, Bullet bullet, Tank from)</span> &#123;        <span class="hljs-keyword">if</span> (hit(tank, bullet) &amp;&amp; !bullet.hasHit(tank)) &#123;        <span class="hljs-comment">//检查是否击中目标 及 目标是否已被击中过</span>            bullet.setHit(tank);            <span class="hljs-keyword">if</span> (tank.invincible &gt; <span class="hljs-number">0</span>) &#123;                bullet.pierce = <span class="hljs-number">0</span>;              <span class="hljs-comment">//撞到无敌的坦克时，子弹直接报销</span>            &#125;            bullet.active = bullet.pierce &gt; <span class="hljs-number">0</span>;          <span class="hljs-comment">//子弹穿透降为 0 的场合，子弹消亡</span>            <span class="hljs-keyword">if</span> (!tank.takeDamage(from, bullet.getDir())) &#123;                      <span class="hljs-comment">//坦克伤害计数完后，在这里把 HP 归 0 的坦克记为已销毁</span>                tank.alive = <span class="hljs-literal">false</span>;            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-comment">//看看子弹是否击中坦克。由上个方法调用</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hit</span><span class="hljs-params">(Tank tank, Bullet bullet)</span> &#123;        <span class="hljs-keyword">if</span> (!tank.alive) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">if</span> (tank.vehicle == Vehicle.Basic) &#123;            <span class="hljs-keyword">return</span> pIn(tank.x + <span class="hljs-number">30</span>, <span class="hljs-number">20</span>, bullet.getX() + <span class="hljs-number">5</span>) &amp;&amp; pIn(tank.y + <span class="hljs-number">30</span>, <span class="hljs-number">20</span>, bullet.getY() + <span class="hljs-number">5</span>);        &#125;        <span class="hljs-keyword">switch</span> (tank.getDir()) &#123;            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;u&#x27;</span>:            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;d&#x27;</span>:                <span class="hljs-keyword">return</span> pIn(tank.x + <span class="hljs-number">20</span>, <span class="hljs-number">40</span>, bullet.getX() + <span class="hljs-number">5</span>) &amp;&amp; pIn(tank.y + <span class="hljs-number">3</span>, <span class="hljs-number">76</span>, bullet.getY() + <span class="hljs-number">5</span>);            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;r&#x27;</span>:            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;l&#x27;</span>:                <span class="hljs-keyword">return</span> pIn(tank.x + <span class="hljs-number">3</span>, <span class="hljs-number">76</span>, bullet.getX() + <span class="hljs-number">5</span>) &amp;&amp; pIn(tank.y + <span class="hljs-number">20</span>, <span class="hljs-number">40</span>, bullet.getY() + <span class="hljs-number">5</span>);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-comment">//看看某个坐标（横坐标或纵坐标）是否在[p, p + w]范围内</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">pIn</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> w, <span class="hljs-type">int</span> toCheck)</span> &#123;        <span class="hljs-keyword">return</span> toCheck &gt;= p &amp;&amp; toCheck &lt;= (p + w);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">keyTyped</span><span class="hljs-params">(KeyEvent e)</span> &#123;    &#125;    <span class="hljs-comment">//监视器。以下方式保证了动画的流畅度</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">keyPressed</span><span class="hljs-params">(KeyEvent e)</span> &#123;        <span class="hljs-keyword">switch</span> (e.getKeyCode()) &#123;            <span class="hljs-keyword">case</span> KeyEvent.VK_W:                isPressingW = <span class="hljs-literal">true</span>;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> KeyEvent.VK_A:                isPressingA = <span class="hljs-literal">true</span>;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> KeyEvent.VK_D:                isPressingD = <span class="hljs-literal">true</span>;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> KeyEvent.VK_S:                isPressingS = <span class="hljs-literal">true</span>;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> KeyEvent.VK_J:         <span class="hljs-comment">//J 是开火键</span>                isFiring = <span class="hljs-literal">true</span>;                <span class="hljs-keyword">break</span>;<span class="hljs-comment">//            //===================以下为测试用=====================</span><span class="hljs-comment">//            case KeyEvent.VK_Q:                                     //该 case 仅测试用。  务必删除！务必删除！</span><span class="hljs-comment">//                for (Tank tank : enemy) &#123;</span><span class="hljs-comment">//                    tank.alive = false;</span><span class="hljs-comment">//                    tank.releaseCollisionSize();</span><span class="hljs-comment">//                &#125;</span><span class="hljs-comment">//                break;</span><span class="hljs-comment">//            case KeyEvent.VK_E:                                     //该 case 仅测试用。  务必删除！务必删除！</span><span class="hljs-comment">//                deadEnemy.clear();</span><span class="hljs-comment">//                break;</span><span class="hljs-comment">//            case KeyEvent.VK_1:                                     //该 case 仅测试用。  务必删除！务必删除！</span><span class="hljs-comment">//                player.setVehicle(Vehicle.Tank_Lv1);</span><span class="hljs-comment">//                player.releaseCollisionSize();</span><span class="hljs-comment">//                break;</span><span class="hljs-comment">//            case KeyEvent.VK_2:                                     //该 case 仅测试用。  务必删除！务必删除！</span><span class="hljs-comment">//                player.setVehicle(Vehicle.Tank_Lv2);</span><span class="hljs-comment">//                player.releaseCollisionSize();</span><span class="hljs-comment">//                break;</span><span class="hljs-comment">//            case KeyEvent.VK_3:                                     //该 case 仅测试用。  务必删除！务必删除！</span><span class="hljs-comment">//                player.setVehicle(Vehicle.Tank_Lv3);</span><span class="hljs-comment">//                player.releaseCollisionSize();</span><span class="hljs-comment">//                break;</span><span class="hljs-comment">//            case KeyEvent.VK_4:                                     //该 case 仅测试用。  务必删除！务必删除！</span><span class="hljs-comment">//                player.setVehicle(Vehicle.Tank_Special);</span><span class="hljs-comment">//                player.releaseCollisionSize();</span><span class="hljs-comment">//                break;</span><span class="hljs-comment">//            case KeyEvent.VK_5:                                     //该 case 仅测试用。  务必删除！务必删除！</span><span class="hljs-comment">//                player.setVehicle(Vehicle.Basic);</span><span class="hljs-comment">//                player.releaseCollisionSize();</span><span class="hljs-comment">//                break;</span><span class="hljs-comment">//            case KeyEvent.VK_Z:                                     //该 case 仅测试用。  务必删除！务必删除！</span><span class="hljs-comment">//                player.buffedDef = 100;</span><span class="hljs-comment">//                break;</span><span class="hljs-comment">//            case KeyEvent.VK_X:                                     //该 case 仅测试用。  务必删除！务必删除！</span><span class="hljs-comment">//                player.buffedDef = 0;</span><span class="hljs-comment">//                break;</span><span class="hljs-comment">//            case KeyEvent.VK_C:                                     //该 case 仅测试用。  务必删除！务必删除！</span><span class="hljs-comment">//                player.invincible = 1000000;</span><span class="hljs-comment">//                break;</span><span class="hljs-comment">//            case KeyEvent.VK_V:                                     //该 case 仅测试用。  务必删除！务必删除！</span><span class="hljs-comment">//                player.invincible = 0;</span><span class="hljs-comment">//                break;</span>            <span class="hljs-comment">//===================以上为测试用=====================</span>        &#125;        isGoing();          <span class="hljs-comment">//看看玩家是否正在移动</span>        isFiring();         <span class="hljs-comment">//看看玩家是否正在开火</span>    &#125;    <span class="hljs-comment">//同上</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">keyReleased</span><span class="hljs-params">(KeyEvent e)</span> &#123;        <span class="hljs-keyword">switch</span> (e.getKeyCode()) &#123;            <span class="hljs-keyword">case</span> KeyEvent.VK_W:             <span class="hljs-comment">//向上</span>                isPressingW = <span class="hljs-literal">false</span>;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> KeyEvent.VK_A:             <span class="hljs-comment">//向左</span>                isPressingA = <span class="hljs-literal">false</span>;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> KeyEvent.VK_D:             <span class="hljs-comment">//向右</span>                isPressingD = <span class="hljs-literal">false</span>;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> KeyEvent.VK_S:             <span class="hljs-comment">//向下</span>                isPressingS = <span class="hljs-literal">false</span>;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> KeyEvent.VK_J:             <span class="hljs-comment">//开火</span>                isFiring = <span class="hljs-literal">false</span>;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> KeyEvent.VK_P:             <span class="hljs-comment">//暂停</span>                gamePause();                saved = <span class="hljs-literal">false</span>;                loaded = <span class="hljs-literal">false</span>;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> KeyEvent.VK_I:             <span class="hljs-comment">//读档（需要暂停）</span>                toLoad = <span class="hljs-literal">true</span>;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> KeyEvent.VK_O:             <span class="hljs-comment">//存档（需要暂停）</span>                toSave = <span class="hljs-literal">true</span>;                <span class="hljs-keyword">break</span>;        &#125;        isGoing();        isFiring();    &#125;    <span class="hljs-comment">//更新玩家的移动状态</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">isGoing</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (!player.pause) &#123;            <span class="hljs-keyword">if</span> (isPressingW) &#123;                player.dir = <span class="hljs-string">&#x27;u&#x27;</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isPressingS) &#123;                player.dir = <span class="hljs-string">&#x27;d&#x27;</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isPressingA) &#123;                player.dir = <span class="hljs-string">&#x27;l&#x27;</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isPressingD) &#123;                player.dir = <span class="hljs-string">&#x27;r&#x27;</span>;            &#125;        &#125;        player.isMoving = isPressingA || isPressingS || isPressingD || isPressingW;    &#125;    <span class="hljs-comment">//更新玩家的开火状态</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">isFiring</span><span class="hljs-params">()</span> &#123;        player.isFiring = isFiring;    &#125;    <span class="hljs-comment">//生成敌人，直到允许的最大数量</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">creatEnemy</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">while</span> (enemy.size() &lt; enemyMax &amp;&amp; enemy.size() &lt; maps[level].levelEnemyNum - deadEnemy.size()) &#123;            <span class="hljs-type">int</span>[] temp = <span class="hljs-literal">null</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] ints : enemyPosition) &#123;                <span class="hljs-keyword">if</span> (!enemyPositions.get(ints)) &#123;            <span class="hljs-comment">//为坦克分配初始位置</span>                    temp = ints;                    enemyPositions.put(ints, <span class="hljs-literal">true</span>);                    <span class="hljs-keyword">break</span>;                &#125;            &#125;            <span class="hljs-keyword">if</span> (temp == <span class="hljs-literal">null</span>) &#123;                 <span class="hljs-comment">//应该不会抛出异常。但，以防万一，加上这句</span>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();            &#125;            <span class="hljs-type">Tank</span> <span class="hljs-variable">tempTank</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enemy</span>(temp[<span class="hljs-number">0</span>], temp[<span class="hljs-number">1</span>], maps[level]);            <span class="hljs-keyword">if</span> (deadEnemy.size() == <span class="hljs-number">0</span>) &#123;                tempTank.specialCount = <span class="hljs-number">0</span>;          <span class="hljs-comment">//坦克有延迟显示。这里取消了第一组坦克（初始敌人坦克）的延迟显示</span>            &#125;            enemy.add(tempTank);         <span class="hljs-comment">//在 敌人集 中添加新的坦克</span>            tempTank.start();            <span class="hljs-comment">//启动该新坦克线程</span>        &#125;    &#125;    <span class="hljs-comment">//这个方法有两个作用：</span>    <span class="hljs-comment">//  1. 其他敌人全灭时，激活 BOSS</span>    <span class="hljs-comment">//  2. 所有敌人全灭时，进入下一关</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkLevelClear</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (deadEnemy.size() == maps[level].levelEnemyNum &amp;&amp; !bossActive &amp;&amp; boss != <span class="hljs-literal">null</span> &amp;&amp; boss.alive) &#123;            boss.start();            bossActive = <span class="hljs-literal">true</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (deadEnemy.size() &gt;= maps[level].levelEnemyNum &amp;&amp; (boss == <span class="hljs-literal">null</span> || !boss.alive)) &#123;            gameSuspend = <span class="hljs-literal">true</span>;        &#125;    &#125;    <span class="hljs-comment">//关卡间设置短暂停顿</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pauseBetweenLevels</span><span class="hljs-params">(<span class="hljs-type">int</span> time)</span> &#123;        gameSuspend = <span class="hljs-literal">false</span>;        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Timing</span>(time)).start();    &#125;    <span class="hljs-comment">//每次调用会切换 暂停状态。</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">gamePause</span><span class="hljs-params">()</span> &#123;        <span class="hljs-built_in">this</span>.pause = !<span class="hljs-built_in">this</span>.pause;    &#125;    <span class="hljs-comment">//进入下一关时，加载下一关数据</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nextLevel</span><span class="hljs-params">()</span> &#123;        player.releaseCollisionSize();        player.x = <span class="hljs-number">200</span>;        player.y = height - <span class="hljs-number">200</span>;        level++;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; maps[level].mapData.length; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; maps[level].mapData[i].length; j++) &#123;                inputMapData(i, j);            &#125;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] ints : enemyPosition) &#123;            enemyPositions.put(ints, <span class="hljs-literal">false</span>);        &#125;        <span class="hljs-keyword">for</span> (Tank tank : deadEnemy) &#123;            tank.releaseCollisionSize();        &#125;        enemy.clear();        deadEnemy.clear();        player.lifeRemains = player.vehicle.LIFE;        player.invincible = <span class="hljs-number">0</span>;        gameSuspend = <span class="hljs-literal">false</span>;        boss = maps[level].boss;        <span class="hljs-keyword">if</span> (boss != <span class="hljs-literal">null</span>) &#123;            boss.x = Math.max(width / <span class="hljs-number">2</span> - <span class="hljs-number">40</span>, <span class="hljs-number">0</span>);            boss.y = <span class="hljs-number">70</span>;        &#125;        bossActive = <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-comment">//从 Map 类中 加载既定的地图数据</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inputMapData</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">40</span>; k++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; l &lt; <span class="hljs-number">40</span>; l++) &#123;                mapData[(x * <span class="hljs-number">40</span>) + k][(y * <span class="hljs-number">40</span>) + l][<span class="hljs-number">1</span>] = maps[level].mapData[x][y][<span class="hljs-number">1</span>];                mapData[(x * <span class="hljs-number">40</span>) + k][(y * <span class="hljs-number">40</span>) + l][<span class="hljs-number">0</span>] = maps[level].mapData[x][y][<span class="hljs-number">0</span>];            &#125;        &#125;                                                                           <span class="hljs-comment">//*****此处需要修改*****</span>        <span class="hljs-comment">//这里需要对 地图逻辑、坦克行进逻辑 都进行修改。</span>        <span class="hljs-comment">// 现行方法是：由 mapData[][] 记录每个像素的数据。每个像素点的占用情况实时更新。</span>        <span class="hljs-comment">// 改成：由 mapData[][] 记录所有 40 * 40 方格的数据。</span>        <span class="hljs-comment">//      相信这个办法应该能解决现行方法偶发的空气墙问题，扩展性也会更好。存档大小也能缩小，因而也有机会优化存档逻辑。</span>        <span class="hljs-comment">//      目前的代码基本兼容这个新方法。Map 类的数据本来就是 40 * 40 方格模式。地图大小、各类模型尺寸也都是 40 的整数倍</span>    &#125;    <span class="hljs-comment">//读档</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadData</span><span class="hljs-params">()</span>&#123;        <span class="hljs-keyword">if</span> (pause) &#123;            <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">if</span> (!TankGame.savePath.exists()) &#123;                    TankGame.savePath.createNewFile();                &#125;                ois = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(TankGame.savePath));                <span class="hljs-keyword">if</span>((MyPanel)ois.readObject() != <span class="hljs-literal">null</span>)&#123;                    player = (Player) ois.readObject();<span class="hljs-comment">//                    mapData = (int[][][]) ois.readObject();</span>                    enemy = (Vector&lt;Tank&gt;) ois.readObject();                    deadEnemy = (Vector&lt;Tank&gt;) ois.readObject();                    enemyPositions = (LinkedHashMap&lt;<span class="hljs-type">int</span>[], Boolean&gt;) ois.readObject();                    enemyPosition = (<span class="hljs-type">int</span>[][]) ois.readObject();                    maps = (Map[]) ois.readObject();                    boss = (Tank) ois.readObject();                    level = ois.readInt();                    bossActive = ois.readBoolean();                &#125;            &#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException ex) &#123;                ex.printStackTrace();            &#125; <span class="hljs-keyword">finally</span> &#123;                <span class="hljs-keyword">try</span> &#123;                    ois.close();                &#125; <span class="hljs-keyword">catch</span> (IOException ex) &#123;                    ex.printStackTrace();                &#125;            &#125;            pause = <span class="hljs-literal">true</span>;            loaded = <span class="hljs-literal">true</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; maps[level].mapData.length; i++) &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; maps[level].mapData[i].length; j++) &#123;                    inputMapData(i, j);                &#125;            &#125;            <span class="hljs-keyword">for</span> (Tank tank : enemy) &#123;                tank.start();                <span class="hljs-keyword">for</span> (Bullet bullet : tank.bullets) &#123;                    bullet.start();                &#125;            &#125;            <span class="hljs-keyword">for</span> (Tank tank : deadEnemy) &#123;                <span class="hljs-keyword">for</span> (Bullet bullet : tank.bullets) &#123;                    bullet.start();                &#125;            &#125;            <span class="hljs-keyword">if</span>(bossActive &amp;&amp; boss.alive)&#123;                boss.start();            &#125;            player.start();        &#125;    &#125;    <span class="hljs-comment">//存档</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveData</span><span class="hljs-params">()</span>&#123;        <span class="hljs-keyword">if</span> (pause) &#123;            <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">if</span> (!TankGame.savePath.exists()) &#123;                    TankGame.savePath.createNewFile();                &#125;                oos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(TankGame.savePath));                oos.writeObject(TankGame.mp);                oos.writeObject(player);<span class="hljs-comment">//                oos.writeObject(mapData);         //占用太大</span>                oos.writeObject(enemy);                oos.writeObject(deadEnemy);                oos.writeObject(enemyPositions);                oos.writeObject(enemyPosition);                oos.writeObject(maps);                oos.writeObject(boss);                oos.writeInt(level);                oos.writeBoolean(bossActive);                saved = <span class="hljs-literal">true</span>;            &#125; <span class="hljs-keyword">catch</span> (IOException ex) &#123;                ex.printStackTrace();            &#125; <span class="hljs-keyword">finally</span> &#123;                <span class="hljs-keyword">try</span> &#123;                    oos.close();                &#125; <span class="hljs-keyword">catch</span> (IOException ex) &#123;                    ex.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></div></li><li><p><strong>Tank.java</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.tank_game;<span class="hljs-keyword">import</span> java.io.Serializable;<span class="hljs-keyword">import</span> java.util.Vector;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-comment">//坦克类。这是一个抽象类，Player 和 Enemy 类会继承此类</span><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tank</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;             <span class="hljs-comment">//为什么是 继承Thread 而不是 实现Runnable？因为我写这些代码的时候还没学到那里……</span>    <span class="hljs-comment">/*从上到下依次是：横坐标、纵坐标、坦克类型、方向、当前生命值、速度增幅、攻速增幅、攻击范围增幅、攻击力增幅、防御力增幅、</span><span class="hljs-comment">                    开火间隔、开火间隔计时、子弹集、是否存活、无敌状态持续时间、阵营、死亡计时</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> x;    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> y;    <span class="hljs-keyword">protected</span> <span class="hljs-type">Vehicle</span> <span class="hljs-variable">vehicle</span> <span class="hljs-operator">=</span> Vehicle.Basic;    <span class="hljs-keyword">protected</span> <span class="hljs-type">char</span> <span class="hljs-variable">dir</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;u&#x27;</span>;    <span class="hljs-keyword">protected</span> <span class="hljs-type">double</span> lifeRemains;    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-variable">buffedSpeed</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-variable">buffedAtkSpeed</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-variable">buffedAtkRange</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-variable">buffedAtk</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-variable">buffedDef</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-variable">fireCD</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">fireCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Vector&lt;Bullet&gt; bullets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>&lt;&gt;();   <span class="hljs-comment">//所有活动中的子弹会被存放在里面</span>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">alive</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">invincible</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> party;    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">pause</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">specialCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">800</span>;             <span class="hljs-comment">//坦克死亡后，该计时才开始计数。这个计数是为了播放爆炸动画。计数完毕后该对象会被消除。</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Tank</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;        <span class="hljs-built_in">this</span>.x = x;        <span class="hljs-built_in">this</span>.y = y;        setVehicle(Vehicle.Basic);    &#125;    <span class="hljs-comment">//设置坦克种类</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVehicle</span><span class="hljs-params">(Vehicle vehicle)</span> &#123;        <span class="hljs-built_in">this</span>.vehicle = vehicle;        <span class="hljs-built_in">this</span>.lifeRemains = vehicle.LIFE;        <span class="hljs-built_in">this</span>.fireCD = <span class="hljs-number">200</span> / getAtkSpeed();      <span class="hljs-comment">//开火间隔由这个公式算出</span>    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">char</span> <span class="hljs-title function_">getDir</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> dir;    &#125;    <span class="hljs-comment">//受到伤害。这个方法由子类实现</span>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">takeDamage</span><span class="hljs-params">(Tank tank, <span class="hljs-type">char</span> dir)</span>;    <span class="hljs-comment">//移动。</span><span class="hljs-comment">//    abstract void move(char move);</span>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span>;    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span>[] tryMove()&#123;        <span class="hljs-type">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];        temp[<span class="hljs-number">0</span>] = x;        temp[<span class="hljs-number">1</span>] = y;        <span class="hljs-keyword">switch</span> (dir) &#123;            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;u&#x27;</span>:                temp[<span class="hljs-number">1</span>]--;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;d&#x27;</span>:                temp[<span class="hljs-number">1</span>]++;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;l&#x27;</span>:                temp[<span class="hljs-number">0</span>]--;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;r&#x27;</span>:                temp[<span class="hljs-number">0</span>]++;                <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">return</span> temp;    &#125;    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">outOfArea</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;        <span class="hljs-keyword">return</span> x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span> || x &gt; MyPanel.width - <span class="hljs-number">80</span> || y &gt; MyPanel.height - <span class="hljs-number">80</span>;    &#125;    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">runIntoSth</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;        <span class="hljs-type">boolean</span> <span class="hljs-variable">checking</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">switch</span> (dir) &#123;            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;u&#x27;</span>:                checking = MyPanel.mapData[x + <span class="hljs-number">40</span> - (vehicle.SIZE / <span class="hljs-number">2</span>)][y + <span class="hljs-number">40</span> - (vehicle.SIZE / <span class="hljs-number">2</span>)][<span class="hljs-number">1</span>] == <span class="hljs-number">0</span> &amp;&amp;                        MyPanel.mapData[x + <span class="hljs-number">40</span>][y + <span class="hljs-number">40</span> - (vehicle.SIZE / <span class="hljs-number">2</span>)][<span class="hljs-number">1</span>] == <span class="hljs-number">0</span> &amp;&amp;                        MyPanel.mapData[x + <span class="hljs-number">39</span> + (vehicle.SIZE / <span class="hljs-number">2</span>)][y + <span class="hljs-number">40</span> - (vehicle.SIZE / <span class="hljs-number">2</span>)][<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;d&#x27;</span>:                checking = MyPanel.mapData[x + <span class="hljs-number">40</span> - (vehicle.SIZE / <span class="hljs-number">2</span>)][y + <span class="hljs-number">39</span> + (vehicle.SIZE / <span class="hljs-number">2</span>)][<span class="hljs-number">1</span>] == <span class="hljs-number">0</span> &amp;&amp;                        MyPanel.mapData[x + <span class="hljs-number">40</span>][y + <span class="hljs-number">40</span> + (vehicle.SIZE / <span class="hljs-number">2</span>)][<span class="hljs-number">1</span>] == <span class="hljs-number">0</span> &amp;&amp;                        MyPanel.mapData[x + <span class="hljs-number">39</span> + (vehicle.SIZE / <span class="hljs-number">2</span>)][y + <span class="hljs-number">39</span> + (vehicle.SIZE / <span class="hljs-number">2</span>)][<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;r&#x27;</span>:                checking = MyPanel.mapData[x + <span class="hljs-number">39</span> + (vehicle.SIZE / <span class="hljs-number">2</span>)][y + <span class="hljs-number">40</span> - (vehicle.SIZE / <span class="hljs-number">2</span>)][<span class="hljs-number">1</span>] == <span class="hljs-number">0</span> &amp;&amp;                        MyPanel.mapData[x + <span class="hljs-number">39</span> + (vehicle.SIZE / <span class="hljs-number">2</span>)][y + <span class="hljs-number">40</span>][<span class="hljs-number">1</span>] == <span class="hljs-number">0</span> &amp;&amp;                        MyPanel.mapData[x + <span class="hljs-number">39</span> + (vehicle.SIZE / <span class="hljs-number">2</span>)][y + <span class="hljs-number">39</span> + (vehicle.SIZE / <span class="hljs-number">2</span>)][<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;l&#x27;</span>:                checking = MyPanel.mapData[x + <span class="hljs-number">40</span> - (vehicle.SIZE / <span class="hljs-number">2</span>)][y + <span class="hljs-number">40</span> - (vehicle.SIZE / <span class="hljs-number">2</span>)][<span class="hljs-number">1</span>] == <span class="hljs-number">0</span> &amp;&amp;                        MyPanel.mapData[x + <span class="hljs-number">40</span> - (vehicle.SIZE / <span class="hljs-number">2</span>)][y + <span class="hljs-number">40</span>][<span class="hljs-number">1</span>] == <span class="hljs-number">0</span> &amp;&amp;                        MyPanel.mapData[x + <span class="hljs-number">40</span> - (vehicle.SIZE / <span class="hljs-number">2</span>)][y + <span class="hljs-number">39</span> + (vehicle.SIZE / <span class="hljs-number">2</span>)][<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>;                <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">return</span> !checking;    &#125;    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCollisionSize</span><span class="hljs-params">(<span class="hljs-type">int</span> tempX, <span class="hljs-type">int</span> tempY, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> hp)</span> &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; vehicle.SIZE; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; vehicle.SIZE; j++) &#123;                MyPanel.mapData[tempX + <span class="hljs-number">40</span> - (vehicle.SIZE / <span class="hljs-number">2</span>) + i][tempY + <span class="hljs-number">40</span> - (vehicle.SIZE / <span class="hljs-number">2</span>) + j][<span class="hljs-number">1</span>] = type;                MyPanel.mapData[tempX + <span class="hljs-number">40</span> - (vehicle.SIZE / <span class="hljs-number">2</span>) + i][tempY + <span class="hljs-number">40</span> - (vehicle.SIZE / <span class="hljs-number">2</span>) + j][<span class="hljs-number">0</span>] = hp;            &#125;        &#125;    &#125;    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseCollisionSize</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; vehicle.SIZE; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; vehicle.SIZE; j++) &#123;                MyPanel.mapData[x + <span class="hljs-number">40</span> - (vehicle.SIZE / <span class="hljs-number">2</span>) + i][y + <span class="hljs-number">40</span> - (vehicle.SIZE / <span class="hljs-number">2</span>) + j][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;                MyPanel.mapData[x + <span class="hljs-number">40</span> - (vehicle.SIZE / <span class="hljs-number">2</span>) + i][y + <span class="hljs-number">40</span> - (vehicle.SIZE / <span class="hljs-number">2</span>) + j][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;            &#125;        &#125;    &#125;    <span class="hljs-comment">//开火</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fire</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (fireCount &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">//fireCount &gt; 0 说明开火CD 还没好，直接 return</span>            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (vehicle == Vehicle.Basic) &#123;     <span class="hljs-comment">//Basic 体积和一般坦克不同，故而发射子弹的位置也不同</span>            fireCount = <span class="hljs-number">10</span>;                 <span class="hljs-comment">//其武器也不同，所以 开火CD 的逻辑也不同。这里使其每发子弹的间隔很短</span>            <span class="hljs-keyword">switch</span> (dir) &#123;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;u&#x27;</span>:                    fire(x + <span class="hljs-number">39</span>, y + <span class="hljs-number">17</span>, dir, getAtkRange());                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;d&#x27;</span>:                    fire(x + <span class="hljs-number">31</span>, y + <span class="hljs-number">53</span>, dir, getAtkRange());                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;l&#x27;</span>:                    fire(x + <span class="hljs-number">17</span>, y + <span class="hljs-number">31</span>, dir, getAtkRange());                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;r&#x27;</span>:                    fire(x + <span class="hljs-number">53</span>, y + <span class="hljs-number">39</span>, dir, getAtkRange());                    <span class="hljs-keyword">break</span>;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            fireCount = fireCD;            <span class="hljs-keyword">switch</span> (dir) &#123;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;u&#x27;</span>:                    fire(x + <span class="hljs-number">35</span>, y - <span class="hljs-number">10</span>, dir, getAtkRange());                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;d&#x27;</span>:                    fire(x + <span class="hljs-number">35</span>, y + <span class="hljs-number">80</span>, dir, getAtkRange());                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;l&#x27;</span>:                    fire(x - <span class="hljs-number">10</span>, y + <span class="hljs-number">35</span>, dir, getAtkRange());                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;r&#x27;</span>:                    fire(x + <span class="hljs-number">80</span>, y + <span class="hljs-number">35</span>, dir, getAtkRange());                    <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fire</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">char</span> dir, <span class="hljs-type">int</span> range)</span> &#123;        <span class="hljs-type">Bullet</span> <span class="hljs-variable">tempBullet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bullet</span>(vehicle.BULLET, x, y, dir, range, <span class="hljs-built_in">this</span>);        bullets.add(tempBullet);  <span class="hljs-comment">//创建一个新的 子弹 实例，并让其运行</span>        tempBullet.start();    &#125;    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFront</span><span class="hljs-params">(<span class="hljs-type">char</span> dir)</span> &#123;               <span class="hljs-comment">//判断是否被从正面击中。如若是，坦克的防御力生效</span>        <span class="hljs-keyword">switch</span> (dir) &#123;            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;u&#x27;</span>:                <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.dir == <span class="hljs-string">&#x27;d&#x27;</span>;            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;d&#x27;</span>:                <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.dir == <span class="hljs-string">&#x27;u&#x27;</span>;            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;r&#x27;</span>:                <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.dir == <span class="hljs-string">&#x27;l&#x27;</span>;            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;l&#x27;</span>:                <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.dir == <span class="hljs-string">&#x27;r&#x27;</span>;            <span class="hljs-keyword">default</span>:                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pause</span><span class="hljs-params">(<span class="hljs-type">boolean</span> pause)</span>&#123;        <span class="hljs-built_in">this</span>.pause = pause;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAtk</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> vehicle.ATK + buffedAtk;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getDef</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> vehicle.DEF + buffedDef;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAtkSpeed</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> vehicle.ATK_SPEED + buffedAtkSpeed;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSpeed</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> vehicle.SPEED + buffedSpeed;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAtkRange</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> vehicle.ATK_RANGE + buffedAtkRange;    &#125;&#125;</code></pre></div></li><li><p><strong>Player.java</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.tank_game;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Tank</span> &#123;    <span class="hljs-comment">//三个属性依次是：经验值、是否正在移动、是否正在开火</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">enhance</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">//这两个变量由 MyPanel 的 监视器决定。按下移动/开火键时，变为 true。松开时，变为 false</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">isMoving</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">isFiring</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Player</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;        <span class="hljs-built_in">super</span>(x, y);        party = <span class="hljs-number">0</span>;              <span class="hljs-comment">//阵营为 0</span>        setVehicle(Vehicle.Basic);          <span class="hljs-comment">//设置初始坦克。               可以随意修改</span>    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">while</span> (alive) &#123;            <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">100</span> / getSpeed());         <span class="hljs-comment">//速度越快、行动越快</span>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-keyword">if</span> (!pause) &#123;                <span class="hljs-keyword">if</span> (invincible &gt; <span class="hljs-number">0</span>) &#123;       <span class="hljs-comment">//无敌冷却减少</span>                    invincible--;                &#125;                <span class="hljs-keyword">if</span> (isMoving) &#123;             <span class="hljs-comment">//正在移动的场合，使其移动</span>                    move();                &#125;                <span class="hljs-keyword">if</span> (isFiring) &#123;             <span class="hljs-comment">//正在开火的场合，使其开火</span>                    fire();                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vehicle == Vehicle.Basic) &#123;          <span class="hljs-comment">//Basic 是特别的。按住开火键的场合，开火CD才减少，不然会增加。</span>                    <span class="hljs-comment">// 这样做是为了模拟 加特林 的手感</span>                    fireCount += fireCount &gt;= fireCD ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;                &#125; <span class="hljs-keyword">else</span> &#123;                    fireCount--;            <span class="hljs-comment">//开火CD 自然减少</span>                &#125;            &#125;        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">int</span>[] temp = tryMove();        <span class="hljs-keyword">if</span> (!outOfArea(temp[<span class="hljs-number">0</span>], temp[<span class="hljs-number">1</span>]) &amp;&amp; !runIntoSth(temp[<span class="hljs-number">0</span>], temp[<span class="hljs-number">1</span>])) &#123;            releaseCollisionSize();            setCollisionSize(temp[<span class="hljs-number">0</span>], temp[<span class="hljs-number">1</span>], -<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>);            x = temp[<span class="hljs-number">0</span>];            y = temp[<span class="hljs-number">1</span>];        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fire</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (fireCount &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">//如果 开火CD 没到，让其自然减少，然后 return</span>            fireCount--;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-built_in">super</span>.fire();               <span class="hljs-comment">//真正的开火</span>    &#125;    <span class="hljs-comment">//获得经验值。每次消灭敌人坦克会调用该方法</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enhanced</span><span class="hljs-params">(Vehicle vehicle)</span> &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.vehicle == Vehicle.Basic &amp;&amp; Math.random() &gt; <span class="hljs-number">0.9</span>) &#123;         <span class="hljs-comment">//特殊设定：Basic 的场合，消灭敌人有概率夺取坦克</span>            <span class="hljs-keyword">switch</span> (vehicle) &#123;                <span class="hljs-keyword">case</span> Tank_E1:                    setVehicle(Vehicle.Tank_Lv1);                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> Tank_E2:                    setVehicle(Vehicle.Tank_Lv2);                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> Tank_E3:                    setVehicle(Vehicle.Tank_Lv3);                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> Tank_Special:                    setVehicle(Vehicle.Tank_Special);                    <span class="hljs-keyword">break</span>;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">switch</span> (vehicle) &#123;                <span class="hljs-keyword">case</span> Tank_E1:                    enhance += <span class="hljs-number">1</span>;                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> Tank_E2:                    enhance += <span class="hljs-number">2</span>;                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> Tank_E3:                    enhance += <span class="hljs-number">3</span>;                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> Tank_Special:                    enhance += <span class="hljs-number">10</span>;                    <span class="hljs-keyword">break</span>;            &#125;            enhanced();         <span class="hljs-comment">//看看能不能升级</span>        &#125;    &#125;    <span class="hljs-comment">//查看是否升级</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enhanced</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (vehicle.LEVEL_UP_REQUIRED &gt; <span class="hljs-number">0</span> &amp;&amp; enhance &gt;= vehicle.LEVEL_UP_REQUIRED) &#123;            enhance -= vehicle.LEVEL_UP_REQUIRED;            releaseCollisionSize();            <span class="hljs-keyword">switch</span> (vehicle) &#123;                <span class="hljs-keyword">case</span> Basic:                    setVehicle(Vehicle.Tank_Lv1);                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> Tank_Lv1:                    setVehicle(Vehicle.Tank_Lv2);                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> Tank_Lv2:                    setVehicle(Vehicle.Tank_Lv3);                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">default</span>:            &#125;            setCollisionSize(x, y, -<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>);        &#125;    &#125;    <span class="hljs-comment">//设置坦克。每次设置会重置经验值</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVehicle</span><span class="hljs-params">(Vehicle vehicle)</span> &#123;        <span class="hljs-built_in">super</span>.setVehicle(vehicle);        <span class="hljs-built_in">this</span>.enhance = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (vehicle == Vehicle.Basic) &#123;            fireCount = fireCD;        &#125;    &#125;    <span class="hljs-comment">//受到伤害。传入的是造成伤害的坦克，和击中的子弹方向</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">takeDamage</span><span class="hljs-params">(Tank tank, <span class="hljs-type">char</span> dir)</span> &#123;        <span class="hljs-type">double</span> <span class="hljs-variable">damage</span> <span class="hljs-operator">=</span> tank.getAtk() * vehicle.DEF_BY_PERCENT - (isFront(dir) ? <span class="hljs-built_in">this</span>.getDef() : <span class="hljs-number">0</span>);    <span class="hljs-comment">//侧后方中弹，防御力不生效</span>        <span class="hljs-keyword">if</span> (invincible &gt; <span class="hljs-number">0</span>) &#123;               <span class="hljs-comment">//无敌的场合，不受伤害</span>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((lifeRemains -= Math.max(damage, <span class="hljs-number">0.1</span>)) &lt;= <span class="hljs-number">0</span>) &#123;           <span class="hljs-comment">//这里扣除了生命值。最少扣除 0.1。</span>            invincible += <span class="hljs-number">200</span>;              <span class="hljs-comment">//坦克被打爆，给一段无敌时间</span>            releaseCollisionSize();            <span class="hljs-keyword">switch</span> (vehicle) &#123;              <span class="hljs-comment">//坦克降级。Basic 的场合，游戏结束</span>                <span class="hljs-keyword">case</span> Tank_Lv3:                <span class="hljs-keyword">case</span> Tank_Lv2:                <span class="hljs-keyword">case</span> Tank_Lv1:                <span class="hljs-keyword">case</span> Tank_Special:                    setVehicle(Vehicle.Basic);                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> Basic:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;                       setCollisionSize(x, y, -<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>);        &#125;        invincible += <span class="hljs-number">100</span>;      <span class="hljs-comment">//只要受到了伤害，产生短暂无敌时间</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;&#125;</code></pre></div></li><li><p><strong>Enemy.java</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.tank_game;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-comment">//敌人的坦克</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Enemy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Tank</span> &#123;    <span class="hljs-comment">//step：坦克的前进次数。归 0 时会转向</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">step</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> FIRE_PROBABILITY;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Enemy</span><span class="hljs-params">(Vehicle vehicle)</span> &#123;        <span class="hljs-built_in">super</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);        setVehicle(vehicle);        party = <span class="hljs-number">1</span>;        dir = <span class="hljs-string">&#x27;d&#x27;</span>;        invincible = <span class="hljs-number">300</span>;        FIRE_PROBABILITY = <span class="hljs-number">0.95</span>;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Enemy</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, Map map)</span> &#123;        <span class="hljs-built_in">this</span>(x, y);        giveVehicle(map.probability_E1, map.probability_E2);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Enemy</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;        <span class="hljs-built_in">super</span>(x, y);        party = <span class="hljs-number">1</span>;              <span class="hljs-comment">//敌方坦克阵营为 1</span><span class="hljs-comment">//        randomDir();</span><span class="hljs-comment">//        giveVehicle();</span>        dir = <span class="hljs-string">&#x27;d&#x27;</span>;        invincible = <span class="hljs-number">130</span>;       <span class="hljs-comment">//敌方坦克出生时，赋予短时间的无敌</span>        FIRE_PROBABILITY = <span class="hljs-number">0.985</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">try</span> &#123;            Thread.sleep(<span class="hljs-number">700</span> + specialCount);          <span class="hljs-comment">//坦克出生时，使其短暂休眠。</span>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        specialCount = <span class="hljs-number">200</span> + (<span class="hljs-type">int</span>) (<span class="hljs-number">80</span> * lifeRemains);         <span class="hljs-comment">//坦克的 死亡计数，和坦克种类有关</span>        <span class="hljs-keyword">while</span> (alive) &#123;            <span class="hljs-keyword">try</span> &#123;                Thread.sleep((<span class="hljs-number">100</span> / getSpeed()));       <span class="hljs-comment">//坦克速度越快，其所有行动速度越快</span>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-keyword">if</span> (!pause) &#123;                <span class="hljs-keyword">if</span> (invincible &gt; <span class="hljs-number">0</span>) &#123;           <span class="hljs-comment">//无敌时间减少</span>                    invincible--;                &#125;                <span class="hljs-keyword">if</span> (fireCount &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">//开火CD计数减少</span>                    fireCount--;                &#125;                move();               <span class="hljs-comment">//移动</span>            &#125;        &#125;        releaseCollisionSize();        <span class="hljs-keyword">while</span> (specialCount &gt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">1</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-keyword">if</span> (!pause) &#123;                specialCount--;                                    <span class="hljs-comment">//*****此处需要修改*****</span>            &#125;        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">giveVehicle</span><span class="hljs-params">(<span class="hljs-type">double</span> probabilityE1, <span class="hljs-type">double</span> probabilityE2)</span> &#123;        <span class="hljs-type">double</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Math.random();        <span class="hljs-keyword">if</span> (result &lt;= probabilityE1) &#123;            setVehicle(Vehicle.Tank_E1);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result &lt;= probabilityE2) &#123;            setVehicle(Vehicle.Tank_E2);        &#125; <span class="hljs-keyword">else</span> &#123;            setVehicle(Vehicle.Tank_E3);        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span> &#123;            <span class="hljs-comment">//传入的字符没用。</span>        <span class="hljs-keyword">if</span> (step &lt;= <span class="hljs-number">0</span>) &#123;            randomDir();                        <span class="hljs-comment">//步数归 0 时，赋予其随机方向</span>            realMove();            step = (<span class="hljs-type">int</span>) (Math.random() * <span class="hljs-number">200</span> + <span class="hljs-number">60</span> - <span class="hljs-number">3</span> * getSpeed());       <span class="hljs-comment">//赋予其随机的步数</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (step &lt;= <span class="hljs-number">60</span> - <span class="hljs-number">2</span> * getSpeed()) &#123;       <span class="hljs-comment">//最后几步的时候，让坦克在原地稍作停留（不移动）</span>            step--;        &#125; <span class="hljs-keyword">else</span> &#123;            realMove();            step--;        &#125;        <span class="hljs-keyword">if</span> (Math.random() &gt; FIRE_PROBABILITY) &#123;            <span class="hljs-comment">//使敌方坦克有 1.5% 的概率开火。这个概率经过测试，比较合适           这里可以更改</span>            fire();        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">realMove</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">int</span>[] temp = tryMove();        <span class="hljs-keyword">if</span> (!outOfArea(temp[<span class="hljs-number">0</span>], temp[<span class="hljs-number">1</span>]) &amp;&amp; !runIntoSth(temp[<span class="hljs-number">0</span>], temp[<span class="hljs-number">1</span>])) &#123;            releaseCollisionSize();            setCollisionSize(temp[<span class="hljs-number">0</span>], temp[<span class="hljs-number">1</span>], -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>);            x = temp[<span class="hljs-number">0</span>];            y = temp[<span class="hljs-number">1</span>];        &#125; <span class="hljs-keyword">else</span> &#123;            step -= <span class="hljs-number">10</span>;        &#125;    &#125;    <span class="hljs-comment">//赋予随机方向（概率均匀）</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">randomDir</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">switch</span> ((<span class="hljs-type">int</span>) (Math.random() * <span class="hljs-number">4</span>)) &#123;            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:                dir = <span class="hljs-string">&#x27;u&#x27;</span>;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:                dir = <span class="hljs-string">&#x27;r&#x27;</span>;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:                dir = <span class="hljs-string">&#x27;d&#x27;</span>;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:                dir = <span class="hljs-string">&#x27;l&#x27;</span>;                <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-comment">//受伤。传入的是造成伤害的坦克（以计算伤害），及子弹方向（用于判断是否是正面中弹）</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">takeDamage</span><span class="hljs-params">(Tank tank, <span class="hljs-type">char</span> dir)</span> &#123;        <span class="hljs-type">double</span> <span class="hljs-variable">damage</span> <span class="hljs-operator">=</span> tank.getAtk() * vehicle.DEF_BY_PERCENT - (isFront(dir) ? getDef() : <span class="hljs-number">0</span>);     <span class="hljs-comment">//侧后方中弹的场合，防御力不生效</span>        <span class="hljs-keyword">if</span> (invincible &gt; <span class="hljs-number">0</span>) &#123;               <span class="hljs-comment">//如果坦克无敌，不会受到伤害</span>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span>.lifeRemains -= Math.max(damage, <span class="hljs-number">0.1</span>)) &gt; <span class="hljs-number">0</span>;        <span class="hljs-comment">//在这里进行了生命值的扣除，最少扣 0.1。返回是否生命值有剩</span>        &#125;    &#125;&#125;</code></pre></div></li><li><p><strong>Vehicle.java</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.tank_game;<span class="hljs-keyword">import</span> java.io.Serializable;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-comment">//该枚举类存放所有可能的坦克种类及其参数</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Vehicle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span>&#123;    <span class="hljs-comment">//Basic 是特别的。设定上，Basic 是离开载具，扛着加特林的驾驶员。其体积和一般坦克不同</span>    Basic(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">20</span>, <span class="hljs-number">3</span>, <span class="hljs-number">400</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-number">10</span>),    Tank_Lv1(<span class="hljs-number">5</span>, <span class="hljs-number">11</span>, <span class="hljs-number">1</span>, <span class="hljs-number">12</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;n&#x27;</span>),    Tank_Lv2(<span class="hljs-number">7</span>, <span class="hljs-number">15</span>, <span class="hljs-number">2</span>, <span class="hljs-number">12</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0.9</span>, <span class="hljs-string">&#x27;n&#x27;</span>),    Tank_Lv3(<span class="hljs-number">10</span>, <span class="hljs-number">17</span>, <span class="hljs-number">3</span>, <span class="hljs-number">12</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1600</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0.8</span>, <span class="hljs-string">&#x27;n&#x27;</span>),    Tank_E1(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">11</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1000</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;n&#x27;</span>),    Tank_E2(<span class="hljs-number">7</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1000</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0.8</span>, <span class="hljs-string">&#x27;n&#x27;</span>),    Tank_E3(<span class="hljs-number">10</span>, <span class="hljs-number">18</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1600</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0.6</span>, <span class="hljs-string">&#x27;n&#x27;</span>),    Tank_Special(<span class="hljs-number">25</span>, <span class="hljs-number">13</span>, <span class="hljs-number">4</span>, <span class="hljs-number">18</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100000</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0.4</span>, <span class="hljs-string">&#x27;e&#x27;</span>);    <span class="hljs-comment">//从上到下依次是：攻击力、生命值、防御力、速度、攻击速度、攻击范围、升级经验、减伤、子弹种类</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> ATK;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> LIFE;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> DEF;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> SPEED;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> ATK_SPEED;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> ATK_RANGE;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> LEVEL_UP_REQUIRED;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> DEF_BY_PERCENT;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> BULLET;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> SIZE;    Vehicle(<span class="hljs-type">int</span> atk, <span class="hljs-type">double</span> life, <span class="hljs-type">int</span> def, <span class="hljs-type">int</span> speed, <span class="hljs-type">int</span> atkSpeed, <span class="hljs-type">int</span> atkRange,            <span class="hljs-type">int</span> levelUpRequired, <span class="hljs-type">double</span> defByPercent, <span class="hljs-type">char</span> bullet, <span class="hljs-type">int</span> size) &#123;        <span class="hljs-built_in">this</span>.ATK = atk;        <span class="hljs-built_in">this</span>.LIFE = life;        <span class="hljs-built_in">this</span>.DEF = def;        <span class="hljs-built_in">this</span>.SPEED = speed;        <span class="hljs-built_in">this</span>.ATK_SPEED = atkSpeed;        <span class="hljs-built_in">this</span>.ATK_RANGE = atkRange;        <span class="hljs-built_in">this</span>.LEVEL_UP_REQUIRED = levelUpRequired;        <span class="hljs-built_in">this</span>.DEF_BY_PERCENT = defByPercent;        <span class="hljs-built_in">this</span>.BULLET = bullet;        <span class="hljs-built_in">this</span>.SIZE = size;    &#125;    Vehicle(<span class="hljs-type">int</span> atk, <span class="hljs-type">double</span> life, <span class="hljs-type">int</span> def, <span class="hljs-type">int</span> speed, <span class="hljs-type">int</span> atkSpeed, <span class="hljs-type">int</span> atkRange,            <span class="hljs-type">int</span> levelUpRequired, <span class="hljs-type">double</span> defByPercent, <span class="hljs-type">char</span> bullet) &#123;        <span class="hljs-built_in">this</span>(atk, life, def, speed, atkSpeed, atkRange, levelUpRequired, defByPercent, bullet, <span class="hljs-number">80</span>);    &#125;&#125;<span class="hljs-comment">//子弹类</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bullet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;    <span class="hljs-comment">//从上到下依次是：横坐标、纵坐标、方向、子弹速度、子弹是否存在、最大飞行范围、穿透数量、已命中的坦克</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> x;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> y;    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> dir;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> BULLET_SPEED;    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">active</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> range;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> pierce;    <span class="hljs-keyword">private</span> Tank master;    <span class="hljs-keyword">private</span> Tank[] hit;    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">pause</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Bullet</span><span class="hljs-params">(<span class="hljs-type">char</span> type, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">char</span> dir, <span class="hljs-type">int</span> range, Tank master)</span> &#123;        <span class="hljs-keyword">switch</span> (type) &#123;            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;e&#x27;</span>:                <span class="hljs-built_in">this</span>.BULLET_SPEED = <span class="hljs-number">3</span>;                <span class="hljs-built_in">this</span>.pierce = <span class="hljs-number">3</span>;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;g&#x27;</span>:                <span class="hljs-built_in">this</span>.BULLET_SPEED = <span class="hljs-number">2</span>;                <span class="hljs-built_in">this</span>.pierce = <span class="hljs-number">1</span>;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;n&#x27;</span>:            <span class="hljs-keyword">default</span>:                <span class="hljs-built_in">this</span>.BULLET_SPEED = <span class="hljs-number">1</span>;                <span class="hljs-built_in">this</span>.pierce = <span class="hljs-number">1</span>;                <span class="hljs-keyword">break</span>;        &#125;        hit = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tank</span>[pierce];        <span class="hljs-built_in">this</span>.x = x;        <span class="hljs-built_in">this</span>.y = y;        <span class="hljs-built_in">this</span>.dir = dir;        <span class="hljs-built_in">this</span>.range = range;        <span class="hljs-built_in">this</span>.master = master;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">switch</span> (dir) &#123;            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;u&#x27;</span>:                y -= BULLET_SPEED;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;d&#x27;</span>:                y += BULLET_SPEED;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;r&#x27;</span>:                x += BULLET_SPEED;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;l&#x27;</span>:                x -= BULLET_SPEED;                <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">if</span> ((range -= BULLET_SPEED) &lt;= <span class="hljs-number">0</span> || outOfArea(x, y)) &#123;     <span class="hljs-comment">//如果达到最大飞行范围，则销毁该子弹</span>            active = <span class="hljs-literal">false</span>;        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">outOfArea</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;        <span class="hljs-keyword">return</span> x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span> || x &gt; MyPanel.width - <span class="hljs-number">10</span> || y &gt; MyPanel.height - <span class="hljs-number">10</span>;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getX</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> x;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getY</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> y;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">char</span> <span class="hljs-title function_">getDir</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> dir;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getBULLET_SPEED</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> BULLET_SPEED;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHit</span><span class="hljs-params">(Tank tank)</span> &#123;             <span class="hljs-comment">//当有坦克被该子弹击中后，该方法会被调用。一般由 MyPanel 类中的 checkHit 方法调用</span>        hit[hit.length - pierce--] = tank;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasHit</span><span class="hljs-params">(Tank tank)</span> &#123;          <span class="hljs-comment">//判断一辆坦克是否已被击中过。一般由 MyPanel 类中的 checkHit 方法调用</span>        <span class="hljs-keyword">for</span> (Tank t : hit) &#123;            <span class="hljs-keyword">if</span> (t == tank) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pause</span><span class="hljs-params">(<span class="hljs-type">boolean</span> pause)</span> &#123;        <span class="hljs-built_in">this</span>.pause = pause;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">while</span> (active) &#123;            <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">1</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-keyword">if</span> (!pause) &#123;                move();            &#125;        &#125;    &#125;&#125;</code></pre></div></li><li><p><strong>Map.java</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.tank_game;<span class="hljs-keyword">import</span> java.io.Serializable;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Map</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;    Level1(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>, creatNewMap1()),    Level2(<span class="hljs-number">15</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">1</span>, Vehicle.Tank_E2, <span class="hljs-number">10</span>, creatNewMap2()),    Level3(<span class="hljs-number">20</span>, <span class="hljs-number">0.33</span>, <span class="hljs-number">0.66</span>, Vehicle.Tank_E3, <span class="hljs-number">15</span>, creatNewMap3()),    Level4(<span class="hljs-number">20</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.5</span>, Vehicle.Tank_Special, <span class="hljs-number">20</span>, creatNewMap4());    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> levelEnemyNum;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> probability_E1;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> probability_E2;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Tank boss;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][][] mapData;    <span class="hljs-comment">//[0]：种类。-1 坦克；0 道路；1 墙；2 草丛；3 水池</span>    <span class="hljs-comment">//[1]：HP。-1 不可破坏；0 可以通行；1 basic以外任意子弹击中1次可以破坏；2、3 同 1</span>    Map(<span class="hljs-type">int</span> levelEnemyNum, <span class="hljs-type">double</span> probability_E1, <span class="hljs-type">double</span> probability_E2, Vehicle boss, <span class="hljs-type">int</span> bossBuff, <span class="hljs-type">int</span>[][][] map) &#123;        <span class="hljs-built_in">this</span>.levelEnemyNum = levelEnemyNum;        <span class="hljs-built_in">this</span>.probability_E1 = probability_E1;        <span class="hljs-built_in">this</span>.probability_E2 = probability_E2;        <span class="hljs-keyword">if</span> (boss == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-built_in">this</span>.boss = <span class="hljs-literal">null</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-built_in">this</span>.boss = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enemy</span>(boss);            <span class="hljs-built_in">this</span>.boss.lifeRemains += bossBuff;        &#125;        mapData = map;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][][] creatNewMap1() &#123;        <span class="hljs-type">int</span>[][][] newMap = creatNewMap();        <span class="hljs-keyword">return</span> newMap;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][][] creatNewMap2() &#123;        <span class="hljs-type">int</span>[][][] newMap = creatNewMap();        <span class="hljs-keyword">return</span> newMap;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][][] creatNewMap3() &#123;        <span class="hljs-type">int</span>[][][] newMap = creatNewMap();        <span class="hljs-keyword">return</span> newMap;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][][] creatNewMap4() &#123;        <span class="hljs-type">int</span>[][][] newMap = creatNewMap();        <span class="hljs-keyword">return</span> newMap;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][][] creatNewMap() &#123;        <span class="hljs-type">int</span>[][][] newMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">30</span>][<span class="hljs-number">20</span>][<span class="hljs-number">2</span>];        newMap = creatBasicMap(newMap);        <span class="hljs-keyword">return</span> newMap;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][][] creatBasicMap(<span class="hljs-type">int</span>[][][] map)&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; map.length; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; map[i].length; j++) &#123;                map[i][j][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;                map[i][j][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> map;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addWall</span><span class="hljs-params">(<span class="hljs-type">int</span>[][][] map, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;        map[x][y][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        map[x][y][<span class="hljs-number">1</span>] = -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[][][] map, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> kind, <span class="hljs-type">int</span> hp)</span> &#123;        map[x][y][<span class="hljs-number">0</span>] = kind;        map[x][y][<span class="hljs-number">1</span>] = hp;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeTankCollisionSize</span><span class="hljs-params">(Tank tank)</span> &#123;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTankCollisionSize</span><span class="hljs-params">(Tank tank)</span> &#123;    &#125;&#125;</code></pre></div></li><li><p><strong>InputImage.java</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.tank_game;<span class="hljs-keyword">import</span> java.awt.*;<span class="hljs-keyword">import</span> java.io.Serializable;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-comment">/*</span><span class="hljs-comment">该类中存放所有需要的图片。</span><span class="hljs-comment">包含：坦克图片（tank/basic：4 * 2 + 1 = 9 种）；</span><span class="hljs-comment">     子弹图片（bullet：2 * 2 = 4 种）；</span><span class="hljs-comment">     护盾图片（bubble：2 * 2 = 4种）；</span><span class="hljs-comment">     星星图片（star：2种）、爆炸图片（explosion：5种）;</span><span class="hljs-comment">     地形图片（4种）</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InputImage</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Image</span> <span class="hljs-variable">tank1</span> <span class="hljs-operator">=</span> Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="hljs-string">&quot;/pic/Tank_Lv1.png&quot;</span>));    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Image</span> <span class="hljs-variable">tank2</span> <span class="hljs-operator">=</span> Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="hljs-string">&quot;/pic/Tank_Lv2.png&quot;</span>));    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Image</span> <span class="hljs-variable">tank3</span> <span class="hljs-operator">=</span> Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="hljs-string">&quot;/pic/Tank_Lv3.png&quot;</span>));    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Image</span> <span class="hljs-variable">basic</span> <span class="hljs-operator">=</span> Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="hljs-string">&quot;/pic/P.png&quot;</span>));    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Image</span> <span class="hljs-variable">basicL</span> <span class="hljs-operator">=</span> Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="hljs-string">&quot;/pic/Pl.png&quot;</span>));    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Image</span> <span class="hljs-variable">basicR</span> <span class="hljs-operator">=</span> Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="hljs-string">&quot;/pic/Pr.png&quot;</span>));    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Image</span> <span class="hljs-variable">basicLR</span> <span class="hljs-operator">=</span> Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="hljs-string">&quot;/pic/Plr.png&quot;</span>));    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Image</span> <span class="hljs-variable">tankE1</span> <span class="hljs-operator">=</span> Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="hljs-string">&quot;/pic/Tank_E1.png&quot;</span>));    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Image</span> <span class="hljs-variable">tankE2</span> <span class="hljs-operator">=</span> Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="hljs-string">&quot;/pic/Tank_E2.png&quot;</span>));    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Image</span> <span class="hljs-variable">tankE3</span> <span class="hljs-operator">=</span> Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="hljs-string">&quot;/pic/Tank_E3.png&quot;</span>));    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Image</span> <span class="hljs-variable">tank1r</span> <span class="hljs-operator">=</span> Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="hljs-string">&quot;/pic/Tank_Lv1r.png&quot;</span>));    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Image</span> <span class="hljs-variable">tank2r</span> <span class="hljs-operator">=</span> Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="hljs-string">&quot;/pic/Tank_Lv2r.png&quot;</span>));    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Image</span> <span class="hljs-variable">tank3r</span> <span class="hljs-operator">=</span> Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="hljs-string">&quot;/pic/Tank_Lv3r.png&quot;</span>));    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Image</span> <span class="hljs-variable">tankE1r</span> <span class="hljs-operator">=</span> Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="hljs-string">&quot;/pic/Tank_E1r.png&quot;</span>));    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Image</span> <span class="hljs-variable">tankE2r</span> <span class="hljs-operator">=</span> Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="hljs-string">&quot;/pic/Tank_E2r.png&quot;</span>));    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Image</span> <span class="hljs-variable">tankE3r</span> <span class="hljs-operator">=</span> Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="hljs-string">&quot;/pic/Tank_E3r.png&quot;</span>));    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Image</span> <span class="hljs-variable">tankSp</span> <span class="hljs-operator">=</span> Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="hljs-string">&quot;/pic/Tank_Sp.png&quot;</span>));    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Image</span> <span class="hljs-variable">tankSpr</span> <span class="hljs-operator">=</span> Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="hljs-string">&quot;/pic/Tank_Spr.png&quot;</span>));    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Image</span> <span class="hljs-variable">bubble</span> <span class="hljs-operator">=</span> Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="hljs-string">&quot;/pic/Bubble_red.png&quot;</span>));    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Image</span> <span class="hljs-variable">bubbleR</span> <span class="hljs-operator">=</span> Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="hljs-string">&quot;/pic/Bubble_red_r.png&quot;</span>));    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Image</span> <span class="hljs-variable">bubbleE</span> <span class="hljs-operator">=</span> Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="hljs-string">&quot;/pic/Bubble.png&quot;</span>));    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Image</span> <span class="hljs-variable">bubbleER</span> <span class="hljs-operator">=</span> Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="hljs-string">&quot;/pic/Bubble_r.png&quot;</span>));    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Image</span> <span class="hljs-variable">eBullet</span> <span class="hljs-operator">=</span> Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="hljs-string">&quot;/pic/E_bullet.png&quot;</span>));    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Image</span> <span class="hljs-variable">eBulletR</span> <span class="hljs-operator">=</span> Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="hljs-string">&quot;/pic/E_bullet_r.png&quot;</span>));    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Image</span> <span class="hljs-variable">nBullet</span> <span class="hljs-operator">=</span> Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="hljs-string">&quot;/pic/N_bullet.png&quot;</span>));    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Image</span> <span class="hljs-variable">nBulletR</span> <span class="hljs-operator">=</span> Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="hljs-string">&quot;/pic/N_bullet_r.png&quot;</span>));    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Image</span> <span class="hljs-variable">gBullet</span> <span class="hljs-operator">=</span> Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="hljs-string">&quot;/pic/G_bullet.png&quot;</span>));    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Image</span> <span class="hljs-variable">gBulletR</span> <span class="hljs-operator">=</span> Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="hljs-string">&quot;/pic/G_bullet_r.png&quot;</span>));    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Image</span> <span class="hljs-variable">star</span> <span class="hljs-operator">=</span> Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="hljs-string">&quot;/pic/Star.png&quot;</span>));    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Image</span> <span class="hljs-variable">nStar</span> <span class="hljs-operator">=</span> Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="hljs-string">&quot;/pic/Star_n.png&quot;</span>));    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Image</span> <span class="hljs-variable">explosion1</span> <span class="hljs-operator">=</span> Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="hljs-string">&quot;/pic/Explosion/Explosion1.png&quot;</span>));    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Image</span> <span class="hljs-variable">explosion2</span> <span class="hljs-operator">=</span> Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="hljs-string">&quot;/pic/Explosion/Explosion2.png&quot;</span>));    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Image</span> <span class="hljs-variable">explosion3</span> <span class="hljs-operator">=</span> Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="hljs-string">&quot;/pic/Explosion/Explosion3.png&quot;</span>));    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Image</span> <span class="hljs-variable">explosion4</span> <span class="hljs-operator">=</span> Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="hljs-string">&quot;/pic/Explosion/Explosion4.png&quot;</span>));    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Image</span> <span class="hljs-variable">explosion5</span> <span class="hljs-operator">=</span> Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="hljs-string">&quot;/pic/Explosion/Explosion5.png&quot;</span>));    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Image</span> <span class="hljs-variable">iron</span> <span class="hljs-operator">=</span> Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="hljs-string">&quot;/pic/Landform/Iron.png&quot;</span>));    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Image</span> <span class="hljs-variable">wall</span> <span class="hljs-operator">=</span> Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="hljs-string">&quot;/pic/Landform/Wall.png&quot;</span>));    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Image</span> <span class="hljs-variable">water</span> <span class="hljs-operator">=</span> Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="hljs-string">&quot;/pic/Landform/Water.png&quot;</span>));    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Image</span> <span class="hljs-variable">trees</span> <span class="hljs-operator">=</span> Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="hljs-string">&quot;/pic/Landform/Trees.png&quot;</span>));&#125;</code></pre></div></li><li><p><strong>Timing.java</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.melody.tank_game;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Timing</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> time;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Timing</span><span class="hljs-params">(<span class="hljs-type">int</span> time)</span>&#123;        <span class="hljs-built_in">this</span>.time = time;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">try</span> &#123;            Thread.sleep(time);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        MyPanel.gameSuspend = <span class="hljs-literal">true</span>;    &#125;&#125;</code></pre></div></li><li><p>导入的图片</p><p><img src="/img/Java_InputImage/pic/Bubble.png" /></p><figure><img src="/img/Java_InputImage/pic/Bubble_r.png" alt="Bubble_r" /><figcaption aria-hidden="true">Bubble_r</figcaption></figure><figure><img src="/img/Java_InputImage/pic/Bubble_red.png" alt="Bubble_red" /><figcaption aria-hidden="true">Bubble_red</figcaption></figure><figure><img src="/img/Java_InputImage/pic/Bubble_red_r.png"alt="Bubble_red_r" /><figcaption aria-hidden="true">Bubble_red_r</figcaption></figure><figure><img src="/img/Java_InputImage/pic/E_bullet.png" alt="E_bullet" /><figcaption aria-hidden="true">E_bullet</figcaption></figure><figure><img src="/img/Java_InputImage/pic/E_bullet_r.png" alt="E_bullet_r" /><figcaption aria-hidden="true">E_bullet_r</figcaption></figure><figure><img src="/img/Java_InputImage/pic/G_Bullet.png" alt="G_Bullet" /><figcaption aria-hidden="true">G_Bullet</figcaption></figure><figure><img src="/img/Java_InputImage/pic/G_Bullet_r.png" alt="G_Bullet_r" /><figcaption aria-hidden="true">G_Bullet_r</figcaption></figure><figure><img src="/img/Java_InputImage/pic/N_bullet.png" alt="N_bullet" /><figcaption aria-hidden="true">N_bullet</figcaption></figure><figure><img src="/img/Java_InputImage/pic/N_bullet_r.png" alt="N_bullet_r" /><figcaption aria-hidden="true">N_bullet_r</figcaption></figure><figure><img src="/img/Java_InputImage/pic/p.png" alt="p" /><figcaption aria-hidden="true">p</figcaption></figure><figure><img src="/img/Java_InputImage/pic/pl.png" alt="pl" /><figcaption aria-hidden="true">pl</figcaption></figure><figure><img src="/img/Java_InputImage/pic/plr.png" alt="plr" /><figcaption aria-hidden="true">plr</figcaption></figure><figure><img src="/img/Java_InputImage/pic/Pr.png" alt="Pr" /><figcaption aria-hidden="true">Pr</figcaption></figure><figure><img src="/img/Java_InputImage/pic/Star.png" alt="Star" /><figcaption aria-hidden="true">Star</figcaption></figure><figure><img src="/img/Java_InputImage/pic/Star_n.png" alt="Star_n" /><figcaption aria-hidden="true">Star_n</figcaption></figure><figure><img src="/img/Java_InputImage/pic/Tank_E1.png" alt="Tank_E1" /><figcaption aria-hidden="true">Tank_E1</figcaption></figure><figure><img src="/img/Java_InputImage/pic/Tank_E1r.png" alt="Tank_E1r" /><figcaption aria-hidden="true">Tank_E1r</figcaption></figure><figure><img src="/img/Java_InputImage/pic/Tank_E2.png" alt="Tank_E2" /><figcaption aria-hidden="true">Tank_E2</figcaption></figure><figure><img src="/img/Java_InputImage/pic/Tank_E2r.png" alt="Tank_E2r" /><figcaption aria-hidden="true">Tank_E2r</figcaption></figure><figure><img src="/img/Java_InputImage/pic/Tank_E3.png" alt="Tank_E3" /><figcaption aria-hidden="true">Tank_E3</figcaption></figure><figure><img src="/img/Java_InputImage/pic/Tank_E3r.png" alt="Tank_E3r" /><figcaption aria-hidden="true">Tank_E3r</figcaption></figure><figure><img src="/img/Java_InputImage/pic/Tank_Lv1.png" alt="Tank_Lv1" /><figcaption aria-hidden="true">Tank_Lv1</figcaption></figure><figure><img src="/img/Java_InputImage/pic/Tank_Lv1r.png" alt="Tank_Lv1r" /><figcaption aria-hidden="true">Tank_Lv1r</figcaption></figure><figure><img src="/img/Java_InputImage/pic/Tank_Lv2.png" alt="Tank_Lv2" /><figcaption aria-hidden="true">Tank_Lv2</figcaption></figure><figure><img src="/img/Java_InputImage/pic/Tank_Lv2r.png" alt="Tank_Lv2r" /><figcaption aria-hidden="true">Tank_Lv2r</figcaption></figure><figure><img src="/img/Java_InputImage/pic/Tank_Lv3.png" alt="Tank_Lv3" /><figcaption aria-hidden="true">Tank_Lv3</figcaption></figure><figure><img src="/img/Java_InputImage/pic/Tank_Lv3r.png" alt="Tank_Lv3r" /><figcaption aria-hidden="true">Tank_Lv3r</figcaption></figure><figure><img src="/img/Java_InputImage/pic/Tank_Sp.png" alt="Tank_Sp" /><figcaption aria-hidden="true">Tank_Sp</figcaption></figure><figure><img src="/img/Java_InputImage/pic/Tank_Spr.png" alt="Tank_Spr" /><figcaption aria-hidden="true">Tank_Spr</figcaption></figure><p><img src="/img/Java_InputImage/pic/Landform/Iron.png" /></p><figure><img src="/img/Java_InputImage/pic/Landform/Trees.png" alt="Trees" /><figcaption aria-hidden="true">Trees</figcaption></figure><figure><img src="/img/Java_InputImage/pic/Landform/Wall.png" alt="Wall" /><figcaption aria-hidden="true">Wall</figcaption></figure><figure><img src="/img/Java_InputImage/pic/Landform/Water.png" alt="Water" /><figcaption aria-hidden="true">Water</figcaption></figure><p><img src="/img/Java_InputImage/pic/Explosion/Explosion1.png" /></p><figure><img src="/img/Java_InputImage/pic/Explosion/Explosion2.png"alt="Explosion2" /><figcaption aria-hidden="true">Explosion2</figcaption></figure><figure><img src="/img/Java_InputImage/pic/Explosion/Explosion3.png"alt="Explosion3" /><figcaption aria-hidden="true">Explosion3</figcaption></figure><figure><img src="/img/Java_InputImage/pic/Explosion/Explosion4.png"alt="Explosion4" /><figcaption aria-hidden="true">Explosion4</figcaption></figure><figure><img src="/img/Java_InputImage/pic/Explosion/Explosion5.png"alt="Explosion5" /><figcaption aria-hidden="true">Explosion5</figcaption></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>程序</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt;17 IO流</title>
    <link href="/2022/01/06/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/17%20IO%E6%B5%81/"/>
    <url>/2022/01/06/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/17%20IO%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="io流">17 IO流</h1><h2 id="文件">17.1 文件</h2><blockquote><p>文件就是保存数据的地方。</p><p>文件流：文件 在 程序 中是以 流 的形式来操作的。</p><p>流：数据在数据源（文件）和程序（内存）之间经历的路径</p><p>输入流：数据从数据源到程序的路径</p><p>输出流：数据从程序到数据源的路径</p></blockquote><h3 id="常用的文件操作">17.1.1 常用的文件操作</h3><blockquote><p>Java 提供了 File 类，用于处理文件相关的操作</p></blockquote><ol type="1"><li><p>创建文件对象相关构造器和方法</p><ul><li><p><code>new File(String pathname)</code>：根据路径创建一个 File对象</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">path1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;d:/test.jpg&quot;</span>;<span class="hljs-type">String</span> <span class="hljs-variable">path2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;d:\\test.jpg&quot;</span>;<span class="hljs-type">File</span> <span class="hljs-variable">file1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path1);<span class="hljs-type">File</span> <span class="hljs-variable">file2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path2);<span class="hljs-comment">//此时只是在内存中产生了一个对象</span></code></pre></div></blockquote></li><li><p><code>new File(File parent, String child)</code>：根据父目录文件+ 子路径构建</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">parentFile1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;d:\\&quot;</span>);<span class="hljs-type">String</span> <span class="hljs-variable">fileName1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test.txt&quot;</span>;<span class="hljs-type">File</span> <span class="hljs-variable">file3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(parentFile1, fileName1);</code></pre></div></blockquote></li><li><p><code>new File(String parent, String child)</code>：根据父路径 +子路径构建</p></li><li><p><code>creatNewFile()</code>：创建新文件</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123; file.createNewFile();<span class="hljs-comment">//这个场合，内存对象才写入磁盘</span>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123; e.printStackTrace();&#125;</code></pre></div></blockquote></li></ul></li><li><p>获取文件相关信息</p><ul><li><p><code>getName()</code>：获取名称</p></li><li><p><code>getAbsolutePath()</code>：获取文件绝对路径</p></li><li><p><code>getParent()</code>：获取文件父级目录</p></li><li><p><code>long length()</code>：获取文件大小（字节）</p></li><li><p><code>exists()</code>：文件是否存在</p></li><li><p><code>isFile()</code>：是不是一个文件</p></li><li><p><code>isDirectory()</code>：是不是一个目录</p></li><li><p><code>isAbsolute()</code>：是不是绝对路径</p></li><li><p><code>canRead()</code>：是否可读</p><p><code>canWirte()</code>：是否可写</p></li><li><p><code>long lastModified()</code>：最后修改时间</p></li><li><p><code>String[] list()</code>：列出符合模式的文件名</p></li></ul></li><li><p>目录的操作和文件删除</p><ul><li><code>mkdir</code>：创建一级目录</li><li><code>mkdirs</code>：创建多级目录</li><li><code>delete</code>：删除空目录或文件</li><li><code>boolean renameTo(File newName)</code>：更改文件名</li></ul><p>其实目录（在内存看来）就是特殊的文件</p></li></ol><p>注意事项：</p><ul><li>File类可以获取文件的各种相关属性，可以对其进行改名，甚至删除。但除了文件名外的属性没有修改方法</li><li>File 类可以用来描述一个目录，但不能改变目录名，也不能删除目录</li></ul><h2 id="io流-1">17.2 IO流</h2><ol type="1"><li>I / O 是 Input / Output 的缩写。IO技术是非常实用的技术，用于处理数据传输。如 读 / 写文件，网络通讯等。</li><li>Java 程序中，对于数据的 输入 / 输出 操作以“流（stream）”的方式进行</li><li><code>java.io</code> 包下提供了各种 “流”类和接口，用以获取不同种类的数据，并通过方法输入或输出数据</li><li>输入（input）：读取外部数据（磁盘、光盘、网络数据等）到程序（内存）中</li><li>输出（output）：将程序（内存）数据输出到外部存储</li></ol><h3 id="io流的分类">17.2.1 IO流的分类</h3><ul><li><p>按操作数据单位不同分为：</p><ul><li>字节流（8 bit）：二进制文件用该方法，能确保文件无损</li><li>字符流（按照字符，字符的字节数由编码决定）：文本文件，效率更高</li></ul></li><li><p>按数据流的流向不同分为：</p><ul><li>输入流：读取外部数据（磁盘、光盘、网络数据等）到程序（内存）中</li><li>输出流：将程序（内存）数据输出到外部存储</li></ul></li><li><p>按流的角色不同分为：</p><ul><li>节点流</li><li>处理流 / 包装流</li></ul><table><thead><tr class="header"><th>Σ(っ °Д °;)っ</th><th>字节流</th><th>字符流</th></tr></thead><tbody><tr class="odd"><td>输入流</td><td>InputStream</td><td>Reader</td></tr><tr class="even"><td>输出流</td><td>OutputStream</td><td>Writer</td></tr></tbody></table></li></ul><p>Java 的 IO流 总共涉及 40多个类，实际上都是上述 4类的抽象基类派生的</p><p>由这 4 个类派生的子类名称都是以其父类名作为子类名后缀</p><h3 id="io流-常用类">17.2.2 IO流 常用类</h3><h4 id="fileinputstream文件字节输入流">17.2.2.1<code>FileInputStream</code>：文件字节输入流</h4><ul><li><p>构造器：</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(File file);<span class="hljs-comment">//通过一个 File 的路径指定创建</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(String path);<span class="hljs-comment">//通过一个路径指定创建</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(FileDescriptor fdObj);<span class="hljs-comment">//通过文件描述符创建</span></code></pre></div></blockquote></li><li><p>方法：</p><ul><li><p><code>available()</code>：返回目前可以从流中读取的字节数</p><p>实际操作时，读取的字节数可能大于这个返回值</p></li><li><p><code>close()</code>：关闭文件输入流，释放资源</p></li><li><p><code>finalize()</code>：确保在不引用文件输入流时调用其<code>close()</code> 方法</p></li><li><p><code>getChannel()</code>：返回与此流有关的唯一的<code>FileChannel</code> 对象</p></li><li><p><code>getFD()</code>：返回描述符</p></li><li><p><code>read()</code>：从该输入流中读取一个数据字节</p><p>如果没有输入可用，该方法会被阻止。返回 -1的场合，说明到达文件的末尾。</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;d:\\test&quot;</span>);<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-type">int</span> read;<span class="hljs-keyword">try</span> &#123; fileInputStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file); <span class="hljs-keyword">while</span> ((read = fileInputStream.read()) != -<span class="hljs-number">1</span>)&#123;     System.out.print((<span class="hljs-type">char</span>) read); &#125;&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123; e.printStackTrace();&#125; <span class="hljs-keyword">finally</span> &#123; <span class="hljs-keyword">try</span> &#123;     fileInputStream.close(); &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;     e.printStackTrace(); &#125;&#125;<span class="hljs-comment">//真 TM 复杂。throw 了算了</span></code></pre></div><p>这个场合，效率较低</p></blockquote><p><code>read(byte[] b)</code>：从该输入流中把最多 b.length个字节的数据读入一个 byte 数组</p><p>读取正常的场合，返回实际读取的字节数。</p><blockquote><div class="code-wrapper"><pre><code class="hljs java">...<span class="hljs-type">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">8</span>];<span class="hljs-comment">//一次读取 8 字节</span><span class="hljs-keyword">try</span> &#123; fileInputStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file); <span class="hljs-keyword">while</span> ((read = fileInputStream.read(b)) != -<span class="hljs-number">1</span>)&#123;     System.out.print(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(b, <span class="hljs-number">0</span>, read));     <span class="hljs-comment">//这一句看不懂请看[12.2 - 4]</span> &#125;<span class="hljs-keyword">catch</span> ...<span class="hljs-keyword">finally</span>...</code></pre></div></blockquote><p><code>read(byte[] b, int off, int len)</code>：从该输入流中读取 len字节数据，从数组下标 off 处起写入</p></li><li><p><code>skip(long n)</code>：从该输入流中跳过并去丢弃 n个字节的数据</p></li><li><p><code>mark(int markArea)</code>：标记数据量的当前位置，并划出一个缓冲区。缓冲区大小至少为markArea</p><p><code>reset()</code>：将输入流重新定位到对此流最后调用<code>mark()</code> 方法时的位置</p><p><code>markSupported()</code>：测试数据流是否支持 <code>mark()</code>和 <code>reset()</code> 操作</p></li></ul></li></ul><h4 id="fileoutputstream文件字节输出流">17.2.2.2<code>FileOutputStream</code>：文件字节输出流</h4><ul><li><p>构造器：</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(File file);<span class="hljs-comment">//通过一个 File 的路径指定创建</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(File file, <span class="hljs-type">boolean</span> append);<span class="hljs-comment">//append = false，写入采用 覆盖原文件 方式</span><span class="hljs-comment">//append = true 的场合，写入采用 末尾追加 方式</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(String path);<span class="hljs-comment">//通过一个路径指定创建</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(String path, <span class="hljs-type">boolean</span> append);<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(FileDescriptor fdObj);<span class="hljs-comment">//通过文件描述符创建</span></code></pre></div></blockquote></li><li><p>方法：</p><ul><li><p><code>close()</code>：关闭文件输入流，释放资源</p></li><li><p><code>flush()</code>：刷新此输出流并强制写出所有缓冲的输出字节</p></li><li><p><code>finalize()</code>：确保在不引用文件输入流时调用其<code>close()</code> 方法</p></li><li><p><code>getChannel()</code>：返回与此流有关的唯一的<code>FileChannel</code> 对象</p></li><li><p><code>getFD()</code>：返回描述符</p></li><li><p><code>write(byte[] b)</code>：将 b.length 个字节从指定 byte数组写入此文件输出流</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;d:\\test1&quot;</span>);<span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-keyword">try</span> &#123; fileOutputStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(file); <span class="hljs-comment">//此时，若文件不存在会被创建</span> fileOutputStream.write(<span class="hljs-string">&#x27;a&#x27;</span>); <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Melody&quot;</span>; fileOutputStream.write(str.getBytes());&#125; <span class="hljs-keyword">catch</span>...<span class="hljs-keyword">finally</span>...</code></pre></div></blockquote><p><code>write(byte[] b， int off, int len)</code>：将指定 byte数组中下标 off 开始的 len 个字节写入此文件输出流</p><p><code>write(int b)</code>：将指定字节写入此文件输出流</p></li></ul></li></ul><h4 id="filereader文件字符输入流">17.2.2.3<code>FileReader</code>：文件字符输入流</h4><blockquote><p>与其他程序设计语言使用 ASCII 码不同，Java 使用 Unicode码表示字符串和字符。ASCII 码的字符占用 1字节，可以认为一个字符就是一个字节。但 Unicode 码用 2 字节表示 1个字符，此时字符流和字节流就不相同。</p></blockquote><ul><li><p>构造器：</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">FileRaeder</span>(File file);<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileRaeder</span>(String string);</code></pre></div></blockquote></li><li><p>方法：</p><ul><li><code>read()</code>：读取单个字符。</li><li><code>read(char[])</code>：批量读取多个字符到数组。</li></ul></li></ul><h4 id="filewriter文件字符输出流">17.2.2.3<code>FileWriter</code>：文件字符输出流</h4><ul><li><p>构造器：</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(File path);<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(String path2);<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(File path3, <span class="hljs-type">boolean</span> append);<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(String path4, <span class="hljs-type">boolean</span> append);</code></pre></div></blockquote></li><li><p>方法：</p><ul><li><code>write(int)</code>：写入单个字符</li><li><code>write(char[])</code>：写入指定数组</li><li><code>write(char[], off, len)</code>：写入指定数组的指定部分</li><li><code>write(string)</code>：写入字符串</li><li><code>write(string, off, len)</code>：写入字符串的指定部分</li><li><code>flush()</code>：刷新该流的缓冲。如果没有执行，内容就不会写入文件</li><li><code>close()</code>：等于 <code>flush()</code> + 关闭</li></ul><p><strong>注意！<code>FileWriter</code>使用后，必须关闭（close）或刷新（flush），否则无法真正写入</strong></p></li></ul><h4 id="转换流-inputstreamreader-和-outputstreamwriter">17.2.2.4 转换流<code>InputStreamReader</code> 和 <code>OutputStreamWriter</code></h4><ol type="1"><li><code>InputStreamReader</code> 是 <code>Reader</code> 的子类。可以把<code>InputStream</code>（字节流）转换成<code>Reader</code>（字符流）</li><li><code>OutputStreamWriter</code> 是 <code>Writer</code>的子类。可以把 <code>OutputStream</code>（字节流）转换成<code>Writer</code>（字符流）</li><li>处理纯文本数据时，如果使用字符流效率更高，并能有效解决中文问题，建议将字节流转换成字符流。</li><li>可以在使用时指定编码格式（UTF -8、GBK 等）</li></ol><ul><li><p>构造器</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">isr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(fileInputStream, <span class="hljs-string">&quot;UTF-8&quot;</span>);<span class="hljs-comment">//传入 字节流 和 编码类型</span><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bufferedreader</span>(isr);<span class="hljs-comment">//用另一个处理流包装</span></code></pre></div></blockquote></li></ul><h3 id="节点流和处理流">17.2.3 节点流和处理流</h3><ol type="1"><li>节点流：从一个特定数据源读写数据。</li><li>处理流（包装流）：是 “连接”在已存在的流（节点流或处理流）上，为程序提供更强大的读写功能。</li></ol><h4 id="节点流和处理流的区别和联系">节点流和处理流的区别和联系</h4><ol type="1"><li>节点流是 底层流 / 低级流。直接和数据源相接。</li><li>处理流（包装流）包装节点流，既可以消除不同节点流的实现差异，也可以提供更方便的方法完成输入输出</li><li>处理流对节点流进行包装，使用了修饰器设计模式。不会直接与数据源相连</li><li>处理流的功能主要体现在<ul><li>性能的提高：以增加缓冲的方式提高输入输出的效率</li><li>操作的便捷：处理流可能提供了一系列便捷方法来一次性输入大量数据，使用更加灵活方便</li></ul></li><li>关闭时关闭外层流即可</li></ol><h4 id="缓冲区流">17.2.3.1 缓冲区流</h4><blockquote><p>缓冲区流是一种包装流。缓冲区字节流有 BufferedInputStream 和BufferedOutputStream；缓冲区字符流有 BufferedWriter 和BufferedReader。他们是在数据流上加了一个缓冲区。读写数据时，数据以块为单位进入缓冲区，其后的读写操作则作用于缓冲区。</p><p>这种方式能降低不同硬件设备间的速度差异，提高 I/O 效率。</p></blockquote><p>构造器：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(reader);<span class="hljs-comment">//传入一个 Reader</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(reader, <span class="hljs-number">1024</span>);<span class="hljs-comment">//传入 Reader 并指定缓冲区大小</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(writer);<span class="hljs-comment">//传入一个 Writer</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(writer, <span class="hljs-number">1024</span>);<span class="hljs-comment">//传入 Writer 并指定缓冲区大小</span><span class="hljs-comment">//追加还是覆盖，取决于 writer</span></code></pre></div><p>方法：</p><ul><li><p><code>bufferedReader.readLine()</code>：按行读取（不含换行符）。</p><p>会返回一个字符串。返回 null 时，表示读取完毕。</p><blockquote><div class="code-wrapper"><pre><code class="hljs java">String line;<span class="hljs-keyword">while</span> (line = bufferedReader.readLine() != <span class="hljs-literal">null</span>)&#123; ...&#125;bufferedReader.close();</code></pre></div></blockquote></li><li><p><code>bufferedWriter.write(String str)</code>：插入字符串</p></li><li><p><code>bufferedWriter.newLine()</code>：插入一个（和系统相关的）换行</p></li></ul><h4 id="数据数据流">17.2.3.2 数据数据流</h4><blockquote><p>除了字节或字节数组外，处理的数据还有其他类型。为解决此问题，可以使用DataInputStream 和 DataOutputStream。它们允许通过数据流来读写 Java基本类型，如布尔型（boolean）、浮点型（float）等</p></blockquote><p>构造器：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(inputStream);<span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(outputStream);</code></pre></div><p>方法：</p><ul><li><p><code>byte readByte()</code>：读取下一个 byte</p><p><code>int readInt()</code>、<code>double readDouble()</code>、<code>String readUTF()</code>……</p></li><li><p><code>void writeByte(byte b)</code>：写入一个 byte</p><p><code>void writeInt(int n)</code>、<code>void writeUTF(String str)</code>……</p><p>虽然有对字符串的读写方法，但应避免使用这些方法，转而使用字符输入/输出流。</p></li></ul><h4 id="对象流">17.2.3.3 对象流</h4><blockquote><p>当我们保存数据时，同时也把 数据类型 或 对象 保存。</p><p>以上要求，就是能够将 基本数据类型 或 对象 进行 序列化·反序列化操作</p></blockquote><p><strong>序列化和反序列化</strong></p><ol type="1"><li>把对象转成字符序列的过程称为序列化。保存数据时，保存数据的值和数据类型</li><li>把字符序列转成对象的过程称为反序列化。恢复数据时，恢复数据的值和数据类型</li><li>需要让某个对象支持序列化机制，则必须让其类是可序列化的。由此，该类必须实现下列接口之一<ul><li><code>Serializable</code>：推荐。因为是标记接口，没有方法</li><li><code>Externalizable</code>：该接口有方法需要实现</li></ul></li></ol><p><strong>transient 关键字</strong></p><ol type="1"><li>有一些对象状态不具有可持久性（如 Thread对象或流对象），这样的成员变量必须用 transient 关键字标明。任何标有transient 关键字的成员变量都不会被保存。</li><li>一些需要保密的数据，不应保存在永久介质中。为保证安全，这些变量前应加上transient 关键字。</li></ol><ul><li><p>构造器：</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(InputStream inputStream);<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(OutputStream outputStream);</code></pre></div></blockquote></li><li><p>方法：</p><p>反序列化顺序需要和序列化顺序一致，否则出现异常。</p><ul><li><p><code>writeInt(Integer)</code>：写入一个 int</p><p><code>readInt()</code>：读取一个 int</p></li><li><p><code>writeBoolean(Boolaen)</code>：写入一个 boolean</p><p><code>readBoolean()</code>：读取一个 boolean</p></li><li><p><code>writeChar(Character)</code>：写入一个 char</p><p><code>readChar()</code>：读取一个 char</p></li><li><p><code>writeDouble(Double)</code>：写入一个 double</p><p><code>readDouble()</code>：读取一个 double</p></li><li><p><code>writeUTF(String)</code>：写入一个 String</p><p><code>readUTF()</code>：读取一个 String</p></li><li><p><code>writeObject(Serializable)</code>：写入一个 Obj</p><p><code>readObject()</code>：读取一个 Obj</p><p>读取的场合，如果想要调用方法，需要向下转型。</p><p>为此，需要该类其引入，或将类的定义拷贝到可以引用的位置。</p></li></ul></li><li><p><strong>注意事项</strong></p><ol type="1"><li><p>读写顺序要一致</p></li><li><p>实现序列化或反序列化的对象，要实现 <code>Serializable</code> 或<code>Externalizable</code> 接口</p></li><li><p>序列化的类中建议添加 <code>SerialVersionUID</code>以提高版本兼容性</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;</code></pre></div></blockquote><p>有此序列号的场合，后续修改该类，系统会认为只是版本修改，而非新的类</p></li><li><p>序列化对象时，默认将其中所有属性进行序列化（除了<code>static</code> 和 <code>tansient</code> 修饰的成员）</p></li><li><p>序列化对象时，要求其属性也实现序列化接口</p></li><li><p>序列化具备可继承性。某类若实现可序列化，则其子类也可序列化</p></li></ol></li></ul><h4 id="标准输入-输出流">17.2.3.4 标准输入 / 输出流</h4><table><thead><tr class="header"><th>Σ( ° △ °lll）</th><th>编译类型</th><th>运行类型</th><th>默认设备</th></tr></thead><tbody><tr class="odd"><td><code>System.in</code>：标准输入</td><td><code>InputStream</code></td><td><code>BufferedInputStream</code></td><td>键盘</td></tr><tr class="even"><td><code>System.out</code>：标准输出</td><td><code>PaintStream</code></td><td><code>PaintStream</code></td><td>显示器</td></tr></tbody></table><h4 id="打印流-paintstream-和-paintwriter">17.2.3.5 打印流<code>PaintStream</code> 和 <code>PaintWriter</code></h4><blockquote><p>打印流只有输出流，没有输入流</p></blockquote><ol type="1"><li><p><code>PaintStream</code> 是 <code>OutputStream</code>的子类。<code>PaintWriter</code> 是 <code>Writer</code>的子类。</p></li><li><p>默认情况下，<code>System.out</code> 输出位置是标准输出（即：显示器）</p><p>修改默认输出位置：</p><blockquote><div class="code-wrapper"><pre><code class="hljs java">System.setOut(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(path));</code></pre></div></blockquote></li></ol><h4 id="properties-类">17.2.3.6 <code>Properties</code> 类</h4><ol type="1"><li><p><code>Properties</code> 是专门用于读写配置文件的集合类</p><p>底层维护了一个 <code>Entry</code> 数组</p></li><li><p>配置文件格式：</p><div class="code-wrapper"><pre><code class="hljs abnf">键<span class="hljs-operator">=</span>值键<span class="hljs-operator">=</span>值…</code></pre></div><p><strong>注意：键值对不需要空格，值不需要引号（值默认<code>String</code>）</strong></p></li><li><p>常见方法：</p><ul><li><p><code>load(InputStream)</code></p><p><code>load(Reader)</code>：加载配置文件的键值对到<code>Properties</code> 对象</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();properties.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;d:\\data.data&quot;</span>));</code></pre></div></blockquote></li><li><p><code>list(PaintStream)</code></p><p><code>list(PaintWriter)</code>：将数据显示到指定设备</p><blockquote><div class="code-wrapper"><pre><code class="hljs java">properties.list(System.out);<span class="hljs-comment">//在控制台显示</span></code></pre></div></blockquote></li><li><p><code>getProperty(key)</code>：根据键获取值</p><blockquote><div class="code-wrapper"><pre><code class="hljs java">properties.get(<span class="hljs-string">&quot;IQ&quot;</span>);</code></pre></div></blockquote></li><li><p><code>setProperty(key, value)</code>：设置键值对到<code>Properties</code> 对象</p><p>如果没有该 key，就是创建。如有，就是替换。</p><blockquote><div class="code-wrapper"><pre><code class="hljs java">properties.set(<span class="hljs-string">&quot;IQ&quot;</span>, <span class="hljs-number">0</span>);properties.set(<span class="hljs-string">&quot;Balance&quot;</span>, <span class="hljs-number">0</span>);</code></pre></div></blockquote></li><li><p><code>store(Writer, String)</code></p><p><code>store(OutputStream, String)</code>：把 <code>Properties</code>中的键值对存储到配置文件。</p><p>后面的 <code>String</code> 是注释。如有，会被用 <code>#</code>标记并写在文件最上方。注释可以为 null。</p><p>IDEA 中，如果含有中文，会储存为 unicode 码</p><p><a href="http://tool.chinaz.com/tools/unicode.aspx">查询 unicode码</a></p></li></ul></li></ol><h4 id="随机访问文件">17.2.3.7 随机访问文件</h4><blockquote><p>程序阅读文件时不仅要从头读到尾，还要实现每次在不同位置进行读取。此时可以使用RandomAccessFile</p></blockquote><p>构造器：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(String name, String mode);<span class="hljs-comment">//通过文件名</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(File file, String mode);<span class="hljs-comment">//通过文件对象</span></code></pre></div><blockquote><p>参数 mode 决定以只读方式 <code>mode = "r"</code> 还是读写方式<code>mode = "rw"</code> 访问文件。</p></blockquote><p>方法：</p><ul><li><p><code>long getFilePointer()</code>：返回文档指针的当前位置</p></li><li><p><code>void seek(long pos)</code>：将文档指针置于指定的绝对位置pos</p><p>文档指针的位置从文档开始的字符处开始计算，<code>pos = 0L</code>表示文档的开始</p></li><li><p><code>long length()</code>：返回文件长度</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt;16 多线程</title>
    <link href="/2022/01/01/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/16%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2022/01/01/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/16%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="多线程">16 多线程</h1><h2 id="线程的概念">16.1 线程的概念</h2><blockquote><p>对于一般程序而言，其结构大都可以分为一个入口、一个出口、一个顺次执行的语句序列。这样的语句结构称为进程，它是程序的一次动态执行，对应了代码加载、执行至完毕的全过程。</p><p>进程即是程序在处理机中的一次运行。在这样一个结构中不仅包含程序代码，也包括了系统资源的概念。</p><p>在单 CPU计算机内部，微观上讲，同一时间只能有一个线程运行。实现多线程即从宏观上使多个作业同时执行。</p></blockquote><p>程序：为完成特定任务，用某种语言编写的一组指令的集合。</p><p>进程：运行中的程序。当你运行一个程序，系统就会为该进程分配空间。进程是程序的一次执行过程。是一个动态过程：有其自身产生、存在、消亡的过程。</p><p>线程：由进程创建的，进程的一个实体。一个进程可以有多个线程。</p><p>单线程：同一时刻，只允许执行一个线程。</p><p>多线程：同一时刻，可以执行多个线程。</p><p>并发：同一时刻，多个任务交替执行，造成一种貌似并行的状态。单核 CPU实现的多任务就是并发。</p><p>并行：同一时刻，多个任务同时进行。多核 CPU 可以实现并行。</p><h3 id="线程的结构">16.1.1 线程的结构</h3><p>在 Java 中，线程由以下 3 部分组成：</p><ul><li>虚拟 CPU：封装在 java.lang.Thread 类中，控制着整个线程的运行</li><li>执行的代码：传递给 Thread 类，由其控制按序执行</li><li>处理的数据：传递给 Thread 类，是在代码执行过程中需要处理的数据</li></ul><h3 id="线程的状态">16.1.2 线程的状态</h3><blockquote><p>Java 的线程是通过包 java.lang 中定义的类 Thread来实现的。当生成了一个 Thread类后就产生了一个线程。通过该对象实例，可以启动线程、终止线程，或暂时挂起线程</p></blockquote><p>线程共有 4种状态：新建（New）、可运行（Runnable）、死亡（Dead）、阻塞（Blocked）</p><ul><li><p><strong>新建（New）：</strong></p><p>线程对象刚刚创建，还未启动（New）。此时还处于不可运行状态，但已有了相应内存空间及其他资源</p></li><li><p><strong>可运行（Runnable）：</strong></p><p>此时线程已经启动，处于线程的 <code>run()</code>方法中。这种情况下线程可能正在运行；也可能没有运行，但只要 CPU空闲就会立刻运行。</p><p>可以运行但没在运行的线程都排在一个队列中，这个队列称为就绪队列。</p><p>可运行状态下，运行中的线程处于运行状态（Running），未运行线程处于就绪状态（Ready）。</p><p>调用 <code>start()</code> 方法可以让线程进入可运行状态。</p></li><li><p><strong>死亡（Dead）：</strong></p><p>线程死亡（Terminated）的原因有两个：一是 <code>run()</code>方法最后一个语句执行完毕，二是线程遇到异常退出</p></li><li><p><strong>阻塞（Blocked）：</strong></p><p>一个正常运行的线程因为特殊原因被暂停执行，就进入阻塞状态（Blocked）。</p><p>阻塞时线程不能进入就绪对流排队，必须等到引起阻塞的原因消除，才能重新进入队列排队。</p><p>引起阻塞的方法很多，<code>sleep()</code> 和 <code>wait()</code>是两个常用的阻塞方法</p></li><li><p><strong>中断线程：</strong></p><ul><li><p><code>void interrupt()</code>：向一个线程发送一个中断请求，并把该线程的interruptd 状态变为 true。</p><p>中断阻塞线程的场合，会抛出 InterruptException 异常</p></li><li><p><code>static boolean interrupted()</code>：检测当前线程是否被中断，并重置状态interrupted 的值。</p><p>连续调用该方法的场合，第二次调用会返回 false</p></li><li><p><code>boolean isInterrupted()</code>：检测当前线程是否中断。不改变interrupted 的值</p></li></ul></li></ul><h2 id="线程的使用">16.2 线程的使用</h2><p>在 Java 中线程使用有两种方法：</p><ol type="1"><li><p>继承 <code>Thread</code> 类，重写 <code>run</code> 方法</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span><span class="hljs-comment">//可见 Thread 也是实现了 Runable 接口</span></code></pre></div></blockquote></li><li><p>实现 <code>Runable</code> 接口，重写 <code>run</code>方法</p></li></ol><h3 id="继承-thread-类">16.2.1 继承 Thread 类</h3><blockquote><p>Thread 类是 Java用于表示线程的类。那么，一个类被定义为其子类，则该类也能用来表示线程</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123; <span class="hljs-type">Type</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Type</span>(); type.start();<span class="hljs-comment">//开始线程</span> <span class="hljs-comment">//如果用 run 方法，则还是停留在主线程</span> <span class="hljs-comment">//  那样，相当于 串行。执行完毕才继续</span>&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Type</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<span class="hljs-comment">//先继承 Thread 类</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;     <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;         System.out.println(i);         <span class="hljs-keyword">try</span> &#123;             Thread.sleep(<span class="hljs-number">100</span>);<span class="hljs-comment">//休眠 100 毫秒</span>         &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;             e.printStackTrace();         &#125;         <span class="hljs-keyword">if</span> (i++ == <span class="hljs-number">10</span>) &#123;<span class="hljs-comment">//i = 10 时停止循环</span>             <span class="hljs-keyword">break</span>;         &#125;     &#125; &#125;&#125;</code></pre></div><p><strong>关于 <code>start()</code> 方法</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;...    start0();&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start0</span><span class="hljs-params">()</span>;<span class="hljs-comment">//start0 是 native。即，底层方法</span></code></pre></div><ol type="1"><li><code>start()</code> 方法调用了一个 <code>start0()</code>底层方法</li><li><code>start0()</code> 是本地方法，由 JVM 调用，底层是 c/c++实现</li><li>真正的多线程效果，是 <code>start0()</code>，而不是<code>run()</code></li><li><code>start()</code> 方法调用 <code>start0()</code>方法后，该线程不一定会立刻执行，只是将线程变成了可运行状态。具体何时运行，由CPU 统一调度</li></ol><h3 id="实现-runable-接口">16.2.2 实现 Runable 接口</h3><blockquote><p>Runnable 是 Java用以实现线程的接口。从根本上将，任何实现线程的类都必须实现该接口。</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123; <span class="hljs-type">Runnable</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Type</span>();<span class="hljs-comment">//Runable 没有 start()方法</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(type);<span class="hljs-comment">//所以，这里使用了 静态代理</span> thread.start();&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Type</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<span class="hljs-comment">//这部分和 Thread 相似</span> <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;     <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;     <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;         System.out.println(i &lt;&lt; i);         <span class="hljs-keyword">try</span> &#123;             Thread.sleep(<span class="hljs-number">100</span>);         &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;             e.printStackTrace();         &#125;         <span class="hljs-keyword">if</span> (++i &gt; <span class="hljs-number">15</span>)&#123;             <span class="hljs-keyword">break</span>;         &#125;     &#125; &#125;&#125;</code></pre></div><p><strong>关于 静态代理</strong></p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runable</span> &#123;&#125;...<span class="hljs-keyword">private</span> Runnable target;... <span class="hljs-keyword">public</span> <span class="hljs-title function_">Thread</span><span class="hljs-params">(Runnable target)</span> &#123;<span class="hljs-comment">//构造器</span>     init(<span class="hljs-literal">null</span>, target, <span class="hljs-string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="hljs-number">0</span>);     <span class="hljs-comment">//这句话可以先理解为 this.target = target;</span> &#125;... <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;     <span class="hljs-keyword">if</span> (target != <span class="hljs-literal">null</span>) &#123;         target.run();     &#125; &#125;...&#125;</code></pre></div><p>相当于，先创建了一个新线程，然后在新线程中调用 run 方法</p></blockquote><h3 id="继承-thread-和-实现-runable-的区别">16.2.3 继承 Thread 和 实现Runable 的区别</h3><ol type="1"><li>从 Java 设计来看，两者本质上没有区别。<code>Thread</code>类本身就实现了 <code>Runable</code> 接口</li><li>实现 <code>Runable</code>接口的方式更加适合多个线程共享一个资源的情况，且避免了单继承的限制。建议使用。</li></ol><h3 id="线程中止">16.2.4 线程中止</h3><ol type="1"><li><p>当线程结束后，会自动退出</p></li><li><p>还可以通过使用变量来控制 <code>run</code>方法退出的方式来停止线程，即 通知方式。</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">while</span> (active) &#123;<span class="hljs-comment">//这个场合，只要外部控制 active 即可</span>     <span class="hljs-keyword">try</span> &#123;         Thread.sleep(<span class="hljs-number">1</span>);     &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;         e.printStackTrace();     &#125;     move(); &#125;&#125;</code></pre></div></blockquote></li></ol><h3 id="线程常用方法">16.2.5 线程常用方法</h3><ul><li><p><code>setName(name)</code>：设置线程名称，使之与参数 name相同</p></li><li><p><code>getName()</code>：返回线程名称</p></li><li><p><code>start()</code>：线程开始执行。JVM 调用 <code>start0</code>方法</p><p>该方法会创建新的线程，新线程调用 <code>run</code>。</p></li><li><p><code>run()</code>：到下面玩跑步</p><p>就是简单的方法调用，不会产生新线程。</p></li><li><p><code>setPriority(int priority)</code>：更改线程优先级</p><p><code>getPriority()</code>：获取线程优先级</p><p>priority 范围：</p><ul><li>MAX_PRIORITY：最高优先级（10）</li><li>MIN_PRIORITY：最低优先级（1）</li><li>NORM_PRIORITY：不高不低，真是好极了的优先级（5）</li></ul><p>每个线程都有一个<strong>优先级</strong>。Java线程调度采用如下优先级策略：</p><ul><li>优先级高的先执行，优先级低的后执行</li><li>每个线程创建时会被自动分配一个优先级。默认的场合，继承父类优先级</li><li>任务紧急的线程，优先级较高</li><li>同优先级线程按 “先进先出” 原则调度</li></ul></li><li><p><code>sleep(int millsecond)</code>：让线程休眠指定的时间</p><p>该方法是 Thread 类的静态方法，可以直接调用</p></li><li><p><code>interrupt()</code>：中断线程（不是 中止）</p></li><li><p><code>yield()</code>：线程的礼让。让出 CPU让其他线程执行。因为礼让的时间不确定，所以不一定礼让成功。</p><p>本质是 RUNNING 切换为 READY，即让当前线程放弃执行权</p></li><li><p><code>wait()</code>：导致当前线程等待</p><p>直到其他线程调用此对象的 <code>notify()</code> 方法或<code>notifyAll()</code> 方法才能唤醒此线程</p><p><code>notify()</code>、<code>notifyAll()</code>：唤醒因<code>wait()</code> 阻塞的线程。</p><p>这些方法（<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>）只能在synchrnized 方法或代码块中调用</p></li><li><p><code>join()</code>：线程的插队。插队的线程一旦插入成功，则必定先执行完插队线程的所有任务</p><p>将导致其他线程的等待，直到 <code>join()</code> 方法的线程结束</p><p><code>join(long timeout)</code>：join，但是时间到后也能结束其他线程的等待</p></li><li><p><code>isAlive()</code>：测试当前线程是否在活动</p></li><li><p><code>Thread.currentThread()</code>：引用当前运行中的线程</p></li></ul><h3 id="用户线程和守护线程">16.2.6 用户线程和守护线程</h3><ul><li><p>用户线程：也叫工作线程。当线程任务执行完毕或通知方式结束</p></li><li><p>守护线程：一般是为工作线程服务的。当所有线程结束，守护线程自动结束</p><p>常见的守护线程：垃圾回收机制</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thraed</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(bullet);thread.setDeamon(<span class="hljs-literal">true</span>);<span class="hljs-comment">//这样，子线程被设置为主线程的守护线程</span>thread.start();</code></pre></div></blockquote></li></ul><h3 id="线程的生命周期">16.2.7 线程的生命周期</h3><p>线程的状态有</p><ul><li><p>NEW：尚未启动</p></li><li><p>RUNNABLE：在 JVM 中执行的线程</p><p>可细分为 READY 和 RUNNING</p></li><li><p>BLOCKED：被阻塞等待监视器锁定的线程</p></li><li><p>WAITING：正等待另一个线程执行特定动作的线程</p></li><li><p>TIMED_WAITING：正等待另一个线程执行特定动作达到等待时间的线程</p></li><li><p>TERMINATED：已退出的线程</p></li></ul><p>有一张重要的图，去 <ahref="https://www.bilibili.com/video/BV1fh411y7R8?p=593&amp;t=1010.6">这里</a>查看吧</p><h2 id="线程的互斥">16.3 线程的互斥</h2><blockquote><p>在多线程编程，一些敏感数据不允许被多个线程同时访问。此时就用同步访问技术，保证数据在任意时刻，最多有一个线程同时访问，以保证数据的完整性。</p><p>也可以这样理解：线程同步，即当有一个线程对内存进行操作时，其他线程都不能对这个内存地址进行操作（被阻塞），直到该线程完成操作，再让下一线程进行操作。</p></blockquote><h3 id="互斥锁">16.3.1 互斥锁</h3><blockquote><p>在 Java 语言中，引入了 “对象互斥锁”的概念，也称为监视器，来保证共享数据操作的完整性</p><p>每个对象都对应一个可称为 “互斥锁”的标记，这个标记用来保证在任一时刻都只能有一个线程访问对象。</p><p>Java 语言中，有 2 种方式实现互斥锁：</p><ul><li>用关键字 volatile声明一个共享数据（变量）。一般很少使用该关键字</li><li>用关键字 synchronized 声明共享数据的一个方法或一个代码</li></ul><p>同步的局限性：导致程序的执行效率要降低。</p><p>非静态的对象，同步方法的锁可以是this，也可以是其他对象（要求是同一对象）</p><p>静态对象，同步方法的锁为当前类本身</p></blockquote><ol type="1"><li><p>同步代码块</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (对象) &#123;<span class="hljs-comment">//得到对象的锁，才能操作同步代码</span>需要被同步代码;&#125;</code></pre></div><p>在第一个线程持有锁定标记时，如果另一个线程企图执行该代码块语句，将从对象中索取锁定标记。</p><p>因为此时该标记不可得，古该线程不能继续执行，而是加入等待队列。</p><p>程序运行完 synchronized代码块后，锁定标记会被自动返还。即使该同步代码块执行过程中抛出异常也是如此。一个线程多次调用该同步代码块的场合，也会在最外层执行完毕后正确返还。</p></li><li><p>放在方法声明中，表示整个方法为同步方法</p><p>因为 synchronized 语句的参数必须是this，因此允许下面这种简洁的写法：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;代码;&#125;</code></pre></div></li></ol><h3 id="线程死锁">16.3.2 线程死锁</h3><blockquote><p>多个线程都占用了对方的资源，不肯相让，就导致了死锁。编程时要避免死锁的产生。</p></blockquote><ul><li><p>以下操作会释放锁</p><ol type="1"><li>当前线程的同步方法、同步代码块执行结束。</li><li>当前线程在同步方法、同步代码块中遇到<code>break</code>、<code>return</code></li><li>当前线程在同步方法、同步代码块中出现了未处理的<code>Error</code></li><li>当前线程在同步方法、同步代码块中执行了 <code>wait()</code>方法，当前线程暂停，并释放锁</li></ol></li><li><p>以下操作不会释放锁</p><ol type="1"><li><p>执行同步方法、同步代码块时，程序调用 <code>Thread.sleep()</code>或 <code>Thread.yield()</code>方法暂停当前线程的执行，不会释放锁</p></li><li><p>线程执行同步代码块时，其他线程调用了该线程的<code>suspend()</code> 方法将该线程挂起，该线程不会释放锁</p><p>所以，应尽量避免使用 <code>suspend()</code> 和 <code>resume()</code>来控制线程</p></li></ol></li></ul><p>## 16.4 线程的同步</p><blockquote><p>Java 中，可以使用<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>来协调线程间的运行速度关系。这些方法都被定义在 java.lang.Object 中</p><p>Java中的每个对象实例都有两个线程队列和它相连。一个用以实现等待锁定标志的线程，另一个用来实现<code>wait()</code> 和 <code>notify()</code> 的交互机制</p></blockquote><ul><li><p><code>wait()</code>：让当前线程释放所有其持有的“对象互斥锁”，进入等待队列</p></li><li><p><code>notify()</code>、<code>notifyAll()</code>：唤醒一个或所有在等待队列中等待的线程，并将他们移入同一个等待“对象互斥锁” 的队列。</p><p>执行这些方法时如果没有等待中的线程，则其不会生效，也不会被保留到以后再生效</p></li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (key) &#123;    <span class="hljs-keyword">if</span> (key.value == <span class="hljs-number">0</span>) key.wait();    key.value--;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (key) &#123;    key.value++;    key.nitifyAll();&#125;</code></pre></div><p>因为调用这些方法时必须持有对象的 “对象互斥锁”，所以上述方法只能在synhronized 方法或代码块中执行。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt;12 常用类</title>
    <link href="/2021/12/19/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/12%20%E5%B8%B8%E7%94%A8%E7%B1%BB/"/>
    <url>/2021/12/19/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/12%20%E5%B8%B8%E7%94%A8%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="常用类">12 常用类</h1><h2 id="包装类">12.1 包装类</h2><blockquote><p>包装类（Wrapper）：针对 八种基本数据类型 相应的 引用类型</p><p>有了类的特点，就可以调用类中的方法</p></blockquote><table><thead><tr class="header"><th>基本数据类型</th><th>包装类</th><th>父类</th></tr></thead><tbody><tr class="odd"><td>boolean</td><td>Boolean</td><td>Object</td></tr><tr class="even"><td>char</td><td>Character</td><td>Object</td></tr><tr class="odd"><td>int</td><td>Integer</td><td>Number</td></tr><tr class="even"><td>float</td><td>Float</td><td>Number</td></tr><tr class="odd"><td>double</td><td>Double</td><td>Number</td></tr><tr class="even"><td>long</td><td>Long</td><td>Number</td></tr><tr class="odd"><td>short</td><td>Short</td><td>Number</td></tr><tr class="even"><td>byte</td><td>Byte</td><td>Number</td></tr><tr class="odd"><td>void</td><td>Void</td><td>Object</td></tr></tbody></table><h3 id="装箱和拆箱">12.1.1 装箱和拆箱</h3><ul><li><p><strong>手动装箱和拆箱（JDK 5 以前）</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<span class="hljs-type">Integer</span> <span class="hljs-variable">integer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(n1);<span class="hljs-comment">// 手动装箱</span><span class="hljs-type">Integer</span> <span class="hljs-variable">integer2</span> <span class="hljs-operator">=</span> Integer.valueOf(n1);<span class="hljs-comment">// 手动装箱</span><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> integer.intValue();<span class="hljs-comment">// 手动拆箱</span></code></pre></div></li><li><p><strong>自动装箱和拆箱（JDK 5 以后）</strong></p><div class="code-wrapper"><pre><code class="hljs java">n2 = <span class="hljs-number">200</span>;<span class="hljs-type">Integer</span> <span class="hljs-variable">integer3</span> <span class="hljs-operator">=</span> n2;<span class="hljs-comment">// 自动装箱</span><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> integer3;<span class="hljs-comment">// 自动拆箱</span></code></pre></div><p>虽然可以自动装箱、拆箱，但使用 ==直接比较两个包装类时，仍然是比较其地址。以下比较通常会失败：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">ia</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<span class="hljs-type">Integer</span> <span class="hljs-variable">ib</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;System.out.print(ia == ib);<span class="hljs-comment">// false</span></code></pre></div><p>但，Java 实现仍有可能使其成立。Byte、Boolean 以及 Short、Integer 中[-128, 127] 间的值已被包装到固定的对象中。对他们的比较可以成功。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">ia</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<span class="hljs-type">Integer</span> <span class="hljs-variable">ib</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;System.out.print(ia == ib);<span class="hljs-comment">// true</span></code></pre></div><p>由此可见，使用 == 直接比较两个包装类会带来不确定性。<strong>尽量使用equals 方法对包装类进行比较。</strong></p></li></ul><p>装箱与拆箱是 <strong>编译器</strong>的工作。在生成可执行的字节码文件时，编译器已经插入了必要的方法调用。</p><h3 id="包装类和-string-的相互转换">12.1.2 包装类和 <code>String</code>的相互转换</h3><ul><li><p>包装类转 <code>String</code>：</p><blockquote><div class="code-wrapper"><pre><code class="hljs java">&gt;<span class="hljs-type">Integer</span> <span class="hljs-variable">integer</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;&gt;<span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> integer + <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-comment">//方法1（自动拆箱）</span>&gt;<span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> integer.toString();<span class="hljs-comment">//方法2（toString方法）</span>&gt;<span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> String.valueOf(integer);<span class="hljs-comment">//方法3（自动拆箱）</span></code></pre></div></blockquote></li><li><p><code>String</code> 转包装类：</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str4</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;100&quot;</span>;<span class="hljs-type">Integer</span> <span class="hljs-variable">integer2</span> <span class="hljs-operator">=</span> Integer.parseInt(str4);<span class="hljs-comment">//方法1（自动装箱）</span><span class="hljs-type">Integer</span> <span class="hljs-variable">integer3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(str4);<span class="hljs-comment">//方法2（构造器）</span></code></pre></div></blockquote></li></ul><h3 id="包装类的常用方法">12.1.3 包装类的常用方法</h3><ul><li><p><code>Integer.MIN_VALUE</code>：返回最大值</p></li><li><p><code>Double.MAX_VALUE</code>：返回最小值</p></li><li><p><code>byteValue()</code>、<code>doubleValue()</code>、<code>floatValue()</code>、<code>intValue()</code>、<code>longValue()</code></p><p>按各种基本数据类型返回该对象的值</p></li><li><p><code>Character.isDigit(int)</code>：判断是不是数字</p><p><code>Character.isLetter(int)</code>：判断是不是字母</p><p><code>Character.isUpperCase(int)</code>：判断是不是大写字母</p><p><code>Character.isLowerCase(int)</code>：判断是不是小写字母</p><p><code>Characher.isWhitespace(int)</code>：判断是不是空格</p></li><li><p><code>Character.toUpperCase(int)</code>：转成大写字母</p><p><code>Character.toLowerCase(int)</code>：转成小写字母</p></li><li><p><code>Integer.parseInt(string)</code>：将 String 内容转为 int</p><p><code>Double.parseDouble(string)</code></p></li><li><p><code>Integer.toBinaryString(int)</code>：将数字转为 2进制表示的字符串</p><p><code>Integer.toHexString(int)</code>：将数字转为 16进制表示的字符串</p><p><code>Integer.toOctalString(int)</code>：将数字转为 8进制表示的字符串</p><p>特别地，浮点数类型的包装类只有转成 16 进制的方法。而 Short、Byte及其他包装类无此方法</p></li><li><p><code>int Integer.bitCount(i int)</code>：统计指定数字的二进制格式中1 的数量</p></li></ul><h3 id="strictfp-关键字">12.1.4 strictfp 关键字</h3><blockquote><p>由于不同处理器对于浮点数寄存采取不同策略（有些处理器使用 64 位寄存double，有些则是 80位），对于浮点数的运算在不同平台上可能出现不同结果。</p></blockquote><p>使用 strictfp关键字标记的方法或类中，所有指令都会使用严格统一的浮点数运算。</p><p>比如，把 main 方法标记为 strictfp</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">strictfp</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;    <span class="hljs-type">double</span> ᓚᘏᗢ = <span class="hljs-number">1</span> / <span class="hljs-number">13.97</span>;    System.out.println(ᓚᘏᗢ);&#125;</code></pre></div><h2 id="string-类">12.2 <code>String</code> 类</h2><ol type="1"><li><p><code>String</code>对象用于保存字符串，也就是一组字符序列</p></li><li><p>字符串常量对象是用双引号扩起的字符序列。例如<code>"你好"</code></p></li><li><p>字符串的字符使用 Unicode 字符编码。一个字符（不论字母汉字）占 2字节</p></li><li><p>常用构造器：</p><ul><li><p><code>String str1 = new String();</code></p></li><li><p><code>String str2 = new String(String original);</code></p></li><li><p><code>String str3 = new String(char[] a);</code></p></li><li><p><code>String str4 = new String(char[] a, int startIndex, int count);</code></p><p>这句意思是：<code>char[]</code> 从 <code>startIndex</code> 起的<code>count</code> 个字符</p></li></ul></li><li><p><code>String</code> 实现了接口 <code>Serializable</code> 和<code>Comparable</code> ，可以 串行化和 比较大小</p><p><strong><em>串行化：即，可以被网络传输，也能保存到文件</em></strong></p></li><li><p><code>String</code> 是 <code>final</code> 类，不能被继承</p></li><li><p><code>String</code> 有属性<code>private final char[] value;</code> 用于存放字符串内容。</p><p><code>value</code> 是 <code>final</code>属性。其在栈中的地址不能修改，但堆中的内容可以修改。</p></li></ol><h3 id="string-构造方法">12.2.1 <code>String</code> 构造方法</h3><ul><li><p>直接指定 <div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;哈哈哈&quot;</span>;</code></pre></div></p><p>该方法：先从常量池看是否有 <code>"哈哈哈"</code>数据空间。有的场合，指向那个空间；否则重新创建然后指向。</p><p>这个方法，<code>str1</code> 指向 常量池中的地址。</p></li><li><p>构造器 <div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;嘿嘿嘿&quot;</span>);</code></pre></div></p><p>该方法：先在堆中创建空间，里面维护一个 <code>value</code> 属性，指向或 创建后指向 常量池的 <code>"嘿嘿嘿"</code> 空间。</p><p>这个方法，<code>str2</code> 指向 堆中的地址</p></li></ul><h3 id="字符串的特性">12.2.2 字符串的特性</h3><ul><li><p>常量相加，看的是池 <div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;aa&quot;</span> + <span class="hljs-string">&quot;bb&quot;</span>;<span class="hljs-comment">//常量相加，看的是池</span></code></pre></div></p><blockquote><p>上例由于构造器自身优化，相当于 <code>String str1 = "aabb";</code></p></blockquote></li><li><p>变量相加，是在堆中 <div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;aa&quot;</span>;<span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;bb&quot;</span>;<span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> a + b;<span class="hljs-comment">//变量相加，是在堆中</span></code></pre></div></p><blockquote><p>上例的底层是如下代码</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();sb.append(a);sb.append(b);str2 = sb.toString();<span class="hljs-comment">//sb.toString()：return new String(value, 0, count);</span></code></pre></div></blockquote></li></ul><h3 id="string-的常用方法">12.2.3 <code>String</code> 的常用方法</h3><p>以下方法不需死记硬背，手熟自然牢记</p><ul><li><p><code>boolean equals(String s)</code>：区分大小写，判断内容是否相等</p><p><code>boolean equalsIgnoreCase(String s)</code>：判断内容是否相等（忽略大小写）</p></li><li><p><code>boolean empty()</code>：返回是否为空</p></li><li><p><code>int charAt(int index)</code>：获取某索引处的字符（代码单元）。</p><p>必须用 <code>char c = str.charAt(15);</code>，不能用<code>char c = str[15];</code></p><p><code>int codePointAt(int index)</code></p><p><code>int length()</code>：获取字符（<strong>代码单元</strong>）的个数</p><p><strong><em>—— 代码单元，见 <ahref="../../../../../../2021/11/22/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/2%20%E5%8F%98%E9%87%8F/#2-6-2-%E5%AD%97%E7%AC%A6%E6%9C%AC%E8%B4%A8%E4%B8%8E%E7%BC%96%E7%A0%81%E8%A1%A8">[2.6.2.4字符本质与编码表]</a></em></strong></p><p><code>IntStream codePoints()</code>：返回字符串中全部码点构成的流</p><p><code>long codePoints().count()</code>：返回真正长度（码点数量）</p><p><strong><em>—— 流，见 <ahref="../../../../../../2022/03/09/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/27%20Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/#27-4-Stream-API">[27.4Stream API]</a></em></strong></p></li><li><p><code>int indexOf(String str)</code>：获取字符（串）在字符串中第一次出现的索引。如果找不到，返回-1</p><p><code>int indexOf(int char)</code> 参数也可以传入一个int。由于自动类型转换的存在，也能填入 char</p><p><code>int indexOf(String str, int index)</code>：从 index处（包含）开始查找指定字符（串）</p><p><code>int lastIndexOf(String str)</code>：获取字符在字符串中最后一次出现的索引。如果找不到，返回-1</p></li><li><p><code>String substring(int start, int end)</code>：返回截取指定范围[start, end) 的 <strong>新</strong> 字符串</p><p><code>String substring(int index)</code>：截取index（包含）之后的部分</p></li><li><p><code>String trim()</code>：返回去前后空格的新字符串</p></li><li><p><code>String toUperCase()</code>：返回字母全部转为大写的新字符串</p><p><code>String toLowerCase()</code>：返回字母全部转为小写的新字符串</p></li><li><p><code>String concat(String another)</code>：返回拼接字符串</p></li><li><p><code>String replace(char oldChar, char newChar)</code>：替换字符串中的元素</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Foolish cultists&quot;</span>;<span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> str1.replace(<span class="hljs-string">&quot;cultists&quot;</span>, <span class="hljs-string">&quot;believers&quot;</span>);<span class="hljs-comment">//str1不变，str2为改变的值</span></code></pre></div></li><li><p><code>String[] split(String regex)</code>：分割字符串。</p><p>对于某些分割字符，我们需要转义</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;aaa,bbb,ccc&quot;</span>;String[] strs1 = str1.split(<span class="hljs-string">&quot;,&quot;</span>);<span class="hljs-comment">//这个场合，strs = &#123;&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;&#125;;4</span><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;aaa\bbb\ccc&quot;</span>;String[] strs2 = str2.split(<span class="hljs-string">&quot;\\&quot;</span>);<span class="hljs-comment">//&quot;\&quot; 是特殊字符，需要转义为 &quot;\\&quot;</span></code></pre></div></li><li><p><code>int compareTo(String another)</code>：按照字典顺序比较两个字符串（的大小）。</p><p>返回出现第一处不同的字符的编号差。前面字符相同，长度不同的场合，返回那个长度差。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ccc&quot;</span>;<span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ca&quot;</span>;<span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ccc111abc&quot;</span>;<span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> str1.compareTo(str2);<span class="hljs-comment">//此时 n1 = &#x27;c&#x27; - &#x27;a&#x27; = 2</span><span class="hljs-type">int</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> str1.compareTo(str3);<span class="hljs-comment">//此时 n2 = str1,length - str3.length = -6</span><span class="hljs-type">int</span> <span class="hljs-variable">n3</span> <span class="hljs-operator">=</span> str1.compareTo(str1);<span class="hljs-comment">//此时 n3 = 0</span></code></pre></div></li><li><p><code>char[] toCharArray()</code>：转换成字符数组</p><p><code>byte[] getBytes()</code>：字符串转为字节数组</p></li><li><p><code>String String.format(String format, Object... args)</code>：（静态方法）格式字符串</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Roin&quot;</span>;<span class="hljs-type">String</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1M&quot;</span>;<span class="hljs-type">String</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;computer&quot;</span>;<span class="hljs-type">String</span> <span class="hljs-variable">formatStr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;I am %s, I am %s old, I am a %s&quot;</span>;<span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> String.format(formatStr, name, age, state);<span class="hljs-comment">//其中 %s 是占位符。此时，str = &quot;I am Roin, I am 1M old, I am a computer&quot;;</span><span class="hljs-comment">//%s 表示字符串替换；%d 表示整数替换；#.2f 表示小数（四舍五入保留2位）替换；%c 表示字符替换</span></code></pre></div></li><li><p><code>String join(deli, ele...)</code>：拼接字符串（<code>ele...</code>），以<code>deli</code> 间隔。</p></li><li><p><code>boolean startsWith(str)</code>：测试 str是否为当前字符串的前缀</p></li><li><p><code>String repeat(int n)</code>：返回该字符串重复 n次的结果</p></li></ul><h2 id="stringbuffer-类">12.3 <code>StringBuffer</code> 类</h2><blockquote><p><code>java.lang.StringBuffer</code>代表可变的字符序列。可以对字符串内容进行增删。</p><p>很多方法和 <code>String</code> 相同，但 <code>StringBuffer</code>是可变长度。同时，<code>StringBuffer</code> 是一个容器</p></blockquote><ol type="1"><li><code>StringBuffer</code> 的直接父类是<code>AbstractStringBuffer</code></li><li><code>StringBuffer</code> 实现了<code>Serialiazable</code>，可以串行化</li><li>在父类中，<code>AbstractStringBuffer</code> 有属性<code>char[] value</code> 不是 <code>final</code></li><li><code>StringBuffer</code> 是一个 <code>final</code>类，不能被继承</li></ol><p><strong><code>String</code> 对比<code>StringBuffer</code></strong></p><ul><li><code>String</code>保存字符串常量，其中的值不能更改。每次更新实际上是更改地址，效率较低</li><li><code>StringBuffer</code>保存字符串变量，里面的值可以更改。每次更新是更新内容，不用每次更新地址。</li></ul><h3 id="stringbuffer-构造方法">12.3.1 <code>StringBuffer</code>构造方法</h3><ol type="1"><li><p>无参构造 <div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">StringBuffer</span> <span class="hljs-variable">strb1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();</code></pre></div></p><blockquote><p>创造一个 16 位容量的空 <code>StringBuffer</code></p></blockquote></li><li><p>传入字符串构造 <div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcabc&quot;</span>;<span class="hljs-type">StringBuffer</span> <span class="hljs-variable">strb2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(str1);</code></pre></div></p><blockquote><p>（上例）创造一个 str1.length + 16 容量的<code>StringBuffer</code></p></blockquote></li><li><p>指定容量构造 <div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">StringBuffer</span> <span class="hljs-variable">strb3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-number">3</span>);</code></pre></div></p><blockquote><p>（上例）创造一个 3 容量的空 <code>StringBuffer</code></p></blockquote></li></ol><h3 id="string-和-stringbuffer的转换">12.3.2 <code>String</code> 和<code>StringBuffer</code>的转换</h3><ol type="1"><li><p>转 <code>StringBuffer</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcabc&quot;</span>;<span class="hljs-type">StringBuffer</span> <span class="hljs-variable">strb1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(str1);<span class="hljs-comment">//方法1（构造器）</span><span class="hljs-type">StringBuffer</span> <span class="hljs-variable">strb1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();strb1 = strb1.append(str1);<span class="hljs-comment">//方法2（先空再append）</span></code></pre></div></li><li><p>转 <code>String</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> strb1.toString();<span class="hljs-comment">//方法1（toString）</span><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(strb1);<span class="hljs-comment">//方法2（构造器）</span></code></pre></div></li></ol><h3 id="stringbuffer-的常用方法">12.3.3 <code>StringBuffer</code>的常用方法</h3><ul><li><p><code>append(char c)</code>：增加</p><p><code>append(String s)</code> 参数也能是字符串</p><p>特别的，<code>append(null);</code> 的场合，等同于<code>append("null");</code></p></li><li><p><code>delete(start, end)</code>：删减 [start, end)的内容</p></li><li><p><code>replace(start, end, string)</code>：将 start 与 end间的内容替换为 string</p></li><li><p><code>indexOf</code>：查找指定字符串第一次出现时的索引。没找到的场合返回-1</p></li><li><p><code>insert</code>：在指定索引位置之前插入指定字符串</p></li><li><p><code>length()</code>：返回字符长度</p><p><code>capacity()</code>：返回当前的容量</p><p>String 类对象分配内存时，按照对象中所含字符个数等量分配。</p><p>StringBuffer 类对象分配内存时，除去字符所占空间外，会另加 16字符大小的缓冲区。</p><p>对于 <code>length()</code> 方法，返回的是字符串长度。对于<code>capacity()</code> 方法，返回的是 字符串 + 缓冲区 的大小。</p></li></ul><h2 id="stringbuilder-类">12.4 <code>StringBuilder</code> 类</h2><blockquote><p>一个可变的字符序列。此类提供一个与 <code>StringBuffer</code> 兼容的API，但不保证同步（有线程安全问题）。该类被设计成<code>StringBuffer</code>的一个简易替换，<strong>用在字符串缓冲区被单个线程使用的时候</strong>。如果可能，建议优先使用该类。因为在大多数实现中，它比起<code>StringBuffer</code> 要快。</p><p>在 <code>StringBuilder</code> 是的主要操作是 <code>append</code> 和<code>insert</code> 方法。可以重载这些方法，以接受任意类型的数据。</p></blockquote><ol type="1"><li><p><code>StringBuilder</code> 也继承了<code>AbstractStringBuffer</code></p></li><li><p><code>StringBuilder</code> 也实现了<code>Serialiazable</code>，可以串行化</p></li><li><p>仍然是在父类中有属性 <code>char[] value</code> ，而且不是<code>final</code></p></li><li><p><code>StringBuilder</code> 也是一个 <code>final</code>类，不能被继承</p></li><li><p><code>StringBuilder</code> 的方法，没有做互斥的处理（没有<code>synchronize</code>），故而存在线程安全问题</p></li></ol><h3 id="stringstringbufferstringbuilder-的对比">12.4.1<code>String</code>、<code>StringBuffer</code>、<code>StringBuilder</code>的对比</h3><ol type="1"><li><p><code>StringBuilder</code> 和 <code>StringBuffer</code>类似，均代表可变字符序列，而且方法也一样</p></li><li><p><code>String</code>：不可变字符序列，效率低，但复用率高</p></li><li><p><code>StringBuffer</code>：可变字符序列，效率较高，线程安全</p></li><li><p><code>StringBuilder</code>：可变字符序列，效率最高，存在线程安全问题</p></li><li><p><code>String</code> 为何效率低：</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;aa&quot;</span>;<span class="hljs-comment">//创建了一个字符串</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; n &lt; <span class="hljs-number">100</span>; n++)&#123;str1 += <span class="hljs-string">&quot;bb&quot;</span>;<span class="hljs-comment">//这里，原先的字符串被丢弃，创建新字符串</span>&#125;<span class="hljs-comment">//多次执行后，大量副本字符串留在内存中</span><span class="hljs-comment">//导致效率降低，也会影响程序性能</span></code></pre></div><p>如上，对 <code>String</code> 大量修改的场合，不要使用<code>String</code></p></blockquote></li></ol><h2 id="math-类">12.5 <code>Math</code> 类</h2><ul><li><p><code>Math.multiplyExact(int n1, int n2)</code>：进行乘法运算，返回运算结果</p><p>通常的乘法 <code>n1 * n2</code>在结果大于那个数据类型存储上限时，可能返回错误的值。</p><p>使用此方法，结果大于那个数据类型存储上限时，会抛出异常</p><p><code>Math.addExact(int n1, int n2)</code>：加法</p><p><code>Math.subtractExact(int n1, int n2)</code>：减法</p><p><code>Math.incrementExact(int n1)</code>：自增</p><p><code>Math.decrementExact(int n1)</code>：自减</p><p><code>Math.negateExact(int n1, int n2)</code>：改变符号</p></li><li><p><code>Math.abs(n)</code>：求绝对值，返回 |n1|</p></li><li><p><code>Math.pow(n, i)</code>：求幂，返回 n3 ^ i</p></li><li><p><code>Math.ceil(n)</code>：向上取整，返回 &gt;= n3的最小整数（转成double）</p></li><li><p><code>Math.floor(n)</code>：向下取整，返回 &lt;=n4的最小整数（转成double）</p></li><li><p><code>Math.floorMod(int n1, int n2)</code>：返回 n1 除以 n2的余数</p><p><code>n1 % n2</code>的场合，返回的可能是负数，而不是数学意义上的余数</p></li><li><p><code>Math.round(n)</code>：四舍五入，相当于<code>Math.floor(n5 + 0.5)</code></p></li><li><p><code>Math.sqrt(n)</code>：求开方。负数的场合，返回<code>NaN</code></p></li><li><p><code>Math.random()</code>：返回一个 [0, 1)区间的随机小数</p></li><li><p><code>Math.sin(n)</code>：正弦函数</p><p><code>Math.cos(n)</code>：余弦函数</p><p><code>Math.tan(n)</code>、<code>Math.atan(n)</code>、<code>Math.atan2(n)</code></p><p>要注意，上述方法传入的参数是 <strong>弧度值</strong>。</p><p>要得到一个角度的弧度值，应使用：<code>Math.toRadians(n)</code></p></li><li><p><code>Math.exp(n)</code>：e 的 n 次幂</p><p><code>Math.log10(n)</code>：10 为底的对数</p><p><code>Math.log()</code>：自然对数</p></li><li><p><code>Math.PI</code>：圆周率的近似值</p><p><code>Math.E</code>：e 的近似值</p></li></ul><h2 id="arrays-类">12.6 <code>Arrays</code> 类</h2><ul><li><p><code>Arrays.toString()</code>：返回数组的字符串形式</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">33</span>&#125;;<span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> Array.toString(nums);<span class="hljs-comment">//此时，str = &quot;[0, 1, 33]&quot;</span></code></pre></div><p>特别的，输入为 null 时返回 "null"</p></blockquote></li><li><p><code>Arrays.sort(arr)</code>：排序</p><p>因为数组是引用类型，使用 sort 排序后，会直接影响到实参。</p><p>默认（自然排序）从小到大排序。</p><p><code>Arrays.sort(arr, Comparator c)</code>：按照传入的比较器决定排序方法</p><div class="code-wrapper"><pre><code class="hljs java">Integer[] nums;...Comparator&lt;Integer, Integer&gt; c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer, Integer&gt;()&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span>&#123;        <span class="hljs-keyword">return</span> n2 - n1;<span class="hljs-comment">// 这个场合，变成从大到小排序</span>    &#125;&#125;Arrays.sort(nums, c);</code></pre></div></li><li><p><code>Arrays.binarySearch(array, num)</code>：通过二分搜索法查找。前提是必须先排序。</p><p>找不到的场合，返回 - (low + 1)。即，其应该在的位置的负值</p><div class="code-wrapper"><pre><code class="hljs java">Integer[] nums2 = &#123;-<span class="hljs-number">10</span>, -<span class="hljs-number">5</span>, -<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>&#125;;<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> Arrays.binarySearch(nums2, <span class="hljs-number">7</span>);<span class="hljs-comment">// 此时 index = -7</span><span class="hljs-comment">// 如果 7 存在，应该在第 7 个位置</span></code></pre></div></li><li><p><code>Arrays.copyOf(arr, n)</code>：从 <code>arr</code> 中，复制n 个元素（成为新的数组）。</p><p>n &gt; arr.length 的场合，在多余的位置添加 <code>null</code>。n &lt;0 的场合，抛出异常。</p><p>该方法的底层使用的是 <code>System.arraycopy</code></p></li><li><p><code>Arrays.fill(arr, o)</code>：用 o 填充 <code>num</code>的所有元素。</p></li><li><p><code>Arrays.equals(arr1, arr2)</code>：比较两个数组元素是否完全一致（<code>true</code>/<code>false</code>）</p></li><li><p><code>Arrays.asList(a, b, c, d)</code>：将输入数据转成一个<code>List</code> 集合</p></li></ul><h2 id="system-类">12.7 <code>System</code> 类</h2><ul><li><p><code>System.exit(0)</code>：退出当前程序。0表示一个状态，正常状态是 0</p></li><li><p><code>System.arraycopy(arr, 0, newArr, 0 ,3)</code>：复制数组元素。</p><p>上例是：arr 自下标 0 起开始，向 newArr 自下标 0 开始，依次拷贝 3个值</p><p>这个方法比较适合底层调用。我们一般使用 <code>Arrays.copyOf</code>来做</p></li><li><p><code>System.currentTimeMillis</code>：返回当前时间距离 1970 - 1- 1 的毫秒数</p></li><li><p><code>System.gc</code>：运行垃圾回收机制</p></li></ul><h2 id="biginteger-和-bigdecimal-类">12.8 <code>BigInteger</code> 和<code>BigDecimal</code> 类</h2><blockquote><p><code>BigInteger</code>：适合保存更大的整数</p><p><code>BigDecimal</code>：适合保存精度更大的浮点数</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//用引号把大数变成字符串</span><span class="hljs-type">BigInteger</span> <span class="hljs-variable">bigNum</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigInteger</span>(<span class="hljs-string">&quot;100000000000000000000000&quot;</span>);</code></pre></div><p><strong>构造方法：</strong></p><ul><li><code>new BigInteger(String intStr)</code>：通过一个字符串构建大数</li><li><code>BigInteger BigInteger.valueOf(1)</code>：通过静态方法，让整数类型转成大数</li></ul><p>另外，在对 <code>BigInteger</code> 和 <code>BigDecimal</code>进行加减乘除的时候，需要使用对应方法</p><p>不能直接用 <code>+</code> <code>-</code> <code>*</code><code>/</code></p><p><strong>常用方法：</strong></p><ul><li><p><code>BigInteger add(BigInteger)</code>：加法运算。返回新的大数</p></li><li><p><code>BigInteger subtract(BigInteger)</code>：减法</p></li><li><p><code>BigInteger multiply(BigInteger)</code>：乘法</p></li><li><p><code>BigInteger divide(BigInteger)</code>：除法运算</p><p>该方法可能抛出异常。因为可能产生是无限长度小数。</p><p>解决方法（保留分子精度）：<code>bigDecimal.divide(bD3, BigDecimal.ROUND_CELLING)</code></p></li><li><p>一些常量：</p><p><code>BigInteger.ONE</code>、<code>BigInteger.ZERO</code>、<code>BigInteger.TEN</code>分别是 1、0、10</p><p>one 就是英文的 1，zero 就是英文的 0……这个大家都懂的吧？</p></li></ul><h2 id="日期类">12.9 日期类</h2><h3 id="第一代日期类">12.9.1 第一代日期类</h3><blockquote><p>Date：精确到毫秒，代表特定瞬间。这里的是 java.util.Date</p><p>SimpleDateFormat：格式和解析日期的类</p></blockquote><ol type="1"><li><p><code>Date d1 = new Date();</code>：调用默认无参构造器，获取当前系统时间。</p><p>默认输出日期格式是国外的格式，因此通常需要进行格式转换</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy.MM.dd HH.mm.ss&quot;</span>);<span class="hljs-type">String</span> <span class="hljs-variable">dateFormated</span> <span class="hljs-operator">=</span> sdf.(d1);<span class="hljs-comment">//日期转成指定格式。</span></code></pre></div></li><li><p>通过指定毫秒数得到时间：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Date</span> <span class="hljs-variable">d2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">10000000000</span>);</code></pre></div></li><li><p>把一个格式化的字符串转成对应的 Date：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy年MM月dd日 HH点mm分 E&quot;</span>);<span class="hljs-type">Date</span> <span class="hljs-variable">d3</span> <span class="hljs-operator">=</span> sdf2.parse(<span class="hljs-string">&quot;2021年12月22日 00点03分 星期三&quot;</span>);</code></pre></div><p>这个场合，给定的字符串格式应和 <code>sdf2</code>格式相同，否则会抛出异常</p></li></ol><h3 id="第二代日期类">12.9.2 第二代日期类</h3><blockquote><p>Calendar：构造器是私有的，要通过 getInstance 方法获取实例</p></blockquote><ol type="1"><li><p>Calendar 是一个抽象类，其构造器私有</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Calendar</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> Calendar.genInstance();<span class="hljs-comment">//获取实例的方法</span></code></pre></div></li><li><p>提供大量方法和字段提供给程序员使用</p><ul><li><p><code>c1.get(Calendar.YEAR)</code>：获取年份数</p></li><li><p><code>c1.get(Calendar.MONTH)</code>：获取月份数</p><p>特别的，实际月份是 返回值 +1。因为 Calendar 的月份是从 0开始编号的</p></li><li><p><code>c1.get(Calendar.DAY_OF_MONTH)</code>：获取日数</p></li><li><p><code>c1.get(Calendar.HOUR)</code>：获取小时数（12小时制）</p><p><code>c1.get(Calendar.HOUR_OF_DATE)</code>：获取小时数（24小时制）</p></li><li><p><code>c1.get(Calendar.MINUTE)</code>：获取分钟数</p></li><li><p><code>c1.get(Calendar.SECOND)</code>：获取秒数</p></li></ul><p>Calendar 没有专门的格式化方法，需要程序员自己组合来显示</p></li></ol><h3 id="第三代日期类">12.9.3 第三代日期类</h3><blockquote><p>JDK 1.0 加入的 Date 在 JDK 1.1 加入 Calendar 后已被弃用</p><p>然而，Calendar 也存在不足：</p><ol type="1"><li>可变性：像日期和实际这样的类应该是不可改变的</li><li>偏移性：年份都是从 1900 年开始，月份都是从 0 开始</li><li>格式化：只对 Date 有用，对 Calendar 没用</li><li>其他问题：如不能保证线程安全，不能处理闰秒（每隔 2 天多 1秒）等</li></ol><p>于是，在 JDK 8 加入了以下新日期类：</p><ul><li>LocalDate：只包含 日期（年月日），可以获取 日期字段</li><li>LocalTime：只包含 时间（时分秒），可以获取 时间字段</li><li>LocalDateTime：包含 日期 + 时间，可以获取 日期 + 时间字段</li><li>DateTimeFormatter：格式化日期</li><li>Instant：时间戳</li></ul></blockquote><ol type="1"><li><p>使用 <code>now()</code> 方法返回当前时间的对象</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">ldt</span> <span class="hljs-operator">=</span> LocalDateTime.now();<span class="hljs-comment">//获取当前时间</span></code></pre></div></li><li><p>获取各字段方法：</p><ul><li><p><code>ldt.getYear();</code>：获取年份数</p></li><li><p><code>ldt.getMonth();</code>：获取月份数（英文）</p><p><code>ldt.getMonthValue();</code>：获取月份数（数字）</p></li><li><p><code>ldt.getDayOfMonth();</code>：获取日数</p></li><li><p><code>LocalDateTime ldt2 = ldt.plusDays(100);</code>：获取 ldt时间 100 天后的时间实例</p></li><li><p><code>LocalDateTime ldt3 = ldt.minusHours(100);</code>：获取 ldt时间 100 小时前的时间实例</p></li><li><p>...</p></li></ul></li><li><p>格式化日期：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">dtf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DateTimeFormatter</span>(<span class="hljs-string">&quot;yyyy.MM.dd HH.mm.ss&quot;</span>);<span class="hljs-type">String</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> dtf.format(ldt);<span class="hljs-comment">//获取格式化字符串</span></code></pre></div></li><li><p><code>Instant</code> 和 <code>Date</code> 类似</p><ul><li><p>获取当前时间戳：<code>Instant instant = Instant.now();</code></p></li><li><p>转换为<code>Date</code>：<code>Date date = Date.form(instant);</code></p></li><li><p>由 <code>Date</code>转换：<code>Instant instant = date.toInstant;</code></p></li></ul></li></ol><h2 id="泛型">12.10 泛型</h2><blockquote><p>泛型（generic）：又称 参数化类型。是JDK 5出现的新特性。解决数据类型的安全性问题。</p><p>在类声明或实例化时只要制定好需要的具体类型即可。</p></blockquote><p>举例说明：</p><div class="code-wrapper"><pre><code class="hljs java">Properties&lt;Person&gt; prop = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>&lt;Person&gt;();</code></pre></div><blockquote><p>上例表示存放到 <code>prop</code> 中的必须是 <code>Person</code>类型。</p><p>如果编译器发现添加类型不符合要求，即报错。</p><p>遍历时，直接取出 <code>Person</code> 而非 <code>Object</code></p></blockquote><ol type="1"><li><p>编译时，检查添加元素的类型。可以保证如果编译时没发出警告，运行就不会产生ClassCastException 异常。提高了安全性，使代码更加简洁、健壮。</p></li><li><p>也减少了转换的次数，提高了效率。</p></li><li><p>泛型的作用是：可以在类声明是通过一个标识表示类中某个属性的类型，或某个方法返回值的类型，或参数类型。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">P</span>&lt;E&gt; &#123;E e;<span class="hljs-comment">//E 表示 e 的数据类型，在定义 P类 时指定。在编译期间即确认类型</span><span class="hljs-keyword">public</span> <span class="hljs-title function_">P</span><span class="hljs-params">(E e)</span>&#123;<span class="hljs-comment">//可作为参数类型</span><span class="hljs-built_in">this</span>.e = e;&#125;<span class="hljs-keyword">public</span> E <span class="hljs-title function_">doSth</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">//可作为返回类型</span><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.e;&#125;&#125;</code></pre></div><p>实例化时指定 E 的类型，编译时上例所有 E会被编译器替换为那个指定类型</p></li></ol><h4 id="使用方法">使用方法：</h4><ul><li><p><strong>声明泛型：</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterfaceName</span>&lt;T&gt; &#123;...&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span>&lt;A, B, C, D&gt; &#123;...&#125;</code></pre></div><p>上例 T、A、B、C、D 不是值，而是类型。可以用任意字母代替</p></li><li><p><strong>实例化泛型：</strong></p><div class="code-wrapper"><pre><code class="hljs java">List&lt;String&gt; strList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();Iterator&lt;Integer&gt; iterator = vector.interator&lt;Integer&gt;();</code></pre></div><p>类名后面指定类型参数的值</p></li></ul><p><strong>注意细节：</strong></p><ol type="1"><li><p>泛型只能是引用类型</p></li><li><p>指定泛型具体类型后，可以传入该类型或其子类类型</p></li><li><p>在实际开发中往往简写泛型</p><div class="code-wrapper"><pre><code class="hljs java">List&lt;String&gt; strList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();</code></pre></div><p>编译器会进行类型推断，右边 <code>&lt; &gt;</code>内容可以省略</p></li><li><p>实例化不写泛型的场合，相当于默认泛型为<code>Object</code></p></li></ol><h4 id="自定义泛型类-接口">自定义泛型类 · 接口：</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Name</span>&lt;A, B...&gt; &#123;...&#125;<span class="hljs-comment">//泛型标识符 可有多个，一般是单个大写字母表示</span></code></pre></div><p>这就是自定义泛型啊</p><ol type="1"><li><p>普通成员可以使用泛型（属性、方法）</p></li><li><p>泛型类的类型，是在创建对象时确定的。</p><p>因此：静态方法中不能使用类的泛型；使用泛型的数组，也不能初始化。</p></li><li><p>创建对象时不指定的场合，默认 Object。建议还是写上<code>&lt;Object&gt;</code>，大气，上档次</p></li><li><p>自定义泛型接口</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Name</span>&lt;T, R...&gt; &#123;...&#125;</code></pre></div><p>泛型接口，其泛型在 继承接口 或 实现接口 时确定。</p></li></ol><h4 id="自定义泛型方法">自定义泛型方法：</h4><div class="code-wrapper"><pre><code class="hljs java">修饰符 &lt;T, R...&gt; 返回类型 方法名(形参) &#123;...&#125;</code></pre></div><ol type="1"><li><p>可以定义在普通类中，也可以定义在泛型类中</p></li><li><p>当泛型方法被调用时，类型会确定</p></li><li><p>以下场合</p><blockquote><div class="code-wrapper"><pre><code class="hljs java">Class C&lt;T&gt; &#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cMethord</span><span class="hljs-params">(T t)</span>&#123;&#125;&#125;</code></pre></div></blockquote><p>没有<code>&lt; &gt;</code>，不是泛型方法，而是使用了泛型的普通方法</p></li></ol><h4 id="泛型继承">泛型继承：</h4><ol type="1"><li>泛型不具有继承性</li><li><code>&lt;?&gt;</code>：支持任意泛型类型</li><li><code>&lt;? extends A&gt;</code>：支持 A 及A的子类，规定了泛型的上限</li><li><code>&lt;? super B&gt;</code>：支持 B 及 B的父类，规定了泛型的下限</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt;11 异常</title>
    <link href="/2021/12/18/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/11%20%E5%BC%82%E5%B8%B8/"/>
    <url>/2021/12/18/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/11%20%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="异常exception">11 异常（Exception）</h1><blockquote><p>在 Java 语言中，将程序执行中发生的不正常情况称为“异常”（开发过程中的语法错误和逻辑错误不是异常）</p><p>这些 异常事件 可分为两类：</p><ul><li><p>Error（错误）：Java 虚拟机无法解决的严重问题。</p><p>如：JVM 系统内部错误，资源耗尽等严重情况。Error是严重错误，程序会崩溃。</p></li><li><p>Exception：其他因编程错误或偶然的外部因素导致的一般性问题，可以使用针对性的代码进行处理。</p><p>如：空指针访问，试图读取不存在的文件，网络中断等等。</p><p>Exception 又分为两大类：</p><ul><li>运行时异常（程序运行时，发生的异常）</li><li>编译时异常（编程时，编译器检查出的异常）</li></ul></li></ul></blockquote><h2 id="异常体系图">11.1 异常体系图</h2><blockquote><p>编译异常（受检异常） 和 运行异常（非受检异常）</p><p>Java 源程序 ——(javac.exe)——&gt; 字节码文件 ——(java.exe)——&gt;在内存中加载，运行类</p><p>​ 编译异常↑ 运行异常↑</p></blockquote><p><img src="/img/Java_InputImage/异常体系图_11.1.png" /></p><p>​ <em>（异常体系图_11.1）</em></p><p>异常分为两大类：运行时异常 和 编译时异常</p><ul><li><p>运行时异常，编译器不要求强制处置的异常。一般是指编程的逻辑错误，是程序员应该避免其出现的异常。</p><p>java.lang.RuntimeException 类及它的子类都是运行时异常</p><p>对于运行时异常，可以不做处理。因为这类异常很普遍，若全处理会对程序的可读性和运行效率产生影响</p></li><li><p>编译时异常，是编译器要求必须处置的异常</p></li></ul><h3 id="常见的运行时异常">11.1.1 常见的运行时异常</h3><blockquote><p>常见的运行时异常（RuntimeException）包括</p><ul><li>NullPointerException：空指针异常</li><li>ArithmeticException：数学运算异常</li><li>ArrayIndexOutOfBoundsException：数组下标越界异常</li><li>ClassCastException：类型转换异常</li><li>NumberFormatException：数学格式异常</li></ul></blockquote><p><strong>空指针异常</strong></p><ul><li>当应用程序试图在需要对象的地方使用 null 时，抛出该异常。</li></ul><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> str.length;<span class="hljs-comment">//这里，出现了 空指针异常</span></code></pre></div></blockquote><p><strong>数学运算异常</strong></p><ul><li>当出现异常的运算条件时，抛出该异常。</li></ul><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">double</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span> / <span class="hljs-number">0</span>;<span class="hljs-comment">//这里，出现了 数学运算异常</span></code></pre></div></blockquote><p><strong>数组下标越界异常</strong></p><ul><li>用非法索引（为负或超出范围）访问数组时，抛出该异常。</li></ul><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;nums[-<span class="hljs-number">50</span>] = <span class="hljs-number">100</span>;<span class="hljs-comment">//这里，出现了 数组下标越界异常</span></code></pre></div></blockquote><p><strong>类型转换异常</strong></p><ul><li>当试图把对象强制转换为不是实例的子类时，抛出该异常。</li></ul><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;        <span class="hljs-type">A</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A1</span>();        <span class="hljs-type">A2</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> (A2)a1;<span class="hljs-comment">//这里，出现了 类型转换异常</span>    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">A2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123;&#125;</code></pre></div></blockquote><p><strong>数字格式不正确异常</strong></p><ul><li>当应用程序试图将字符串转成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</li></ul><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ABC&quot;</span>;<span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> Integer.parseInt(str);<span class="hljs-comment">//这里，出现了 数字格式不正确异常</span></code></pre></div></blockquote><h3 id="常见的编译异常">11.1.2 常见的编译异常</h3><blockquote><p>常见的编译异常：</p><ul><li>SQLException：操作数据库时，查询表可能发生异常</li><li>IOException：操作文件时，发生的异常</li><li>FileNotFoundException：操作一个不存在的文件时，发生的异常</li><li>ClassNotFoundException：加载类，而该类不存在时，发生的异常</li><li>EOFException：操作文件，到文档末尾，发生的异常</li><li>IllegalArguementException：参数异常</li></ul></blockquote><p>因为还没有学习 SQL、文件编程 等，这里不举例子</p><h2 id="异常处理">11.2 异常处理</h2><blockquote><p>异常发生时，对异常的处理方式。如果没有显式异常处理，默认处理方式是<code>throws</code></p><ul><li><code>try - chatch - finally</code>：程序员在代码中捕获发生的异常，自行处理</li><li><code>throws</code>：将发生的异常抛出，交给调用者（方法）来处理。最顶级的处理者就是JVM</li></ul></blockquote><h3 id="try---catch-异常处理">11.2.1 <code>try - catch</code>异常处理</h3><blockquote><p>Java 提供 try 和 catch 块 来处理异常。try块用于包含可能出错的代码，catch 块用于处理 try块中的异常。可以根据需要在程序中有多个 <code>try - catch</code> 块。</p></blockquote><blockquote><p>基本语法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//可疑代码</span><span class="hljs-comment">//将异常生成对应的异常对象，传递给 catch 块</span>&#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;<span class="hljs-comment">//如果发生异常，执行这些代码</span>&#125; <span class="hljs-keyword">finally</span> &#123;    <span class="hljs-comment">//无论是否异常，都执行这些代码</span>    <span class="hljs-comment">//finally 块可以不写</span>&#125;</code></pre></div></blockquote><blockquote><p>快捷键：选中代码后按 ctrl + alt + T</p></blockquote><h4 id="使用细节">11.2.1.1 使用细节</h4><ol type="1"><li><p>如果异常发生了，则异常发生后面的代码块都不执行，直接进入 catch块</p></li><li><p>如果异常未发生，则顺序执行 try 代码块，catch 块不执行</p></li><li><p>如果希望不管是否异常，都执行一些代码，则使用 finally</p></li><li><p>可以有多个 catch 捕获不同的异常。要求子类异常在前，父类异常在后。</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;...&#125; <span class="hljs-keyword">catch</span> (NullPointerException e) &#123;...&#125; <span class="hljs-keyword">catch</span> (ArithmeticException e) &#123;...&#125; <span class="hljs-keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;...&#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;...&#125;</code></pre></div></blockquote></li><li><p>可以进行 try - finally 配合使用（不写catch）。这种用法相当于没有捕获异常，此时程序如果出错会直接退出。</p><p>应用场景，就是写一段代码，不管是否发生异常，都必须执行某个业务逻辑。</p></li><li><p>如果没有出现异常，执行 try 中所有语句，不执行 catch语句，最后执行 finally 语句</p></li><li><p>如果出现异常，则 try 块异常发生后，剩余语句不执行。之后执行 catch语句，最后，执行 finally 语句。</p></li></ol><h3 id="throws-异常处理">11.2.2 <code>throws</code> 异常处理</h3><blockquote><p>如果一个方法可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显式地声明抛出异常，表明该方法将不对这些异常进行处理，而由调用者负责处理</p><p>在方法中声明 <code>throws</code>语句可以声明抛出异常的列表。<code>throws</code>后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。</p></blockquote><blockquote><p>语法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">metord</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> FileNontFoundException ,NullPointerException &#123;...&#125;</code></pre></div></blockquote><h4 id="使用细节-1">11.2.2.1 使用细节</h4><ol type="1"><li>对于 <strong>编译异常</strong>，程序中必须处理。</li><li>对于 <strong>运行异常</strong>，程序中诺没有处理，默认处理是<code>throws</code></li><li>子类 重写父类方法时，子类方法抛出的异常类型必须和父类一致，或者是父类抛出异常类型的子类型。</li><li>如果有 <code>try - catch</code> 就不必 <code>throws</code> 了</li></ol><h2 id="自定义异常">11.3 自定义异常</h2><blockquote><p>当程序中出现了某些 “错误”，但该信息并未在 <code>Throwable</code>子类中描述处理，这时候可以自己设计异常类，用于描述该错误信息</p></blockquote><ol type="1"><li>定义类：自定义异常类名，继承 RuntimeException 或 Exception</li><li>如果继承 Exception，属于 编译异常。</li><li>如果继承 RuntimeException，属于运行异常。（一般来说，选这个。这样利用了默认处理机制，更方便）</li></ol><blockquote><div class="code-wrapper"><pre><code class="hljs java">&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Metords</span> &#123;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;       <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;       <span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">100</span>)&#123;           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomException</span>(<span class="hljs-string">&quot;不能大于100&quot;</span>);       &#125;   &#125;&gt;&#125;&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span> &#123;<span class="hljs-keyword">public</span> <span class="hljs-title function_">CustomException</span><span class="hljs-params">(String message)</span> &#123;<span class="hljs-built_in">super</span>(message);&#125;&gt;&#125;</code></pre></div></blockquote><h3 id="throw-和-throws">11.3.1 <code>throw</code> 和<code>throws</code></h3><table><thead><tr class="header"><th></th><th>意义</th><th>位置</th><th>后面跟的东西</th></tr></thead><tbody><tr class="odd"><td><code>throws</code></td><td>异常处理的一种方式</td><td>方法声明时</td><td>异常类型</td></tr><tr class="even"><td><code>throw</code></td><td>手动生成异常对象关键字</td><td>方法体中</td><td>异常对象</td></tr></tbody></table><h3 id="编程小技巧">11.3.2 编程小技巧</h3><p>老韩曰：编写异常时，先确定正确的情况，然后取反。这样写，你的思路就不乱。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt;10 枚举和注解</title>
    <link href="/2021/12/17/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/10%20%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3/"/>
    <url>/2021/12/17/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/10%20%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="枚举和注解">10 枚举和注解</h1><h2 id="枚举">10.1 枚举</h2><p>把具体的对象一一列举出来的类，就称为 枚举类（enumeration）</p><p>实现方法：</p><ol type="1"><li>自定义枚举</li><li><code>enum</code> 关键字枚举</li></ol><h3 id="自定义枚举">10.1.1 自定义枚举</h3><ol type="1"><li>构造器私有化</li><li>去掉 set 方法（可保留get），防止属性被修改。因为枚举对象值通常为只读</li><li>在类内部直接创建固定对象。使用 <code>final</code> +<code>static</code> 共同修饰，对象名通常全部大写。</li><li>枚举对象按照需要可以有多个属性</li></ol><h3 id="enum-关键字">10.1.2 <code>enum</code> 关键字</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Example</span> &#123; RED(<span class="hljs-string">&quot;小红&quot;</span>, <span class="hljs-number">10</span>), BLUE(<span class="hljs-string">&quot;小蓝&quot;</span>, <span class="hljs-number">11</span>), YELLOW; <span class="hljs-comment">//这句话要放在前面，第三个是无参</span> <span class="hljs-keyword">private</span> String name; <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age; <span class="hljs-keyword">private</span> <span class="hljs-title function_">Example</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;     <span class="hljs-built_in">this</span>.name = name;     <span class="hljs-built_in">this</span>.age = age; &#125;&#125;</code></pre></div><ol type="1"><li>用关键字 <code>enum</code> 替代 <code>class</code></li><li>用 <code>常量名.(形参列表);</code>代替创建对象（放在前面）。多个对象的场合，用 <code>,</code> 间隔。</li><li>如果使用 <code>enum</code> 枚举，要求将常量对象写在前面</li></ol><h4 id="使用细节">10.1.2.1 使用细节</h4><ol type="1"><li><p>当我们用 <code>enum</code> 关键字开发一个枚举类时，默认会继承java.lang.Enum 类，而且是一个 <code>final</code> 类。</p><p>这样，我们就能使用 Enum 中的相关方法。</p><p><strong>也正因为如此，<code>enum</code>类不能继承其他类，亦不能被其它类继承</strong></p><p>不过，<code>enum</code> 类和其他类一样，可以实现接口。</p></li><li><p>传统的 <code>public ststic final RED("小红", 10);</code> 简化为<code>RED("小红", 10);</code></p></li><li><p>如果使用无参构造器创建枚举对象，则 实参列表 和 <code>( )</code>都能省略</p></li></ol><h4 id="enum-类中的常用方法">10.1.2.2 <code>Enum</code>类中的常用方法</h4><ul><li><code>valueOf</code>：将字符串转换成枚举对象。要求字符串必须是已有的常量名，否则报异常。</li><li><code>values</code>：返回一个数组<code>Example[]</code>，其中包含定义的所有枚举对象</li><li><code>getDeclaringClass</code>：得到枚举常量所属的<code>class</code></li><li><code>name</code>：得到当前枚举常量的名称。建议优先用<code>toString</code></li><li><code>ordinal</code>：输出该枚举对象的次序/编号（从 0开始编号。如上例 <code>BLUE.ordinal = 1</code>）</li><li><code>compareTo</code>：比较两个枚举常量的编号（调用常量编号 减去传入常量编号）</li><li><code>clone</code>：枚举类不能<code>clone</code>，所以，这是一个只会抛出异常的方法</li></ul><h2 id="注解">10.2 注解</h2><p>注解（Annotation）也被称为元数据（Metadata）。用于修饰包、类、方法、属性、构造器、局部变量 等数据信息</p><p>和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息</p><p>在 JavaSE 中，注解的使用目的比较简单，例如 标记过时的功能，忽略警告等。在 JavaEE中注解占据了更重要的角色，例如用于配置应用程序的任何切面，代替 JavaEE旧版中所遗留的繁冗代码和 XML 配置等。</p><ol type="1"><li>使用 <code>@Annotation</code> 时要在前面增加 <code>@</code>符号，并把该注解当成一个修饰符使用。用于修饰它支持的程序元素。</li><li>三个基本的 <code>@Annotation</code>：<ul><li><code>@Override</code>：限定某个方法，是 重写父类方法。该注解只能用于方法。如果你写了该注解，编译器会替你校验，看看是不是真的重写 了父类方法。</li><li><code>@Deprecated</code>：用于表示某个程序元素（类、方法等）已经过时</li><li><code>@SuppressWarnings()</code>：抑制编辑器警告</li></ul></li><li>如果发现 <code>public @interface XXX&#123;&#125;</code>这种东西，说明是定义了一个注解类 <code>XXX</code>。这里的<code>@interface</code> 不代表接口（<code>interface</code>）。</li></ol><h3 id="override">10.2.1 <code>@Override</code></h3><ol type="1"><li><code>@Override</code>表示指定重写父类的方法（从编译器层面验证），如果父类没有该方法，就报错</li><li>不写该注解，重写依然构成重写</li><li><code>@Override</code> 只能修饰方法，不能修饰其他类、包、属性等</li><li>查看 <code>@Override</code> 注解源码为<code>@Target(ElementType.METHOD)</code> 说明只能修饰方法</li><li><code>@Target</code> 是修饰注解的注解，称为 元注解</li></ol><h3 id="deprecated">10.2.2 <code>@Deprecated</code></h3><ol type="1"><li><p><code>@Deprecated</code>表示指定的某个程序元素（类、方法等）已过时</p></li><li><p>不推荐使用，但仍能使用</p></li><li><p>可以修饰方法、类、字段、包、参数</p><p><code>@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</code></p></li><li><p><code>@Deprecated</code> 可以做到新旧版本的兼容和过度</p></li></ol><h3 id="suppresswarnings">10.2.3 <code>@SuppressWarnings()</code></h3><ol type="1"><li><p>当我们不想看到警告信息时，用 <code>@SuppressWarnings()</code></p><p>语法：<code>@SuppressWarnings(&#123;"..."&#125;)</code></p><p>在后面 <code>(&#123;"unused", "unchecked"&#125;)</code>这样写入你希望抑制的信息，以下是所有可以输入的关键字</p><table><thead><tr class="header"><th style="text-align: left;"><strong>关键字</strong></th><th style="text-align: left;"><strong>用途</strong></th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">all</td><td style="text-align: left;">抑制所有警告</td></tr><tr class="even"><td style="text-align: left;">boxing</td><td style="text-align: left;">抑制与装箱/解装箱操作相关的警告</td></tr><tr class="odd"><td style="text-align: left;">cast</td><td style="text-align: left;">抑制与强制转换操作相关的警告</td></tr><tr class="even"><td style="text-align: left;">dep-ann</td><td style="text-align: left;">抑制与已弃用注释相关的警告</td></tr><tr class="odd"><td style="text-align: left;">deprecation</td><td style="text-align: left;">抑制与弃用有关的警告</td></tr><tr class="even"><td style="text-align: left;">fallthrough</td><td style="text-align: left;">抑制与 switch语句中丢失断点相关的警告</td></tr><tr class="odd"><td style="text-align: left;">finally</td><td style="text-align: left;">抑制不返回的 finally 块的相关警告</td></tr><tr class="even"><td style="text-align: left;">hiding</td><td style="text-align: left;">抑制与隐藏变量的局部变量相关的警告</td></tr><tr class="odd"><td style="text-align: left;">incomplete-switch</td><td style="text-align: left;">抑制与 switch语句中缺少条目相关的警告（enum）</td></tr><tr class="even"><td style="text-align: left;">nls</td><td style="text-align: left;">抑制与 非nls 字符串字面值相关的警告</td></tr><tr class="odd"><td style="text-align: left;">null</td><td style="text-align: left;">抑制相对于null分析的警告</td></tr><tr class="even"><td style="text-align: left;">rawtypes</td><tdstyle="text-align: left;">在类参数上使用泛型时，抑制与非特定类型相关的警告</td></tr><tr class="odd"><td style="text-align: left;">restriction</td><td style="text-align: left;">抑制与不推荐或禁止引用有关的警告</td></tr><tr class="even"><td style="text-align: left;">serial</td><tdstyle="text-align: left;">抑制与可序列化类缺少serialVersionUID字段相关的警告</td></tr><tr class="odd"><td style="text-align: left;">static-access</td><td style="text-align: left;">抑制与不正确的静态访问有关的警告</td></tr><tr class="even"><td style="text-align: left;">synthetic-access</td><td style="text-align: left;">抑制与未优化的内部类访问相关的警告</td></tr><tr class="odd"><td style="text-align: left;">unchecked</td><td style="text-align: left;">抑制与未检查的操作相关的警告</td></tr><tr class="even"><td style="text-align: left;">unqualified-field-access</td><td style="text-align: left;">抑制与字段访问不合格相关的警告</td></tr><tr class="odd"><td style="text-align: left;">unused</td><td style="text-align: left;">抑制与未使用代码相关的警告</td></tr></tbody></table></li><li><p><code>@SuppressWarnings</code>的范围与你放置的位置相关。</p></li></ol><h3 id="jdk-的元注解了解即可">10.2.4 JDK 的元注解（了解即可）</h3><blockquote><p>JDK 的 元注解 是用于修饰其他注解的注解</p></blockquote><ol type="1"><li><p><code>@Rentention</code>：指定注解的作用范围，有三种范围<code>SOURCE</code> <code>CLASS</code> <code>RUNTIME</code></p><p><code>@Rentention</code> 的三种值：</p><ul><li><code>RententionPolicy.SOURCE</code>：编译器使用后，直接丢弃这种策略的注释</li><li><code>RententionPolicy.CLASS</code>：编译器把注解记录在 class文件中。当运行 Java 程序时， JVM 不会保留注释。这是默认值</li><li><code>RententionPolicy.RUNTIME</code>：编译器把注解记录在 class文件中。当运行 Java 程序时，JVM会保留注解。程序可以通过反射获取该注解</li></ul></li><li><p><code>@Target</code>：指定注解的使用范围</p><p><code>@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</code></p></li><li><p><code>@Documented</code>：指定该注解会不会在 Javadoc体现</p></li><li><p><code>@Inherited</code>：子类会继承父类注解</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt;9 面向对象编程（高级）</title>
    <link href="/2021/12/14/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/9%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/"/>
    <url>/2021/12/14/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/9%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象编程高级">9 面向对象编程（高级）</h1><h2 id="类变量和类方法">9.1 类变量和类方法</h2><h3 id="类变量">9.1.1 类变量</h3><blockquote><p>类变量：也叫静态变量/静态属性。是该类所有对象共享的变量。任何一个该类对象访问时都是相同的值，任何一个该类对象修改时也是同一个变量。</p><p>语法（推荐）：<code>访问修饰符 static 数据类型 变量名;</code></p><p>或者也可以：<code>static 访问修饰符 数据类型 变量名;</code></p><p>根据 JDK 版本的不同，类变量存放在 堆 中或 方法区 中。</p></blockquote><ol type="1"><li><p>什么时候需要用类变量：</p><p>当我们需要让某个类的所有对象都共享一个变量时，就可以考虑使用类变量（静态变量）</p></li><li><p>类变量 与 实例变量（普通属性）的区别：</p><p>类变量 是该类所有对象共享的，而 实例变量 是每个对象独享的</p></li><li><p>加上 <code>static</code> 称为 类变量 或 静态变量。否则称为实例变量/普通变量/非静态变量</p></li><li><p>静态变量 可以通过 <code>类名.类变量名;</code> 或<code>对象名.类变量名;</code> 来访问。但 Java 设计者推荐我们用<code>类名.类变量名;</code> 来访问。（需满足访问权限和范围）</p></li><li><p>类变量是在加载类时就初始化了。所以，没有创建对象实例也能访问。</p></li><li><p>类变量 的生命周期是随着 类的加载 开始，随着 类的消亡而销毁。</p></li><li><p>特别地：<strong>一个 null 对象也可以访问静态变量 /静态方法</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">met</span><span class="hljs-params">()</span> &#123;        System.out.println(++n);    &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;        <span class="hljs-type">Test</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        System.out.println(t.n);<span class="hljs-comment">//这样不会报错</span>        t.met();<span class="hljs-comment">//这样也不会报错</span>    &#125;&#125;</code></pre></div></li></ol><h3 id="类方法">9.1.2 类方法</h3><blockquote><p>当方法使用 <code>static</code> 修饰后，就是静态方法。静态方法就能访问静态属性。如果我们不希望创建实例，也能调用方法，这个场合把方法做成静态方法是合适的。开发工具类时就可以如此做。</p></blockquote><ol type="1"><li>类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区。</li><li>类方法中不允许使用和对象有关的关键字。所以，类方法没有<code>this</code> 或 <code>super</code></li><li>类方法可以通过类名调用，也能通过对象名调用。普通方法不能通过类名调用。</li><li>类方法 中只能访问 类变量 或 类方法</li><li>普通方法既可以访问普通方法也可以访问类方法</li></ol><h2 id="理解-main-方法语法">9.2 理解 <code>main</code> 方法语法</h2><blockquote><p><code>public static void main(String[] args)&#123;...&#125;</code></p></blockquote><ol type="1"><li><p><code>main</code> 方法 是 JVM 调用的方法。所以该方法的 访问权限必须为 <code>public</code></p></li><li><p>JVM 在执行 <code>main</code> 方法时不必创建对象，所以<code>main</code>方法 必须为 <code>static</code></p></li><li><p>该方法接收 <code>String</code> 类型的数组参数。该数组中保存执行Java 命令 时传递给所运行的类的参数。</p><blockquote><p>工作台中：<code>javac 执行的程序.java</code></p><p>​<code>java 执行的程序 参数1(arg[0]) 参数2(arg[1]) 参数3(arg[2]) ..</code></p><p><ahref="https://www.bilibili.com/video/BV1fh411y7R8?p=385&amp;t=129.5"title="看视频吧，累了">IDEA中怎么做？</a></p></blockquote></li><li><p>在 <code>main</code> 方法 中，我们可以直接调用 <code>main</code>方法 所在类的静态方法或静态属性。</p><p>但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例后才能通过该实例访问非静态成员。</p></li></ol><h2 id="代码块">9.3 代码块</h2><blockquote><p>代码块：又称为初始化块。属于类中的成员。类似于方法，将逻辑语句封装在方法体中，通过<code>&#123; &#125;</code> 包围起来。</p><p>和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显式调用，而是加载类时，或创建对象时 隐式调用。</p><p>语法：<code>[修饰符]&#123;代码&#125;;</code></p></blockquote><ol type="1"><li>修饰符 是可选项，可不写。要写的话，只能写 <code>static</code></li><li>代码块分为两类：<ul><li>静态代码块：有 <code>static</code></li><li>普通代码块：无 <code>static</code></li></ul></li><li>逻辑语句可以为任意的逻辑语句。</li><li><code>;</code> 可以写，也可以省略。建议写上。</li><li>代码块相当于另一种形式的构造器（构造器的补充机制），可以做初始化操作</li><li>如果多个构造器中都有重复语句，就可以抽取到初始化块中，提高代码复用率。这样，不管用哪个构造器，都会执行代码块。</li></ol><h3 id="使用细节">9.3.1 使用细节</h3><ol type="1"><li><code>static</code> 代码块：作用是对类进行初始化。<strong>随着类的加载会且只会执行一次</strong>。相对的：普通代码块每创建一个对象就执行一次。</li></ol><ul><li><p><strong>类什么时候被加载？ </strong></p><ul><li><p>创建对象实例时（new）</p></li><li><p>创建子类对象实例，父类也会加载</p></li><li><p>使用类的静态成员时（父类也会加载）</p></li></ul><p>以上情况下类会被加载。加载后不需要再次加载，所以，静态代码块也只会执行一次。</p></li></ul><ol start="2" type="1"><li><p>创建一个对象时，在 <strong>一个类里</strong> 调用顺序是：</p><ul><li>调用静态代码块 和静态属性初始化。这两者优先级相同，多个存在时按照定义的顺序依次执行。</li><li>调用普通代码块 和 普通属性初始化。这两者优先级也相同。</li><li>调用构造器。</li></ul></li><li><p><code>构造器</code> 的最前面其实隐含了 <code>super();</code> 和<code>调用普通代码块</code>。而静态相关的代码块，属性初始化，在类加载时就执行完毕了。</p><p>这样，创建一个对象时，在 <strong>有继承关系的多个类里</strong>调用顺序是：</p><ul><li>父类 静态代码块 和 静态初始化</li><li>子类 静态代码块 和 静态初始化</li><li>父类 普通代码块 和 普通初始化</li><li>父类 构造器</li><li>子类 普通代码块 和 普通初始化</li><li>子类 构造器</li></ul></li><li><p>静态代码块 只能调用 静态成员。普通代码块 能调用任意成员。</p></li></ol><h2 id="单例设计模式">9.4 单例设计模式</h2><blockquote><p>什么是设计模式：设计模式是在大量的实践中总结和理论化后优选的代码结构、编程风格、解决问题的思考方式。设计模式就像是经典的棋谱，免去我们自己再思考和摸索。</p></blockquote><p>单例设计模式：采取一定的方法，保证再整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法</p><h3 id="应用实例">9.4.1 应用实例</h3><blockquote><p>后面会学更多，这里先展示两种：饿汉式、懒汉式</p></blockquote><h4 id="饿汉式">9.4.1.1 饿汉式</h4><p>步骤如下：</p><ol type="1"><li><p>构造器私有化（防止用户直接 new）</p></li><li><p>类的内部创建对象</p></li><li><p>向外暴露一个静态的公共方法</p></li><li><p>代码实现</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GF</span>&#123;       <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">GF</span> <span class="hljs-variable">gf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GF</span>(<span class="hljs-string">&quot;萝茵&quot;</span>);       <span class="hljs-keyword">private</span> <span class="hljs-title function_">GF</span><span class="hljs-params">(String name)</span>&#123;           <span class="hljs-built_in">this</span>.name = name;       &#125;       <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GF <span class="hljs-title function_">getGF</span><span class="hljs-params">()</span>&#123;           <span class="hljs-keyword">return</span> gf;       &#125; &#125;</code></pre></div><p>对象，通常都是重量级的对象</p><p>有时，我们用不到这个创建的对象，那个场合，会造成资源浪费。</p></blockquote></li></ol><h4 id="懒汉式">9.4.1.2 懒汉式</h4><p>步骤如下：</p><ol type="1"><li><p>构造器私有化</p></li><li><p>定义一个静态属性对象</p></li><li><p>提供一个静态的公共方法，可以返回对象。如果静态对象为空，则创建对象</p></li><li><p>代码实现</p><blockquote><div class="code-wrapper"><pre><code class="hljs java">  &gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">GF</span>&#123;   <span class="hljs-keyword">private</span> String name;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> GF gf;   <span class="hljs-keyword">private</span> <span class="hljs-title function_">GF</span><span class="hljs-params">(String name)</span>&#123;       <span class="hljs-built_in">this</span>.name = name;   &#125;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GF <span class="hljs-title function_">getGF</span><span class="hljs-params">()</span>&#123;       <span class="hljs-keyword">if</span>(gf == <span class="hljs-literal">null</span>)&#123;           gf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GF</span>(<span class="hljs-string">&quot;萝茵&quot;</span>);       &#125;       <span class="hljs-keyword">return</span> gf;   &#125;   &gt;&#125;</code></pre></div></blockquote></li></ol><h4 id="两种方法对比">9.4.1.3 两种方法对比</h4><ol type="1"><li>二者创建对象的时机不同。饿汉式在加载类信息时创建，懒汉式在使用时才创建</li><li>饿汉式可能造成资源浪费，懒汉式可能存在线程安全问题（学习[线程]后会进行完善）。</li><li>Java SE 标准类中 java.lang.Runtime 就是一个单例模式。</li></ol><h2 id="final-关键字">9.5 <code>final</code> 关键字</h2><blockquote><p><code>final</code> 可以修饰 类、属性、方法、局部变量</p><p>以下情况下，可能用到 <code>final</code></p><ol type="1"><li><code>final</code> 修饰类：该类不能被继承</li><li><code>final</code> 修饰方法：该方法不能被重写</li><li><code>final</code> 修饰值：该值不能被修改</li></ol></blockquote><h3 id="使用细节-1">9.5.1 使用细节</h3><ol type="1"><li><p><code>final</code> 修饰的属性又叫常量，一般用 XX_XX_XX来命名（全大写字母+下划线）</p></li><li><p><code>final</code>修饰的属性在定义时，必须赋初始值，且之后不能再修改。赋值可以在下列位置之一：</p><ul><li>定义时</li><li>构造器中</li><li>代码块中</li></ul><p>注意：如果 <code>final</code>修饰的属性是静态的，则只能在以下位置赋值。</p><ul><li>定义时</li><li>静态代码块中</li></ul></li><li><p><code>final</code>类不能继承，但能实例化对象。对的，是可以的。</p></li><li><p>如果不是 <code>final</code> 类，但含有 <code>final</code>方法，虽然该方法不能重写，但能被继承。</p></li><li><p><code>final</code> 类可以有 <code>final</code>方法。可以，但没必要。</p></li><li><p><code>final</code> 不能修饰构造方法。</p></li><li><p><code>final</code> 和 <code>static</code>搭配使用，效率更高（那个场合，虽然顺序不限，还是推荐 <code>static</code>在前）。底层编译器做了优化处理。这样做，调用<strong>属性（定义时赋值）</strong> 时居然<strong>不会造成类的加载！</strong></p></li><li><p>包装类（Integer、Double、Float、Boolean、String等）都是<code>final</code> 类，都不能被继承。</p></li></ol><h2 id="抽象类">9.6 抽象类</h2><blockquote><p>当父类的某些方法需要声明，却不知道如何实现时，可以将其声明为抽象方法。那个场合，要将该类声明为<code>abstract</code> 类。</p><p>抽象类的价值更多是用于设计。设计者设计好后，让子类继承并实现。也是考官爱问的考点。</p></blockquote><blockquote><p>定义抽象类：<code>访问修饰符 abstract 类名&#123;...&#125;</code></p><p>定义抽象方法（注意：无方法体）：<code>访问修饰符 abstract 返回值 方法名(形参列表);</code></p></blockquote><h3 id="使用细节-2">9.6.1 使用细节</h3><ol type="1"><li>抽象类不能被实例化</li><li>抽象类不一定包含抽象方法。也就是说，抽象类可以没有<code>abstract</code>方法</li><li>一旦包含 <code>abstract</code> 方法，则该类一定要声明为<code>abstract</code></li><li><code>abstract</code> 只能修饰 类 和 方法，不能修饰其他。</li><li>抽象类可以有任意成员（非抽象方法、构造器、静态属性等）。即，抽象类本质还是类。</li><li>抽象方法不能有主体。即，抽象方法不能实现。</li><li>如果一个类继承了 <code>abstract</code> 类，则其必须实现所有<code>abstract</code> 方法，除非其自己也是 <code>abstract</code>类。</li><li>抽象方法不能用 <code>private</code> <code>final</code><code>static</code> 来修饰。因为，这些关键词都和 重写 相违背。</li></ol><h3 id="模板设计模式">9.6.2 模板设计模式</h3><h2 id="接口">9.7 接口</h2><blockquote><p>接口就是给出一些没有实现的方法，封装到一起，到某个类要用的时候，再根据具体情况把这些方法写出来。</p><p>语法：<code>interface 接口名&#123;...&#125;</code></p><p><code>class 类名 implements 接口名&#123;...必须实现接口的抽象方法...&#125;</code></p><p>注意：JDK 7.0 以前，接口中只能是抽象方法。而 JDK 8.0后，接口可以有静态（<code>static</code>）方法、默认（<code>default</code>）方法。</p><p>在接口中，抽象方法可以省略 <code>abstract</code></p></blockquote><p>接口中可以存在：</p><ul><li>属性（只有静态 <code>static</code> 属性，可以不加<code>static</code> 关键字）</li><li>方法（抽象 <code>abstract</code> 方法、默认 <code>default</code>实现方法、静态 <code>static</code> 方法）</li></ul><h3 id="使用细节-3">9.7.1 使用细节</h3><ol type="1"><li>接口 不能被实例化。</li><li>接口中所有方法都是 <code>public</code> 方法。接口中的 抽象方法可以不用 <code>abstract</code> 修饰。</li><li>一个普通类实现接口，就必须把该接口所有方法都实现。（用快捷键吧<code>alt + enter</code>）</li><li>抽象类实现接口，可以不用实现接口的方法。</li><li>一个类可以同时实现多个接口。<code>class Name implements In1,In2&#123;...&#125;</code></li><li>接口中的属性只能是 <code>final</code> 的，并且是<code>public static final</code> 修饰符。修饰符就算不写，还是这样。</li><li>接口中属性的访问形式：<code>接口名.属性名</code></li><li>接口不能 <strong>继承</strong> 其他的类，但可以<strong>继承</strong><font color=#FF0000>多个</font>别的接口。（不是也不能 实现别的接口）</li><li>接口的修饰符只能是 <code>public</code> 和默认。这点和类的修饰符相同。</li></ol><h3 id="实现接口-vs-继承类">9.7.2 实现接口 vs 继承类</h3><ol type="1"><li>当子类继承父类，就自动拥有父类的所有功能。如果需要扩展功能，可以通过接口方式扩展。</li><li>可以认为，接口 是对于 Java 单继承机制的补充。</li><li>继承的价值主要在于：解决代码的复用性和可维护性。</li><li>接口的价值主要在于：设计。设计好各种规范，让其他类去实现这些方法。</li><li>接口比继承更加灵活。继承需要满足 is - a 的关系，而接口只需要满足like - a 关系。</li><li>接口在一定程度上实现代码解耦。（即：接口规范性 + 动态绑定机制）</li></ol><h3 id="接口的多态特性">9.7.3 接口的多态特性</h3><ol type="1"><li><p>多态参数（接口的引用可以指向实现了接口的类的对象）</p><blockquote><p><code>viod work(Inerface01 i1)&#123;...&#125;</code>参数可以传入任意实现该接口的类</p></blockquote></li><li><p>多态数组</p></li><li><p>接口存在多态传递现象</p></li></ol><h2 id="内部类">9.8 内部类</h2><blockquote><p>一个类的内部又完整的嵌套了另一个类结构。被嵌套的类被称为 内部类。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<span class="hljs-comment">//外部类</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;<span class="hljs-comment">//内部类</span>&#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Other</span>&#123;<span class="hljs-comment">//外部其他类</span>&#125;</code></pre></div><p>内部类的最大特点是可以直接访问私有属性，并且可以体现类与类之间的包含关系。</p></blockquote><h3 id="四种内部类">9.8.1 四种内部类</h3><p>分别是：</p><ul><li>定义在外部类的局部位置上<ul><li>局部内部类：有 类名</li><li><strong>匿名内部类：无 类名</strong></li></ul></li><li>定义在外部类的成员位置上<ul><li>成员内部类：无 <code>static</code> 修饰</li><li>静态内部类： <code>static</code> 修饰的类</li></ul></li></ul><h3 id="局部内部类">9.8.2 局部内部类</h3><blockquote><p>局部内部类：定义在外部类的局部位置上，并且有类名。（局部位置？比如：方法/代码块里）</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<span class="hljs-comment">//外部类</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tools01</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123;<span class="hljs-comment">//局部内部类</span>        &#125;    &#125;&#125;</code></pre></div></blockquote><h4 id="使用细节-4">9.8.2.1 使用细节</h4><ol type="1"><li><p>定义在外部类的局部位置上，并且有类名。</p></li><li><p>可以访问外部类的所有成员，包含私有成员</p></li><li><p>局部内部类可以 直接访问 外部类的成员。</p></li><li><p>不能添加 访问修饰符，因为其地位相当于局部变量。但，可以使用<code>final</code>，因为局部变量也能用 <code>final</code></p></li><li><p>作用域 仅仅在定义它的方法或代码块中</p></li><li><p>外部类 在方法中，可以创建 局部内部类的对象实例，然后调用方法。</p></li><li><p>外部其他类 不能访问 局部内部类</p></li><li><p>如果外部类和局部内部类的成员重名时，默认遵循就近原则。那个场合，访问外部类成员使用<code>外部类名.this.变量名</code></p><p><code>外部类名.this</code> 本质就是外部类的对象。即，调用了该方法（上例的 <code>tools01</code> ）的对象</p><p>还不懂的话，看一下 <ahref="https://www.bilibili.com/video/BV1fh411y7R8?p=415&amp;t=289.9"title="谢谢韩老师">这个视频</a> 悟一悟</p></li></ol><h3 id="匿名内部类">9.8.3 匿名内部类</h3><blockquote><p>匿名内部类：定义在外部类的局部位置，且没有类名</p><div class="code-wrapper"><pre><code class="hljs java">&gt;<span class="hljs-keyword">new</span> 类/接口 (参数列表) &#123;   类体&gt;&#125;</code></pre></div><p>匿名内部类本质是没有名字的类，而且是内部类。同时，还是一个对象。</p><p>可以用匿名内部类简化开发</p></blockquote><blockquote><p>一个例子</p><div class="code-wrapper"><pre><code class="hljs java">&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<span class="hljs-comment">//外部类</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tools01</span><span class="hljs-params">()</span> &#123;       <span class="hljs-type">Inter</span> <span class="hljs-variable">whatEver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inter</span>()&#123;<span class="hljs-comment">//匿名内部类            </span>       &#125;;   &#125;&gt;&#125;&gt;<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Inter</span>&#123;&gt;&#125;</code></pre></div><p>其实，这个匿名内部类 <code>new Inter()&#123;&#125;</code> 的运行类型就是<code>class XXXX implements Inter</code>。系统自动分配的名字是<code>Outer$1</code>（<code>whatEver.getClass = "Outer$1"</code>）</p><p>JDK 在创建匿名内部类 <code>Outer$1</code>时，立即创建了一个对象实例，并将地址返回给了 <code>whatEver</code></p><p>匿名内部类使用一次后就不能再次使用（<code>Outer$1</code>就这一个了）</p></blockquote><h4 id="使用细节-5">9.8.3.1 使用细节</h4><ol type="1"><li>匿名内部类语法比较独特。其既是一个类的定义，也是一个对象。因此，从语法上看，其既有定义类的特征，也有 创建对象的特征。</li><li>可以访问外部类的所有成员，包括私有的。</li><li>局部内部类可以 直接访问 外部类的成员。</li><li>不能添加 访问修饰符，因为其地位相当于局部变量。但，可以使用<code>final</code>，因为局部变量也能用 <code>final</code></li><li>作用域：仅仅在定义它的方法或方法快中</li><li>外部其他类 不能访问 匿名内部类</li><li>如果外部类和匿名内部类的成员重名时，默认遵循就近原则。那个场合，访问外部类成员使用<code>外部类名.this.变量名</code></li></ol><h4 id="使用场景">9.8.3.2 使用场景</h4><ol type="1"><li><p>当作实参直接传递，简洁高效</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Homework1</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cellphone</span>().clock(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Bell</span>() &#123;<span class="hljs-comment">//看这里看这里</span>            <span class="hljs-meta">@Override</span>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">belling</span><span class="hljs-params">()</span> &#123;                System.out.println(<span class="hljs-string">&quot;小懒猪起床了！&quot;</span>);            &#125;        &#125;);    &#125;&#125;<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Bell</span> &#123;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">ringing</span><span class="hljs-params">()</span>;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Cellphone</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clock</span><span class="hljs-params">(Bell bell)</span>&#123;        bell.ringing();    &#125;&#125;</code></pre></div></blockquote></li></ol><h3 id="成员内部类">9.8.4 成员内部类</h3><blockquote><p>成员内部类：定义在外部类的成员位置，并且没有 <code>static</code>修饰。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;&#125;&#125;</code></pre></div></blockquote><h4 id="使用细节-6">9.8.4.1 使用细节</h4><ol type="1"><li>可以直接访问外部类的所有成员，包括私有的</li><li>可以添加任意访问修饰符。因为，成员内部类的地位就是一个成员。</li><li>作用域 和外部类其他成员相同，为整个类体。</li><li>局部内部类可以 直接访问 外部类的成员。</li><li>外部类可以通过创建对象的方式访问成员内部类</li><li>外部其他类访问成员内部类<ul><li><code>Outer.Inner name = Outer.new Inner();</code>下个方法的缩写</li><li><code>Outer.Inner name = new Outer().new Inner();</code></li><li>在外部类中编写一个方法，返回一个 <code>Inner</code>的对象实例（就是对象的 getter）</li></ul></li><li>如果外部类和匿名内部类的成员重名时，默认遵循就近原则。那个场合，访问外部类成员使用<code>外部类名.this.变量名</code></li></ol><h3 id="静态内部类">9.8.5 静态内部类</h3><blockquote><p>静态内部类：定义在外部类的成员位置，经由 <code>static</code>修饰。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;&#125;&#125;</code></pre></div></blockquote><h4 id="使用细节-7">9.8.5.1 使用细节</h4><ol type="1"><li>可以直接访问外部类的所有 <strong>静态</strong>成员，包括私有的。但不能访问非静态成员</li><li>可以添加访问修饰符。因为，静态内部类的地位就是一个成员。</li><li>作用域 和其他成员相同，为整个类体。</li><li>静态内部类可以 直接访问 外部类的成员。</li><li>外部类可以通过创建对象的方式访问静态内部类</li><li>外部其他类访问静态内部类<ul><li><code>Outer.Inner name = new Outer.Inner();</code>即通过类名直接访问</li><li>在外部类中编写一个方法，返回一个 <code>Inner</code> 的对象实例</li><li>如果外部类和匿名内部类的成员重名时，默认遵循就近原则。那个场合，访问外部类成员使用<code>外部类名.变量名</code>。<em>（怎么不一样了呢？因为静态内部类访问的都是静态成员）</em></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt;8 项目（房屋出租系统）</title>
    <link href="/2021/12/13/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/8%20%E9%A1%B9%E7%9B%AE%EF%BC%9A%E6%88%BF%E5%B1%8B%E5%87%BA%E7%A7%9F%E7%B3%BB%E7%BB%9F/"/>
    <url>/2021/12/13/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/8%20%E9%A1%B9%E7%9B%AE%EF%BC%9A%E6%88%BF%E5%B1%8B%E5%87%BA%E7%A7%9F%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="项目房屋出租系统">8 项目：房屋出租系统</h1><blockquote><p>crud： c[create] r[read] u[update] d[delete]</p></blockquote><h3 id="一阶段毕业作业">一阶段毕业作业</h3><ul><li><p><strong>RentSystem.java（入口）</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.house_rent;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RentSystem</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">RentSysMenu</span> <span class="hljs-variable">rentSys</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RentSysMenu</span>();        rentSys.menu();        System.out.println(<span class="hljs-string">&quot;再见~&quot;</span>);    &#125;&#125;</code></pre></div></li><li><p><strong>RentSysMenu.java</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.house_rent;<span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RentSysMenu</span> &#123;    <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Method</span>();    <span class="hljs-keyword">private</span> <span class="hljs-type">Scanner</span> <span class="hljs-variable">inp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);    <span class="hljs-comment">//menu：这是出租系统的系统菜单界面。用户输入 1 - 6，并据此调用方法。该方法自身会无限循环。</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">menu</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">for</span> (; ; ) &#123;            <span class="hljs-comment">//这是系统菜单的显示页面</span>            System.out.print(<span class="hljs-string">&quot;\n---------------房屋出租系统---------------&quot;</span>                    + <span class="hljs-string">&quot;\n\t\t\t 1 新 增 房 屋&quot;</span>                    + <span class="hljs-string">&quot;\n\t\t\t 2 查 找 房 屋&quot;</span>                    + <span class="hljs-string">&quot;\n\t\t\t 3 删 除 房 屋&quot;</span>                    + <span class="hljs-string">&quot;\n\t\t\t 4 修 改 房 屋 信 息&quot;</span>                    + <span class="hljs-string">&quot;\n\t\t\t 5 房 屋 列 表&quot;</span>                    + <span class="hljs-string">&quot;\n\t\t\t 6 退       出&quot;</span>                    + <span class="hljs-string">&quot;\n请选择（1-6）：&quot;</span>);            <span class="hljs-type">char</span> <span class="hljs-variable">inpChar</span> <span class="hljs-operator">=</span> inp.next().charAt(<span class="hljs-number">0</span>);            System.out.println(<span class="hljs-string">&quot;----------------------------------------\n&quot;</span>);            <span class="hljs-keyword">switch</span> (inpChar) &#123;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;1&#x27;</span>:                    <span class="hljs-comment">//输入 1 时，调用 创建房屋 方法</span>                    method.newHouse();                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;2&#x27;</span>:                    <span class="hljs-comment">//输入 2 时，调用 搜索房屋 方法</span>                    method.searchAHouseFromMenu();                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;3&#x27;</span>:                    <span class="hljs-comment">//输入 3 时，调用 删除房屋 方法</span>                    method.deleteSpecificHouse();                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;4&#x27;</span>:                    <span class="hljs-comment">//输入 4 时，调用 修改信息 方法</span>                    method.changeHouseInfo();                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;5&#x27;</span>:                    <span class="hljs-comment">//输入 5 时，调用 展示全部 方法</span>                    method.showAllHouseFromMenu();                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;6&#x27;</span>:                    <span class="hljs-comment">//输入 6 时，进行二次确认。通过则退出系统。</span>                    System.out.println(<span class="hljs-string">&quot;确认退出吗？：（Y/N）：&quot;</span>);                    <span class="hljs-comment">//yesOrNo 方法，是可以判断用户输入的到底是 Y 还是 N 的方法。</span>                    <span class="hljs-keyword">if</span> (method.yesOrNo(inp.next().charAt(<span class="hljs-number">0</span>))) &#123;                        System.out.println(<span class="hljs-string">&quot;程序已退出。&quot;</span>);                        <span class="hljs-keyword">return</span>;                    &#125;                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">default</span>:                    <span class="hljs-comment">//当用户输入了 1 - 6 以外的东西，提示一个错误信息</span>                    System.out.println(<span class="hljs-string">&quot;错误，请输入纯数字（1-6）&quot;</span>);            &#125;        &#125;    &#125;&#125;</code></pre></div></li><li><p><strong>Method.java</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.house_rent;<span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Method</span> &#123;    <span class="hljs-comment">//创建一个 数据数组。该数组将存放所有未来的房屋数据，每个房屋占用 1 个长度。目前，其长度为0</span>    Data[] houses = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Data</span>[<span class="hljs-number">0</span>];    <span class="hljs-keyword">private</span> <span class="hljs-type">Scanner</span> <span class="hljs-variable">inp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);    <span class="hljs-comment">//newHouse：1 创建房屋 方法。由 menu 接入。</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">newHouse</span><span class="hljs-params">()</span> &#123;        System.out.print(<span class="hljs-string">&quot;=================添加房屋=================&quot;</span>                + <span class="hljs-string">&quot;\n请输入姓名：&quot;</span>);        <span class="hljs-type">String</span> <span class="hljs-variable">inName</span> <span class="hljs-operator">=</span> inp.next();        <span class="hljs-comment">//如果名字太短，补长一些，方便排版</span>        <span class="hljs-keyword">if</span> (inName.length() &lt;= <span class="hljs-number">2</span>) &#123;            inName = inName + <span class="hljs-string">&quot;   &quot;</span>;        &#125;        System.out.print(<span class="hljs-string">&quot;请输入电话：&quot;</span>);        <span class="hljs-type">String</span> <span class="hljs-variable">inCall</span> <span class="hljs-operator">=</span> inp.next();        System.out.print(<span class="hljs-string">&quot;请输入地址：&quot;</span>);        <span class="hljs-type">String</span> <span class="hljs-variable">inLocation</span> <span class="hljs-operator">=</span> inp.next();        <span class="hljs-comment">//如果地址太短，补长一些，方便排版</span>        <span class="hljs-keyword">if</span> (inLocation.length() &lt;= <span class="hljs-number">2</span>) &#123;            inLocation = inLocation + <span class="hljs-string">&quot;   &quot;</span>;        &#125;        System.out.print(<span class="hljs-string">&quot;请输入月租金：&quot;</span>);        <span class="hljs-type">double</span> <span class="hljs-variable">inPrice</span> <span class="hljs-operator">=</span> inp.nextDouble();        System.out.print(<span class="hljs-string">&quot;是否租出？（Y/N）：&quot;</span>);        <span class="hljs-comment">//yesOrNo 方法，是可以判断用户输入的到底是 Y 还是 N 的方法。</span>        <span class="hljs-type">boolean</span> <span class="hljs-variable">inIsRented</span> <span class="hljs-operator">=</span> yesOrNo(inp.next().charAt(<span class="hljs-number">0</span>));        <span class="hljs-comment">//调用 写入创建房屋 方法，将以上参数写入 数据数组</span>        creatData(inName, inCall, inLocation, inPrice, inIsRented);        System.out.println(<span class="hljs-string">&quot;=================添加完成=================&quot;</span>);        <span class="hljs-comment">//调用 真-搜索房屋 方法。为用户展示刚刚创建的房屋信息。</span>        searchAHouse(houses[houses.length - <span class="hljs-number">1</span>].getId());        System.out.println(<span class="hljs-string">&quot;\n请牢记房屋 ID\n如果想要修改信息，请于主菜单选择[4 修改房屋信息]&quot;</span>);    &#125;    <span class="hljs-comment">//searchAHouseFromMenu：2 搜索房屋 方法。由 menu 接入。</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">searchAHouseFromMenu</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;=================查找房屋=================&quot;</span>);        <span class="hljs-comment">//调用 真-搜索房屋 方法</span>        searchAHouse();        System.out.println(<span class="hljs-string">&quot;=================查找完毕=================&quot;</span>);    &#125;    <span class="hljs-comment">//deleteSpecificHouse：3 删除房屋 方法。由 menu 接入。</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteSpecificHouse</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;=================删除房屋=================&quot;</span>);        <span class="hljs-comment">//首先，搜索并展示用户想要的房屋。</span>        <span class="hljs-comment">//调用 真-搜索房屋 方法。如果找到，会返回该房屋的 数组编号；否则，返回 -100</span>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> searchAHouse();        <span class="hljs-comment">//如果找到房屋（返回值不为 -100），则进行二次确认。</span>        <span class="hljs-keyword">if</span> (num != -<span class="hljs-number">100</span>) &#123;            System.out.println(<span class="hljs-string">&quot;确定要删除该房屋信息吗？（Y/N）：&quot;</span>);            <span class="hljs-comment">//yesOrNo 方法，是可以判断用户输入的到底是 Y 还是 N 的方法。</span>            <span class="hljs-keyword">if</span> (yesOrNo(inp.next().charAt(<span class="hljs-number">0</span>))) &#123;                System.out.println(<span class="hljs-string">&quot;一经删除无法恢复！请再次确认，是否删除！（Y/N）：&quot;</span>);                <span class="hljs-keyword">if</span> (yesOrNo(inp.next().charAt(<span class="hljs-number">0</span>))) &#123;                    <span class="hljs-comment">//调用 注销房屋 方法。</span>                    deleteHouse(num);                    System.out.println(<span class="hljs-string">&quot;===============房屋已删除===============&quot;</span>);                &#125;            &#125;        &#125;    &#125;    <span class="hljs-comment">//changeHouseInfo：4 修改信息 方法。由 menu 接入</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">changeHouseInfo</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;=================修改房屋=================&quot;</span>);        <span class="hljs-comment">//首先，搜索并展示用户想要的房屋</span>        <span class="hljs-comment">//调用 真-搜索房屋 方法。如果找到，会返回该房屋的 数组编号；否则，返回 -100</span>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> searchAHouse();        <span class="hljs-comment">//找到房屋的场合，逐项提示并进行修改</span>        <span class="hljs-keyword">if</span> (num != -<span class="hljs-number">100</span>) &#123;            System.out.println(<span class="hljs-string">&quot;姓名（&quot;</span> + houses[num].getName() + <span class="hljs-string">&quot;）：&quot;</span>);            <span class="hljs-type">String</span> <span class="hljs-variable">inName</span> <span class="hljs-operator">=</span> inp.next();            <span class="hljs-keyword">if</span> (inName.length() &lt;= <span class="hljs-number">2</span>) &#123;                inName = inName + <span class="hljs-string">&quot;   &quot;</span>;            &#125;            houses[num].setName(inName);            System.out.println(<span class="hljs-string">&quot;电话号码（&quot;</span> + houses[num].getCall() + <span class="hljs-string">&quot;）：&quot;</span>);            houses[num].setCall(inp.next());            System.out.println(<span class="hljs-string">&quot;地址（&quot;</span> + houses[num].getLocation() + <span class="hljs-string">&quot;）：&quot;</span>);            <span class="hljs-type">String</span> <span class="hljs-variable">inLocation</span> <span class="hljs-operator">=</span> inp.next();            <span class="hljs-keyword">if</span> (inLocation.length() &lt;= <span class="hljs-number">2</span>) &#123;                inLocation = inLocation + <span class="hljs-string">&quot;   &quot;</span>;            &#125;            houses[num].setLocation(inLocation);            System.out.println(<span class="hljs-string">&quot;月租金（&quot;</span> + houses[num].getPrice() + <span class="hljs-string">&quot;）：&quot;</span>);            houses[num].setPrice(inp.nextDouble());            System.out.println(<span class="hljs-string">&quot;是否租出（&quot;</span> + (houses[num].isRented() ? <span class="hljs-string">&quot;已出租！&quot;</span> : <span class="hljs-string">&quot;未出租。&quot;</span>) + <span class="hljs-string">&quot;）（Y/N）：&quot;</span>);            houses[num].setRented(yesOrNo(inp.next().charAt(<span class="hljs-number">0</span>)));            <span class="hljs-comment">//到这里就改完了</span>            <span class="hljs-comment">//调用 真-搜索房屋 方法，展示房屋</span>            System.out.println(<span class="hljs-string">&quot;=================修改完成=================&quot;</span>);            searchAHouse(houses[num].getId());        &#125;    &#125;    <span class="hljs-comment">//showAllHouseFromMenu：5 展示全部 方法。由 menu 接入</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showAllHouseFromMenu</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;===============所有房屋信息===============&quot;</span>);        <span class="hljs-comment">//调用 展示全部房屋 方法</span>        showAllHouses();        System.out.println(<span class="hljs-string">&quot;============以上是所有房屋信息=============&quot;</span>);    &#125;    <span class="hljs-comment">//yesOrNo：这个方法用于判断用户输入的字符究竟表示 Yes 还是 No。</span>    <span class="hljs-comment">//判断不了的情况，提示错误语句，并默认为 No</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">yesOrNo</span><span class="hljs-params">(<span class="hljs-type">char</span> cha)</span> &#123;        <span class="hljs-keyword">switch</span> (cha) &#123;            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;y&#x27;</span>:            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;Y&#x27;</span>:            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;是&#x27;</span>:            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;对&#x27;</span>:            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;已&#x27;</span>:                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;n&#x27;</span>:            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;N&#x27;</span>:            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;否&#x27;</span>:            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;没&#x27;</span>:            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;不&#x27;</span>:            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;未&#x27;</span>:                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            <span class="hljs-keyword">default</span>:                System.out.println(<span class="hljs-string">&quot;输入无效。&quot;</span>);                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    &#125;    <span class="hljs-comment">//searchAHouse：真-搜索房屋 方法（无参）。</span>    <span class="hljs-comment">//如果调用的是这无参方法，会先提示用户输入一个 ID，然后调用有参方法</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchAHouse</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;请输入4位数房屋ID：&quot;</span>);        <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> inp.next();        <span class="hljs-keyword">return</span> searchAHouse(id);    &#125;    <span class="hljs-comment">//searchAHouse：真-搜索房屋 方法（有参）。输入房屋 ID，搜索该房屋。</span>    <span class="hljs-comment">//找到房屋的场合，展示房屋 并返回其 数组坐标。如果没找到对应房屋，提示错误信息，并返回 -100。</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchAHouse</span><span class="hljs-params">(String id)</span> &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; houses.length; i++) &#123;            <span class="hljs-keyword">if</span> (houses[i].getId().equals(id) &amp;&amp; houses[i].isActive()) &#123;                System.out.println(<span class="hljs-string">&quot;房屋ID\t姓名\t\t电话\t\t\t地址\t\t月租金\t出租状态&quot;</span>);                houses[i].showThisData();                <span class="hljs-keyword">return</span> i;            &#125;        &#125;        System.out.println(<span class="hljs-string">&quot;没有找到房屋！&quot;</span>);        <span class="hljs-keyword">return</span> -<span class="hljs-number">100</span>;    &#125;    <span class="hljs-comment">//creatData：写入创建房屋 方法。需要的信息齐集的场合，将其写入 数据数组，并生成一个 ID</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">creatData</span><span class="hljs-params">(String name, String call, String location, <span class="hljs-type">double</span> price, <span class="hljs-type">boolean</span> isRented)</span> &#123;        Data[] tempData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Data</span>[houses.length + <span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; houses.length; i++) &#123;            tempData[i] = houses[i];        &#125;        tempData[tempData.length - <span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Data</span>(tempData.length, name, call, location, price);        tempData[tempData.length - <span class="hljs-number">1</span>].setRented(isRented);        houses = tempData;    &#125;    <span class="hljs-comment">//showAllHouses：展示全部房屋 方法。由 展示全部（showAllHouseFromMenu）方法接入</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showAllHouses</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;房屋ID\t姓名\t\t电话\t\t\t地址\t\t月租金\t出租状态&quot;</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; houses.length; i++) &#123;            <span class="hljs-keyword">if</span> (houses[i].isActive()) &#123;                houses[i].showThisData();            &#125;        &#125;    &#125;    <span class="hljs-comment">//deleteHouse：注销房屋 方法。将该房屋注销。数据其实保留在 数据数组，但注销使其无法被查到。</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteHouse</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;        houses[num].setActive(<span class="hljs-literal">false</span>);    &#125;&#125;</code></pre></div></li><li><p><strong>Data.java</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.house_rent;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span> &#123;    <span class="hljs-comment">//房屋信息。包含：ID，名字，电话，地址，房租，是否租出。</span>    <span class="hljs-keyword">private</span> String id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String call;    <span class="hljs-keyword">private</span> String location;    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> price;    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">isRented</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">active</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Data</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String name, String call, String location, <span class="hljs-type">double</span> price)</span> &#123;        <span class="hljs-comment">//将输入的数字 ID 转化成固定 4 位的 字符串 ID</span>        <span class="hljs-keyword">if</span> (id &lt; <span class="hljs-number">10</span>) &#123;            <span class="hljs-built_in">this</span>.id = <span class="hljs-string">&quot;000&quot;</span> + id;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (id &lt; <span class="hljs-number">100</span>) &#123;            <span class="hljs-built_in">this</span>.id = <span class="hljs-string">&quot;00&quot;</span> + id;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (id &lt; <span class="hljs-number">1000</span>) &#123;            <span class="hljs-built_in">this</span>.id = <span class="hljs-string">&quot;0&quot;</span> + id;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-built_in">this</span>.id = <span class="hljs-string">&quot;&quot;</span> + id;        &#125;        <span class="hljs-built_in">this</span>.name = name;        <span class="hljs-built_in">this</span>.call = call;        <span class="hljs-built_in">this</span>.location = location;        <span class="hljs-built_in">this</span>.price = price;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isActive</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> active;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setActive</span><span class="hljs-params">(<span class="hljs-type">boolean</span> active)</span> &#123;        <span class="hljs-built_in">this</span>.active = active;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(String id)</span> &#123;        <span class="hljs-built_in">this</span>.id = id;    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;        <span class="hljs-built_in">this</span>.name = name;    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getCall</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> call;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCall</span><span class="hljs-params">(String call)</span> &#123;        <span class="hljs-built_in">this</span>.call = call;    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getLocation</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> location;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setLocation</span><span class="hljs-params">(String location)</span> &#123;        <span class="hljs-built_in">this</span>.location = location;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getPrice</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> price;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPrice</span><span class="hljs-params">(<span class="hljs-type">double</span> price)</span> &#123;        <span class="hljs-built_in">this</span>.price = price;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isRented</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> isRented;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRented</span><span class="hljs-params">(<span class="hljs-type">boolean</span> rented)</span> &#123;        isRented = rented;    &#125;    <span class="hljs-comment">//展示信息</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showThisData</span><span class="hljs-params">()</span> &#123;        System.out.println(id + <span class="hljs-string">&quot;\t&quot;</span> + name + <span class="hljs-string">&quot;\t&quot;</span> + call + <span class="hljs-string">&quot;\t&quot;</span> + location + <span class="hljs-string">&quot;\t&quot;</span> + price + <span class="hljs-string">&quot;\t&quot;</span>                + (isRented ? <span class="hljs-string">&quot;已出租！&quot;</span> : <span class="hljs-string">&quot;未出租。&quot;</span>));    &#125;&#125;</code></pre></div></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>程序</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt;7 面向对象编程（中级）</title>
    <link href="/2021/12/05/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/7%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%AD%E7%BA%A7%EF%BC%89/"/>
    <url>/2021/12/05/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/7%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%AD%E7%BA%A7%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象编程中级">7 面向对象编程（中级）</h1><blockquote><p>IDE：集成开发环境</p><ul><li><p>IDEA</p></li><li><p>Eeclipse：一个开源的、基于 Java 的可扩展开发平台。是由 IBM公司开发，在 2001 年 11 月贡献给开源社区的，目前最优秀的 Java 开发 IDE之一。</p></li></ul></blockquote><h2 id="idea-的使用">7.1 IDEA 的使用</h2><blockquote><p>IDEA：全程 IntelliJ IDEA。在业界被公认为最好的 Java 开发工具。是捷克JetBrains 公司的产品。除了 Java 开发，还支持HTML，CSS，PHP，MySQL，Python 等。<ahref="https://www.jetbrains.com/zh-cn/idea/download/#section=windows"title="下载左边的旗舰版。试用30天，之后是 你 懂 的">下载地址</a></p></blockquote><h3 id="常用快捷键">7.1.1 常用快捷键</h3><ul><li>删除当前行：<code>ctrl + Y</code></li><li>复制当前行：<code>ctrl + D</code></li><li>补全代码：<code>alt + /</code></li><li>添加 / 取消注释：<code>ctrl + /</code></li><li>导入该行需要的类：<code>alt + enter</code></li><li>快速格式化代码：<code>ctrl + alt + L</code></li><li>快速运行程序：<code>shift + F10</code>（我改成了<code>alt + R</code>）</li><li>生成构造器：<code>alt + insert</code></li><li>查看一个类的层级关系：<code>ctrl + H</code></li><li>定位一个方法：把光标放在一个方法上，按 <code>ctrl + B</code></li><li>自动分配变量名：在后面加上 <code>.var</code></li><li>查看模板快捷键：<code>ctrl + J</code></li><li>快速环绕代码：<code>ctrl + alt + T</code></li></ul><h3 id="模板快捷键">7.1.2 模板快捷键</h3><ul><li><code>main</code>：<code>public static void main(String[] args) &#123;&#125;</code></li><li><code>sout</code>：<code>System.out.println();</code></li><li><code>fori</code>：<code>for (int i = 0; i &lt; ; i++) &#123;&#125;</code></li><li><code>xxx.for</code>：<code>for(int i = 0; i &lt; xxx; i++) &#123;&#125;</code></li></ul><p>更多的请在 File - Settings - Editor - Live template 中查看或添加</p><p>或者，通过下列快捷键查看</p><ul><li><code>ctrl + J</code>：查看模板快捷键</li></ul><h2 id="包">7.2 包</h2><blockquote><p>包的作用：1. 区分相同名字的类 2. 当类很多时，便于管理 3.控制访问范围</p><p>语法：<code>package com.name</code> 其中 <code>com</code><code>name</code> 分别是 一级 和 二级目录，用 <code>.</code> 分隔</p><p>包的本质：就是创建不同 文件夹/目录 来保存 类 文件</p></blockquote><p>如何使用包中的对象：</p><ol type="1"><li><p>先引入包，之后创建对象</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.name.T;...<span class="hljs-type">T</span> <span class="hljs-variable">tools</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>();</code></pre></div></li><li><p>不引入包，而在创建对象时写全路径</p><p><div class="code-wrapper"><pre><code class="hljs java">com.name.<span class="hljs-type">T</span> <span class="hljs-variable">tools</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">com</span>.name.T();</code></pre></div></p></li></ol><p><strong>命名规则：</strong></p><ul><li>只能包含 数字 <code>1 2 3</code>、字母 <code>a b A b</code>、下划线<code>_</code>、小圆点 <code>.</code></li><li>不能用 数字 开头。每级目录都不能。</li></ul><p><strong>命名规范：</strong></p><ul><li>全小写字母 + 小圆点</li><li><code>com.公司名.项目名.业务模块名</code></li></ul><p><strong>常用的包：</strong></p><p><code>java.lang</code>：基本包，默认引入，不需要再引入</p><p><code>java.util</code>：系统提供的工具包。工具类。</p><p><code>java.net</code>：网络包，网络开发。</p><p><code>java.awt</code>：Java 的界面开发，GUI。</p><p><strong>引入包：</strong></p><ul><li>只引入该包下的一个类：<code>import java.util.Scanner</code></li><li>引入该包的所有内容（不建议）：<code>import java.util.*</code></li></ul><p><strong>使用细节：</strong></p><ol type="1"><li><p><code>package</code> 的作用是声明当前类所在的包，要放在 类 的最上面。一个 类 中最多有一句 <code>package</code></p></li><li><p><code>import</code> 放在 <code>package</code> 下面，类定义前面。可以有多条语句，且没有顺序要求</p></li><li><p>编译器编译时 <strong>不会</strong> 检查目录结构。</p><p>即使一个包处于错误的目录下（只要其不依赖其他包）也可能通过编译。</p><p>但是，虚拟机会找不到该包，最终程序无法运行。</p></li><li><p>从 1.2 版本开始，用户不能再把包放在 java.开头的目录下了。若如此做，这些包会被禁止加载。</p></li></ol><h3 id="静态导入">7.4.1 静态导入</h3><blockquote><p>有一种 import 语句允许导入静态方法和字段，而不只是类</p></blockquote><p>比如：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.Math.*;</code></pre></div><p>这个场合，使用 Math包内的静态方法、字段时，不需要再添加类名前缀。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">double</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> pow(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>);<span class="hljs-comment">// &lt;———— 本来是 double n = Math.pow(10, 5);</span><span class="hljs-type">double</span> <span class="hljs-variable">pi</span> <span class="hljs-operator">=</span> PI;<span class="hljs-comment">// &lt;———— 本来是 double pi = Math.PI;</span></code></pre></div><p><strong><em>—— 上述方法、字段见 <ahref="../../../../../../2021/12/19/Java/入门阶段/12%20%E5%B8%B8%E7%94%A8%E7%B1%BB/#12-5-Math-%E7%B1%BB">[12.5Math 类]</a></em></strong></p><h2 id="访问修饰符">7.3 访问修饰符</h2><h3 id="访问权限特点">7.3.1 访问权限特点</h3><p>Java 提供 4 种访问控制修饰符号，用于控制方法和属性（成员变量）的访问权限（范围）</p><ul><li><p>公开级别：<code>public</code>，对外公开。</p></li><li><p>受保护级别：<code>protected</code>，对 子类 和 同一个包中的类公开。</p><p><strong><em>——什么是 子类？详见 <ahref="../../../../../../2021/12/05/Java/入门阶段/7%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%AD%E7%BA%A7%EF%BC%89/#7-5-%E7%BB%A7%E6%89%BF%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89">[7.5 继承 ]</a></em></strong></p></li><li><p>默认级别：没有修饰符号，向 同一个包的类 公开。</p></li><li><p>私有级别：<code>private</code>，只有 同类可以访问，不对外公开。</p></li></ul><table><thead><tr class="header"><th>(⌐■_■)</th><th style="text-align: center;">默认（无修饰符）</th><th style="text-align: center;">private</th><th style="text-align: center;">protected</th><th style="text-align: center;">public</th></tr></thead><tbody><tr class="odd"><td>本类</td><td style="text-align: center;">可</td><td style="text-align: center;">可</td><td style="text-align: center;">可</td><td style="text-align: center;">可</td></tr><tr class="even"><td>同包中的子类</td><td style="text-align: center;">可</td><td style="text-align: center;">不可以</td><td style="text-align: center;">可</td><td style="text-align: center;">可</td></tr><tr class="odd"><td>同包的非子类</td><td style="text-align: center;">可</td><td style="text-align: center;">不可以</td><td style="text-align: center;">可</td><td style="text-align: center;">可</td></tr><tr class="even"><td>其他包的子类</td><td style="text-align: center;">不可以</td><td style="text-align: center;">不可以</td><td style="text-align: center;">可</td><td style="text-align: center;">可</td></tr><tr class="odd"><td>其他包的非子类</td><td style="text-align: center;">不可以</td><td style="text-align: center;">不可以</td><td style="text-align: center;">不可以</td><td style="text-align: center;">可</td></tr></tbody></table><h3 id="使用说明">7.3.2 使用说明</h3><ol type="1"><li>修饰符可以修饰类中的 属性、成员方法 及 类</li><li>只有 默认 和 <code>public</code> 才能修饰类，并遵循上述访问权限特点</li><li>成员方法 的访问规则和 属性 相同</li><li>private 修饰的变量可以被 任意本对象同类的对象访问</li></ol><h2 id="封装">7.4 封装</h2><blockquote><p>封装（encapsulation）就是把抽象出的 数据[属性] 和对数据的 操作[方法]封装在一起。数据 被保护在内部，程序的其他部分只有通过被授权的操作[方法]，才能对数据进行操作。</p></blockquote><p>封装的好处：</p><ul><li>隐藏实现细节</li><li>可以对数据进行验证，保证安全合理</li></ul><p><strong>实现步骤：</strong></p><ol type="1"><li>将属性私有化 <code>private</code></li><li>提供一个公共的 <code>set</code> 方法，用于对属性判断并赋值</li><li>提供一个公共的 <code>get</code> 方法，用于获取属性的值</li></ol><p><strong>编译多个源文件：</strong></p><div class="code-wrapper"><pre><code class="hljs cmd">javac MyClass.java</code></pre></div><p>该文件中使用了其他类时，Java 编译器会查找对应名称的 .class文件。没有找到的场合，转而寻找 .java 文件，并对其编译。倘若 .java文件相较原有 .class 文件更新，编译器也会自动重新编译该文件。</p><h3 id="静态导入-1">7.4.1 静态导入</h3><blockquote><p>有一种 import 语句允许导入静态方法和字段，而不只是类</p></blockquote><p>比如：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.Math.*;</code></pre></div><p>这个场合，使用 Math包内的静态方法、字段时，不需要再添加类名前缀。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">double</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> pow(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>);<span class="hljs-comment">// &lt;———— 本来是 double n = Math.pow(10, 5);</span><span class="hljs-type">double</span> <span class="hljs-variable">pi</span> <span class="hljs-operator">=</span> PI;<span class="hljs-comment">// &lt;———— 本来是 double pi = Math.PI;</span></code></pre></div><p><strong><em>—— 上述方法、字段见 [12.5 Math 类]</em></strong></p><h3 id="jar-文件">7.4.2 JAR 文件</h3><blockquote><p>为了避免向用户提供包含大量类文件的复杂目录结构，可以将 Java程序打包成 JAR （Java 归档）文件。</p><p>一个 JAR文件既可以包含类文件，也可以包含诸如图像和声音等其他类型的文件。</p><p>JAR 文件是压缩的。其使用了 ZIP压缩格式。</p></blockquote><p><strong>创建 JAR：</strong></p><p>使用 jar 工具以制作 JAR 文件。该工具在 jdk/bin 目录下</p><div class="code-wrapper"><pre><code class="hljs cmd">jar cvf 包名 文件名<span class="hljs-number">1</span> 文件名<span class="hljs-number">2</span> ...</code></pre></div><p>关于 jar 工具的各种指令，还是自己去百度一下吧</p><h2 id="继承">7.5 继承</h2><blockquote><p>继承：能解决代码复用，让我们的编程更接近人类思维。当多个类存在相同的属性（变量）和 方法 时，可以从这些类中抽象出 父类（基类/超类）。在 父类中定义这些属性·方法，所有的子类不需要重新定义这些属性和方法，只需要通过<code>extends</code> 来声明继承父类即可。</p><p>通过继承的方法，代码的复用性提高了，代码的维护性和拓展性也提高了。</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Father</span> &#123;&#125;;<span class="hljs-comment">// Son 类继承了 Father 类</span></code></pre></div><p>定义类时可以指明其父类，也能不指明。不指明的场合，默认继承 Object类。</p><p>所有类有且只有一个父类。Object 是所有类的直接或间接父类。只有 Object本身没有父类。</p><h3 id="使用细节">7.5.1 使用细节</h3><ol type="1"><li><p>子类 继承了所有属性和方法，但私有（<code>private</code>）的属性·方法 不能在 子类 直接访问。要调用父类提供的公共（<code>public</code>）等方法 访问。</p></li><li><p>子类 必须调用 父类 的 构造器，完成 父类 的 初始化。</p></li><li><p>当创建 子类对象 时，不管使用 子类的哪个构造器，默认情况下总会调用父类的无参构造器。如果 父类 没有提供 无参构造器，则必须在 子类的构造器中用 <code>super</code> 去指定使用 父类的哪个构造器 完成对父类的初始化。否则编译不能通过。</p></li><li><p>如果希望指定调用父类的某构造器，则显式地调用一下：<code>super(形参列表);</code></p></li><li><p><code>super</code>在使用时，必须放在构造器第一行。<code>super</code>只能在构造器中使用。</p></li><li><p>由于 <code>super</code> 与 <code>this</code>都要求放在第一行，所以此两个方法不能同时存在于同一构造器。</p></li><li><p>Java 所有的类都是 <code>Object</code>的子类。换言之，<code>Object</code> 是所有类的父类。</p></li><li><p>父类构造器的调用不限于直接父类，将持续向上直至追溯到顶级父类<code>Object</code></p></li><li><p>子类 最多只能直接继承 一个 父类。即，Java 中是单继承机制。</p></li><li><p>不能滥用继承。子类 和 父类 之间必须满足 is - a的逻辑关系。</p></li></ol><h3 id="继承的本质">7.5.2 继承的本质</h3><ul><li>内存布局：<ol type="1"><li>在 方法区，自顶级父类起，依次加载 类信息。</li><li>在 堆中开辟一个空间，自顶级父类起，依次创建并初始化各个类包含的所有属性信息。</li><li>在 栈 中存放该空间的 地址。</li></ol></li><li>如何查找信息？<ol type="1"><li>查看该子类是否有该属性。如果该子类有这个属性且可以访问，则返回信息。</li><li>子类没有该属性的场合，查看父类是否有该属性。如有且可访问，则返回信息。如不可访问，则报错。</li><li>父类也没有该属性的场合，继续查找上级父类，直到顶级父类（Object）。</li><li>如需调用某个特定类包含的特定信息，可以调用该类提供的方法。</li></ol></li></ul><h3 id="super-关键字">7.5.3 <code>super</code> 关键字</h3><blockquote><p><code>super</code> 代表父类的引用。用于访问父类的属性、方法、构造器。</p></blockquote><p><strong>super 的使用：</strong></p><ul><li><code>super.属性名</code>：访问父类的属性。不能访问父类的私有（private）属性。</li><li><code>super.方法名(形参列表)</code>：访问父类的方法。不能访问父类的私有（private）方法。</li><li><code>super(参数列表);</code>：访问父类的构造器。此时，super语句必须放在第一句。</li></ul><p><strong>使用细节：</strong></p><ol type="1"><li>调用父类构造器，好处是分工明确。父类属性由父类初始化，子类由子类初始化。</li><li>子类中由和父类中成员（属性和方法）重名时，要调用父类成员必须用<code>super</code>。没有重名的场合，<code>super</code>、<code>this</code>及直接调用的效果相同。</li><li><code>super</code>的访问不限于直接父类。如果爷爷类和本类中都有同名成员也能使用。如果多个基类中都有同名成员，则遵循就近原则。</li></ol><h3 id="方法重写-覆盖">7.5.4 方法重写 / 覆盖</h3><blockquote><p>方法重写/覆盖（Override）：如若子类有一个方法，和父类的某方法的名称、返回类型、参数 一样，那么我们就说该子类方法 覆盖了那个父类方法。</p></blockquote><p><strong>使用细节：</strong></p><ol type="1"><li>子类方法的参数，方法名称，要和父类方法完全一致。</li><li>子类方法的返回类型需和父类方法 一致，或者是父类返回类型的子类。</li><li>子类方法 <strong>不能缩小</strong>父类方法的访问范围（访问修饰符）。</li></ol><h2 id="多态">7.6 多态</h2><blockquote><p>多态：方法 或 对象 有多种形态。多态 是面向对象的第三大特征，是建立在封装 和 继承 的基础之上的</p></blockquote><h3 id="多态的体现">7.6.1 多态的体现</h3><ol type="1"><li><p>方法的多态：重写 和 重载 体现了 方法的多态。</p></li><li><p><strong>对象的多态：</strong></p><ul><li><p>一个对象的 编译类型 和 运行类型 可以不一致。</p><p><code>Animal animal = new Dog();</code></p><p>上例，编译类型是 <code>Animal</code>，运行类型是子类<code>Dog</code>。要理解这句话，请回想 <ahref="../../../../../../2021/11/29/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/6%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/#6-1-4-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E6%9C%BA%E5%88%B6">[6.1.4类与对象的内存访问机制]</a>：<code>animal</code>是对象的<strong>引用</strong>。</p></li><li><p>编译类型在定义对象时就确定了，不能改变。</p></li><li><p>运行类型是可以变化的。</p><p>上例中，再让 <code>animal = new Cat();</code>，这样，运行类型变为了<code>Cat</code></p></li><li><p>编译类型看定义时 <code>=</code> 的左边，运行类型看 <code>=</code>的右边。</p></li></ul></li></ol><h3 id="使用细节-1">7.6.2 使用细节</h3><ol type="1"><li><p>多态的前提：两个对象 / 类存在继承关系。</p></li><li><p>多态的向上转型：</p><ul><li>本质：父类的引用指向了子类的对象。（如 [ 7.6.1.2 ]）</li><li>语法：<code>父类类型 引用名 = new 子类类型(参数列表);</code></li><li>编译类型看左边，运行类型看右边。</li><li>可以调用父类中的所有成员，但不能调用子类特有的成员，而且需要遵守访问权限。因为在编译阶段，能调用哪些成员是由编译类型决定的。</li><li>最终的运行结果要看子类的具体实现。即从子类起向上查找方法调用（与 [7.5.2 ] 规则相同）。</li></ul></li><li><p>多态的向下转型：</p><ul><li><p>语法：<code>子类类型 引用名 = (子类类型)父类引用;</code></p><p>[7.6.2.2] 的例子里，向下转型。这个语法其实和 [2.8.2 强制类型转换]很像。</p><p><code>Dog dog = (Dog)animal;</code></p></li><li><p>只能强转父类的引用，不能强转父类的对象。</p></li><li><p>要求父类的引用必须指向的是当前目标类型的对象。即上例中的<code>animal</code> 运行类型需是 <code>Dog</code></p></li><li><p>向下转型后，可以调用子类类型中的所有成员。</p></li></ul></li><li><p>属性没有重写一说。<strong>和 方法 不同，属性的值看编译类型。</strong></p></li><li><p><code>instanceof</code>比较操作符。用于判断对象类型是否是某类型或其子类型。此时判断的是<strong>运行类型</strong>。</p></li></ol><h3 id="理解方法调用">7.6.3 理解方法调用</h3><p>在对象上调用方法的过程如下：</p><ol type="1"><li><p>编译器查看对象的声明类型和方法名。该类和其父类中，所有同名方法（包括参数不同的方法）都被列举。</p><p>至此，编译器已经知道所有可能被调用的方法。</p></li><li><p>编译器确认方法调用中提供的参数类型。</p><p>那些列举方法中存在参数类型完全匹配的方法时，即调用该方法。</p><p>没有发现匹配方法，抑或是发现经过类型转换产生了多个匹配方法时，就会报错</p><p>至此，编译器已经知道要调用方法的名字和参数类型</p></li><li><p>如若是 private 方法、static 方法、final方法、构造器，那么编译器将能准确知道要调用哪个方法。这称为<strong>静态绑定</strong></p><p>与之相对的，如果调用方法依赖于隐式参数类型，那么必须在运行时<strong>动态绑定</strong></p></li><li><p>程序运行并采取动态绑定方法时，JVM 将调用那个<strong>实际类型</strong> 对应的方法。</p></li></ol><p>倘若每次调用方法都进行以上搜索，会造成庞大的时间开销。为此，JVM预先为每个类计算了 <strong>方法表</strong>。</p><p>方法表中列举了所有方法的签名与实际调用的方法。如此，每次调用方法时，只需查找该表即可。</p><p>特别地，使用 super 关键字时，JVM 会查找其父类的方法表。</p><p><font color="F0000A"><strong>动态绑定机制：</strong></font></p><ul><li>当调用对象方法的时候，该方法和该对象（隐式参数）的内存地址/运行类型绑定。</li><li>当调用对象属性时，没有动态绑定机制。于是哪里声明，哪里调用。</li></ul><h2 id="object-类">7.7 Object 类</h2><p>Object 类是所有类的超类。Java 中所有类默认继承该类。</p><h3 id="equals-方法">equals 方法</h3><p><code>boolean equals(Object obj)</code></p><p>用于检测一个对象是否等于另一对象。</p><p>在 Object 中，该方法的实现是比较 形参 与 隐式参数的对象引用是否一致。</p><p><strong>与 <code>==</code> 的区别：</strong></p><ul><li><p><code>==</code>：既可以判断基本类型，也可以判断引用类型。如果判断基本类型，判断的是值是否相等。如果判断引用类型，判断的是地址是否相等。</p></li><li><p>equals 方法：是 Object中的方法，只能判断引用类型。默认判断地址是否相等，但子类中往往重写该代码，以判断内容是否相等。</p><p>在子类中定义 equals 方法时，首先调用超类的 equals方法。那个一致时，再比较子类中的字段。</p></li></ul><p><strong>Java 语言规范要求 equals 方法具有如下特性：</strong></p><ul><li><p><em>自反性</em>：对于任何非空引用 x，<code>x.equals(x)</code>应返回 true</p></li><li><p><em>对称性</em>：对于任何引用 x 和 y，当且仅当<code>x.equals(y)</code> 为 true 时，<code>y.equals(x)</code> 为true</p><p>如果所有的子类具有相同的相等性语义，可以使用 <code>instanceof</code>检测其类型。否则，最好使用 <code>getClass</code> 方法比较类型。</p></li><li><p><em>传递性</em>：对于任何引用 x、y、z，如果<code>x.equals(y)</code> 为 true ，<code>y.equals(z)</code> 为true，那么 <code>x.equals(z)</code> 也应该为 true</p></li><li><p><em>一致性</em>：如果 x 和 y 的引用没有发生变化，反复调用<code>x.equals(y)</code> 应该返回相同的结果</p></li><li><p>对于任何非空引用 x，<code>x.equals(null)</code> 应该返回false</p></li></ul><h3 id="hashcode-方法">hashCode 方法</h3><p><code>int hashCode()</code></p><p>返回对象的 散列码值。</p><p>散列码值是由对象导出的一个整型值。散列码是无规律的。如果 x 与 y是不同对象，两者的散列码基本上不会相同。</p><p>字符串的散列码是由其内容导出的，而其他引用对象的散列码是根据存储地址得出的。</p><p><strong>散列码的作用：</strong></p><ol type="1"><li>提高哈希结构的容器的效率。</li><li>两个引用，若是指向同一对象，则哈希值一般不同。</li><li>哈希值是根据地址生成的，因而，哈希值不能等同于地址</li></ol><p><strong>相关方法：</strong></p><ul><li><p><code>Objects.hashCode(Object obj)</code></p><p>这是一个 null 安全的返回散列值的方法。传入 null 时会返回 0</p></li><li><p><code>Objects.hash(Object... values)</code></p><p>组合所有传入参数的散列值</p></li><li><p><code>Integer.hashCode(int value)</code></p><p>返回给定基本数据类型的散列值。所有包装类都有该静态方法</p></li><li><p><code>Arrays.hashCode(xxx[] a)</code></p><p>计算数组的散列码。数组类型可以是 Object 或基本数据类型</p></li></ul><p>空对象调用 hashCode 方法会抛出异常。</p><p>hashCode 与 equals 的定义必须相符。如果 <code>x.equals(y)</code> 返回true，那么 <code>x.hashCode()</code> 与 <code>y.hashCode()</code>应该返回相同的值。</p><h3 id="tostring-方法">toString 方法</h3><p><code>String toString()</code></p><p>返回表示对象的一个字符串。Object 的默认实现如下</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">return</span> getClass().getName() + <span class="hljs-string">&quot;@&quot;</span> + Integer.toHexString(hashCode());&#125;</code></pre></div><ul><li><p><code>Class getClass()</code></p><p>返回包含对象信息的 Class 对象。</p></li><li><p><code>String getName()</code></p><p>由 Class 类实例调用。返回这个类的全类名</p><p>全类名：即包名 + 类名。比如<code>com.prictice.codes.Person</code></p></li><li><p><code>Class getSuperClass()</code></p><p>由 Class 类实例调用。以 Class 形式返回其父类</p><p>Object 使用时返回 null</p></li><li><p><code>Integer.toHexString(int val)</code></p><p>返回一个数字的十六进制表示的字符串</p></li></ul><p>toString 方法非常实用。Java标准类库中的很多类重写了该方法，以便用户能获得一些有关对象状态的信息。</p><p>打印对象 或 使用 <strong>+</strong> 操作符拼接对象时，都会自动调用该对象的 toString 方法。</p><p>当直接调用对象时，也会默认调用该方法。</p><h3 id="finalize-方法">finalize 方法</h3><ol type="1"><li>当对象被回收时，系统会自动调用该对象的 <code>finalize</code>方法。子类可以重写该方法，做一些释放资源的操作。</li><li>何时被回收：当某对象没有任何引用时，JVM就认为该对象是一个垃圾对象，就会（在算法决定的某个时刻）使用垃圾回收机制来销毁该对象。在销毁该对象前，会调用<code>finalize</code> 方法。</li><li>垃圾回收机制的调用，是由系统决定。也可以通过<code>System.gc();</code>主动触发垃圾回收机制。这个方法一经调用就会继续执行余下代码，而不会等待回收完毕。</li><li>实际开发中，几乎不会运用该方法。</li></ol><h2 id="断点调试debug">7.8 断点调试（Debug）</h2><blockquote><p>断点调试：在程序某一行设置一个断点，调试时，代码运行至此就会停住，然后可以一步一步往下调试。调试过程中可以看各个变量当前的值。如若出错，则测试到该出错代码行即显示错误并停下。进行分析从而找到这个Bug。</p><p>调试过程中是运行状态，所以，是以对象的 运行类型 执行。</p><p>断点调试是程序员必须掌握的技能，能帮助我们查看 Java底层源代码的执行过程，提高程序员 Java 水平。</p></blockquote><p>快捷键如下</p><ul><li>跳入：<code>F7</code></li><li>跳过：<code>F8</code></li><li>跳出：<code>shift + F8</code></li><li>resume，执行到下一个断点：<code>F9</code></li></ul><h2 id="附录">附录</h2><h3 id="零钱通程序">零钱通程序</h3><ul><li><p><strong>Wallet.java</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.the_wallet;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Wallet</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">Data</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Data</span>(<span class="hljs-string">&quot;Melody&quot;</span>);        p1.menu();        System.out.println(<span class="hljs-string">&quot;再见~&quot;</span>);    &#125;&#125;</code></pre></div></li><li><p><strong>Data.java</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.the_wallet;<span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<span class="hljs-keyword">import</span> java.util.Date;<span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;user&quot;</span>;    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> <span class="hljs-variable">balance</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">private</span> String[][] detail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">1</span>][<span class="hljs-number">5</span>];    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Data</span><span class="hljs-params">()</span> &#123;        detail[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;项目\t&quot;</span>;        detail[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;\t\t&quot;</span>;        detail[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;时间&quot;</span>;        detail[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = <span class="hljs-string">&quot; &quot;</span>;        detail[<span class="hljs-number">0</span>][<span class="hljs-number">4</span>] = <span class="hljs-string">&quot; &quot;</span>;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Data</span><span class="hljs-params">(String name)</span> &#123;        <span class="hljs-built_in">this</span>();        <span class="hljs-built_in">this</span>.name = name;    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;        <span class="hljs-built_in">this</span>.name = name;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">menu</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">char</span> <span class="hljs-variable">inp</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;        <span class="hljs-type">double</span> inpD;        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);        <span class="hljs-keyword">while</span> (inp != <span class="hljs-string">&#x27;y&#x27;</span> &amp;&amp; inp != <span class="hljs-string">&#x27;Y&#x27;</span>) &#123;            System.out.print(<span class="hljs-string">&quot;\n===============零钱通菜单===============&quot;</span>                    + <span class="hljs-string">&quot;\n\t\t\t1.零钱通明细&quot;</span>                    + <span class="hljs-string">&quot;\n\t\t\t2.收益入帐&quot;</span>                    + <span class="hljs-string">&quot;\n\t\t\t3.消费入账&quot;</span>                    + <span class="hljs-string">&quot;\n\t\t\t4.退   出&quot;</span>                    + <span class="hljs-string">&quot;\n请选择（1-4）：&quot;</span>);            inp = scanner.next().charAt(<span class="hljs-number">0</span>);            System.out.println(<span class="hljs-string">&quot;======================================&quot;</span>);            <span class="hljs-keyword">switch</span> (inp) &#123;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;4&#x27;</span>:                    System.out.println(<span class="hljs-string">&quot;确定要退出吗？（y/n）：&quot;</span>);                    inp = scanner.next().charAt(<span class="hljs-number">0</span>);                    <span class="hljs-keyword">while</span> (inp != <span class="hljs-string">&#x27;y&#x27;</span> &amp;&amp; inp != <span class="hljs-string">&#x27;n&#x27;</span> &amp;&amp; inp != <span class="hljs-string">&#x27;Y&#x27;</span> &amp;&amp; inp != <span class="hljs-string">&#x27;N&#x27;</span>) &#123;                        System.out.println(<span class="hljs-string">&quot;请输入“y”或者“n”！听话！&quot;</span>);                        inp = scanner.next().charAt(<span class="hljs-number">0</span>);                    &#125;                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;1&#x27;</span>:                    showDetail();                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;2&#x27;</span>:                    System.out.println(<span class="hljs-string">&quot;请输入收益数额：&quot;</span>);                    inpD = scanner.nextDouble();                    <span class="hljs-keyword">if</span> (inpD &lt;= <span class="hljs-number">0</span>) &#123;                        System.out.print(<span class="hljs-string">&quot;收益需要为正，记录消费请选择“消费入账”&quot;</span>);                        <span class="hljs-keyword">break</span>;                    &#125;                    earning(inpD);                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;3&#x27;</span>:                    System.out.println(<span class="hljs-string">&quot;请输入支出数额：&quot;</span>);                    inpD = scanner.nextDouble();                    <span class="hljs-keyword">if</span> (inpD &lt; <span class="hljs-number">0</span>) &#123;                        inpD = -inpD;                    &#125;                    <span class="hljs-keyword">if</span> (balance &lt; inpD) &#123;                        System.out.println(<span class="hljs-string">&quot;您的余额不足！&quot;</span>);                        <span class="hljs-keyword">break</span>;                    &#125;                    System.out.println(<span class="hljs-string">&quot;请输入支出项目：&quot;</span>);                    spending(inpD, scanner.next());                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;g&#x27;</span>:                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">default</span>:                    System.out.print(<span class="hljs-string">&quot;错误。请输入数字（1-4）&quot;</span>);            &#125;        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">earning</span><span class="hljs-params">(<span class="hljs-type">double</span> earn)</span> &#123;        String[][] temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-built_in">this</span>.detail.length + <span class="hljs-number">1</span>][<span class="hljs-number">5</span>];        record(detail, temp);        <span class="hljs-built_in">this</span>.balance += earn;        tidy(<span class="hljs-string">&quot;收益入账&quot;</span>, earn, <span class="hljs-literal">true</span>, temp);        showDetail();        System.out.println(<span class="hljs-string">&quot;\n收益记录完成&quot;</span>);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">spending</span><span class="hljs-params">(<span class="hljs-type">double</span> spend, String title)</span> &#123;        String[][] temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-built_in">this</span>.detail.length + <span class="hljs-number">1</span>][<span class="hljs-number">5</span>];        record(detail, temp);        <span class="hljs-built_in">this</span>.balance -= spend;        tidy(title, spend, <span class="hljs-literal">false</span>, temp);        showDetail();        System.out.println(<span class="hljs-string">&quot;\n消费记录完成&quot;</span>);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">record</span><span class="hljs-params">(String[][] detail, String[][] temp)</span> &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; detail.length; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++) &#123;                temp[i][j] = detail[i][j];            &#125;        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tidy</span><span class="hljs-params">(String title, <span class="hljs-type">double</span> num, <span class="hljs-type">boolean</span> isPos, String[][] temp)</span> &#123;        <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();        <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sDate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);        <span class="hljs-keyword">if</span> (title.length() &lt;= <span class="hljs-number">2</span>) &#123;            temp[temp.length - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = title + <span class="hljs-string">&quot;\t\t&quot;</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            temp[temp.length - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = title + <span class="hljs-string">&quot;\t&quot;</span>;        &#125;        <span class="hljs-type">String</span> <span class="hljs-variable">sign</span> <span class="hljs-operator">=</span> isPos ? <span class="hljs-string">&quot;+&quot;</span> : <span class="hljs-string">&quot;-&quot;</span>;        temp[temp.length - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = sign + num + <span class="hljs-string">&quot;&quot;</span>;        temp[temp.length - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = sDate.format(date);        temp[temp.length - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;余额：&quot;</span>;        temp[temp.length - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>] = balance + <span class="hljs-string">&quot;&quot;</span>;        detail = temp;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showDetail</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;--------------------------------------&quot;</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; detail.length; i++) &#123;            System.out.println(detail[i][<span class="hljs-number">0</span>] + detail[i][<span class="hljs-number">1</span>] + <span class="hljs-string">&quot;\t&quot;</span> + detail[i][<span class="hljs-number">2</span>] + <span class="hljs-string">&quot;\t\t&quot;</span> + detail[i][<span class="hljs-number">3</span>] + detail[i][<span class="hljs-number">4</span>]);        &#125;        System.out.println(<span class="hljs-string">&quot;--------------------------------------&quot;</span>);    &#125;&#125;</code></pre></div></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>程序</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt;6 面向对象编程（基础）</title>
    <link href="/2021/11/29/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/6%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/"/>
    <url>/2021/11/29/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/6%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象编程基础">6 面向对象编程（基础）</h1><blockquote><p>面向对象是一种开发软件的方法，使分析、设计和实现一个系统的方法尽可能接近人们认识一个系统的方法。包括三个方面：面向对象分析、面向对象设计、面向对象程序设计。</p><p>Java语言是纯面向对象的语言。其所有数据类型都有相应的类，程序可以完全基于对象编写。</p></blockquote><h2 id="类与对象oop">6.1 类与对象（OOP）</h2><blockquote><p>类 就是数据类型。可以是 <code>int</code> 也可以是<code>人类</code></p><p>对象 就是其中具体的实例。可以是 <code>100</code> 也可以是<code>韩顺平</code></p><p>从 类 到 对象，可以称为 创建一个对象，也可以说 实例化一个对象，或者把对象实例化</p><ol type="1"><li>类 是抽象的、概念的，代表一类事物</li><li>对象 是具体的、实际的，代表一个个具体事物</li><li>类 是 对象 的模板，对象 是 类 的一个个体，对应一个实例</li></ol></blockquote><p>下面，我们定义了一个类 <code>Cat</code> 并创建了一些 对象<code>cat1</code> <code>cat2</code>：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Code6_1</span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<span class="hljs-type">Cat</span> <span class="hljs-variable">cat1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();cat1.name = <span class="hljs-string">&quot;福福&quot;</span>;cat1.age = <span class="hljs-number">2</span>;<span class="hljs-type">Cat</span> <span class="hljs-variable">cat2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();cat2.name = <span class="hljs-string">&quot;妞子&quot;</span>;cat2.age = <span class="hljs-number">1</span>;System.out.println(cat1.name);&#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>&#123;String name;<span class="hljs-type">int</span> age;&#125;</code></pre></div><h3 id="属性成员变量">6.1.1 属性/成员变量</h3><blockquote><p>从概念或叫法上看：成员变量 = 属性 = field（字段）</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>&#123;String name;<span class="hljs-type">int</span> age;&#125;</code></pre></div><p>其中，<code>String name;</code> 就是一个成员变量（属性）。</p><p>属性可以是基本数据类型，也可以是引用数据类型。</p><ol type="1"><li>属性的定义语法同变量。<code>访问修饰符 属性类型 属性名</code><ul><li>访问修饰符：控制属性的访问范围。有四种：<code>publie</code><code>protected</code> <code>默认(空)</code> <code>private</code></li></ul></li><li>属性的定义类型可以为任意类型，包含 基本类型 或 引用类型</li><li>属性如果不赋值，有默认值。规则同 <em><ahref="../../../../../../2021/11/27/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/5%20%E6%95%B0%E7%BB%84%E3%80%81%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/#5-1-1-%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82">[5.1.1数组 - 使用细节 - 3]</a></em></li></ol><h3 id="创建对象">6.1.2 创建对象</h3><ul><li><p>先声明再创建：</p><div class="code-wrapper"><pre><code class="hljs java">Cat cat1;      <span class="hljs-comment">//声明对象cat1</span>cat1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<span class="hljs-comment">//创建对象</span></code></pre></div></li><li><p>直接创建：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Cat</span> <span class="hljs-variable">cat2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();</code></pre></div></li></ul><p>注意事项：</p><ol type="1"><li><p>声明对象的场合，只是在内存中建立了一个引用。此时，该地址引用不指向任何内存空间。</p><p>对象的引用，也被称为对象的句柄。</p></li><li><p>使用 new运算符创建对象实例时，会为对象分配空间，就会调用类的构造方法。那之后，会将该段内存的首地址赋给刚才建立的引用。</p></li></ol><h3 id="访问对象">6.1.3 访问对象</h3><p>基本语法：<code>对象名.属性名</code></p><div class="code-wrapper"><pre><code class="hljs java">System.out.println(cat1.name);</code></pre></div><h3 id="类与对象的内存访问机制">6.1.4 类与对象的内存访问机制</h3><blockquote><p>栈：一般存放基本数据类型（局部变量）</p><p>堆：存放对象（如<code>Cat cat1 = new Cat()</code>，是在这里开辟的空间）</p><p>方法区：常量池（常量，比如字符串），类加载信息</p></blockquote><ol type="1"><li>创建对象时，先加载 类 信息，然后在 堆 中分配空间，栈中的对象名被赋予指向那个空间的地址。</li><li>之后进行指定初始化。该对象的 属性 中，是 基本数据类型 的直接记录在堆 中；是 字符串 的记录一个地址，该地址指向方法区，那里的常量池有该字符串。</li></ol><h2 id="成员方法">6.2 成员方法</h2><p>在某些情况下，我们需要定义成员方法。比如 <code>Cat</code>除了有属性（<code>name</code><code>age</code>）外，还可以有一些行为比如玩耍。</p><div class="code-wrapper"><pre><code class="hljs java">修饰符 返回数据类型 方法名(形参列表)&#123;方法体语句;returen 返回值;<span class="hljs-comment">//返回数据类型是 void 的场合，return语句不是必须的</span>&#125;</code></pre></div><ol type="1"><li><p>方法名必须是一个合法的标识符</p></li><li><p>返回类型即返回值的类型。如果方法没有返回值，应声明为void</p></li><li><p>修饰符段可以有几个不同的修饰符。</p><p>比如</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">strictfp</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;哎咿呀~ 哎咿呀~&quot;</span>);    &#125;</code></pre></div><p>其中 public（访问修饰符）、static（static 关键字）、final（final关键字）</p><p><strong><em>—— 访问修饰符见 <ahref="../../../../../../2021/12/05/Java/入门阶段/7%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%AD%E7%BA%A7%EF%BC%89/#7-3-%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6">[7.3访问修饰符]</a></em></strong></p><p><strong><em>—— static 关键字见 <ahref="../../../../../../2021/12/14/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/9%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/#9-1-1-%E7%B1%BB%E5%8F%98%E9%87%8F">[9.1.1类变量]</a></em></strong></p><p><strong><em>—— final 关键字见 <ahref="../../../../../../2021/12/14/Java/入门阶段/9%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/#9-5-final-%E5%85%B3%E9%94%AE%E5%AD%97">[9.5final 关键字]</a></em></strong></p><p><strong><em>—— strictfp 关键字见 <ahref="../../../../../../2021/12/19/Java/入门阶段/12%20%常用类/#12-1-4-strictfp-关键字">[12.1.4strictfp 关键字]</a></em></strong></p></li><li><p>参数列表是传递给方法的参数表。各个元素间以 <code>,</code>分隔。每个元素由一个类型和一个标识符表示的参数组成。</p><p>特别地，<code>参数类型... 标识符</code> 这样的参数被称为可变参数</p><p><strong><em>—— 可变参数见 <ahref="../../../../../../2021/11/29/Java/入门阶段/6%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/#6-5-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0">[6.5可变参数]</a></em></strong></p></li><li><p>方法体是实际要执行的代码块。方法体一般用 return作为方法的结束。</p></li></ol><p>使用成员方法，能提高代码的复用性。而且能把实现的细节封装起来，供其他用户调用。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>&#123;String name;<span class="hljs-comment">//属性 name</span><span class="hljs-type">int</span> age;<span class="hljs-comment">//属性 age</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">speak</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">//方法 speak()</span>  System.out.println(<span class="hljs-string">&quot;喵~&quot;</span>);&#125;&#125;</code></pre></div><blockquote><ol type="1"><li>方法写好后，不去调用就不会输出</li><li>先创建对象，然后调用方法即可</li></ol></blockquote><p>下面，展示一个含有成员方法的代码：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Code6_2</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;       <span class="hljs-type">Cat</span> <span class="hljs-variable">cat1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();       cat1.speak(<span class="hljs-number">10</span>, <span class="hljs-number">15</span>);<span class="hljs-comment">//调用 speak 方法，并且给 n1 = 10, n2 = 15</span>       <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> cat1.speak2(<span class="hljs-number">15</span>, <span class="hljs-number">135</span>);<span class="hljs-comment">//调用 speak2 方法,返回值赋给 r</span>    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">speak</span><span class="hljs-params">(<span class="hljs-type">int</span> n1, <span class="hljs-type">int</span> n2)</span>&#123;<span class="hljs-comment">//(int n1, int n2)形参列表，当前有两个形参 n1,n2</span>       <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> n1 + n2;       System.out.println(<span class="hljs-string">&quot;喵~&quot;</span> + n1 + <span class="hljs-string">&quot; + &quot;</span> + n2 +<span class="hljs-string">&quot; 的值是：&quot;</span> + res);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">speak2</span><span class="hljs-params">(<span class="hljs-type">int</span> n1, <span class="hljs-type">int</span> n2)</span>&#123;<span class="hljs-comment">//int 表示方法执行后，返回一个 int 值</span>       <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> n1 + n2;       <span class="hljs-keyword">return</span> res;<span class="hljs-comment">//返回 res 的值</span>    &#125;&#125;</code></pre></div><h3 id="方法的调用机制">6.2.1 方法的调用机制</h3><p>以前文代码为例：</p><div class="code-wrapper"><pre><code class="hljs java">...<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> cat1.speak2(<span class="hljs-number">15</span>, <span class="hljs-number">135</span>);...<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">speak2</span><span class="hljs-params">(<span class="hljs-type">int</span> n1, <span class="hljs-type">int</span> n2)</span>&#123;   <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> n1 + n2;   <span class="hljs-keyword">return</span> res;&#125;...</code></pre></div><ol type="1"><li>当程序执行到方法时，在 栈 中开辟一个新的 栈空间。该空间里储存<code>n1 = 15</code> <code>n2 = 135</code>，之后计算并储存结果<code>res = 150</code></li><li>当方法执行完毕，或执行到 <code>return</code> 语句时，就会返回</li><li>把 新栈空间 中的 <code>res = 150</code> 返回 main栈中调用方法的地方</li><li>返回后，继续执行该方法的后续代码</li></ol><h3 id="使用细节">6.2.2 使用细节</h3><ol type="1"><li><p>访问修饰符：作用是控制方法的使用范围。</p><ul><li>不写（默认访问控制范围）</li><li>public：公共</li><li>protected：受保护</li><li>private：私有</li></ul><p><strong><em>—— 访问修饰符见 <ahref="../../../../../../2021/12/05/Java/入门阶段/7%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%AD%E7%BA%A7%EF%BC%89/#7-3-%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6">[7.3访问修饰符]</a></em></strong></p></li><li><p>返回数据类型：</p><ul><li>一个方法最多有一个返回值。要返回多个结果可以使用 数组。</li><li>返回类型为任意类型。包括 基本数据类型 和 引用数据类型。</li><li>如果方法要求有返回数据类型，则方法体中最后的执行语句必为<code>return 值</code>，且返回类型必须和 return 的值一致。</li><li>如果 返回数据类型 为 <code>void</code>，则可以不写<code>return</code> 语句</li></ul></li><li><p>方法名：</p><ul><li>遵循驼峰命名法，最好见名知意，表达出该功能的意思。</li></ul></li><li><p>参数列表（形参列表）：</p><ul><li>一个方法可以有 0 个参数，也可以有多个参数。参数间用 <code>,</code>间隔。</li><li>参数类型可以为任意类型，包含 基本类型 和 引用类型。</li><li>调用带参数的方法时，一定对应着 参数列表 传入 相同类型 或 兼容类型的参数。</li><li>方法定义时的参数称为 形式参数 ，简称形参；方法调用时的参数（传入的参数）称为 实际参数，简称 实参。实参 与形参 的类型、个数、顺序必须一致。</li></ul></li><li><p>方法体：</p><ul><li>写完成功能的具体语句。方法中不能再定义方法。即：方法不能嵌套定义。</li></ul></li><li><p>调用细节：</p><ul><li><p>同一个类中的方法调用，可以直接调用。</p></li><li><p>跨类的方法调用，需要创建新对象，然后再调用方法。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C1</span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m1</span><span class="hljs-params">()</span>&#123;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m2</span><span class="hljs-params">()</span>&#123;   m1();<span class="hljs-comment">//同一个类中的方法调用，可以直接调用。</span>&#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">C2</span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m3</span><span class="hljs-params">()</span>&#123;   <span class="hljs-type">C1</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">C1</span>();   c.m2();<span class="hljs-comment">//跨类的方法调用，需要创建新对象，然后再调用方法。</span>&#125;&#125;</code></pre></div></li></ul></li></ol><h3 id="成员方法传参机制">6.2.3 成员方法传参机制</h3><p>Java 语言对对象采用的是<strong>值传递</strong>，方法得到的总是那个传入对象的副本。</p><ul><li><p>方法不能修改基本数据类型的参数。基本数据类型传递的是一个值，形参不影响实参。</p></li><li><p>方法可以改变对象参数的状态。</p><p>引用类型传递的是一个地址，形参和实参指向一处，两者总会相关。</p><p>但改变那个形参地址指向的场合，实参的指向不会改变。</p></li></ul><h2 id="方法递归调用">6.3 方法递归调用</h2><blockquote><p>递归：即方法自己调用自己，每次调用时传入不同变量。递归有助于编程者解决复杂问题，同时可以让代码变得简洁。</p></blockquote><blockquote><p>下面，示范一个斐波那契数列方法</p><div class="code-wrapper"><pre><code class="hljs java">&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&#123;   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;       <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>)&#123;           <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;       &#125;<span class="hljs-keyword">else</span>&#123;           <span class="hljs-keyword">return</span> (fib(n - <span class="hljs-number">1</span>)) + (feb(n - <span class="hljs-number">2</span>));       &#125;   &#125;&gt;&#125;</code></pre></div></blockquote><h3 id="使用细节-1">6.3.1 使用细节</h3><ol type="1"><li>执行一个方法时，就创建一个新的受保护的独立 栈空间。</li><li>方法的局部变量是独立的，不会相互影响。</li><li>如果方法中使用的是引用变量，就会共享数据。（因为 <ahref="../../../../../../2021/11/29/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/6%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/#6-2-3-%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E4%BC%A0%E5%8F%82%E6%9C%BA%E5%88%B6">[6.2.3成员方法传参机制]</a>）</li><li>递归必须向退出递归的条件逼近，否则就是无限递归，会提示<code>StackOverflowError</code> “死龟”</li><li>当一个方法执行完毕，或遇到 <code>return</code>就会返回。遵守谁调用就返回给谁。同时当方法执行完毕或返回时，该方法也执行完毕。</li></ol><h2 id="方法重载">6.4 方法重载</h2><blockquote><p>方法重载（Overload）：Java 中允许同一类中，多个同名方法的存在，但要求形参列表 不一致。</p><p>这样，减轻了起名和记名的麻烦。</p></blockquote><p><strong>使用细节：</strong></p><ol type="1"><li>方法名：必须相同</li><li>形参列表：必须不同（参数的类型、个数、顺序，这其中至少一个不同）</li><li>返回值：无要求</li></ol><p><strong>签名：</strong></p><p>由于重载的存在，要完整的描述一个方法，要指定方法名及参数类型。这叫做方法的签名。</p><p>如：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">act</span><span class="hljs-params">()</span> &#123;&#125;<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">act</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;    <span class="hljs-keyword">return</span> n;&#125;</code></pre></div><p>两个方法的签名分别是：<code>act()</code> 和<code>act(int n)</code></p><h2 id="可变参数">6.5 可变参数</h2><blockquote><p>Java允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法。</p></blockquote><p>语法：<code>访问修饰符 返回类型 方法名（数据类型... 形参名）&#123;代码块;&#125;</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m</span><span class="hljs-params">(<span class="hljs-type">int</span>... n)</span>&#123;<span class="hljs-comment">//此时，n 相当于一个 数组。</span><span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> n.length;<span class="hljs-type">int</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> n[<span class="hljs-number">0</span>];&#125;</code></pre></div><h3 id="使用细节-2">6.5.1 使用细节</h3><ol type="1"><li><p>可变参数 的实参可以是 0 个，也可以是 任意多 个。</p></li><li><p>可变参数 的实参可以是数组</p></li><li><p>可变参数 本质就是数组</p><p>因此，出现：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">met</span><span class="hljs-params">(<span class="hljs-type">int</span>... n)</span>&#123;<span class="hljs-comment">//这个方法与下面的方法不能构成重载</span>&#125;</code></pre></div><p>的场合，不能有方法：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">met</span><span class="hljs-params">(<span class="hljs-type">int</span>[] n)</span>&#123;<span class="hljs-comment">//这个方法与上面的方法不能构成重载</span>&#125;</code></pre></div></li><li><p>可变参数 和 普通参数 可以一起放在形参列表，但必须保证 可变参数在最后</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m</span><span class="hljs-params">(<span class="hljs-type">double</span> dou, <span class="hljs-type">int</span>... n)</span> &#123;&#125;</code></pre></div></li><li><p>一个形参列表最多出现 一个 可变参数。</p></li></ol><h2 id="作用域">6.6 作用域</h2><ol type="1"><li>在 Java 编程中，主要的变量就是 属性（成员变量）和 局部变量。</li><li>我们说的 局部变量 一般是指在成员方法中定义的变量。</li><li>作用域的分类<ul><li>全局变量：也就是 属性，作用域为整个类体</li><li>局部变量：除了属性外的其他变量。作用域为定义它的代码块中</li></ul></li><li>全局变量（属性）可以不赋值直接使用，那个场合有默认值。局部变量必须赋值使用</li></ol><h3 id="使用细节-3">6.6.1 使用细节</h3><ol type="1"><li><p>属性 和 局部变量 可以重名，访问时遵循就近原则</p></li><li><p>在同一作用域中，两个局部变量不能重名</p></li><li><p>属性的生命周期较长。其伴随对象的创建而创建，伴随对象的销毁而销毁。</p><p>局部变量生命周期较短。其伴随代码块的执行而创建，伴随代码块的结束而销毁。</p></li><li><p>全局变量/属性可以被本类使用，也可以被其他类（通过对象）使用。</p><p>局部变量 只能被本类的对应方法中调用</p></li><li><p>全局变量/属性 <strong>可以加</strong> 修饰符</p><p>局部变量 <strong>不能加</strong> 修饰符</p></li></ol><h2 id="构造方法构造器">6.7 构造方法、构造器</h2><blockquote><p>构造方法又叫构造器（constructor），是类的一种特殊的方法。它的主要作用是完成对新对象的初始化。</p></blockquote><p>语法：<code>[修饰符] 方法名(形参列表)&#123;方法体&#125;</code></p><ol type="1"><li>构造器的修饰符可以是默认。也可以是别的</li><li>参数列表 规则同 成员方法</li></ol><p>以下示范一个构造器：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&#123;String name;<span class="hljs-type">int</span> mun;    <span class="hljs-comment">//下面这块就是构造器</span><span class="hljs-keyword">public</span> <span class="hljs-title function_">T</span><span class="hljs-params">(String str, <span class="hljs-type">int</span> i)</span>&#123;name = str;num = i;&#125;&#125;</code></pre></div><h3 id="使用细节-4">6.7.1 使用细节</h3><ol type="1"><li><p>构造器本质也是方法。所以，可以 构造器重载。</p></li><li><p>构造器名 和 类名 相同</p></li><li><p>构造器无返回值</p></li><li><p>构造器是完成对象的初始化，而不是创建</p></li><li><p>创建对象时，系统自动调用构造器</p></li><li><p>如果程序员没有定义构造器，系统会自动给类生成一个无参构造器（默认构造器）</p></li><li><p>一旦定义了自己的构造器，就不能用无参构造器了。除非显式的定义一个无参构造器</p></li></ol><h3 id="流程分析">6.7.2 流程分析</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Amy&quot;</span>, <span class="hljs-number">10</span>);...    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;String name;<span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String pName, <span class="hljs-type">int</span> pAge)</span>&#123;name = pName;age = pAge;&#125;&#125;</code></pre></div><ol type="1"><li><p>加载 类信息（方法区）</p></li><li><p>在 堆 中开辟空间（地址）</p></li><li><p>完成对象初始化</p><ul><li><p>首先默认初始化。<code>age = 0; name = null</code></p></li><li><p>之后显式初始化。<code>age = 20; name = null</code></p><p>其中，显式初始化和代码块初始化按编写的先后顺序依次进行。</p></li><li><p>之后构造器的初始化。<code>age = 10; name = "Amy"</code></p></li></ul></li><li><p>把对象在 堆 中的 地址，返回给 <code>p1</code></p></li></ol><h2 id="this-关键字">6.8 <code>this</code> 关键字</h2><blockquote><p>JVM 会给每个对象分配 this 代表当前对象。</p><p>相当于在 堆 中，this 指向自己（对象）</p><p>在类定义的方法中，Java 会自动用 this关键字把所有变量和方法引用结合在一起。</p><p>遇到有同名的局部变量的场合，需要程序员加入 this关键字进行区分。不加入 this 关键字的场合，Java 遵循就近原则。</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span>&#123;    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">act</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;&#125;&#125;</code></pre></div><p>上面这个类的 <code>act()</code> 方法实际有 2 个参数。对其调用：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Example</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exmaple</span>();e.act(<span class="hljs-number">100</span>);</code></pre></div><p>可见，出现在方法名前的参数<code>e</code>，以及出现在方法名后的括号中的参数 <code>100</code></p><p>出现在方法名前的参数被称为 <strong>隐式参数</strong>（也称为方法调用的 目标 或 接收者）</p><p>出现在方法名后的参数被称为<strong>显式参数</strong>，就是所谓的实参</p><p>在每一个方法中，用 this 指代隐式参数。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">act</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;    <span class="hljs-built_in">this</span>.n = n;&#125;</code></pre></div><p>此时，再以相同方式调用方法：</p><div class="code-wrapper"><pre><code class="hljs java">e.act(<span class="hljs-number">100</span>);<span class="hljs-comment">// &lt;———— 相当于 e.n = 100;</span></code></pre></div><h3 id="使用方法">6.8.1 使用方法</h3><ol type="1"><li><p><code>this</code>关键字可以用来访问本类的属性、方法、构造器</p></li><li><p><code>this</code> 用于区分当前类的 属性 和 局部变量</p></li><li><p>访问本类中成员方法的语法：<code>this.方法名</code></p></li><li><p>访问构造器的语法：<code>this(参数列表);</code></p><p>注意：只能在构造器中访问另一个构造器。而且，如果有这个语法，必须放置在第一条语句。</p></li><li><p><code>this</code> 不能在类定义的 外部 使用，只能在类定义的 方法中使用</p></li></ol><h2 id="附录">附录</h2><h3 id="迷宫游戏代码">迷宫游戏代码</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">*<span class="hljs-doctag">@author</span> Melody</span><span class="hljs-comment">*<span class="hljs-doctag">@version</span> v1.2.6</span><span class="hljs-comment">**/</span><span class="hljs-comment">//迷宫</span><span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MazeOut</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;        <span class="hljs-comment">//tools 方便后面调用方法。 inP 可以接收用户输入</span>        <span class="hljs-type">T</span> <span class="hljs-variable">tools</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>();        <span class="hljs-type">Scanner</span> <span class="hljs-variable">inP</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);                <span class="hljs-comment">//提示并接收用户输入信息</span>        System.out.println(<span class="hljs-string">&quot;\n输入迷宫宽度（至少为6）：&quot;</span>);        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> inP.nextInt();        System.out.println(<span class="hljs-string">&quot;\n输入迷宫长度（至少为6）：&quot;</span>);        <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> inP.nextInt();          <span class="hljs-comment">//若用户输入的长或宽超出范围，则将其重置为正常值</span>        <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">6</span>)&#123;            x = <span class="hljs-number">6</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &gt; <span class="hljs-number">110</span>)&#123;        x = <span class="hljs-number">110</span>;        &#125;        <span class="hljs-keyword">if</span>(y &lt; <span class="hljs-number">6</span>)&#123;            y = <span class="hljs-number">6</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(y &gt; <span class="hljs-number">60</span>)&#123;        y = <span class="hljs-number">60</span>;        &#125;        System.out.println(<span class="hljs-string">&quot;\n输入迷宫的困难度（请输入1 - 6的数字，数字越高越不容易获胜）：&quot;</span>);        <span class="hljs-type">int</span> <span class="hljs-variable">hard</span> <span class="hljs-operator">=</span> inP.nextInt();        <span class="hljs-keyword">if</span>(hard == <span class="hljs-number">7</span>)&#123;        System.out.println(<span class="hljs-string">&quot;\n\n您选择了找点麻烦&quot;</span>);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hard == <span class="hljs-number">8</span> || hard == <span class="hljs-number">9</span>)&#123;        System.out.println(<span class="hljs-string">&quot;\n\n您选择了给自己添堵&quot;</span>);        &#125;        System.out.println(<span class="hljs-string">&quot;\n\t迷宫生产完毕\n&quot;</span>);                <span class="hljs-comment">//设置一个 count 值，记录步数。设为数组，以便数据通用。第一位记录当前值，第二位为最大值。</span>        <span class="hljs-type">int</span>[] count = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;        <span class="hljs-comment">//调用方法，生成迷宫</span>        <span class="hljs-type">char</span>[][] maze =<span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[y][x];        tools.newMaze(maze.length, maze[<span class="hljs-number">0</span>].length, maze, hard);        <span class="hljs-comment">//调用方法，展示迷宫</span>        tools.showMaze(maze);                <span class="hljs-comment">//提示用户开始游戏</span>        System.out.println(<span class="hljs-string">&quot;\n召唤一个探索者，来探索迷宫吧（随便输点什么吧）&quot;</span>);        <span class="hljs-comment">//输入 r 或 c 则采用递归方法，其余采用爬墙方法</span>        <span class="hljs-type">char</span> <span class="hljs-variable">inC</span> <span class="hljs-operator">=</span> inP.next().charAt(<span class="hljs-number">0</span>);        <span class="hljs-keyword">if</span>(inC == <span class="hljs-string">&#x27;c&#x27;</span>)&#123;            System.out.println(<span class="hljs-string">&quot;\n您触发了迷宫之神的眷顾。&quot;</span>);            <span class="hljs-keyword">if</span>(hard &gt; <span class="hljs-number">5</span>)&#123;            System.out.println(<span class="hljs-string">&quot;\n迷宫之神眉头一皱，发现事情并不简单。&quot;</span>);            &#125;            <span class="hljs-keyword">if</span>(x &gt; <span class="hljs-number">12</span> || y &gt; <span class="hljs-number">12</span>)&#123;                System.out.println(<span class="hljs-string">&quot;看到地图这么大，迷宫之神悻悻而归。他只喜欢12格以下的地图。&quot;</span>);                <span class="hljs-keyword">return</span>;             &#125;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(inC == <span class="hljs-string">&#x27;r&#x27;</span>)&#123;            System.out.println(<span class="hljs-string">&quot;\n您引来了一群无畏小黄鸡。他们视死如归，一心想着寻找出口&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            System.out.println(<span class="hljs-string">&quot;\n我们找来了一只小蜘蛛。试试看吧。&quot;</span>);        &#125;        System.out.println(<span class="hljs-string">&quot;\n&quot;</span>);        <span class="hljs-comment">//调用方法，解密</span>        <span class="hljs-keyword">if</span>(inC == <span class="hljs-string">&#x27;r&#x27;</span> || inC == <span class="hljs-string">&#x27;c&#x27;</span>)&#123;            tools.outMazeRec(maze, inC, count);        &#125; <span class="hljs-keyword">else</span> &#123;            tools.outMaze(maze, count);        &#125;    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&#123;       <span class="hljs-comment">//=======================================================================================    </span>        <span class="hljs-comment">//方法 newMaze：让 n3 生成随机的 长 * 宽 = n1 * n2 的迷宫，其困难度为 n4</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">newMaze</span><span class="hljs-params">(<span class="hljs-type">int</span> n1, <span class="hljs-type">int</span> n2, <span class="hljs-type">char</span>[][] n3, <span class="hljs-type">int</span> n4)</span>&#123;        <span class="hljs-comment">//构建迷宫墙壁，以&#x27;#&#x27;表示。并随机向其中填充石块，以&#x27;O&#x27;表示</span>        <span class="hljs-comment">////墙壁是迷宫的 开头和结尾行 以及 每行的开头和结尾</span>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n1; i++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n2; j++)&#123;                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> || i == n1 - <span class="hljs-number">1</span> ||j == <span class="hljs-number">0</span> || j == n2 - <span class="hljs-number">1</span>)&#123;                    n3[i][j] = <span class="hljs-string">&#x27;#&#x27;</span>;                &#125;<span class="hljs-keyword">else</span>&#123;                    <span class="hljs-comment">//ran 是一个随机值，此处是概率生成挡路的石块&#x27;O&#x27;。其概率与 n4 值的大小正相关</span>                    <span class="hljs-comment">//此外，若 n4（即用户输入的难度值 hard）超过范围，则按照 难度6 计算</span>                    <span class="hljs-type">int</span> ran;                    <span class="hljs-keyword">if</span>(n4 &lt;= <span class="hljs-number">9</span> &amp;&amp; n4 &gt;= <span class="hljs-number">0</span>)&#123;                        ran = (<span class="hljs-type">int</span>)(Math.random() * (<span class="hljs-number">9</span> - n4) + <span class="hljs-number">1</span>);                    &#125;<span class="hljs-keyword">else</span>&#123;                        ran = (<span class="hljs-type">int</span>)(Math.random() * <span class="hljs-number">3</span> + <span class="hljs-number">1</span>);                    &#125;                    n3[i][j] = (ran == <span class="hljs-number">1</span>) ? <span class="hljs-string">&#x27;O&#x27;</span> : <span class="hljs-string">&#x27; &#x27;</span>;                &#125;            &#125;        &#125;        <span class="hljs-comment">//生成起点、终点，优化地形</span>        n3[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;B&#x27;</span>;        n3[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27; &#x27;</span>;        n3[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27; &#x27;</span>;        n3[n1 - <span class="hljs-number">2</span>][n2 - <span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;F&#x27;</span>;        n3[n1 - <span class="hljs-number">3</span>][n2 - <span class="hljs-number">2</span>] = <span class="hljs-string">&#x27; &#x27;</span>;        n3[n1 - <span class="hljs-number">2</span>][n2 - <span class="hljs-number">3</span>] = <span class="hljs-string">&#x27; &#x27;</span>;    &#125;                    <span class="hljs-comment">//方法 showMaze：展示一个迷宫</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showMaze</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] n1)</span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n1.length; i++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n1[i].length; j++)&#123;                System.out.print(<span class="hljs-string">&quot; &quot;</span> + n1[i][j]);            &#125;            System.out.println();        &#125;    &#125;    <span class="hljs-comment">//=======================================================================================   </span>    <span class="hljs-comment">//=======================================================================================</span>    <span class="hljs-comment">//方法 outMazeRec：递归方法迷宫游戏入口。可以接入普通递归方法，或最短路径方法。</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">outMazeRec</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] n1, <span class="hljs-type">char</span> n2, <span class="hljs-type">int</span>[] count)</span>&#123;        <span class="hljs-comment">//out：是否走出迷宫</span>        <span class="hljs-type">boolean</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;        <span class="hljs-comment">//将迷宫的起止位置记为通路</span>        n1[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27; &#x27;</span>;        n1[n1.length - <span class="hljs-number">2</span>][n1[<span class="hljs-number">0</span>].length -<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27; &#x27;</span>;        <span class="hljs-comment">//如果输入的是&#x27;c&#x27;，则采用最短路径法。反之采用普通递归方法</span>        <span class="hljs-keyword">if</span>(n2 == <span class="hljs-string">&#x27;c&#x27;</span>)&#123;            out = outCountMaze(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n1, count);        &#125;<span class="hljs-keyword">else</span>&#123;            out = outMazeRecursion(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n1, count);                   &#125;        <span class="hljs-comment">//把迷宫起始位置重新标注出来</span>        n1[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;B&#x27;</span>;        <span class="hljs-comment">//判断是否解谜成功。如果成功，迷宫终点显示&#x27;V&#x27;，并展示步数，否则显示&#x27;F&#x27;</span>        <span class="hljs-keyword">if</span>(out)&#123;            n1[n1.length - <span class="hljs-number">2</span>][n1[<span class="hljs-number">0</span>].length -<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;V&#x27;</span>;            showMaze(n1);            System.out.println(<span class="hljs-string">&quot;\t YOU WIN！！！&quot;</span>);            System.out.println(<span class="hljs-string">&quot;通过路径为 &quot;</span> + count[<span class="hljs-number">1</span>] + <span class="hljs-string">&quot; 格&quot;</span>);            &#125; <span class="hljs-keyword">else</span> &#123;            n1[n1.length - <span class="hljs-number">2</span>][n1[<span class="hljs-number">0</span>].length -<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;F&#x27;</span>;            showMaze(n1);            System.out.println(<span class="hljs-string">&quot;\t YOU LOSE&quot;</span>);        &#125;            &#125;    <span class="hljs-comment">//=======================================================================================</span>    <span class="hljs-comment">//=======================================================================================</span>    <span class="hljs-comment">//方法 outMazeRecursion：迷宫游戏，普通递归方法</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">outMazeRecursion</span><span class="hljs-params">(<span class="hljs-type">int</span> y, <span class="hljs-type">int</span> x, <span class="hljs-type">char</span>[][] n3, <span class="hljs-type">int</span>[] count)</span>&#123;        count[<span class="hljs-number">1</span>]++;        <span class="hljs-keyword">if</span>(n3[n3.length - <span class="hljs-number">2</span>][n3[<span class="hljs-number">0</span>].length - <span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;.&#x27;</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n3[y][x] == <span class="hljs-string">&#x27; &#x27;</span>)&#123;            n3[y][x] = <span class="hljs-string">&#x27;.&#x27;</span>;            <span class="hljs-keyword">if</span>(outMazeRecursion(y, x + <span class="hljs-number">1</span>, n3, count))&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(outMazeRecursion(y + <span class="hljs-number">1</span>, x, n3, count))&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(outMazeRecursion(y, x - <span class="hljs-number">1</span>, n3, count))&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(outMazeRecursion(y - <span class="hljs-number">1</span>, x, n3, count))&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125; <span class="hljs-keyword">else</span>&#123;                count[<span class="hljs-number">1</span>]--;                n3[y][x] = <span class="hljs-string">&#x27;+&#x27;</span>;             &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            count[<span class="hljs-number">1</span>]--;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        count[<span class="hljs-number">1</span>]--;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-comment">//=======================================================================================    </span>    <span class="hljs-comment">//=======================================================================================</span>    <span class="hljs-comment">//方法 outCountMaze：迷宫游戏，最短路径法的入口。这个入口由普通递归法接入。</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">outCountMaze</span><span class="hljs-params">(<span class="hljs-type">int</span> y, <span class="hljs-type">int</span> x, <span class="hljs-type">char</span>[][] n, <span class="hljs-type">int</span>[] count)</span>&#123;        <span class="hljs-comment">//首先，创建一个里数组。该数组用于 part1，原数组用于 part2。</span>        <span class="hljs-comment">//似乎没必要作此设计。但我还是予以保留。</span>        <span class="hljs-type">char</span>[][] inMaze = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[n.length][n[<span class="hljs-number">0</span>].length];        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n.length; i++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n[<span class="hljs-number">0</span>].length; j++)&#123;                inMaze[i][j] = n[i][j];            &#125;        &#125;        <span class="hljs-comment">//首先进行 part1，然后必定进行 part2。因为 part1 总会返回一个 false</span>        <span class="hljs-keyword">if</span>(countMazeRec(y, x, inMaze, count) || <span class="hljs-literal">true</span>)&#123;            count[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;            <span class="hljs-keyword">return</span> outMazeRecC(y, x, n, count);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-comment">//方法 countMazeRec：迷宫游戏，最短路径法，part1</span>    <span class="hljs-comment">//该方法是先统计最短路径。最终总会返回 false</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">countMazeRec</span><span class="hljs-params">(<span class="hljs-type">int</span> y, <span class="hljs-type">int</span> x, <span class="hljs-type">char</span>[][] n3, <span class="hljs-type">int</span>[] count)</span>&#123;        count[<span class="hljs-number">0</span>]++;        <span class="hljs-keyword">if</span>(y == n3.length - <span class="hljs-number">2</span> &amp;&amp; x == n3[<span class="hljs-number">0</span>].length - <span class="hljs-number">2</span>)&#123;            <span class="hljs-keyword">if</span>(count[<span class="hljs-number">0</span>] &lt; count[<span class="hljs-number">1</span>] || count[<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>)&#123;                count[<span class="hljs-number">1</span>] = count[<span class="hljs-number">0</span>];            &#125;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n3[y][x] == <span class="hljs-string">&#x27; &#x27;</span>)&#123;            n3[y][x] = <span class="hljs-string">&#x27;.&#x27;</span>;                       <span class="hljs-keyword">if</span>(countMazeRec(y, x + <span class="hljs-number">1</span>, n3, count))&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(countMazeRec(y + <span class="hljs-number">1</span>, x, n3, count))&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(countMazeRec(y, x - <span class="hljs-number">1</span>, n3, count))&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(countMazeRec(y - <span class="hljs-number">1</span>, x, n3, count))&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125; <span class="hljs-keyword">else</span>&#123;                n3[y][x] = <span class="hljs-string">&#x27; &#x27;</span>;                count[<span class="hljs-number">0</span>]--;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            count[<span class="hljs-number">0</span>]--;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        count[<span class="hljs-number">0</span>]--;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-comment">//方法 outMazeRecC：迷宫游戏，最短路径法，part2</span>    <span class="hljs-comment">//该方法是在 part1 统计完最短路径后，按最短路径走出迷宫，并绘制路径</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">outMazeRecC</span><span class="hljs-params">(<span class="hljs-type">int</span> y, <span class="hljs-type">int</span> x, <span class="hljs-type">char</span>[][] n3, <span class="hljs-type">int</span>[] count)</span>&#123;        count[<span class="hljs-number">0</span>]++;        <span class="hljs-keyword">if</span>(y == n3.length - <span class="hljs-number">2</span> &amp;&amp; x == n3[<span class="hljs-number">0</span>].length - <span class="hljs-number">2</span>)&#123;            <span class="hljs-keyword">if</span>(count[<span class="hljs-number">0</span>] &lt;= count[<span class="hljs-number">1</span>])&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                n3[n3.length - <span class="hljs-number">2</span>][n3[<span class="hljs-number">0</span>].length - <span class="hljs-number">2</span>] = <span class="hljs-string">&#x27; &#x27;</span>;                count[<span class="hljs-number">0</span>]--;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n3[y][x] == <span class="hljs-string">&#x27; &#x27;</span>)&#123;            n3[y][x] = <span class="hljs-string">&#x27;.&#x27;</span>;            <span class="hljs-keyword">if</span>(outMazeRecC(y, x + <span class="hljs-number">1</span>, n3, count))&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(outMazeRecC(y + <span class="hljs-number">1</span>, x, n3, count))&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(outMazeRecC(y, x - <span class="hljs-number">1</span>, n3, count))&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(outMazeRecC(y - <span class="hljs-number">1</span>, x, n3, count))&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125; <span class="hljs-keyword">else</span>&#123;                n3[y][x] = <span class="hljs-string">&#x27; &#x27;</span>;                count[<span class="hljs-number">0</span>]--;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            count[<span class="hljs-number">0</span>]--;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    &#125;    <span class="hljs-comment">//=======================================================================================</span>        <span class="hljs-comment">//=======================================================================================</span>    <span class="hljs-comment">//方法 outMaze：爬墙方法迷宫游戏入口</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">outMaze</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] n1, <span class="hljs-type">int</span>[] count)</span>&#123;        <span class="hljs-comment">//boolean out：记录是否走出迷宫</span>        <span class="hljs-type">boolean</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;        <span class="hljs-comment">//角色光标 m</span>        n1[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;m&#x27;</span>;                <span class="hljs-comment">//创建一系列变量，后面解释用法</span>        <span class="hljs-comment">//创建 角色坐标</span>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;        <span class="hljs-comment">//创建 辅助坐标 及 方向字符。初始方向为右。</span>        <span class="hljs-type">int</span> <span class="hljs-variable">xi</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">yi</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-type">char</span> <span class="hljs-variable">dir</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;r&#x27;</span>;          <span class="hljs-comment">//创建 里迷宫，标记起止点。</span>        <span class="hljs-type">char</span>[][] inMaze = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[n1.length][n1[<span class="hljs-number">0</span>].length];        inMaze[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;B&#x27;</span>;        inMaze[n1.length - <span class="hljs-number">2</span>][n1[<span class="hljs-number">0</span>].length - <span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;F&#x27;</span>;                <span class="hljs-comment">//开始走迷宫。</span>        <span class="hljs-comment">//如果一个迷宫有出路，则沿着一侧的墙壁走就一定能走到出路。以下方法就是基于这个原理。</span>        <span class="hljs-comment">//角色坐标 y,x 是角色所在的位置坐标。辅助坐标 yi，xi 是角色靠近的墙壁坐标。</span>        <span class="hljs-comment">//dir 代表角色此时的朝向。只要角色按照墙壁延申的方向向前，就一定不会迷路。</span>        <span class="hljs-comment">//里迷宫的大小和真迷宫相同，坐标也一一对应。目的是为了记录数据，这些数据不会被用户看到。</span>        <span class="hljs-comment">//里迷宫记载了 起始点 和 终点 的位置。如角色回到起点，则必定失败。到达终点则成功。</span>        <span class="hljs-keyword">for</span>(;;)&#123;            <span class="hljs-comment">//判断 是否走出迷宫。如若是，则展示迷宫，记录脱出为真，并退出寻路</span>            <span class="hljs-keyword">if</span>(inMaze[y][x] == <span class="hljs-string">&#x27;F&#x27;</span>)&#123;                n1[y][x] = <span class="hljs-string">&#x27;V&#x27;</span>;                n1[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;B&#x27;</span>;                showMaze(n1);                out = <span class="hljs-literal">true</span>;                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-comment">//通过爬墙方式试图走出迷宫</span>            <span class="hljs-comment">//这是方向朝右时的情况</span>            <span class="hljs-keyword">if</span>(dir == <span class="hljs-string">&#x27;r&#x27;</span>)&#123;                <span class="hljs-comment">//如果角色面对墙壁，意味着走到了墙角，则角色坐标不变，调整墙壁坐标，并转向</span>                <span class="hljs-keyword">if</span>(n1[y][x + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;#&#x27;</span> || n1[y][x + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;O&#x27;</span>)&#123;                    dir = yi &gt; y ? <span class="hljs-string">&#x27;u&#x27;</span> : <span class="hljs-string">&#x27;d&#x27;</span>;                    yi = y;                    xi = x + <span class="hljs-number">1</span>;                <span class="hljs-comment">//如果面前有路，且墙壁延伸，则前进</span>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n1[yi][xi + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;#&#x27;</span> || n1[yi][xi + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;O&#x27;</span>)&#123;                    n1[y][x] = <span class="hljs-string">&#x27;.&#x27;</span>;                    x++;                    xi++;                    n1[y][x] = <span class="hljs-string">&#x27;m&#x27;</span>;                    count[<span class="hljs-number">1</span>]++;                <span class="hljs-comment">//如果面前有路，但墙壁不延伸，则是遇到了转角。角色移动，转向，但墙壁坐标不变</span>                &#125; <span class="hljs-keyword">else</span> &#123;                    dir = yi &gt; y ? <span class="hljs-string">&#x27;d&#x27;</span> : <span class="hljs-string">&#x27;u&#x27;</span>;                    n1[y][x] = <span class="hljs-string">&#x27;.&#x27;</span>;                    n1[y][x + <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;.&#x27;</span>;                    y = yi;                    x = xi + <span class="hljs-number">1</span>;                    n1[y][x] = <span class="hljs-string">&#x27;m&#x27;</span>;                    count[<span class="hljs-number">1</span>] += <span class="hljs-number">2</span>;                &#125;            <span class="hljs-comment">//这是方向朝左的情况</span>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dir == <span class="hljs-string">&#x27;l&#x27;</span>)&#123;                <span class="hljs-keyword">if</span>(n1[y][x - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;#&#x27;</span> || n1[y][x - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;O&#x27;</span>)&#123;                    dir = yi &gt; y ? <span class="hljs-string">&#x27;u&#x27;</span> : <span class="hljs-string">&#x27;d&#x27;</span>;                    yi = y;                    xi = x - <span class="hljs-number">1</span>;                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n1[yi][xi - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;#&#x27;</span> || n1[yi][xi - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;O&#x27;</span>)&#123;                    n1[y][x] = <span class="hljs-string">&#x27;.&#x27;</span>;                    x--;                    xi--;                    n1[y][x] = <span class="hljs-string">&#x27;m&#x27;</span>;                    count[<span class="hljs-number">1</span>]++;                &#125; <span class="hljs-keyword">else</span> &#123;                    dir = yi &gt; y ? <span class="hljs-string">&#x27;d&#x27;</span> : <span class="hljs-string">&#x27;u&#x27;</span>;                    n1[y][x] = <span class="hljs-string">&#x27;.&#x27;</span>;                    n1[y][x - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;.&#x27;</span>;                    y = yi;                    x = xi - <span class="hljs-number">1</span>;                    n1[y][x] = <span class="hljs-string">&#x27;m&#x27;</span>;                    count[<span class="hljs-number">1</span>] += <span class="hljs-number">2</span>;                &#125;            <span class="hljs-comment">//这是方向朝下的情况</span>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dir == <span class="hljs-string">&#x27;d&#x27;</span>)&#123;                <span class="hljs-keyword">if</span>(n1[y + <span class="hljs-number">1</span>][x] == <span class="hljs-string">&#x27;#&#x27;</span> || n1[y + <span class="hljs-number">1</span>][x] == <span class="hljs-string">&#x27;O&#x27;</span>)&#123;                    dir = xi &lt; x ? <span class="hljs-string">&#x27;r&#x27;</span> : <span class="hljs-string">&#x27;l&#x27;</span>;                    yi = y + <span class="hljs-number">1</span>;                    xi = x;                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n1[yi + <span class="hljs-number">1</span>][xi] == <span class="hljs-string">&#x27;#&#x27;</span> || n1[yi + <span class="hljs-number">1</span>][xi] == <span class="hljs-string">&#x27;O&#x27;</span>)&#123;                    n1[y][x] = <span class="hljs-string">&#x27;.&#x27;</span>;                    y++;                    yi++;                    n1[y][x] = <span class="hljs-string">&#x27;m&#x27;</span>;                    count[<span class="hljs-number">1</span>]++;                &#125; <span class="hljs-keyword">else</span> &#123;                    dir = xi &lt; x ? <span class="hljs-string">&#x27;l&#x27;</span> : <span class="hljs-string">&#x27;r&#x27;</span>;                    n1[y][x] = <span class="hljs-string">&#x27;.&#x27;</span>;                    n1[y + <span class="hljs-number">1</span>][x] = <span class="hljs-string">&#x27;.&#x27;</span>;                    y = yi + <span class="hljs-number">1</span>;                    x = xi;                    n1[y][x] = <span class="hljs-string">&#x27;m&#x27;</span>;                    count[<span class="hljs-number">1</span>] += <span class="hljs-number">2</span>;                &#125;            <span class="hljs-comment">//这是方向朝上的情况</span>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dir == <span class="hljs-string">&#x27;u&#x27;</span>)&#123;                <span class="hljs-keyword">if</span>(n1[y - <span class="hljs-number">1</span>][x] == <span class="hljs-string">&#x27;#&#x27;</span> || n1[y - <span class="hljs-number">1</span>][x] == <span class="hljs-string">&#x27;O&#x27;</span>)&#123;                    dir = xi &lt; x ? <span class="hljs-string">&#x27;r&#x27;</span> : <span class="hljs-string">&#x27;l&#x27;</span>;                    yi = y - <span class="hljs-number">1</span>;                    xi = x;                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n1[yi - <span class="hljs-number">1</span>][xi] == <span class="hljs-string">&#x27;#&#x27;</span> || n1[yi - <span class="hljs-number">1</span>][xi] == <span class="hljs-string">&#x27;O&#x27;</span>)&#123;                    n1[y][x] = <span class="hljs-string">&#x27;.&#x27;</span>;                    y--;                    yi--;                    n1[y][x] = <span class="hljs-string">&#x27;m&#x27;</span>;                    count[<span class="hljs-number">1</span>]++;                &#125; <span class="hljs-keyword">else</span> &#123;                    dir = xi &lt; x ? <span class="hljs-string">&#x27;l&#x27;</span> : <span class="hljs-string">&#x27;r&#x27;</span>;                    n1[y][x] = <span class="hljs-string">&#x27;.&#x27;</span>;                    n1[y - <span class="hljs-number">1</span>][x] = <span class="hljs-string">&#x27;.&#x27;</span>;                    y = yi - <span class="hljs-number">1</span>;                    x = xi;                    n1[y][x] = <span class="hljs-string">&#x27;m&#x27;</span>;                    count[<span class="hljs-number">1</span>] += <span class="hljs-number">2</span>;                &#125;            &#125;            <span class="hljs-comment">//判断 是否回到起点。如若是，则一定是迷宫无解。展示迷宫并退出寻路</span>            <span class="hljs-keyword">if</span>(inMaze[y][x] == <span class="hljs-string">&#x27;B&#x27;</span>)&#123;                showMaze(n1);                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-comment">//输出结果</span>        <span class="hljs-keyword">if</span>(out)&#123;            System.out.println(<span class="hljs-string">&quot;\t YOU WIN！！！\n\t您的步数为：&quot;</span> + count[<span class="hljs-number">1</span>]);        &#125; <span class="hljs-keyword">else</span> &#123;            System.out.println(<span class="hljs-string">&quot;\t YOU LOSE&quot;</span>);        &#125;    &#125;&#125;</code></pre></div><h3 id="八皇后代码">八皇后代码</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EightQueen</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;        <span class="hljs-type">T</span> <span class="hljs-variable">tools</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>();        <span class="hljs-type">char</span>[][] chess = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">8</span>][<span class="hljs-number">8</span>];        <span class="hljs-comment">//调用方法，建立棋盘</span>        tools.buildChess(chess);        <span class="hljs-comment">//调用方法，开始游戏</span>        tools.eightQueen(chess);    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&#123;    <span class="hljs-comment">//buildChess：建立一个新棋盘。该棋盘白色格子用&#x27; &#x27;表示，黑色格子用&#x27;#&#x27;表示</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildChess</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] chess)</span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; chess.length; i++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; chess[<span class="hljs-number">0</span>].length; j++)&#123;                chess[i][j] = ((i + j) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) ? <span class="hljs-string">&#x27; &#x27;</span> : <span class="hljs-string">&#x27;#&#x27;</span>;            &#125;        &#125;    &#125;    <span class="hljs-comment">//eightQueen：八皇后游戏的接入口</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eightQueen</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] chess)</span>&#123;    <span class="hljs-comment">//建立 里棋盘 inward 及 计数数组 count。里棋盘用于计算问题，原棋盘输出给用户看。</span>    <span class="hljs-comment">//计数 count 使用数组，这样其数据在所有方法都能通用</span>        <span class="hljs-type">char</span>[][] inward = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[chess.length][chess[<span class="hljs-number">0</span>].length];        <span class="hljs-type">int</span>[] count = &#123;<span class="hljs-number">0</span>&#125; ;        <span class="hljs-comment">//进行游戏。因为穷举所有方法，最后返回的一定是 false。反正我们不在意。</span>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isFinished</span> <span class="hljs-operator">=</span> gameEQS(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, chess, inward, count);    &#125;    <span class="hljs-comment">//gameEQS：八皇后游戏的基本方法</span>    <span class="hljs-comment">//八皇后游戏方法。y 代表当前位置的纵坐标，x 是横坐标。chess 是棋盘，inward 是里棋盘，count 是计数数组</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">gameEQS</span><span class="hljs-params">(<span class="hljs-type">int</span> y, <span class="hljs-type">int</span> x, <span class="hljs-type">char</span>[][] chess, <span class="hljs-type">char</span>[][] inward, <span class="hljs-type">int</span>[] count)</span>&#123;        <span class="hljs-comment">//当 y 超出棋盘 时，显然已经完成八皇后。</span>        <span class="hljs-comment">//由于要进行穷举，此时我们计数并输出棋盘，然后返回 false 使其继续计算</span>        <span class="hljs-keyword">if</span>(y == inward.length)&#123;            count[<span class="hljs-number">0</span>]++;            System.out.println();            gameEQS2(chess, inward, count);            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-comment">//当 x 超出棋盘 时，显然棋盘该列已经无合法放置位置。我们返回 false</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x == inward[<span class="hljs-number">0</span>].length)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-comment">//gameEQS1，这个方法是查看该格子是否是合法放置位置。如若是，返回 true，而且在该位置放置棋子&#x27;Q&#x27;</span>        <span class="hljs-comment">//当这个位置合法，我们进入下一行，从头开始判断。</span>        <span class="hljs-comment">//如果后面的判断为 false，我们就拿掉这枚棋子。如果后面判断为 true 说明我们找到了一个方法。</span>        <span class="hljs-comment">//特别地，由于代码目前是穷举模式，我想我们永远不会在此输出 true</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(gameEQS1(y, x, inward))&#123;            <span class="hljs-keyword">if</span>(gameEQS(y + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, chess, inward, count))&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                inward[y][x] = <span class="hljs-string">&#x27; &#x27;</span>;            &#125;        &#125;        <span class="hljs-comment">//如果代码进行到这个位置，证明我们所在的格子不适合放置棋子。我们只好去看看下一格如何。</span>        <span class="hljs-keyword">return</span> gameEQS(y, x + <span class="hljs-number">1</span>, chess, inward, count);    &#125;    <span class="hljs-comment">//gameEQS1：该方法是输入一个坐标，并输入里棋盘地址，在里棋盘上查看该位置是否合法</span>    <span class="hljs-comment">//什么是合法的位置：就是该坐标的 同列、同行、同斜线 没有别的棋子</span>    <span class="hljs-comment">//如果是合法位置，我们放置一个棋子，并返回 true</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">gameEQS1</span><span class="hljs-params">(<span class="hljs-type">int</span> y, <span class="hljs-type">int</span> x, <span class="hljs-type">char</span>[][] inward)</span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; inward.length; i++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; inward[<span class="hljs-number">0</span>].length; j++)&#123;                <span class="hljs-keyword">if</span>(j == x || i == y || i - j == y - x || i + j == y + x)&#123;                    <span class="hljs-keyword">if</span>(inward[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>)&#123;                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                    &#125;                &#125;            &#125;        &#125;        inward[y][x] = <span class="hljs-string">&#x27;Q&#x27;</span>;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-comment">//gameEQS2：这个方法是把当前 里棋盘 的棋子放置到棋盘上，输出棋盘 并 输出计数。</span>    <span class="hljs-comment">//在输出完成后，会清空棋盘。</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">gameEQS2</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] chess, <span class="hljs-type">char</span>[][] inward,<span class="hljs-type">int</span>[] count)</span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; chess.length; i++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; chess[<span class="hljs-number">0</span>].length; j++)&#123;                <span class="hljs-keyword">if</span>(inward[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>)&#123;                    chess[i][j] = <span class="hljs-string">&#x27;Q&#x27;</span>;                &#125;                System.out.print(<span class="hljs-string">&quot; &quot;</span> + chess[i][j]);            &#125;            System.out.println();        &#125;        System.out.print(<span class="hljs-string">&quot;\n&quot;</span> + count[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot;\n&quot;</span>);        buildChess(chess);    &#125;    <span class="hljs-comment">//gameEQSDebug</span>    <span class="hljs-comment">//输出里棋盘。测试用。</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">gameEQSDebug</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] inward)</span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; inward.length; i++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; inward[<span class="hljs-number">0</span>].length; j++)&#123;                System.out.print(<span class="hljs-string">&quot; &quot;</span> + inward[i][j]);            &#125;            System.out.println();        &#125;        System.out.println();    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>程序</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt;5 数组、排序和查找</title>
    <link href="/2021/11/27/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/5%20%E6%95%B0%E7%BB%84%E3%80%81%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/"/>
    <url>/2021/11/27/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/5%20%E6%95%B0%E7%BB%84%E3%80%81%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="数组排序和查找">5 数组、排序和查找</h1><blockquote><p>数组：可以存放多个同一类型的数据。数组也是一种数据，是引用类型。</p><p>即：数组就是一组数据。</p></blockquote><h2 id="一维数组">5.1 一维数组</h2><blockquote><p>数组可以是多个相同类型数据的组合，实现对这些数据的统一管理。</p><p>数组中的元素可以是任何数据类型。包括基本类型和引用类型。</p><p>数组的下标从 0 开始。且必须在指定范围内使用，否则报错。</p><p>数组属于 引用类型，数组型数据是 对象（Object）</p><p>数组创建后，如果没有赋值，有默认值：int（0），short（0），byte（0），long（0L），float（0.0F），double（0.0），char（000），boolean（false），String（null），Object（null）</p></blockquote><p><strong>数组的构造方法：</strong></p><p>使用数组的步骤：1.声明数组并开辟空间 2.给数组各个元素赋值3.使用数组</p><ul><li><p>构造方式1：动态初始化</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span>[] ints = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];<span class="hljs-comment">// 创建了数组 name，存放5个int</span><span class="hljs-type">int</span> ints2[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1</span>];<span class="hljs-comment">// 这种写法也行</span>ints[<span class="hljs-number">2</span>] = <span class="hljs-number">15</span>;<span class="hljs-comment">// 访问数组第3个数</span></code></pre></div></li><li><p>构造方式2：动态初始化</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">char</span>[] chars;<span class="hljs-comment">// 先声明数组 name，此时数组是 null</span>chars = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">2</span>];<span class="hljs-comment">// 分配内存空间，可以存放数据了</span>chars[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;\t&#x27;</span>;</code></pre></div></li><li><p>构造方式3：静态初始化</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">boolean</span>[] bools = &#123;<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>&#125;;String[] strs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;阿伟，你又在打电动噢&quot;</span>, <span class="hljs-string">&quot;烦啦&quot;</span>&#125;;</code></pre></div><p>确切知道数组每个元素的场合可以用这个方法。</p></li></ul><p><strong>数组的使用方法：</strong></p><ul><li><p>访问数组元素：<code>数组名[元素下标]</code></p><p>其中，元素下标从 0 开始编号。如：访问 strs 数组的第一个元素<code>strs[0]</code></p></li><li><p>数组长度：<code>数组名.length</code></p><p>是一个 int 值。不能通过试图改变该值来改变数组容量</p></li></ul><h3 id="数组赋值机制">5.1.1 数组赋值机制</h3><ol type="1"><li><p>基本数据类型赋值，赋值方式是值拷贝。这个值就是具体的数据，且互不影响</p></li><li><p>数组在默认情况下是引用传递，赋的值是地址，赋值方式为引用传达。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span>[] array1 = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<span class="hljs-type">int</span>[] array2 = array1;array2[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span>;</code></pre></div><p>上述情况下，<code>array1[0]</code> 也会变成<code>100</code>。因为数组在 JVM 的 栈 里是一个地址，指向 堆里的一个空间。这两个数组在上述情况下指向同一空间。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span>[] array1 = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<span class="hljs-type">int</span>[] array2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[array1.length];<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; array1.length;i++) &#123;    array2[i] = array1[i];&#125;</code></pre></div><p>上述方式拷贝后，两数组相互独立。</p></li></ol><h3 id="数组的扩容">5.1.2 数组的扩容</h3><p>当数组达到上限时，创建一个容量更大的新数组。将旧数组的元素依次放入，之后替换旧数组。</p><p>以下是一个扩容方法：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Code5_1_3</span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<span class="hljs-type">Scanner</span> <span class="hljs-variable">inP</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<span class="hljs-type">int</span>[] arr1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<span class="hljs-comment">// 这是原数组</span><span class="hljs-type">int</span> <span class="hljs-variable">add</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// 这个变量记录输入的新元素的值</span><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> arr1.length;<span class="hljs-comment">// 这个变量是新数组的长度</span><span class="hljs-type">char</span> <span class="hljs-variable">yN</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;<span class="hljs-comment">// 记录询问继续与否时用户的输入字符</span><span class="hljs-keyword">do</span>&#123;       <span class="hljs-comment">/* 创建多一位的新数组，把新元素赋给新数组的最后一位 */</span>System.out.println(<span class="hljs-string">&quot;请输入添加数字：&quot;</span>);add = inP.nextInt();<span class="hljs-type">int</span>[] tem = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr1.length + <span class="hljs-number">1</span>];tem[count] = add;       <span class="hljs-comment">/* 把旧数组的值全部赋给新数组 */</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr1.length; i++)&#123;tem[i] = arr1[i];&#125;       <span class="hljs-comment">/* 把新数组保存下来，输出现在的数组 */</span>arr1 = tem;count++;System.out.println(<span class="hljs-string">&quot;\n\n当前数组为：&quot;</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr1.length; i++)&#123;System.out.print(arr1[i] + <span class="hljs-string">&quot; &quot;</span>);&#125;       <span class="hljs-comment">/* 询问是否继续添加，输入n跳出，否则循环 */</span>System.out.println(<span class="hljs-string">&quot;\n\n是否继续添加？（Y/N）&quot;</span>);yN = inP.next().charAt(<span class="hljs-number">0</span>);&#125;<span class="hljs-keyword">while</span>(yN != <span class="hljs-string">&#x27;N&#x27;</span> &amp;&amp; yN != <span class="hljs-string">&#x27;n&#x27;</span>);&#125;&#125;</code></pre></div><h2 id="二维数组">5.2 二维数组</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] ints;<span class="hljs-comment">// 声明一个二维数组</span><span class="hljs-type">int</span>[] ints2[];<span class="hljs-comment">// 也能这样声明</span><span class="hljs-type">int</span> ints3[][];<span class="hljs-comment">// 这样也行</span><span class="hljs-type">int</span>[] x,y[];<span class="hljs-comment">// 声明了两个数组，一个是 int[] x 一个是 int[][] y</span><span class="hljs-comment">// 把 int[] 视作一个类型，就能很好地理解这个写法</span></code></pre></div><p>二维数组实际是由多个一维数组组成的，它的各个元素的长度可以相同，也可以不同。</p><p>数组是一个对象，所以二维数组的元素存放的是一维数组的地址。</p><p><strong>二维数组构造方法：</strong></p><ul><li><p>构造方法1：动态初始化</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] many_ints = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>]<span class="hljs-comment">// 创建 有3个 包含4个元素的一维数组 的二维数组</span></code></pre></div></li><li><p>构造方法2：动态初始化</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">double</span>[][] many_doubles;<span class="hljs-comment">// 先声明变量</span>many_doubles = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>];<span class="hljs-comment">// 再开辟空间</span></code></pre></div></li><li><p>构造方法3：动态初始化-列数不确定</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">char</span>[][] many_chars = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">3</span>][];<span class="hljs-comment">// 创建一个三行列数不确定的二维数组</span><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;    many_chars[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[i + <span class="hljs-number">1</span>];<span class="hljs-comment">// 此时，每个数组空间依次增大</span>&#125;</code></pre></div></li><li><p>构造方法4：静态初始化</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] many_many = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">95</span>&#125;&#125;;</code></pre></div></li></ul><p><strong>二维数组使用方法：</strong></p><ul><li><code>ints.length</code>：该二维数组的长度，这里是 3</li><li><code>ints[0]</code>：该二维数组的第一个子数组</li><li><code>ints[0].length</code>：该二维数组的第一个子数组的长度，这里是4</li><li><code>ints[1][0]</code>：该二维数组第二个子数组的第一个元素的值，这里是21</li></ul><del>这是一维数组：int[]a、这是二维数组：int[][] b。好了，现在来写一个堆排序吧</del><h2 id="查找算法">5.3 查找算法</h2><p>在 Java 中，常用的查找有 4 种：</p><ul><li>顺序查找（遍历）</li><li>二分查找</li><li>插值查找</li><li>斐波那契查找</li></ul><h3 id="线性查找">5.3.1 线性查找</h3><p>逐一比对，直到发现目标值</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">seqSearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> target)</span> &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;        <span class="hljs-keyword">if</span> (array[i] == target) <span class="hljs-keyword">return</span> i;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre></div><h3 id="二分查找">5.3.2 二分查找</h3><p>二分查找要求数组必须是有序数组。</p><p>每次取出那个中位数。目标值大于中位数的场合，则在较小一侧的范围内继续二分查找。否则在那个较大一侧查找。</p><p>递归方式二分查找：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> target)</span> &#123;    <span class="hljs-keyword">return</span> binarySearch(array, target, <span class="hljs-number">0</span>, array.length);&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> -l - <span class="hljs-number">1</span>;    <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> (l + r) / <span class="hljs-number">2</span>;    <span class="hljs-keyword">if</span> (target == array[p]) <span class="hljs-keyword">return</span> p;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &gt; array[p]) &#123;        <span class="hljs-keyword">return</span> binarySearch(array, target, p + <span class="hljs-number">1</span>, r);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> binarySearch(array, target, l, p - <span class="hljs-number">1</span>);&#125;</code></pre></div><p>非递归方式二分查找：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> target)</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> array.length;    <span class="hljs-keyword">while</span> (r &gt; l) &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> (r + l) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span> (target == array[p]) <span class="hljs-keyword">return</span> p;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &gt; array[p]) l = p + <span class="hljs-number">1</span>;        <span class="hljs-type">else</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> p - <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> -l - <span class="hljs-number">1</span>;&#125;</code></pre></div><h3 id="插值查找">5.3.3 插值查找</h3><p>插值查找类似于二分查找，但其不是取出中位数，而是从自适应的位置取出一个元素</p><p>那个自适应的取出位置 mid = low + (target - arr[low]) ×<font color="#00C0FF">(</font>high - low<font color="#00C0FF">)</font> /<font color="FFC000">(</font>arr[high] -arr[low]<font color="FFC000">)</font></p><p>如若那个目标值更靠近某一端，这个自适应的取出位置也会更接近那一端</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">insertSearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> target)</span> &#123;    <span class="hljs-keyword">if</span> (target &gt; array[array.length - <span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> -array.length;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &lt; array[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> array.length;    <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (r &gt;= l) &#123;        p = l + (target - array[l]) * (r - <span class="hljs-number">1</span> - l) / (array[r - <span class="hljs-number">1</span>] - array[l]);        <span class="hljs-keyword">if</span> (target == array[p]) <span class="hljs-keyword">return</span> p;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &gt; array[p]) l = p + <span class="hljs-number">1</span>;        <span class="hljs-type">else</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> p - <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> -p;&#125;</code></pre></div><h3 id="斐波那契查找">5.3.4 斐波那契查找</h3><p>斐波那契查找原理与前两种类似，仅仅改变了中间节点的位置。</p><p>其中间节点不是中位或插值，而是位于黄金分割点附近。</p><p><font color="#0F0300">…</font><font color="#AF4600">…</font><font color="#CFAF00">是</font><font color="#FFCF00">黄金</font><font color="#DFAF00">分</font><font color="#CF8C00">割</font><font color="#CF0F00">，</font><font color="#BF6900">真</font><font color="#AF4600">好</font><font color="#0F2300">呀！</font></p><h2 id="排序算法">5.4 排序算法</h2><blockquote><p>排序也叫排序算法。是将一组数据，依指定的顺序进行排列的过程</p></blockquote><p>排序分为两类：</p><ul><li><p>内部排序：将所有要处理的数据加载到内部存储器中进行排序</p><p>内部排序主要有以下几种：</p><ul><li>插入排序：直接插入排序、希儿排序</li><li>选择排序：简单选择排序、堆排序</li><li>交换排序：冒泡排序、快速排序</li><li>归并排序</li><li>基数排序</li></ul></li><li><p>外部排序：数据量庞大，无法全部加载到内存中，需要借助外部存储进行排序</p><p>如：合并排序法、直接合并排序法</p></li></ul><h4 id="排序算法的时间复杂度">排序算法的时间复杂度：</h4><table><tr><th>排序法</th><th>平均时间</th><th>最差情形</th><th>稳定性</th><th>额外空间</th><th>说明</th></tr><tr><th>冒泡排序</th><td>O(n<sup>2</sup>)</td><td>O(n<sup>2</sup>)</td><td>稳定</td><td>O(1)</td><td>n 小时较好</td></tr><tr><th>交换排序</th><td>O(n<sup>2</sup>)</td><td>O(n<sup>2</sup>)</td><td>不稳定</td><td>O(1)</td><td>n 小时较好</td></tr><tr><th>选择排序</th><td>O(n<sup>2</sup>)</td><td>O(n<sup>2</sup>)</td><td>不稳定</td><td>O(1)</td><td>n 小时较好</td></tr><tr><th>插入排序</th><td>O(n<sup>2</sup>)</td><td>O(n<sup>2</sup>)</td><td>稳定</td><td>O(1)</td><td>大部分已排序时较好</td></tr><tr><th>基数排序</th><td>O(n × k)</td><td>O(n × k)</td><td>稳定</td><td>O(n)</td><td>k 是 “桶” 的个数</td></tr><tr><th>Shell 排序</th><td>O(n㏒<sub>2</sub>n)</td><td>O(n㏒<sub>2</sub><sup>2</sup>n)</td><td>不稳定</td><td>O(1)</td><td>n 大时较好</td></tr><tr><th>快速排序</th><td>O(n㏒<sub>2</sub>n)</td><td>O(n<sup>2</sup>)</td><td>不稳定</td><td>O(n㏒n)</td><td>n 大时较好</td></tr><tr><th>归并排序</th><td>O(n㏒<sub>2</sub>n)</td><td>O(n㏒<sub>2</sub>n)</td><td>稳定</td><td>O(1)</td><td>n 小时较好</td></tr><tr><th>堆排序</th><td>O(n㏒<sub>2</sub>n)</td><td>O(n㏒<sub>2</sub>n)</td><td>不稳定</td><td>O(1)</td><td>n 大时较好</td></tr></table><p><strong>稳定性：</strong>排序后，那些原本相等元素的相对顺序不改变</p><p><strong><em>—— 时间复杂度，见 [26.1.1 时间复杂度]</em></strong></p><h3 id="冒泡排序">5.4.1 冒泡排序</h3><p><strong>冒泡排序：</strong>通过对<font color="#10ACAF">待排序序列</font>从后向前遍历，依次比较相邻元素的值。若发现<font color="#FF5A0F">逆序</font> 则交换。</p><pre><code class=" mermaid">graph LRa(待排序序列)--&gt;b[遍历]--&gt;e((元素))--&gt;B(序列)e--比前一个元素小--&gt;c[交换]--&gt;BB--有未确定的值--&gt;bB--&gt;F(有序序列)</code></pre><p>如此，各元素不断接近自己的位置。<font color="#FF5A0F">值较大的元素逐渐向后移动</font>，就像水下的气泡一样逐渐上浮。</p><p>特别地：如果在某次排序中没有发生过任何交换，则此时是已完成排序，可提前结束排序过程。</p><iframe src="//player.bilibili.com/player.html?aid=641228181&amp;bvid=BV1CY4y1t7TZ&amp;cid=588760371&amp;page=2" scrolling="no" width="600" height="600"></iframe><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bubble_sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span> &#123;    <span class="hljs-comment">/* 共执行 n - 1 轮排序 */</span>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; count &lt; array.length; count++)&#123;        <span class="hljs-type">boolean</span> <span class="hljs-variable">non_exchange</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">// 该轮排序进行了交换时变为 false</span>        <span class="hljs-comment">/* 每轮遍历 n - count 次 */</span>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; n &lt; array.length - count; n++)&#123;            <span class="hljs-comment">/* 当比较时，如果逆序，则交换 */</span>            <span class="hljs-keyword">if</span>(array[n] &gt; array[n + <span class="hljs-number">1</span>])&#123;                non_exchange = <span class="hljs-literal">false</span>;                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> array[n + <span class="hljs-number">1</span>];                array[n + <span class="hljs-number">1</span>] = array[n];                array[n] = temp;            &#125;        &#125;        <span class="hljs-comment">/* 如果没有交换过，则提前结束排序过程 */</span>        <span class="hljs-keyword">if</span> (non_exchange) <span class="hljs-keyword">break</span>;    &#125;&#125;</code></pre></div><p>如果有 n 个元素，就进行 n - 1 轮排序，第 k 轮排序比较 n - k个元素，并进行最多 n - k 次交换。时间复杂度为 O(n<sup>2</sup>)</p><p class="note note-info">对随机数组 int[] array（array.length = 80000；array[i] ∊ [0,10<sup>7</sup>)）进行冒泡排序。<br/>那个统计时间是：6416 ms</p><h3 id="选择排序">5.4.2 选择排序</h3><p><strong>选择排序：</strong>从 <font color="#10ACAF">待排序序列</font>中，按指定规则选出某一元素，再依照规定交换位置后达到排序目的。</p><pre><code class=" mermaid">graph LRA(待排序序列)--&gt;S[遍历查找]--&gt;e((最小元素))--&gt;D[与首位交换]--&gt;oo--为空--&gt;F(有序序列)o(剩余序列)--不为空--&gt;S</code></pre><p>从 <font color="#10ACAF">待排序序列</font> 中找出<font color="#6AAF0F">最小值</font>，与下标 0 位置元素<font color="#FF5A0F">交换</font>。之后在剩余元素中找出<font color="#6AAF0F">最小值</font>，与下标 1 元素<font color="#FF5A0F">交换</font>。以此类推，直到完成。</p><iframe src="//player.bilibili.com/player.html?aid=641228181&amp;bvid=BV1CY4y1t7TZ&amp;cid=588760371&amp;page=3" scrolling="no" width="600" height="600"></iframe><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">choice_sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span> &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; p &lt; array.length - <span class="hljs-number">1</span>; p++) &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">min_index</span> <span class="hljs-operator">=</span> p;<span class="hljs-comment">// loc 指向那个当前找到的最小值的下标</span>        <span class="hljs-comment">/* 找出当前剩余元素中的最小值 */</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> p + <span class="hljs-number">1</span>; n &lt; array.length; n++) &#123;            <span class="hljs-keyword">if</span> (array[n] &lt; array[min_index]) min_index = n;        &#125;        <span class="hljs-comment">/* 将找到的最小值与对应位置元素交换 */</span>        <span class="hljs-keyword">if</span> (min_index != p) &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> array[min_index];            array[min_index] = array[p];            array[p] = temp;        &#125;    &#125;&#125;</code></pre></div><p>如果有 n 个元素，就进行 n - 1 轮排序，第 k 轮排序比较 n - k个元素，并进行 1 次交换。时间复杂度为 O(n<sup>2</sup>)</p><p class="note note-info">对随机数组 int[] array（array.length = 80000；array[i] ∊ [0,10<sup>7</sup>)）进行选择排序。<br/>那个统计时间是：1616 ms</p><h3 id="插入排序">5.4.3 插入排序</h3><p><strong>插入排序：</strong>在 <font color="#10ACAF">待排序序列</font>中的元素，以插入的方式找寻该元素的适当位置，以达到排序目的。</p><pre><code class=" mermaid">graph LRa(待排序序列)--首元素--&gt;O(有序表).-&gt;F(有序列表)a--其他元素--&gt;N(无序表)N--&gt;G((取出元素))--&gt;i[插入]--&gt;Oi-.无序表不为空.-&gt;N</code></pre><p>将 <font color="#10ACAF">待排序序列</font> 的元素视为一个<font color="#6AAF0F">有序表</font> 和一个<font color="#FF5A0F">无序表</font>。起初，<font color="#6AAF0F">有序表</font> 中只有一个元素，<font color="#FF5A0F">无序表</font> 中有 n - 1 个元素。</p><p>排序过程中每次从 <font color="#FF5A0F">无序表</font>中取出第一个元素，把它依次与 <font color="#6AAF0F">有序表</font>元素进行比较，确定其在 <font color="#6AAF0F">有序表</font>的位置，将其插入 <font color="#6AAF0F">有序表</font> ，成为新的<font color="#6AAF0F">有序表</font> 。</p><iframe src="//player.bilibili.com/player.html?aid=641228181&amp;bvid=BV1CY4y1t7TZ&amp;cid=588760371&amp;page=1" scrolling="no" width="600" height="600"></iframe><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert_sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span> &#123;    <span class="hljs-comment">/* 数组的前一部分视为有序表，后一部分视为无序表 */</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; p &lt; array.length; p++) &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> array[p];<span class="hljs-comment">// 那个 无序表首元素 的值</span>        <span class="hljs-type">int</span> <span class="hljs-variable">insertPos</span> <span class="hljs-operator">=</span> p;<span class="hljs-comment">// 那个 无序表首元素 在有序表的位置</span>                <span class="hljs-comment">/* 逆向遍历那个有序表，以确定该无序表首元素在有序表的位置。</span><span class="hljs-comment">        到达位置前，将有序表的插入位置后的元素后移 */</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> p - <span class="hljs-number">1</span>; n &gt;= <span class="hljs-number">0</span>; n--) &#123;            <span class="hljs-keyword">if</span> (array[n] &lt; temp) <span class="hljs-keyword">break</span>;            array[n + <span class="hljs-number">1</span>] = array[n];            insertPos--;        &#125;        <span class="hljs-comment">/* 将该元素插入指定位置 */</span>        array[insertPos] = temp;    &#125;&#125;</code></pre></div><p>如果有 n 个元素，就进行 n - 1 轮排序，第 k 轮排序需要进行 k次比较、移动或插入。时间复杂度为 O(n<sup>2</sup>)</p><p class="note note-info">对随机数组 int[] array（array.length = 80000；array[i] ∊ [0,10<sup>7</sup>)）进行插入排序。<br/>那个统计时间是：423 ms</p><h3 id="希儿排序">5.4.4 <font color="#0000FF">希儿</font>排序</h3><p><b><font color="#0000FF">希儿</font>排序：</b>是<font color="#0000FF">希儿</font>通过在量子之海中领悟事物的演变模式，于1959年提出的一种排序算法。<font color="#0000FF">希儿</font>真的很聪明！</p><pre><code class=" mermaid">graph LRA(待排序序列)--长度的一半--&gt;B((步长))B--&gt;D[分组]T--步长是 1--&gt;F(有序序列)D--&gt;d1((组1))--&gt;d11[插入排序]--&gt;T(序列)--&gt;t[步长减半]--&gt;BD--&gt;d2((组2))--&gt;d12[插入排序]--&gt;T(序列)D--&gt;d3((组3))--&gt;d13[插入排序]--&gt;T(序列)D--&gt;d4((...))--&gt;d141[插入排序]--&gt;T(序列)</code></pre><p><font color="#0000FF">希儿</font>排序也是一种插入排序，是简单插入排序的高效改进版。也称为：缩小增量排序。</p><p><font color="#0000FF">希儿</font>排序是把<font color="#10ACAF">待排序序列</font> 按下标的一定<font color="#FF5A0F">步长</font> 进行<font color="#6AAF0F">分组</font>，对每组使用 插入排序法。随着<font color="#FF5A0F">步长</font> 逐渐减少，每组包含的<font color="#6AAF0F">元素个数</font> 也越来越多。</p><p>当 <font color="#FF5A0F">步长</font> 减至 1 时，整个<font color="#10ACAF">待排序序列</font> 恰被分为 1 组，算法便中止。</p><iframe src="//player.bilibili.com/player.html?aid=641228181&amp;bvid=BV1CY4y1t7TZ&amp;cid=588760371&amp;page=20" scrolling="no" width="600" height="600"></iframe><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">seele_sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">step</span> <span class="hljs-operator">=</span> array.length / <span class="hljs-number">2</span>;<span class="hljs-comment">// 步长。该值等于分组数量</span>        <span class="hljs-comment">/* 初始将数组为 2 数一组，那么每组的步长就是 array.length / 2</span><span class="hljs-comment">    步长是那个分组中，相邻两个数的下标间隔。步长的值也等于组数</span><span class="hljs-comment">    直到那个分组大小等于原序列，也就是步长 == 1 时，进行最后一次排序 */</span>    <span class="hljs-keyword">while</span> (step &gt;= <span class="hljs-number">1</span>) &#123;                <span class="hljs-comment">/* 一共有 step 组，对每一组都进行一次完整的插入排序 */</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; group &lt; step; group++) &#123;                        <span class="hljs-comment">/* 每一组中，下一个元素的下标是：当前下标 + step</span><span class="hljs-comment">            每组的起始下标是 group，根据插入排序法，将每组视为有序表和无序表</span><span class="hljs-comment">            那个无序表从每组第二个元素开始计数，也就是下标 group + step */</span>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">toSort</span> <span class="hljs-operator">=</span> group + step; toSort &lt; array.length; toSort += step) &#123;                <span class="hljs-type">int</span> <span class="hljs-variable">insertPos</span> <span class="hljs-operator">=</span> toSort;                <span class="hljs-type">int</span> temp;                <span class="hljs-comment">/* 已经有序时直接 continue */</span>                <span class="hljs-keyword">if</span> ((temp = array[toSort]) &gt;= array[toSort - step]) <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">/* 寻找插入位置。在找到位置前，移动那些有序表元素 */</span>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">exPos</span> <span class="hljs-operator">=</span> toSort - step; exPos &gt;= group; exPos -= step) &#123;                        <span class="hljs-keyword">if</span> (array[exPos] &lt; temp) <span class="hljs-keyword">break</span>;                        array[exPos + step] = array[exPos];                        insertPos -= step;                    &#125;                <span class="hljs-comment">/* 执行插入 */</span>                array[insertPos] = temp;            &#125;        &#125;        <span class="hljs-comment">/* 每轮循环后，分组容量变为 2 倍，那么步长就会变为一半 */</span>        step /= <span class="hljs-number">2</span>;    &#125;&#125;</code></pre></div><p>如果有 n 个元素，就进行 ㏒<sub>2</sub>n 次排序。每轮排序最多进行 k*n次比较、移动或插入。因此，时间复杂度为 O(n㏒<sub>2</sub>n)</p><p class="note note-info">对随机数组 int[] array（array.length = 80000；array[i] ∊ [0,10<sup>7</sup>)）进行<font color="#0000FF">希儿</font>排序。<br/>那个统计时间是：11ms</p><h3 id="快速排序">5.4.5 快速排序</h3><p><strong>快速排序：</strong>是对冒泡排序的一种改进。通过一趟排序，将<font color="#10ACAF">待排序序列</font><font color="#6AAF0F">分割</font>成独立的两部分，其中一部分的所有数据都比另一部分小，再按此方法对这两部分数据<font color="#FF5A0F">分别进行快速排序</font>。</p><pre><code class=" mermaid">graph TDA(待排序序列) --取出一个元素--&gt; B[比较] B--&gt;Ba(较小元素序列)--取出一个元素--&gt;baa[比较]--&gt;baaa(较小元素序列)--取出一个元素--&gt;baaaa[比较]--&gt;k1((元素))baaaa[...]--&gt;k2((元素))baa--&gt;baab(较大元素序列)--取出一个元素--&gt;baaac[..]--&gt;k3((元素))baaac--&gt;k4((元素))B--&gt;Bb(较大元素序列)--取出一个元素--&gt;bab[比较]--&gt;baba(较小元素序列)--取出一个元素--&gt;baaad[...]--&gt;k5((元素))baaad--&gt;k6((元素))bab--&gt;babb(较大元素序列)--取出一个元素--&gt;baaae[...]--&gt;k7((元素))baaae--&gt;k8((元素))k1.-&gt;K(有序序列)k2.-&gt;Kk3.-&gt;Kk4.-&gt;Kk5.-&gt;Kk6.-&gt;Kk7.-&gt;Kk8.-&gt;K</code></pre><p>整个排序过程可以<font color="#FF5A0F">递归进行</font>，最终使整个数据变成有序序列。</p><iframe src="//player.bilibili.com/player.html?aid=641228181&amp;bvid=BV1CY4y1t7TZ&amp;cid=588760371&amp;page=13" scrolling="no" width="600" height="600"></iframe><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span> &#123;    quick_sort(array, <span class="hljs-number">0</span>, array.length);&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;    <span class="hljs-keyword">if</span> (start == end) <span class="hljs-keyword">return</span>;    <span class="hljs-type">int</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> array[end - <span class="hljs-number">1</span>];<span class="hljs-comment">// 将最后一个值取出作为比较值</span>    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> start;<span class="hljs-comment">// 左指针</span>    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> end;<span class="hljs-comment">// 右指针</span>    <span class="hljs-comment">/* 遍历指定区间，将那些较小值放到左侧，较大值放到右侧 */</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; r; ) &#123;        <span class="hljs-keyword">if</span> (array[i] &lt; key) &#123;            array[l++] = array[i];        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (array[i] &gt; key) &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> array[--r];            array[r] = array[i];            array[i] = temp;            <span class="hljs-keyword">continue</span>;        &#125;        i++;    &#125;    <span class="hljs-comment">/* key 值可能重复，那些左右指针间的空位置都是 key 值 */</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l; i &lt; r; i++) &#123;        array[i] = key;    &#125;    quick_sort(array, start, l);<span class="hljs-comment">// 对那个较小侧区间再进行快速排序</span>    quick_sort(array, r, end);<span class="hljs-comment">// 对那个较大测区间再进行快速排序</span>&#125;</code></pre></div><p>如果有 n 个元素，就进行 ㏒<sub>2</sub>n ~ n 次排序。第 k轮排序最多进行 2n - 2<sup>k - 1</sup>次比较、交换或插入。因此，时间复杂度为 O(n㏒<sub>2</sub>n)，最差情况为O(n<sup>2</sup>)</p><p class="note note-info">对随机数组 int[] array（array.length = 80000；array[i] ∊ [0,10<sup>7</sup>)）进行快速排序。<br/>那个统计时间是：16 ms</p><h3 id="归并排序">5.4.6 归并排序</h3><p><strong>归并排序：</strong>利用归并的思想实现的排序方法。该算法采用经典的分治策略（将问题分解成几个小问题，然后分而治之）。</p><pre><code class=" mermaid">graph TDA(待排序序列)--&gt;B[分解]B--&gt;b1((元素1))--&gt;ba[排序]--&gt;bb1((组1))--&gt;bba[合并]--&gt;bbb1((组1))--&gt;bbba[合并]--&gt;bbbb(有序序列)B--&gt;b2((元素2))--&gt;baB--&gt;b3((元素3))--&gt;ba2[排序]--&gt;bb2((组2))--&gt;bbaB--&gt;b4((元素4))--&gt;ba2B--&gt;b5((元素5))--&gt;ba3[排序]--&gt;bb3((组3))--&gt;bba2[合并]--&gt;bbb2((组2))--&gt;bbbaB--&gt;b6((元素6))--&gt;ba3B--&gt;b7((元素7))--&gt;ba4[排序]--&gt;bb4((组4))--&gt;bba2B--&gt;b8((元素8))--&gt;ba4</code></pre><p>对 2 个元素进行比较、排序，是很容易的。对 2个有序序列，将其合并为新的有序序列，也是容易的。</p><p>因此，我们把 <font color="#10ACAF">待排序序列</font> 分成许多<font color="#FF5A0F">组</font>，每组包含 2个元素，并对每组进行排序。再逐渐 <font color="#6AAF0F">合并</font>那些组，最终就能得到一个完整的有序序列。</p><iframe src="//player.bilibili.com/player.html?aid=641228181&amp;bvid=BV1CY4y1t7TZ&amp;cid=588760371&amp;page=4" scrolling="no" width="600" height="600"></iframe><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merger_sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">tl</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.ceil(array.length / <span class="hljs-number">2.0</span>);    <span class="hljs-type">int</span>[][] temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[tl][];    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; i += <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">if</span> (i == array.length) &#123;            <span class="hljs-keyword">if</span> (i == array.length + <span class="hljs-number">1</span>) temp[i / <span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;array[i - <span class="hljs-number">1</span>]&#125;;            <span class="hljs-keyword">break</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span> (array[i] &gt; array[i + <span class="hljs-number">1</span>]) &#123;                temp[i / <span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;array[i + <span class="hljs-number">1</span>], array[i]&#125;;            &#125; <span class="hljs-keyword">else</span> &#123;                temp[i / <span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;array[i], array[i + <span class="hljs-number">1</span>]&#125;;            &#125;        &#125;    &#125;    <span class="hljs-keyword">while</span> (temp.length != <span class="hljs-number">1</span>) &#123;        temp = combine(temp);    &#125;    System.arraycopy(temp[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>, array, <span class="hljs-number">0</span>, array.length);&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] combine(<span class="hljs-type">int</span>[][] temp) &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">tl</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.ceil(temp.length / <span class="hljs-number">2.0</span>);    <span class="hljs-type">int</span>[][] tt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[tl][];    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; tt.length; i++) &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">tp</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * i;        <span class="hljs-keyword">if</span> (tp + <span class="hljs-number">1</span> &gt;= temp.length) tt[i] = temp[tp];        <span class="hljs-keyword">else</span> tt[i] = combine(temp[tp], temp[tp + <span class="hljs-number">1</span>]);    &#125;    <span class="hljs-keyword">return</span> tt;&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] combine(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span>[] b) &#123;    <span class="hljs-type">int</span>[] ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[a.length + b.length];    <span class="hljs-type">int</span> <span class="hljs-variable">ap</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> <span class="hljs-variable">bp</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> <span class="hljs-variable">rp</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;        <span class="hljs-keyword">if</span> (ap &gt;= a.length) &#123;            <span class="hljs-keyword">while</span> (bp &lt; b.length) &#123;                ret[rp++] = b[bp++];            &#125;            <span class="hljs-keyword">break</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bp &gt;= b.length) &#123;            <span class="hljs-keyword">while</span> (ap &lt; a.length) &#123;                ret[rp++] = a[ap++];            &#125;            <span class="hljs-keyword">break</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[ap] &gt; b[bp]) &#123;            ret[rp++] = b[bp++];        &#125; <span class="hljs-keyword">else</span> &#123;            ret[rp++] = a[ap++];        &#125;    &#125;    <span class="hljs-keyword">return</span> ret;&#125;</code></pre></div><p>如果有 n 个元素，就进行 ㏒<sub>2</sub>n ~ n 次排序。每轮排序最多进行2n 次比较或插入。因此，时间复杂度为 O(n㏒<sub>2</sub>n)</p><p class="note note-info">对随机数组 int[] array（array.length = 80000；array[i] ∊ [0,10<sup>7</sup>)）进行归并排序。<br/>那个统计时间是：15 ms</p><h3 id="基数排序">5.4.7 基数排序</h3><p><strong>基数排序：</strong>属于分配式排序（又称“桶排序”。顾名思义，通过键值各个位的值，将<font color="#10ACAF">待排序序列</font> 的元素分配至某些<font color="#FF5A0F">桶</font>中，达到排序的作用）。基数排序是经典的空间换时间的算法</p><pre><code class=" mermaid">graph TDA(待排序序列) --&gt; B&#123;第 k 轮&#125; --&gt; C[元素的第 k 位]C -.是 0--&gt; c0((桶0)).-&gt;D(新序列)C --是 1--&gt; c1((桶1)).-&gt;DC --是 2--&gt; c2((桶2)).-&gt;DC --是 3--&gt; c3((桶3)).-&gt;DC --是 4--&gt; c4((桶4)).-&gt;DC --是 5--&gt; c5((桶5)).-&gt;DC --是 6--&gt; c6((桶6)).-&gt;DC --是 7--&gt; c7((桶7)).-&gt;DC --是 8--&gt; c8((桶8)).-&gt;DC --是 9--&gt; c9((桶9)).-&gt;DD --&gt; F[序列的最大值]--小于 10&lt;sup&gt;k&lt;/sup&gt;--&gt;E(有序序列)F --大于等于 10&lt;sup&gt;k&lt;/sup&gt;--&gt; B</code></pre><p>基数排序法是桶排序的扩展。将整数<font color="#FF5A0F">按照位数切割成不同数字</font>，然后<font color="#6AAF0F">按照每个位数分别比较</font>。</p><p>该方法只能用于比较正数。你非要比较负数？咱也不说不行，你自己看着办吧</p><iframe src="//player.bilibili.com/player.html?aid=641228181&amp;bvid=BV1CY4y1t7TZ&amp;cid=588760371&amp;page=15" scrolling="no" width="600" height="600"></iframe><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">radix_sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span> &#123;    <span class="hljs-type">int</span>[][] bucket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>][array.length];    <span class="hljs-type">int</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;    <span class="hljs-type">int</span> <span class="hljs-variable">border</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span>;    <span class="hljs-type">int</span>[] p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;        <span class="hljs-type">boolean</span> <span class="hljs-variable">noMore</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i :array) &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> (i / sub) % <span class="hljs-number">10</span>;            bucket[pos][p[pos]++] = i;            <span class="hljs-keyword">if</span> (i &gt; border) noMore = <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span> (p[i] &gt; <span class="hljs-number">0</span>) &#123;                array[n++] = bucket[i][j++];                --p[i];            &#125;        &#125;        sub *= <span class="hljs-number">10</span>;        border = <span class="hljs-number">10</span> * sub - <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (noMore) <span class="hljs-keyword">break</span>;    &#125;&#125;</code></pre></div><p>根据那个最大数值的不同，需要进行 r 轮排序。每轮排序进行 3n次计算、插入。因此，时间复杂度是 O(n㏒<sub>R</sub>B)</p><p class="note note-info">对随机数组 int[] array（array.length = 80000；array[i] ∊ [0,10<sup>7</sup>)）进行基数排序。<br/>那个统计时间是：15 ms</p><h3 id="堆排序">5.4.8 堆排序</h3><p><strong>堆排序：</strong>利用 <strong>堆</strong>数据结构而设计的一种排序算法。堆排序是一种选择排序，也是一种不稳定排序。</p><p><strong>堆</strong> 是具有以下性质的二叉树：</p><ul><li><p>大顶堆：每个节点的值都大于等于其子节点的值</p><p>即，对于任意节点 arr[i] 都有 arr[i] &gt;= arr[2 * i + 1] 并且 arr[i]&gt;= arr[2 * i + 2]</p></li><li><p>小顶堆：每个节点的值都小于等于其子节点的值</p><p>即，对于任意节点 arr[i] 都有 arr[i] &lt;= arr[2 * i + 1] 并且 arr[i]&lt;= arr[2 * i + 2]</p><p><strong><em>——见 <ahref="../../../../../../2022/06/02/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/14%20%E6%A0%91/#14-1-1-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91">[14.1.1顺序存储二叉树]</a></em></strong></p></li></ul><pre><code class=" mermaid">graph LRA(待排序序列)--&gt;B[...]subgraph ...B[整理]endG --&gt; BB --&gt; C(堆)C --&gt; E&#123;唯一元素?&#125;E --是--&gt; F(有序序列)E --否--&gt; D((首尾交换))D --&gt; G(剩余元素)subgraph 整理 kk--&gt;b&#123;子节点更大&#125;kt--遍历结束--&gt;d(堆)k(当前序列)--&gt;kt[逆序遍历非叶节点]--继续遍历--&gt;kk((节点))b--否--&gt;ktb--是--&gt;c[与子节点交换]c--&gt;切换到子节点--&gt;kkend</code></pre><ol type="1"><li><p>将 <font color="#10ACAF">待排序序列</font> 构成一个<font color="#FF5A0F">大顶堆</font>（数组形式）</p><p>从最后一个非叶节点开始，从左至右，从下至上进行调整。</p><p>调整时如果乱序，则将子节点中较大方的值与该节点交换即可。交换后，那些子节点乱序的场合也要依次调整。</p><p>调整完成后，就得到了一个<font color="#FF5A0F">大顶堆</font>。</p></li><li><p>此时，堆顶元素即整个序列的最大值。将其<font color="#6AAF0F">与队列末尾元素交换</font>。</p></li><li><p>对剩余元素进行调整，使其恢复成<font color="#FF5A0F">大顶堆</font>。</p></li><li><p>重复上述步骤，就得到了有序序列。</p></li></ol><iframe src="//player.bilibili.com/player.html?aid=641228181&amp;bvid=BV1CY4y1t7TZ&amp;cid=588764772&amp;page=11" width="600" height="600" name="tar"></iframe><table><tr><td><a herf="//player.bilibili.com/player.html?aid=641228181&bvid=BV1CY4y1t7TZ&cid=588764772&page=08" target="tar">什么是堆</a></td><td><a herf="//player.bilibili.com/player.html?aid=641228181&bvid=BV1CY4y1t7TZ&cid=588764772&page=09" target="tar">生成大顶堆</a></td><td><a herf="//player.bilibili.com/player.html?aid=641228181&bvid=BV1CY4y1t7TZ&cid=588764772&page=10" target="tar">维护大顶堆</a></td><td><a herf="//player.bilibili.com/player.html?aid=641228181&bvid=BV1CY4y1t7TZ&cid=588764772&page=11" target="tar">堆排序</a></td></tr></table><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heap_sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> array.length;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> array.length / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;        heap_help(array, j, len);    &#125;    heap_swap(array, --len);    <span class="hljs-keyword">while</span> (len &gt; <span class="hljs-number">1</span>) &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">tar</span> <span class="hljs-operator">=</span> len;        <span class="hljs-keyword">while</span> (tar &gt; <span class="hljs-number">0</span>) &#123;            tar = (tar - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;            heap_help(array, tar, len);        &#125;        heap_swap(array, --len);    &#125;&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heap_help</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> tar, <span class="hljs-type">int</span> length)</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> array[tar];    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> tar * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>; i &lt; length; i = i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">if</span> (i &lt; length - <span class="hljs-number">1</span> &amp;&amp; array[i] &lt; array[i + <span class="hljs-number">1</span>]) i++;        <span class="hljs-keyword">if</span> (array[i] &gt; temp) &#123;            array[tar] = array[i];            tar = i;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">break</span>;        &#125;    &#125;    array[tar] = temp;&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heap_swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> index)</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> array[<span class="hljs-number">0</span>];    array[<span class="hljs-number">0</span>] = array[index];    array[index] = temp;&#125;</code></pre></div><p class="note note-info">对随机数组 int[] array（array.length = 80000；array[i] ∊ [0,10<sup>7</sup>)）进行堆排序。<br/>那个统计时间是：16 ms</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt;4 程序控制结构</title>
    <link href="/2021/11/24/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/4%20%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/"/>
    <url>/2021/11/24/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/4%20%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="程序控制结构">4 程序控制结构</h1><blockquote><p>程序运行的流程控制决定程序是如何执行的，是我们必须掌握的。主要分为：顺序控制、分支控制、循环控制。</p></blockquote><h2 id="顺序控制">4.1 顺序控制</h2><blockquote><p>程序从上到下逐行执行，中间没有任何判断和跳转（默认的控制顺序）</p><p>比如：Java 定义变量时采用合法的前向引用。</p></blockquote><pre><code class=" mermaid">graph LRA(A语句)--&gt;B(B语句)--&gt;C(C语句)--&gt;D(D语句)--&gt;E(...)</code></pre><p>语句：Java 中最小的执行单位。语句分为 单语句 和 复合语句。</p><ul><li><p>单语句：通常意义的一条语句。语句间以分号 <code>;</code>分隔。</p></li><li><p>复合语句：一对大括号括起来的语句组。也称为 “块”</p><p><div class="code-wrapper"><pre><code class="hljs java">&#123;    语句<span class="hljs-number">1</span>;     语句<span class="hljs-number">2</span>;    ...&#125;</code></pre></div></p><p>块中可以有多条语句。块后没有分号 <code>;</code></p></li></ul><h2 id="分支控制-if-else">4.2 分支控制 <code>if-else</code></h2><blockquote><p>让程序有选择的执行。主要分为：单分支控制、双分支控制</p></blockquote><h3 id="单分支控制">4.2.1 单分支控制</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (条件表达式) 语句;</code></pre></div><p>特别地，把代码块（复合语句）作为语句的场合也能这样写：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (条件表达式) &#123; 执行代码块;&#125;</code></pre></div><p>当条件表达式为 <code>ture</code>，就会执行<code>&#123;执行代码块;&#125;</code>；如果为 <code>false</code>则不执行。特别地：如果 <code>&#123;执行代码块;&#125;</code>中只有一条代码，也可以不写 <code>&#123; &#125;</code>（但还是建议写上）</p><h3 id="双分支控制">4.2.2 双分支控制</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (条件表达式) &#123; 执行代码块;&#125; <span class="hljs-keyword">else</span> &#123; 执行代码块<span class="hljs-number">2</span>;&#125;</code></pre></div><p>当条件表达式为 <code>ture</code>，就会执行<code>&#123;执行代码块1;&#125;</code>；如果为 <code>false</code> 则执行<code>&#123;执行代码块2;&#125;</code>。</p><h3 id="多分支控制">4.2.3 多分支控制</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (条件表达式) &#123; 执行代码块;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (条件表达式<span class="hljs-number">2</span>) &#123; 执行代码块<span class="hljs-number">2</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (条件表达式<span class="hljs-number">3</span>) &#123; 执行代码块<span class="hljs-number">3</span>;&#125;...<span class="hljs-keyword">else</span> &#123; 执行代码块n；&#125;</code></pre></div><p>特别地：多分支可以没有<code>else</code>。此时如果条件都不成立，则无执行入口</p><h3 id="嵌套分支">4.2.4 嵌套分支</h3><blockquote><p>在一个分支结构中又完整嵌套了另一个完整的分支结构。里面的分支称为内层分支，外面的分支称为外层分支。</p></blockquote><p>Java 规定，else 子句属于逻辑上距其最近，且没有匹配 else 的 if语句：</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) n++;<span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>) n++;<span class="hljs-keyword">else</span> n--;<span class="hljs-comment">//属于上面这个 if 语句</span></code></pre></div><p>这个场合，这个 else 语句属于上面的 <code>if (n &gt; 1)</code>这个语句</p></blockquote><p>要想改变那个匹配关系，要使用 <code>&#123; &#125;</code> 改变语句结构：</p><blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) &#123;    n++;<span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>) n++;  &#125; <span class="hljs-keyword">else</span> n--;</code></pre></div></blockquote><p><strong>规范：嵌套尽量不超过 3 层（可读性不好）</strong></p><h2 id="switch-分支结构">4.3 <code>switch</code> 分支结构</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">switch</span>(表达式)&#123;<span class="hljs-keyword">case</span> 常量<span class="hljs-number">1</span>:语句块<span class="hljs-number">1</span>;<span class="hljs-keyword">break</span>;<span class="hljs-comment">//break 语句可选</span><span class="hljs-keyword">case</span> 常量<span class="hljs-number">2</span>:语句块<span class="hljs-number">2</span>;<span class="hljs-keyword">break</span>;<span class="hljs-comment">//break 语句可选</span>...<span class="hljs-keyword">default</span>:<span class="hljs-comment">//default 语句可选</span><span class="hljs-keyword">default</span>语句块;<span class="hljs-keyword">break</span>;<span class="hljs-comment">//break 语句可选</span>&#125;</code></pre></div><ol type="1"><li><code>switch</code> 关键字，表示 switch 分支。</li><li><code>表达式</code> 对应一个值。<strong>该值必须是 int 或char</strong>（char 可以转化为 int）。是 byte 或 short 的场合，要提升为int。不允许 long、double 或 float</li><li><code>case 常量1;</code> 表示：当 <code>表达式</code> 的值等于<code>常量1</code> ，则执行 <code>语句块1</code>。</li><li><code>break;</code> 表示退出 switch 分支。</li><li>当 <code>表达式</code> 的值匹配 <code>常量1</code> ，则执行<code>语句块1</code>，如果不匹配，则继续匹配 <code>常量2</code>，以此类推。</li><li>如果全都不匹配，则执行 <code>default</code>。</li><li>如果不写 <code>break;</code>，则会发生<strong>穿透</strong>，即不进行判断而继续执行下一语句块。</li></ol><h3 id="使用细节">4.3.1 使用细节</h3><ol type="1"><li><p><code>表达式;</code> 数据类型，应和 <code>case</code> 后的<code>常量</code>类型一致，或者是可以自动转换成可以比较的类型。如：输入的是<code>char</code> 而 <code>常量</code> 是 <code>int</code></p></li><li><p>switch 中 <code>表达式</code> 的返回值必须是：<code>byte</code><code>short</code> <code>int</code> <code>char</code> <code>enum</code><code>String</code></p><p><strong><em>——<code>enum</code> 是什么？详见 <ahref="../../../../../../2021/12/17/Java/入门阶段/10%20%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3/#10-1-%E6%9E%9A%E4%B8%BE">[10.1枚举 ]</a></em></strong></p></li><li><p><code>case</code> 语句中的值必须是 常量 或 常量表达式，不能是变量。</p></li><li><p><code>default</code> 是可选的。没有就不执行。</p></li><li><p><code>break;</code> 用来跳出 switch分支。如果不写，会持续执行语句，直到分支结束或遇到下一个<code>break;</code></p></li></ol><h3 id="与-if-else-分支结构的取舍">4.3.2 与 <code>if-else</code>分支结构的取舍</h3><ul><li>如果判断的具体数值不多，且符合 <strong><em><ahref="../../../../../../2021/11/24/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/4%20%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/#4-3-1-%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82">[4.3.1.1]</a></em></strong>，推荐使用 switch。</li><li>对区间判断的场合，对结果为 boolean 类型的判断，使用<code>if-else</code>。</li></ul><h2 id="for-循环控制">4.4 <code>for</code> 循环控制</h2><blockquote><p>让代码可以循环执行。</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(循环变量初始化;循环条件;循环变量迭代)&#123;循环操作（代码块）;&#125;</code></pre></div><ul><li><p><code>for</code> 关键字，表示循环控制</p></li><li><p>四个要素：1. 循环变量初始化 2. 循环的条件 3. 循环的操作 4.循环变量迭代</p></li></ul><p>所有循环开始前仅一次进行初始化。直到循环条件变为 false前，执行循环操作。每轮循环结束后，进行循环变量迭代。</p><ul><li><p>循环操作可以有多条语句</p></li><li><p>如果循环操作只有一条语句，可以省略<code>" "</code>，但建议不省略</p></li></ul><h3 id="使用细节-1">4.4.1 使用细节</h3><ol type="1"><li><p>循环条件是返回一个 boolean 值（<code>ture</code> 或<code>false</code>）的公式。</p><p>循环条件可以为空。这个场合，默认为真（true）</p></li><li><p><code>for(;循环条件;)&#123; &#125;</code>其中的初始化和变量迭代可以写在别处，但 <code>;</code>不能省略。如果不写在别处，那个 <code>循环变量初始化</code>中声明的变量只能在该 for 循环中使用。</p></li><li><p>控制台用 ctrl + c 强制结束一个流程</p></li><li><p>循环初始值可以有多条初始化语句，但要求类型一样，并用<code>,</code> 隔开。</p><p>变量迭代也可以有多条代码，用 <code>,</code> 隔开。</p></li></ol><h3 id="for-each泛型-for-循环">4.4.2 for each（泛型 for 循环）</h3><blockquote><p>泛型 for 循环（增强 for循环）能用来依次处理数组（或其他元素集合）中的每个元素，而不必考虑下标值</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : nums)&#123;<span class="hljs-comment">//其中 nums 是一个一维 int 数组</span>System.out.println(i);&#125;</code></pre></div><p>上述写法（增强 <code>for</code> 写法）类似于以下写法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;System.out.println(nums[i]);&#125;</code></pre></div><p>泛型 for 循环适用于数组或一个实现了 Iterable 接口的对象。泛型 for循环的本质是一个 Iterator（迭代器）</p><p><strong><em>—— 迭代器，见 <ahref="../../../../../../2021/12/22/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/13%20%E9%9B%86%E5%90%88/#13-2-2-2-%E7%94%A8-enhanced-for-%E9%81%8D%E5%8E%86%E5%85%83%E7%B4%A0">[13.2.2.1用 Iterator 遍历元素]</a></em></strong></p><h2 id="while-循环控制">4.5 <code>while</code> 循环控制</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(循环条件)&#123; 循环体(代码块); 循环变量迭代;&#125;</code></pre></div><p><code>while</code> 也有四要素，只是位置和 <code>for</code> 不同</p><h3 id="使用细节-2">4.5.1 使用细节</h3><ol type="1"><li><p>循环条件是返回一个 boolean 值（<code>ture</code> 或<code>false</code>）的公式。</p><p>while 循环中，循环条件不能为空。</p></li><li><p><code>while</code> 循环是先判断再执行语句。</p></li></ol><h2 id="do..while-循环控制">4.6 <code>do..while</code> 循环控制</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">do</span>&#123;循环体;循环变量迭代;&#125;<span class="hljs-keyword">while</span>(循环条件);</code></pre></div><ol type="1"><li><code>do</code> <code>while</code> 是关键字</li><li>也有四要素，位置不同</li><li>先执行，再判断。也就是说，一定会至少执行一次</li><li><strong>最后有一个 <code>;</code></strong></li><li><code>while</code> 与 <code>do..while</code> 区别："要账"</li></ol><h3 id="使用细节-3">4.6.1 使用细节</h3><ol type="1"><li>循环条件是返回一个 boolean 值（<code>ture</code> 或<code>false</code>）的公式。</li><li><code>do..while</code>循环是先执行再判断的语句。因此至少执行一次。</li></ol><h2 id="多重循环控制">4.7 多重循环控制</h2><p>将一个循环放在另一个循环体内，就形成了嵌套循环。建议一般使用两层，最多不超过三层。</p><p>嵌套循环 是把 内层循环 当成 外层循环 的 循环体。只有内层<code>false</code> 时才可能结束当层循环。</p><p>若内层执行 n 次，外层 m 次，则合计会循环 n*m 次</p><blockquote><p>以下是一个示例（乘法口诀）</p><div class="code-wrapper"><pre><code class="hljs java">&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Code4_7</span>&#123;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;       <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//声明第一个乘数</span>       <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//声明第二个乘数</span>       <span class="hljs-keyword">do</span>&#123;           <span class="hljs-comment">//直到 a &gt; b 为止，a 不断增长，并让两数相乘，输出公式</span>           <span class="hljs-keyword">do</span>&#123;               System.out.print(a + <span class="hljs-string">&quot; * &quot;</span> + b + <span class="hljs-string">&quot; = &quot;</span> + a * b                + <span class="hljs-string">&quot;\t&quot;</span>);               a++;           &#125;<span class="hljs-keyword">while</span>(a &lt;= b);       <span class="hljs-comment">//把 a 重置为 1，让 b 增长，然后循环</span>       a = <span class="hljs-number">1</span>;       System.out.println();       b++;       &#125;<span class="hljs-keyword">while</span>(b &lt;= <span class="hljs-number">9</span>);   &#125;&gt;&#125;</code></pre></div></blockquote><h2 id="跳转控制语句">4.8 跳转控制语句</h2><blockquote><p>跳转控制语句用于分支或循环中，以便程序员更好控制程序执行方向</p></blockquote><h3 id="标签">4.8.1 标签</h3><div class="code-wrapper"><pre><code class="hljs java">a:&#123;b:&#123;c:&#123;   ... berak b;&#125;&#125;&#125;</code></pre></div><ol type="1"><li><code>a:</code> <code>b:</code> <code>c:</code>是标签，名字由程序员指定</li><li><code>break</code> 后指定哪个标签就退出到哪里</li><li><strong>实际开发中，尽量不要使用标签</strong></li></ol><h3 id="break">4.8.2 break</h3><blockquote><p>用于中止一个语句块的执行</p></blockquote><p>语法：<code>break;</code></p><p>break 可以被用在三种场合中</p><ul><li><p>switch 语句中，以跳出判断（结束穿透）</p></li><li><p>for、while、do...while 循环语句中，以跳出循环</p></li><li><p>语句块中，以跳过本块中所有剩余语句</p><p><code>break</code> 语句出现在多层嵌套的语句块中时，可以通过<strong>标签</strong> 指明要终止的时哪一层语句块。</p></li></ul><h3 id="continue">4.8.3 continue</h3><blockquote><p>在循环中出现。用于结束本次循环，继续下一次循环</p></blockquote><p>语法：<code>continue;</code></p><p>进行下次循环前，仍会判断循环条件是否满足</p><p>在多层嵌套循环中，可以通过标签指出跳出哪次循环（同<code>break</code>）</p><h3 id="return">4.8.4 return</h3><blockquote><p>用于方法。表示跳出所在的方法</p></blockquote><p>语法：<code>return;</code></p><p>方法有返回值的场合，将返回值写在 return后：<code>return 值;</code></p><p><strong><em>——见 <ahref="../../../../../../2021/11/29/Java/入门阶段/6%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/#6-2-%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95">[6.2成员方法]</a></em></strong></p><p>如果写在 主方法 则跳出程序</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt;3 运算符</title>
    <link href="/2021/11/23/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/3%20%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/2021/11/23/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/3%20%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="运算符">3 运算符</h1><blockquote><p>运算符：一种特殊的符号，用于表示数据的运算、赋值和比较等。</p></blockquote><h2 id="算数运算符">3.1 算数运算符</h2><blockquote><p>算术运算符是对数值类型的变量进行运算的运算符，在 Java程序中使用得非常多。其运算结果是一个数值量。</p></blockquote><ul><li><p><code>+</code> ; <code>-</code> ; <code>*</code> ; <code>/</code>：加（正）、减（负）、乘、除</p><blockquote><p><code>5 / 2 = 2;</code> 因为是 <code>int</code>。同理<code>5.0 / 2 = 2.5</code></p></blockquote></li><li><p><code>%</code> ：取模（求余数），结果和被取模数同号。其实<code>a % b == a - (int)a / b * b;</code></p><blockquote><p><code>11 % 9 = 2;</code></p><p><code>-11 % 9 = -2;</code></p><p><code>11 % -9 = 2;</code></p><p><code>-11 % -9 = -2;</code></p></blockquote></li><li><p><code>++</code> ：自增。</p><p><code>++i</code> 先自增后赋值；<code>i++</code> 先赋值后自增</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> ++i; <span class="hljs-comment">//等价于 i = i + 1; j = i; 此时 i = 10; j = 10`</span><span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i++; <span class="hljs-comment">//等价于 k = i; i = i + 1; 此时 i = 11; k = 10`</span>i = i++; <span class="hljs-comment">//系统会先后执行 int temp = i;     i = i + 1;     i = temp</span>i = ++i; <span class="hljs-comment">//系统会先后执行 i = i + 1;     int temp = i;     i = temp</span></code></pre></div></li><li><p><code>--</code> ：自减。和 <code>++</code> 同理。</p></li><li><p><code>+</code> ：字符串相加</p></li></ul><h2 id="关系运算符比较运算符">3.2 关系运算符（比较运算符）</h2><blockquote><p>关系运算符结果都为 <code>boolean</code> 型，要么是 <code>ture</code>要么是 <code>false</code>。其关系表达式经常用在 <code>if</code>结构的条件中或循环结构的条件中。</p></blockquote><ul><li><code>==</code> ：相等于。<code>8 == 7</code> 结果<code>false</code></li><li><code>!=</code> ：不等于</li><li><code>&lt;</code> <code>&gt;</code> ：小于、大于</li><li><code>&lt;=</code> <code>&gt;=</code> ：小于等于、大于等于</li><li><code>instanceof</code>：检查是否是类的对象。<code>"a" istanceof String</code> 结果<code>ture</code></li></ul><h3 id="使用细节">3.2.1 使用细节</h3><ol type="1"><li>关系运算符结果都是 <code>boolean</code> 型，要么是 <code>ture</code>，要么是 <code>false</code></li><li>关系运算符的表达式，称为<em>关系表达式</em></li><li>比较运算符 <code>==</code> 不要误写为 <code>=</code></li><li>Java 允许将 <code>==</code>、<code>!=</code>两种运算用于任何数据类型</li></ol><h2 id="逻辑运算符">3.3 逻辑运算符</h2><blockquote><p>用于连接多个条件（多个关系表达式），最终的结果也是一个<code>boolean</code> 值。</p></blockquote><ul><li><p><code>&amp;&amp;</code> ：短路与。<code>a</code> <code>b</code>同时为 <code>ture</code>，则结果为 <code>ture</code>，否则为<code>false</code>。</p></li><li><p><code>&amp;</code> ：逻辑与。<code>a</code> <code>b</code> 同时为<code>ture</code>，则结果为 <code>ture</code>，否则为<code>false</code>。</p><p><code>&amp;&amp;</code> 与 <code>&amp;</code> 的区别，在于<code>a &amp;&amp; b</code> 的场合，<code>a = false</code> 时，则<code>b</code> 不判断。而 <code>&amp;</code> 会完成判断。开发中多用<code>&amp;&amp;</code> ，因为其效率更高。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (a++ &gt; <span class="hljs-number">1</span> &amp;&amp; ++b &lt; <span class="hljs-number">1</span>) System.out.println(<span class="hljs-string">&quot;Nothing happened&quot;</span>);<span class="hljs-comment">/*</span><span class="hljs-comment">此时 a 经历了先判断后自增，返回 false 并且 a = 2</span><span class="hljs-comment">但此时 b = 1; 因为 a = false; 所以 ++b 不执行。</span><span class="hljs-comment">*/</span></code></pre></div></li><li><p><code>||</code> ：短路或。<code>a</code> <code>b</code> 任一为<code>ture</code>，则结果为 <code>ture</code>，否则为<code>false</code>。</p></li><li><p><code>|</code> ：逻辑或。<code>a</code> <code>b</code> 任一为<code>ture</code>，则结果为 <code>ture</code>，否则为<code>false</code>。</p><blockquote><p>两者的区别和<code>&amp;&amp;</code> 与 <code>&amp;</code>相似，若第一个为 <code>ture</code> ，则 <code>||</code>不会判断第二个。</p></blockquote></li><li><p><code>!</code> ：取反。<code>a</code> 为<code>ture</code>，则结果为 <code>false</code>。反之为<code>ture</code>。</p></li><li><p><code>^</code>：逻辑异或。<code>a</code> <code>b</code>不同时，结果为 <code>ture</code>，否则为 <code>false</code>。</p></li></ul><h2 id="赋值运算符">3.4 赋值运算符</h2><blockquote><p>将某个运算后的值，赋给指定变量</p></blockquote><ul><li><p>基本赋值运算符：<code>=</code></p></li><li><p>符合赋值运算符：<code>+=</code> ; <code>-=</code> ;<code>*=</code> ; <code>/=</code> ; <code>%=</code> 等</p><blockquote><p><code>a += b</code> 等价于 <code>a = a + b</code>。其余同理。</p></blockquote></li></ul><h3 id="使用细节-1">3.4.1 使用细节</h3><ol type="1"><li><p>运算顺序从右往左。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> a + b + c;<span class="hljs-comment">// 先运行(a + b + c)，再结算int num =</span></code></pre></div></li><li><p>运算符左边只能是变量，右边可以是变量、表达式、常量值。</p></li><li><p>复合赋值运算符会进行类型转换。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; b += <span class="hljs-number">3</span>;<span class="hljs-comment">// 此时 b += 3 等价于 b = (byte)(b + 3)</span>b++;<span class="hljs-comment">// 同理</span></code></pre></div></li></ol><h2 id="三元运算符">3.5 三元运算符</h2><blockquote><p>基本语法：<code>条件表达式 ? 表达式1 : 表达式2;</code></p><p>运算规则：如果条件表达式为 <code>ture</code>，运算的结果是表达式1；反之为表达式2。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">11</span>;<span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (a == b ? a++ : b++);<span class="hljs-comment">// 此时 a = 10  result = 11  b = 12</span></code></pre></div></blockquote><h3 id="使用细节-2">3.5.1 使用细节</h3><ol type="1"><li><p>表达式1 和 表达式2要为可以赋给接受变量的类型（或可以自动转换，或进行强制转换）</p></li><li><p>三元运算符可以转成 <code>if--else</code></p></li><li><p>三元运算符是一个整体。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">1</span>) : <span class="hljs-keyword">new</span> <span class="hljs-title class_">Double</span>(<span class="hljs-number">2.2</span>);System.out.print(obj)</code></pre></div><p>上例中，系统将会输出 <code>1.0</code></p><p>因为 三元运算符 是一个整体，所以根据 [2.8.1.1.1]发生了类型转换。</p></li></ol><h2 id="运算符优先级">3.6 运算符优先级</h2><p><a href="http://c.biancheng.net/view/794.html"title="百度搜的，你去百度也行">一个网页，可以查看详细优先级</a></p><table><thead><tr class="header"><th>运算符（优先级从高到低）</th><th>结核性</th></tr></thead><tbody><tr class="odd"><td><code>[]</code>、<code>()</code> 方法调用</td><td>从左向右</td></tr><tr class="even"><td><code>!</code>、<code>~</code>、<code>++</code>、<code>--</code>、<code>+</code>（一元运算）、<code>-</code>（一元运算）、强制类型转换、new</td><td>从右向左</td></tr><tr class="odd"><td><code>*</code>、<code>/</code>、<code>%</code></td><td>从左向右</td></tr><tr class="even"><td><code>+</code>、<code>-</code></td><td>从左向右</td></tr><tr class="odd"><td><code>&lt;&lt;</code>、<code>&gt;&gt;</code>、<code>&gt;&gt;&gt;</code></td><td>从左向右</td></tr><tr class="even"><td><code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code>、instanceof</td><td>从左向右</td></tr><tr class="odd"><td><code>==</code>、<code>!=</code></td><td>从左向右</td></tr><tr class="even"><td><code>&amp;</code></td><td>从左向右</td></tr><tr class="odd"><td><code>^</code></td><td>从左向右</td></tr><tr class="even"><td><code>|</code></td><td>从左向右</td></tr><tr class="odd"><td><code>&amp;&amp;</code></td><td>从左向右</td></tr><tr class="even"><td><code>||</code></td><td>从左向右</td></tr><tr class="odd"><td><code>?:</code>（三元运算符）</td><td>从右向左</td></tr><tr class="even"><td><code>=</code>、<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>&amp;=</code>、<code>%=</code>、<code>^=</code>、<code>|=</code>、<code>&lt;&lt;=</code>、<code>&gt;&gt;=</code>、<code>&gt;&gt;&gt;=</code></td><td>从右向左</td></tr></tbody></table><ol type="1"><li>运算符有不同优先级。优先级高的总是优先于低的。</li><li>只有单目运算符、赋值运算符是从右向左运算的。</li></ol><h2 id="标识符">3.7 标识符</h2><blockquote><p>Java 对各种变量、方法和类等命名时使用的字符序列称为标识符</p><p>凡是自己可以起名字的地方都叫标识符<code>double height = 0.0;</code></p></blockquote><h3 id="命名规则">3.7.1 命名规则</h3><ol type="1"><li><p>标识符由 26 个大、小写英文字母，0 - 9 阿拉伯数字，_ 或 $符号组成。</p></li><li><p><strong>数字不能开头</strong>。错误示范：<code>int 3a = 1;</code></p></li><li><p>不能使用关键字和保留字（可以包含）。<a href="www.baidu.com"title="百度一下，你就知道。">具体的关键字和保留字请自行查询</a></p></li><li><p>严格区分大小写，长度无限制。</p></li><li><p>不能包含空格。</p></li><li><p>与多数编程语言不同。Java 可以用任何 Unicode字符（特殊字符除外）作为标识符。但不推荐这么做</p><blockquote><p><font face=等线 color=#00AFFA><strong>来 String一只猫：</strong></font></p></blockquote><div class="code-wrapper"><pre><code class="hljs java">String ᓚᘏᗢ = <span class="hljs-string">&quot;✪ ω ✪&quot;</span>;<span class="hljs-comment">// 喵？</span></code></pre></div></li></ol><h3 id="命名规范">3.7.2 命名规范</h3><ol type="1"><li>包名：多单词组成时所有字母都小写：aaa.bbb.ccc</li><li>类名、接口名：多单词组成时，采用大驼峰法，所有单词的首字母大写：XxxYyyZzz</li><li>变量名、方法名：多单词组成时，采小驼峰法（驼峰法），第一个单词首字母小写，第二个开始每个单词首字母大写：xxxYyyZzz</li><li>常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ</li><li>更详细的规则查看 <ahref="https://developer.aliyun.com/article/709470"title="直接百度也行">Java 编码规范</a></li></ol><h2 id="输入与输出">3.8 输入与输出</h2><blockquote><p>为满足读取用户输入、输出的需求，Java 提供了几个基本类</p></blockquote><h3 id="scanner-类">3.8.1 Scanner 类</h3><blockquote><p>在编程中，需要接收用户输入的数据，就可以使用键盘输入语句来获取。</p><p><code>Input.java</code> ，需要一个 扫描器（对象），就是 Scanner</p><p>Scanner 属于 java.util 包。其包含许多方法</p></blockquote><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-comment">//[1] 导入</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Code3_8_1</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;    <span class="hljs-type">Scanner</span> <span class="hljs-variable">aScannerName</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<span class="hljs-comment">//[2] 创建 Scanner 对象</span>    System.out.println(<span class="hljs-string">&quot;\n输入点什么吧！&quot;</span>);    <span class="hljs-type">String</span> <span class="hljs-variable">pointSomething</span> <span class="hljs-operator">=</span> aScannerName.next();<span class="hljs-comment">//[3] 接收用户输入</span>    System.out.println(<span class="hljs-string">&quot;\n接下来，输入一个数字吧！&quot;</span>);    <span class="hljs-type">double</span> <span class="hljs-variable">aNumber</span> <span class="hljs-operator">=</span> aScannerName.nextDouble();<span class="hljs-comment">//[3] 接收用户输入</span>    System.out.println(<span class="hljs-string">&quot;\n你输入的\&quot;点什么\&quot;是:\&quot;&quot;</span>     + pointSomething + <span class="hljs-string">&quot;\&quot;\n你输入的\&quot;一个数字\&quot;是：\&quot;&quot;</span>     + aNumber + <span class="hljs-string">&quot;\&quot;&quot;</span>);    &#125;&#125;</code></pre></div><blockquote><ol type="1"><li>导入该类所在的包</li><li>创建该类对象（声明变量）</li><li>调用里面的功能，接收用户输入</li></ol></blockquote><p>构造方法：</p><ul><li><p><code>new Scanner(System.in)</code>：该方法接收一个参数（输入源）。其中<code>System.in</code> 代表标准输入流。默认情况指键盘。</p><p><strong><em>—— 见 <ahref="../../../../../../2022/01/06/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/17%20IO%E6%B5%81/#17-2-3-4-%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5-x2F-%E8%BE%93%E5%87%BA%E6%B5%81">[17.2.3.4标准输入 / 输出流]</a></em></strong></p></li></ul><p>常用方法：</p><ul><li><p><code>String next()</code>：读取下一个输入对象</p><p>Scanner对象用空白（空格、水平制表符或回车换行符）作为输入的分隔元素</p></li><li><p><code>Double nextDouble()</code>：读取下一个 double</p><p><code>Int nextInt()</code>：读取下一个 int</p></li><li><p><code>String nextLine()</code>：读入当前行的所有输入，直到行尾</p></li><li><p><code>boolean hasNext()</code>：输入中是否还有其他单词</p><p><code>boolean hasNextInt()</code>、<code>boolean hasNextDouble()</code></p></li></ul><h3 id="格式化输出">3.8.2 格式化输出</h3><blockquote><p>System.out 标准输出流。调用该流方法以输出内容至控制台窗口</p></blockquote><ul><li><p><code>println(String s)</code>：输出字符，结束后换行</p><p><code>print(String s)</code>：输出字符，结束后不换行</p><p><code>println(int n)</code>、<code>println(char c)</code>、<code>println(Object obj)</code>……</p></li><li><p><code>printf(String format, Object ... args)</code>：格式化输出</p><div class="code-wrapper"><pre><code class="hljs JAVA">System.out.printf(<span class="hljs-string">&quot;%s，你来啦，给你 %d 拳&quot;</span>, <span class="hljs-string">&quot;柏枝凪斗&quot;</span>, <span class="hljs-number">1</span>);<span class="hljs-comment">// &lt;———— 给了柏枝凪斗一拳</span></code></pre></div><p>以 % 开头的 <em>格式说明符</em>都用相应参数替换。格式说明符尾部的转换符表示要格式化的数值类型</p><table><thead><tr class="header"><th>转换符</th><th>类型</th><th style="text-align: center;"></th><th>转换符</th><th>类型</th></tr></thead><tbody><tr class="odd"><td>d</td><td>十进制整数</td><td style="text-align: center;"></td><td>s</td><td>字符串</td></tr><tr class="even"><td>x</td><td>十六进制整数</td><td style="text-align: center;"></td><td>c</td><td>字符</td></tr><tr class="odd"><td>o</td><td>八进制整数</td><td style="text-align: center;"></td><td>b</td><td>布尔值</td></tr><tr class="even"><td>f</td><td>定点浮点数</td><td style="text-align: center;"></td><td>h</td><td>散列码</td></tr><tr class="odd"><td>e</td><td>指数浮点数</td><td style="text-align: center;"></td><td>tx 或 Tx</td><td>日期时间（T强制大写）</td></tr><tr class="even"><td>g</td><td>通用浮点数</td><td style="text-align: center;"></td><td>%</td><td>百分号</td></tr><tr class="odd"><td>a</td><td>十六进制浮点数</td><td style="text-align: center;"></td><td>n</td><td>行分隔符</td></tr></tbody></table><p>也能指定控制格式化输出外观的各种标志</p><div class="code-wrapper"><pre><code class="hljs java">System.out.printf(<span class="hljs-string">&quot;% (4.12f&quot;</span>, Math.PI);<span class="hljs-comment">// &lt;————— 保留 12 位，正数添加空格，负数添加括号</span></code></pre></div><table><thead><tr class="header"><th>标志</th><th>目的</th></tr></thead><tbody><tr class="odd"><td>+</td><td>打印正数和负数的符号</td></tr><tr class="even"><td>（空格）</td><td>在正数前添加空格</td></tr><tr class="odd"><td>0</td><td>数字前面补 0</td></tr><tr class="even"><td>-</td><td>左对齐</td></tr><tr class="odd"><td>(</td><td>负号被括号环绕</td></tr><tr class="even"><td>,</td><td>添加分组分隔符</td></tr><tr class="odd"><td>#（对于 f 格式）</td><td>包含小数点</td></tr><tr class="even"><td>#（对于 x 或 0 格式）</td><td>添加前缀 0x 或 0</td></tr><tr class="odd"><td>$</td><td>指定要格式化的参数索引：%1$d 以十进制打印第 1 个参数</td></tr><tr class="even"><td>&lt;</td><td>格式化前面说明的数值：%d%&lt;x十进制打印后，再以十六进制打印一遍</td></tr></tbody></table></li></ul><h3 id="numberformat-类">3.8.3 NumberFormat 类</h3><blockquote><p>Java 提供的格式化输出功能，能使打印或显示是信息更美观</p><p>NumberFormat 类属于 Java 标准类库，在 java.text 包中</p><p>NumberFormat类不能直接创建对象。利用类中的静态方法获取一个对象实例</p></blockquote><p>获取实例：</p><ul><li><code>NumberFormat.getInstance()</code>：返回当前默认语言环境的默认数值格式</li><li><code>NumberFormat.getCurrnecyInstance()</code>：返回当前默认语言环境的通用格式</li><li><code>NumberFormat.getNumberInstance()</code>：返回当前默认语言环境的通用数值格式</li><li><code>NumberFormat.getPercentInstance()</code>：返回当前默认语言环境的百分比格式</li></ul><p>常用方法：</p><ul><li><p><code>format(num)</code>：获取 num 的格式化语句</p></li><li><p><code>setMaximunFactionDigits(n)</code>：将该格式的小数部分允许的最大位数设置为n</p><p><code>setMinimunFactionDigits(n)</code>：将该格式的小数部分允许的最小位数设置为n</p></li><li><p><code>setMaximunIntegerDigits(n)</code>：将该格式的整数部分允许的最大位数设置为n</p><p><code>setMinimunIntegerDigits(n)</code>：将该格式的整数部分允许的最小位数设置为n</p></li></ul><h3 id="decimalformat-类">3.8.4 DecimalFormat 类</h3><blockquote><p>与 NumberFormat 类不同，DecimalFormat 类可以直接实例化对象。</p></blockquote><p>实例化：</p><ul><li><p><code>new DecimalFormat(pattern)</code></p><p>其中 pattern 是一个 String，代表格式化处理模式。如</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">DecimalFormat</span> <span class="hljs-variable">df</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DecimalFormat</span>(<span class="hljs-string">&quot;0.###&quot;</span>);<span class="hljs-comment">//格式对象，保留 3 位小数</span></code></pre></div></li></ul><p>常用方法：</p><ul><li><code>format(num)</code>：获取 num 的格式化语句</li><li><code>applyPattern(pattern)</code>：变更要使用的格式</li></ul><h2 id="进制">3.9 进制</h2><ul><li>二进制：数字有 0 - 1，满 2 进 1，以 <code>0b</code> 或<code>0B</code> 开头</li><li>十进制</li><li>八进制：0 - 7，满 8 进 1，以 <code>0</code> 开头表示</li><li>十六进制：0 - 9 及 A - F，满 16 进 1，以<code>0x</code> 或<code>0X</code> 开头。此处的 A - F 不分大小写。</li></ul><h3 id="进制的转换">3.9.1 进制的转换</h3><ul><li>其他进制 转 十进制：略</li><li>十进制 转其他进制：将该数不断除以对象进制数，直到商为0为止，将每步得到的余数倒过来。</li><li>二进制 与 八进制 或 十六进制 互相转换：二进制 从低位开始，每 3位一组，转成对应的 八进制 即可。反之同理。十六进制亦同理（每 4位一组）。</li></ul><h3 id="原码反码补码">3.9.2 原码、反码、补码</h3><p>对于有符号数而言：</p><ol type="1"><li>二进制的最高位是符号位：0表示正数，1表示负数。</li><li>正数的原码、反码、补码都一样。</li><li>负数的反码 = 原码符号位不变，其他位取反（0 变 1，1 变 0）</li><li><strong>负数的补码 = 反码 + 1。也就是说，负数的反码 = 补码 -1。</strong></li><li>0 的反码、补码都是 0。</li><li>Java 没有无符号数。换言之，Java 的数都是有符号的。</li><li><strong>计算机运算时，都是以补码的方式来运算的。</strong></li><li><strong>当我们看运算结果时，要看其原码。</strong></li></ol><h2 id="位运算符">3.10 位运算符</h2><ul><li><p><code>&amp;</code> 按位与：两位都为 1，结果为 1，否则为0</p></li><li><p><code>|</code> 按位或：两位有一个为 1，结果为 1，否则为0</p></li><li><p><code>^</code> 按位异或：两位不同，结果为 1，否则为 0</p></li><li><p><code>~</code> 按位取反：把 0 变 1，1 变 0</p><p>以下是几个示例：</p><ul><li><p><code>2 &amp; 3</code>：</p><blockquote><p>2 的原码：00000000 00000000 00000000 00000010</p><p>2 的补码：00000000 00000000 00000000 00000010</p><p>3 的原码：00000000 00000000 00000000 00000011</p><p>3 的补码：00000000 00000000 00000000 00000011</p><p>补码运算结果：00000000 00000000 00000000 00000010</p><p>结果转成原码：00000000 00000000 00000000 00000010</p><p>运算结果：2</p></blockquote></li><li><p><code>~-2</code>：</p><blockquote><p>得到 -2 的原码：10000000 00000000 00000000 00000010</p><p>得到 -2 的反码：11111111 11111111 11111111 11111101</p><p>得到 -2 的补码：11111111 11111111 11111111 11111110</p><p>补码运算结果：00000000 00000000 00000000 00000001</p><p>结果转成原码：00000000 00000000 00000000 00000001</p><p>运算结果：1</p></blockquote></li><li><p><code>~2</code>：</p><blockquote><p>2 的原码：00000000 00000000 00000000 00000010</p><p>2 的补码：00000000 00000000 00000000 00000010</p><p>补码运算：11111111 11111111 11111111 11111101</p><p>结果转成反码：11111111 11111111 11111111 11111100</p><p>反码转成原码：10000000 00000000 00000000 00000011</p><p>运算结果：-3</p></blockquote></li></ul></li><li><p><code>&gt;&gt;</code>算术右移：低位溢出，符号位不变，用符号位补溢出的高位</p></li><li><p><code>&lt;&lt;</code> 算数左移：符号位不变，低位补 0</p></li><li><p><code>&gt;&gt;&gt;</code>逻辑右移（无符号右移）：低位溢出，高位补 0</p><p>下面是示例：</p><ul><li><p>将数字 1 算术右移 2 位：<code>int a = 1 &gt;&gt; 2</code></p><blockquote><p>1 的补码：00000000 00000000 00000000 00000001</p><p>补码结果：00000000 00000000 00000000 00000000</p><p>结果：00000000 00000000 00000000 00000000</p></blockquote></li><li><p>将数字 1 算术左移 2 位：<code>int b = 1 &lt;&lt; 2</code></p><blockquote><p>1 的补码：00000000 00000000 00000000 00000001</p><p>补码结果：00000000 00000000 00000000 00000100</p><p>结果：00000000 00000000 00000000 00000100</p></blockquote></li></ul><p>也就是说，<code>1 &lt;&lt; 2</code> 本质是<code>1 * 2 * 2 = 4</code></p><p>而 <code>1 &gt;&gt; 2</code> 本质是<code>1 / 2 / 2 = 0</code></p></li></ul><p><strong>使用细节：</strong></p><ol type="1"><li><p>位运算符只对整型、字符类型有效</p></li><li><p>移位运算中，左侧操作 int 的场合，右侧操作数以 32 取模；long的场合，右侧操作数以 64 取模。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;n &gt;&gt;= <span class="hljs-number">32</span>;<span class="hljs-comment">//这个场合，n 不改变。这样能保证左侧数字不被全部移走</span></code></pre></div></li></ol><h2 id="附录">附录</h2><h3 id="java-api-文档">Java API 文档</h3><blockquote><p>API：Application Programming Iterface（应用程序编程接口），是 Java提供的基本编程接口（Java 提供的一些类和方法）。</p><p>Java语言提供了大量基础类，为了告诉开发者如何使用这些类，及类里包含的方法，就有了API文档。<ahref="www.matools.com" title="中文在线文档">具体有哪些请查找</a>；<ahref="https://www.matools.com/api/java8"title="Java 8 API 文档">特别地，Java 8 请查找</a></p></blockquote><h4 id="使用方法">使用方法</h4><ul><li>包 —— 类 / 接口 —— 方法</li><li>直接检索</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt;2 变量</title>
    <link href="/2021/11/22/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/2%20%E5%8F%98%E9%87%8F/"/>
    <url>/2021/11/22/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/2%20%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="变量">2 变量</h1><blockquote><p>变量：变量是程序的基本组成单位</p><p>变量的三个基本要素：类型 + 名称 + 值</p><p>示例：<code>int a = 1</code> 类型 int 名称 a 值 1</p></blockquote><p><strong>如何声明变量：</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span> a;a = <span class="hljs-number">100</span>;<span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>, d;</code></pre></div><h2 id="变量使用注意事项">2.1 变量使用注意事项</h2><ol type="1"><li>变量表示内存中的一个存储区域。不同变量，不同类型，占用的空间大小不同。如<code>int</code> 有 4 byte，而 <code>double</code> 有 8 byte。</li><li>该区域有自己的名称 <code>变量名</code> 和类型<code>数据类型</code></li><li>变量必须先声明，后使用。</li><li>变量在同一作用域内不能重名。</li><li>该区域的数据 · 值可以在同一类型范围内变化。</li><li>变量的三个基本要素：类型 + 名称 + 值</li></ol><h2 id="程序中-的使用">2.2 程序中 <code>+</code> 的使用</h2><ol type="1"><li><p>当左右两边都是数值型，做加法运算</p></li><li><p>当左右两边任意一方为字符串，做拼接运算</p></li><li><p>运算顺序是从左到右的</p><div class="code-wrapper"><pre><code class="hljs java">System.out.println(<span class="hljs-number">1</span> + <span class="hljs-number">1</span> + <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-number">1</span> + <span class="hljs-number">1</span>);<span class="hljs-comment">// 输出 2a11</span></code></pre></div></li></ol><h2 id="java-数据类型">2.3 Java 数据类型</h2><h4 id="基本数据类型本章">- 基本数据类型（本章）</h4><ul><li><p><strong>数值型</strong></p><ul><li>整数类型：<ul><li>byte：占用 1 字节</li><li>short：占用 2 字节</li><li>int：占用 4 字节</li><li>long：占用 8 字节</li></ul></li><li>浮点（小数）类型：<ul><li>float：占用 4 字节</li><li>double：占用 8 字节</li></ul></li></ul></li><li><p><strong>字符型</strong></p><ul><li>char：存放单个字符，占用 2 字节</li></ul></li><li><p><strong>布尔型</strong></p><ul><li>boolean：存放 true（真），false（假）。占用 1 字节</li></ul></li></ul><h4 id="引用数据类型复合数据类型">- 引用数据类型（复合数据类型）</h4><ul><li><p><strong>类</strong>：class</p><p><strong><em>——详见 <ahref="../../../../../../2021/11/29/Java/入门阶段/6%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/#6-1-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88OOP%EF%BC%89">[6 类与对象 ]</a></em></strong></p></li><li><p><strong>接口</strong>：interface</p><p><strong><em>——详见 <ahref="../../../../../../2021/12/14/Java/入门阶段/9%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/#9-7-%E6%8E%A5%E5%8F%A3">[9.7 接口 ]</a></em></strong></p></li><li><p><strong>数组</strong>：<code>[]</code></p><p><strong><em>——详见 <ahref="../../../../../../2021/11/27/Java/入门阶段/5%20%E6%95%B0%E7%BB%84%E3%80%81%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/#5-%E6%95%B0%E7%BB%84%E3%80%81%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE">[5 数组、排序和查找 ]</a></em></strong></p></li></ul><h2 id="整数类型">2.4 整数类型</h2><blockquote><p>用于存放整数值</p></blockquote><ul><li><code>byte</code> 占用 1 字节，范围 -128 ~ 127</li><li><code>short</code> 占用 2 字节，范围 -2<sup>15</sup> ~2<sup>15</sup> - 1</li><li><code>int</code> 占用 4 字节，范围 -2<sup>31</sup> ~ 2<sup>31</sup>- 1</li><li><code>long</code> 占用 8 字节，范围 -2<sup>63</sup> ~ 2<sup>63</sup>- 1</li></ul><p><strong>使用细节：</strong></p><ol type="1"><li><p>Java 各整数类型有固定的范围和字符长度，不受具体OS（操作系统）影响，以保证 Java 程序的可移植性。</p></li><li><p>Java 默认整型常量为 <code>int</code> ，要声明 <code>long</code>型常量必须后加 <code>l</code> 或 <code>L</code>。</p></li><li><p>从 Java 7 开始，加上前缀 <code>0b</code> 或 <code>0B</code>就可以写二进制数。</p></li><li><p>从 Java 7开始，可以为数字字面添加下划线。这不会影响数字的值，只是为了方便阅读。</p></li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0b0010</span>;n = <span class="hljs-number">0b001</span>;n = <span class="hljs-number">100_0_000000</span>;n = <span class="hljs-number">0B0000_0010_1100</span>;<span class="hljs-type">float</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.0F</span>;</code></pre></div><p>如果基本的整数、浮点类型不能满足范围、精度的需求，可以使用 “大数”</p><p><strong><em>—— 大数，见 <ahref="../../../../../../2021/12/19/Java/入门阶段/12%20%E5%B8%B8%E7%94%A8%E7%B1%BB/#12-8-BigInteger-%E5%92%8C-BigDecimal-%E7%B1%BB">[12.8BigInteger 和 BigDecimal 类]</a></em></strong></p><h2 id="浮点类型">2.5 浮点类型</h2><blockquote><p>可以表示一个小数</p></blockquote><ul><li><code>float</code> 单精度（6 ~ 7 位有效数字），占用 4 字节，范围约-3.403E38 ~ 3.403E38</li><li><code>double</code> 双精度（15 位有效数字），占用 8 字节，范围约-1.798E308 ~ 1.798E308</li></ul><p><em>浮点数在机器中存放形式为：浮点数 = 符号位 + 指数位 +尾数位</em></p><p><strong><em>因此，尾数部分可能丢失，造成精度损失。换言之，小数都是近似值</em></strong></p><h3 id="使用细节">2.5.1 使用细节</h3><ol type="1"><li><p>与整数类型相似，有固定的范围和字符长度，不受具体OS（操作系统）影响。</p></li><li><p>Java 默认浮点常量为 <code>double</code> ，要声明<code>float</code> 型常量必须后加 ”f“ 或 ”F“</p></li><li><p>浮点型常量有两种表示形式</p><blockquote><p>十进制数形式：<code>5.13</code>、<code>315.4F</code>、<code>.414</code></p><p>科学计数法：<code>5.12e2</code> 即[5.12 ×10<sup>2</sup>]、<code>5.12E-2</code> 即[5.12 / 10<sup>2</sup>]</p></blockquote></li><li><p>通常情况下，应该使用 <code>double</code>类型，以其更为精确。</p></li><li><p>浮点数使用陷阱：当我们对运算结果是小数的进行相对判断时，要小心。（因为<strong><em>小数都是近似值</em></strong>）</p><p>正确方法是：<strong>以两个数差值的绝对值，在某个精度范围内判断</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (Math.abs(num1 - num2) &lt; <span class="hljs-number">0.00001</span>) &#123;System.out.println(<span class="hljs-string">&quot;插值范围内认为相等&quot;</span>);&#125;</code></pre></div></li><li><p>特殊的浮点类型常量</p><ul><li><p>正无穷大：<code>Float.POSITIVE_INFINITY</code>、<code>Double.POSITIVE_INFINITY</code></p><p>（浮点数运算中）一个正数除以 0，会得到该值</p></li><li><p>负无穷大：<code>Float.NEGATIVE_INFINITY</code>、<code>Double.NEGATIVE_INFINITY</code></p><p>（浮点数运算中）一个负数除以 0，会得到该值</p></li><li><p>0 / 0：<code>Float.NaN</code>、<code>Double.NaN</code></p><p>（浮点数运算中）0 除以 0，会得到该值</p></li><li><p>最大、最小值：<code>Float.MAX_VALUE</code>、<code>Double.MIN_VALUE</code></p></li></ul></li><li><p>不能用运算符来比较特殊值，而要用特别的方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">double</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.0</span> / <span class="hljs-number">0</span>;System.out.println(num == Double.NaN);<span class="hljs-comment">// &lt;——— 始终为 false。不能如此比较</span>System.out.println(Double.isNaN(num));<span class="hljs-comment">// &lt;——— 判断是否是 NaN</span>num = <span class="hljs-number">1.0</span> / <span class="hljs-number">0</span>;System.out.println(Double.isInfinite(num));<span class="hljs-comment">// &lt;——— 是否是无穷大</span></code></pre></div></li><li><p>由于不同处理器寄存浮点数的策略可能不同，浮点数运算的结果也可能不同。</p><p><strong><em>—— 见 <ahref="../../../../../../2021/12/19/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/12%20%E5%B8%B8%E7%94%A8%E7%B1%BB/#12-1-4-strictfp-%E5%85%B3%E9%94%AE%E5%AD%97">[12.1.4strictfp 关键字]</a></em></strong></p></li></ol><h2 id="字符类型">2.6 字符类型</h2><blockquote><p>可以表示单个字符。（可以存放一个数字，因为其字符是数字编号的。输出时会输出数字对应的字符。”编码的概念“）</p><p><code>char c1 = 'a';</code> <code>char c2 = '\t';</code><code>char c3 = '字';</code> <code>char c4 = 99;</code></p></blockquote><h3 id="使用细节-1">2.6.1 使用细节</h3><ol type="1"><li><p>字符常量用单引号括起 `'字'</p></li><li><p><code>char</code> 的本质是一个整数，输出时，输出的是 unicode码对应的字符。<a href="tool.chinaz.com/Tools/Unicode.aspx">unicode码查询</a> 。</p><p>要输出那个整数，用 <code>int</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;System.out.println((<span class="hljs-type">int</span>)c1);</code></pre></div></li><li><p><code>char</code>是可以进行运算的，其相当于一个整数。<strong><em>注意与 <ahref="../../../../../../2021/11/22/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/2%20%E5%8F%98%E9%87%8F/#2-2-%E7%A8%8B%E5%BA%8F%E4%B8%AD-%E7%9A%84%E4%BD%BF%E7%94%A8">[2.2示例]</a> 的区别</em></strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 注：(int)&#x27;a&#x27; = 97</span><span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">1</span>;<span class="hljs-comment">// 相当于 char c1 = &#x27;b&#x27;</span>System.out.println(<span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">1</span>);<span class="hljs-comment">// 这个代码输出 98</span>System.out.println(<span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-number">1</span>);<span class="hljs-comment">// 这个代码输出 a1</span></code></pre></div></li><li><p>字符允许使用转义符（<em>见 [1.8 Java 转义字符]</em>）</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;\u0041&#x27;</span>;</code></pre></div><p><strong>转义序列出现在引号外。所有这些转义序列会在解析代码前得到处理</strong></p><ul><li><p>以下字符串是空串：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;\u0022+\u0022&quot;</span>;</code></pre></div><p>因为 022 表示引号。该代码等同于以下代码</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span> + <span class="hljs-string">&quot;&quot;</span>;</code></pre></div></li><li><p>以下注释会报错：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// \u000A is a newline</span></code></pre></div><p>因为 00A是换行符。在解析前会得到处理。在程序看来，上述注释等于以下写法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// </span>is a newline</code></pre></div></li><li><p>以下注释也会报错：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// look inside c:\users</span></code></pre></div><p>因为程序认为，不是一个合法的转义字符</p></li><li><p>在某些场合下这种写法似乎也能实现：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span>\u005B\u005D a;<span class="hljs-comment">// int[] a; 一个数组</span></code></pre></div></li></ul></li></ol><h3 id="字符本质与编码表">2.6.2 字符本质与编码表</h3><ul><li><p>字符类型的本质，是把字符对应的码值编程二进制，存储。显示时将二进制代码转化为码值，找到对应的字符。</p></li><li><p>字符与码值的对应关系是字符编码表规定的。</p><blockquote><p>ASCII 编码表，占用 1 byte，共有 128 个字符。</p><p>Unicode 编码表，占用 2 byte，字母汉字都占用 2byte，这样可能浪费空间。0 - 127 的字符与 ASCII 相同，所以兼容ASCII。</p><p>UTF-8 编码表，根据不同符号大小可变（1 - 6 byte），字母占用 1byte，汉字占用 3 byte。是 Unicode 的改进，是互联网上使用最广的 Unicode实现方式。</p><p>GBK 编码表，可以表示汉字，字母占用 1 byte，汉字占用 2 byte。</p><p>GB2312 编码表，可以表示汉字（GB2312 &lt; GBK）</p><p>BIG5 编码表，可以存放繁体中文（香港，台湾）</p></blockquote></li><li><p>UTF-16 编码采用不同长度的编码表示所有 Unicode 码点。包含从 U+0000到 U+FFFF 的经典 Unicode 代码（16位，1 个代码单元），以及 U+10000 到U+10FFFF 的辅助字符（32位，2 个代码单元）</p></li><li><p>在 Java 中，char 类型描述的是 UTF-16 编码中的 1 个代码单元。</p><p>字符串中的一个辅助字符（如 🎶）可能占用 2 个代码单元。这个场合，使用char 可能会导致错误</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;🎶Melody🎶&quot;</span>;<span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> str.charAt(<span class="hljs-number">1</span>);<span class="hljs-comment">// &lt;———— 这个场合，c 是 🎶 符号的第二个代码单元而非 &#x27;M&#x27;</span></code></pre></div><p><strong>因此，一般不建议在程序中使用 char 类型</strong></p></li></ul><h2 id="布尔类型">2.7 布尔类型</h2><blockquote><p><code>boolean</code> 只允许取值 <code>ture</code> 或<code>false</code> ，没有<code>null</code>。适用于逻辑运算，通常用于程序流程控制</p><p><code>if</code> <code>while</code> <code>do-while</code><code>for</code></p></blockquote><p><strong>使用细节：</strong></p><ol type="1"><li><p>不可以用 0 或 非0 的整数替代 <code>false</code> 或<code>ture</code> 。这点和 C语言 不同。</p></li><li><p>不能让布尔类型转换为其他类型。如需转换，请使用如下方法：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> b ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;</code></pre></div><p><strong><em>——见 <ahref="../../../../../../2021/11/23/Java/入门阶段/3%20%E8%BF%90%E7%AE%97%E7%AC%A6/#3-5-%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6">[3.5三元运算符]</a></em></strong></p></li></ol><h2 id="基本数据类型转换">2.8 基本数据类型转换</h2><h3 id="自动类型转换">2.8.1 自动类型转换</h3><blockquote><p>自动类型转换：Java在进行赋值或运算时，精度（容量）小的类型自动转换为精度（容量）大的类型。</p><p><code>char</code> &gt; <code>int</code> &gt; <code>long</code> &gt;<code>float</code> &gt; <code>double</code></p><p><code>byte</code> &gt; <code>short</code> &gt; <code>int</code> &gt;<code>long</code> &gt; <code>float</code> &gt; <code>double</code></p><p>例子：<code>int a = 'c'</code> 或者 <code>double b = 80</code></p></blockquote><h4 id="使用细节-2">2.8.1.1 使用细节</h4><ol type="1"><li><p>有多种类型数据混合运算时，系统会将所有数据转换成容量最大的那种，再进行运算。</p></li><li><p>如若把大精度（容量）数据赋值给小精度（容量）类型，就会报错（小数由于精度原因，大赋小会丢失精度，必不可用。但整数大赋小时：1.赋予具体数值时，判断范围。2.变量赋值时，判断类型。反之进行自动类型转换。</p></li><li><p><code>byte</code> <code>short</code> <code>char</code>三者不会相互自动转换，但可以计算。计算时首先转化为<code>int</code>。</p><blockquote><p><code>byte a = 1;</code></p><p><code>byte b = 1;</code></p><p><code>a + b</code> 结果是 <code>int</code> 类型</p></blockquote></li><li><p><code>boolean</code> 类型不参与自动转换</p></li><li><p>自动提升原则：表达式结果的类型自动提升为操作数中最大的类型。</p></li></ol><h3 id="强制类型转换">2.8.2 强制类型转换</h3><blockquote><p>强制类型转换：自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时加上强制转换符<code>( )</code>，但<strong>可能造成精度降低或溢出</strong>，要格外注意。</p></blockquote><h4 id="使用细节-3">2.8.2.1 使用细节</h4><ol type="1"><li><p>当进行数据从大到小转换时，用强制转换。</p></li><li><p>强制转换只能对最近的操作数有效，往往会使用 <code>( )</code>提升优先级。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">3</span> * <span class="hljs-number">2.5</span> + <span class="hljs-number">1.1</span> * <span class="hljs-number">6</span>);</code></pre></div></li><li><p><code>char</code> 可以保留 <code>int</code>的常量值，但不能保存其变量值。此时需要强制类型转换。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<span class="hljs-type">char</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (<span class="hljs-type">char</span>)a;</code></pre></div></li><li><p><code>byte</code> <code>short</code> <code>char</code>在进行运算时，当作 <code>int</code> 处理。</p></li></ol><h3 id="基本数据类型和-string-的转换">2.8.3 基本数据类型和<code>String</code> 的转换</h3><ul><li><p>基本类型转 <code>String</code>：基本数据类型加上<code>" "</code>。即利用了 <strong><em><ahref="../../../../../../2021/11/22/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/2%20%E5%8F%98%E9%87%8F/#2-2-%E7%A8%8B%E5%BA%8F%E4%B8%AD-%E7%9A%84%E4%BD%BF%E7%94%A8">[2.2.2]</a></em></strong>中的方法。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> n1 + <span class="hljs-string">&quot;&quot;</span>;System.out.println(n1 + <span class="hljs-string">&quot;&quot;</span> + n1 + <span class="hljs-string">&quot;&quot;</span> + n1 + <span class="hljs-string">&quot;&quot;</span>);</code></pre></div></li><li><p><code>String</code> 转基本数据类型：通过基本数据类型的包装类调用<code>parseXX</code> 方法。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;100&quot;</span>;<span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> Interger <span class="hljs-title function_">parseInt</span><span class="hljs-params">(s)</span>;</code></pre></div><p>特别的，把 <code>String</code> 转换为 <code>char</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(<span class="hljs-number">0</span>);<span class="hljs-comment">// 得到 s 字符串中的第一个字符。</span></code></pre></div></li></ul><h4 id="使用细节-4">2.8.3.1 使用细节</h4><ol type="1"><li>将 <code>String</code>转成基本数据类型时，要保证其能转换为有效数据。即不能把<code>"Hello"</code> 转换成 <code>int</code>。</li><li>如果格式不正确，会抛出<ahref="../../../../../../2021/12/18/Java/入门阶段/11%20%E5%BC%82%E5%B8%B8/">异常</a>，程序会中止。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt;1 基础知识</title>
    <link href="/2021/11/21/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/1%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2021/11/21/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/1%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="java-概述">1 Java 概述</h1><blockquote><p>程序：一系列有序指令的集合</p></blockquote><h2 id="java-历史">1.1 Java 历史</h2><ul><li><p>目前 Java 版权属于甲骨文公司。</p></li><li><p>长期支持的版本只有 Java8 与Java11。这两个版本也是最多使用的版本。</p></li><li><p>Java SE：标准版</p><p>Java EE：企业版（重要）</p><p>Java ME：小型版（少）</p></li></ul><h2 id="java-重要特点">1.2 Java 重要特点</h2><ol type="1"><li><p>Java 语言是<strong>面向对象的（oop）</strong></p><p>简单来说，面向对象是一种程序设计技术。其重点放在数据（对象）和对象的接口上。</p><p><strong><em>——何为面向对象？详见 <ahref="../../../../../../2021/11/29/Java/入门阶段/6%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/">[6 面向对象编程 ]</a></em></strong></p></li><li><p>Java语言是<strong>健壮的</strong>。其强类型机制、异常处理、垃圾自动收集是健壮性的保证。</p><p>Java强调早期问题检测、后期动态检测，及消除易出错的情况。其编译器能检测很多其他语言仅在运行时才会发现的问题。</p><p><strong><em>——异常见 <ahref="../../../../../../2021/12/18/Java/入门阶段/11%20%E5%BC%82%E5%B8%B8/">[11 异常 ]</a></em></strong></p></li><li><p>Java 语言是<strong>跨平台性</strong>的：一个编译好的<code>.class</code> 文件可以在多个不同系统下直接运行。</p><p>Java 中没有 “依赖具体实现”的地方。其基本数据类型大小、有关运算的行为等都有明确说明。其绝大多数库都能很好地支持平台独立性，而不用担心操作系统。</p></li><li><p>Java语言是<strong>解释型</strong>的：解释型语言编译后需要解释器才能运行。相对的，编译型语言可以被直接执行。</p><p>Java 解释器能在任何移植了解释器的机器上直接执行 Java字节码。</p></li></ol><h2 id="java-的开发工具">1.3 Java 的开发工具</h2><ul><li>javac：Java 编译器。将 Java 程序编译成字节码</li><li>java：Java 解释器。执行已经转换为字节码的文件</li><li>jdb：Java 调试器。调试 Java 程序</li><li>javap：反编译。将类文件还原回方法和变量</li><li>javadoc：文档生成器。创建 HTML 文件</li></ul><h2 id="java-运行基础">1.4 Java 运行基础</h2><blockquote><p>JVM：Java 虚拟机</p></blockquote><ul><li>JVM 是--跨平台性的基础。被包含在 JDK 中。</li><li>不同平台有各自对应的不同 JVM</li><li>JVM 屏蔽了底层平台的区别。能做到 ”一次编译，到处运行”</li></ul><blockquote><p>JDK 全称：Java Development Kit（Java 开发工具包）</p></blockquote><ul><li>JDK = JRE + Java 的开发工具（Java，Javac，Javadoc 等等）</li><li>给开发人员使用的，包含 JRE</li></ul><blockquote><p>JRE：Java Runtime Enviroment（Java 运行环境）</p></blockquote><ul><li>JRE = JVM + Java SE 标准类库（Java 的核心类库）</li><li>运行一个 Java 程序的基本条件</li></ul><h2 id="java-执行流程分析">1.5 Java 执行流程分析</h2><blockquote><p><code>.Java</code> 文件（源文件） — javac（编译）—<code>.class</code> 文件（字节码文件） — java（运行）— 结果</p></blockquote><h3 id="编译">1.5.1 编译</h3><div class="code-wrapper"><pre><code class="hljs doc">javac [选项] 源文件名.java//[] 中是可选项</code></pre></div><ul><li>通过编译器将 Java 源文件编译成 JVM可识别的字节码文件。字节码文件是二进制格式的，其格式是统一的。在源文件目录下使用Javac 编译工具对 Java 文件进行编译。</li><li>如果没有错误将没有提示，当前目录会对应其中每一个类生成对应名称的<code>.class</code> 文件，即字节码文件，也是可执行的 Java 程序。</li></ul><h3 id="运行">1.5.2 运行</h3><div class="code-wrapper"><pre><code class="hljs doc">java [选项] 程序名 [参数列表]//[] 中是可选项</code></pre></div><ul><li>有了可执行的 Java 程序（字节码文件）</li><li>通过运行工具<code>Java.exe</code> 对字节码文件进行执行，本质是将<code>.class</code> 文件装载到 JVM 运行。</li></ul><h6 id="注意修改后的-.java-源文件需要重新编译"><em>注意，修改后的 .Java源文件需要重新编译</em></h6><h2 id="java-开发注意事项和细节说明">1.6 Java开发注意事项和细节说明</h2><ol type="1"><li><p>源文件以 <code>.java</code>为扩展名，源文件的基本组成部分是类（class）</p></li><li><p>Java 应用程序的执行入口是 <code>main()</code>方法。其有固定的<strong>书写格式：</strong></p><p><code>public static void main(string[]args)&#123;…&#125;</code></p></li><li><p>Java 语言<strong>严格区分大小写</strong>。</p></li><li><p>Java 方法由一条条语句构成，<strong>每个语句都以 <code>;</code>结束</strong>。</p></li><li><p><strong>大括号 <code>&#123;</code> <code>&#125;</code>是成对出现的</strong>，缺一不可。习惯先写 <code>&#123;&#125;</code>再写代码</p></li><li><p>一个源文件中<strong>最多只有一个 public类</strong>，其余类不限。</p></li><li><p><strong>如果文件中包含 public类，则文件名必须按该类命名。</strong></p></li><li><p>也可以把 main 方法写在非 public 类中，然后运行指定非 public类，这样入口方法是非 public 类的主方法。</p></li><li><p><strong><em>在控制台按 tab 可以实现代码补齐。按方向键 ↑ 或 ↓可以调用历史代码。</em></strong></p></li></ol><h2 id="代码规范">1.7 代码规范</h2><ol type="1"><li><p>类、方法的注释要以 Javadoc 的方式来写</p></li><li><p>非 Javadoc的注释，往往是给维护者看的，着重告诉读者为什么这样写，如何修改，注意什么问题等。</p></li><li><p>不要用 <code>a</code><code>b</code>，这种名称命名变量，尽量写得清楚<code>int age = 10;</code></p><p>另外，<strong>Java 源代码使用的是 Unicode码，因此汉语也能作为标识符</strong>。但不推荐使用汉语做标识符。</p></li><li><p>使用 tab 键操作，使代码右移。使用 shift+tab键，使代码左移。</p></li><li><p>运算符两边各加入空格。注意排版规范。</p></li><li><p>源文件使用 UTF-8 编码。</p></li><li><p>代码行宽度不要超过 80 个字符。超过时通过换行保持简洁。</p></li><li><p>代码编写<strong>次行风格</strong>及<strong>行尾风格</strong></p><blockquote><p>次行风格：换行输入<code>&#123;</code> <code>&#125;</code>，使其总在行头</p><p>行尾风格：在一行的末尾输入 <code>&#123;</code>，换行输入<code>&#125;</code></p></blockquote></li><li><p>一段代码完成一个小功能，尽量不要混合。这样更加灵活。</p></li></ol><h2 id="java-转义字符">1.8 Java 转义字符</h2><ol type="1"><li><p><code>\t</code>：一个制表位，实现对齐功能</p></li><li><p><code>\n</code>：换行符</p></li><li><p><code>\\</code>：一个 <code>\</code></p></li><li><p><code>\"</code>：一个 <code>"</code></p></li><li><p><code>\'</code>：一个 <code>'</code></p></li><li><p><code>\r</code>：一个回车（不是换行）</p></li><li><p><code>\\.</code>：一个小圆点 <code>.</code></p></li><li><p><code>\b</code>：退格键</p></li><li><p><code>\u????</code>：一个具体的 Unicode 字符。其中 ???? 是 4 位16 进制数</p><p><code>\???</code>：一个具体的 Unicode 字符。其中 ??? 是 3 位 8进制数</p></li></ol><h2 id="注释">1.9 注释</h2><blockquote><p>注释：用于注解说明程序的文字。其提高了代码的可读性，是一个程序员必须要具有的良好编程习惯。将自己的思想通过注释先整理出来，再用代码去体现。</p><p>被注释的文字不会被 JVM 解释执行。</p></blockquote><h3 id="注释类型">1.9.1 注释类型</h3><ul><li><p><strong>单行注释：</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//这是一条单行注释</span></code></pre></div><p>选中文字按 <code>ctrl</code> + <code>/</code>将选中文字变为单行注释</p></li><li><p><strong>多行注释：</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*这</span><span class="hljs-comment">是一段</span><span class="hljs-comment">多行注释</span><span class="hljs-comment">*/</span></code></pre></div><p>多行注释中不允许多行注释嵌套。</p></li><li><p><strong>文档注释：</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">*<span class="hljs-doctag">@auther</span> Melody</span><span class="hljs-comment">*<span class="hljs-doctag">@version</span> 3.2.0</span><span class="hljs-comment">*/</span></code></pre></div><p>以下写法也同样合法：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">就是说咱可以每行开头不加星号的</span><span class="hljs-comment">*/</span></code></pre></div></li></ul><h3 id="文档注释">1.9.2 文档注释</h3><blockquote><p>文档注释的注释内容可被 JDK 中的 Javadoc 工具解析，生成一套以 HTML形式体现的说明文档。</p><p>抽取注释：<code>javadoc -d 生成目录 -author -.. 文档名.java</code></p></blockquote><p>文档注释包含 <strong>标记</strong> 和紧随其后的<strong>自由格式文本</strong>：</p><ul><li><p><strong>标记：</strong></p><p>以 <code>@</code> 开始，如 <code>@since</code></p><p>下面列出了一些 <strong>通用注释</strong>：</p><ul><li><p><code>@since 始于</code>：创建一个 <strong>始于</strong>条目。其后文本可以是引入该特性的版本的任何描述</p></li><li><p><code>@author 作者</code>：产生一个 <strong>作者</strong>条目。可以使用多个 <code>@author</code> 标记</p></li><li><p><code>@version 版本</code>：产生一个 <strong>版本</strong>条目。这里的文本可以是对当前版本的任意描述</p></li><li><p><code>@link 超链接</code>：产生一个<strong>超链接</strong>，链接到 javadoc 相关部分或外部文档</p><p><code>@see 引用</code>：在 <strong>see also</strong>部分增加一个超链接。可以添加多个 <code>@see</code>标记，但必须放在一起。</p><p>这里的 引用 有以下选择：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">*<span class="hljs-doctag">@see</span> com.test.Example#act()</span><span class="hljs-comment">*<span class="hljs-doctag">@see</span> &lt;a herf=&quot;../../../../../../&quot;&gt;Melody&#x27;s Box&lt;/a&gt;</span><span class="hljs-comment">*<span class="hljs-doctag">@see</span> &quot;一段文本&quot;</span><span class="hljs-comment">*/</span></code></pre></div><blockquote><ol type="1"><li>只提供类、方法或变量的名字。那个场合，使用 <strong>#</strong>来分隔类名和方法名</li><li><code>@see</code> 后有一个 <strong>&lt;</strong>字符的场合，需要指定超链接。可以指向任何 URL</li><li><code>@see</code> 后有一个 <strong>“</strong>字符的场合，文本会显示在 see alse 部分</li></ol></blockquote></li></ul></li><li><p><strong>自由格式文本：</strong></p><p>第一句应该是一个概要性的句子。javadoc会自动抽取这些语句生成概要页</p><p>自由格式文本中，可以使用 HTML 修饰符</p></li></ul><h4 id="注释的插入">注释的插入</h4><p>javadoc 工具抽取文档注释时，会从以下位置抽取：</p><ul><li><p>模块</p></li><li><p>包（包注释）</p><p><strong>要想产生包注释，必须在每个包目录中添加一个单独的文件</strong></p><p>有 2 种方法：</p><ul><li>提供一个名为 package-info.java 的文件。其中 <strong>只能</strong>包含文档注释，以及后面的一个 package语句。不能包含更多的代码或注释。</li><li>提供一个名为 package.html 的 HTML 文件。此时会抽取<code>&lt;body&gt;...&lt;/body&gt;</code> 间的所有文本</li></ul></li><li><p>公共类和接口（类注释）</p><p>类注释必须放在 import 语句后，类定义之前</p></li><li><p>公共的和受保护的字段</p><p>只需要对公共字段（通常是静态常量）建立文档</p></li><li><p>公共的和受保护的构造器和方法</p><p>方法注释必须放在所描述的方法之前。除了通用标记外，还能使用如下标记：</p><ul><li><p><code>@param 变量描述</code>：该标记能给当前方法的<strong>参数</strong> 部分添加一个条目。该描述可以占据多行。</p><p>一个方法的所有 <code>@param</code> 标记必须放在一起</p></li><li><p><code>@return 返回值描述</code>：该标记能给当前方法的<strong>返回值</strong> 部分添加一个条目。该描述可以占据多行。</p></li><li><p><code>@throws 异常描述</code>：该标记能给当前方法的可能抛出的<strong>异常</strong> 添加一个条目。</p></li></ul></li></ul><h2 id="jshell">1.10 JShell</h2><blockquote><p>Java 9 中引入了一种使用 Java 的方法，即 JShell。</p><p>JShell 程序提供了一个 “读取 - 计算 - 打印循环”。键入一个 Java表达式，JShell 会评估你的输入，打印结果，并等待下一个输入。</p><p>在命令提示符中输入 <code>jshell</code> 以启动 JShell</p></blockquote><div class="code-wrapper"><pre><code class="hljs cmd"><span class="hljs-function">C:\<span class="hljs-title">Users</span>\<span class="hljs-title">Melody</span>&gt;<span class="hljs-title">jshell</span></span></code></pre></div><p>在 cmd 中输入 jshell 以启动 JShell</p><div class="code-wrapper"><pre><code class="hljs cmd">|  欢迎使用 JShell -- 版本 <span class="hljs-number">11</span>.<span class="hljs-number">0</span>.<span class="hljs-number">12</span>|  要大致了解该版本, 请键入: /<span class="hljs-built_in">help</span> introjshell&gt;</code></pre></div><p>JShell 会显示一个问候语，之后出现提示符</p><div class="code-wrapper"><pre><code class="hljs cmd">jshell&gt; int n1 = <span class="hljs-number">10</span>;n1 ==&gt; <span class="hljs-number">10</span>jshell&gt; n1++;$<span class="hljs-number">2</span> ==&gt; <span class="hljs-number">10</span></code></pre></div><p>输入一条语句，JShell 会自动打印每条输入语句的值</p><p>其中的 $2 表示该值可以用于将来的计算。上面的 n1是自己定义的标识符</p><div class="code-wrapper"><pre><code class="hljs cmd">jshell&gt; Math.E                 IEEEremainder(    PI                abs(              acos(             addExact(asin(             atan(             atan2(            cbrt(             ceil(             classcopySign(         cos(              cosh(             decrementExact(   exp(              expm1(floor(            floorDiv(         floorMod(         fma(              getExponent(      hypot(incrementExact(   log(              log10(            log1p(            max(              min(multiplyExact(    multiplyFull(     multiplyHigh(     negateExact(      nextAfter(        nextDown(nextUp(           pow(              random()          rint(             round(            scalb(signum(           sin(              sinh(             sqrt(             subtractExact(    tan(tanh(             toDegrees(        toIntExact(       toRadians(        ulp(</code></pre></div><p>输入不完整的语句后，按 tab键实现方法补全。上面的场合，提示了所有方法的列表</p><div class="code-wrapper"><pre><code class="hljs cmd">jshell&gt; Math.pow(</code></pre></div><p>自动补全后的代码。可以手动填入剩余部分。</p><p>可以按 ↑ 键自动填充运行过的代码，以实现重复运行</p><h2 id="附录">附录</h2><h3 id="如何快速学习技术和知识点">如何快速学习技术和知识点</h3><h4 id="查看需求">1 查看需求</h4><blockquote><ol type="1"><li>工作需要跳槽</li><li>对方要求</li><li>技术控</li></ol></blockquote><h4 id="能否使用传统技术解决">2 能否使用传统技术解决</h4><blockquote><ol type="1"><li>能解决，但不完美</li><li>解决不了</li></ol></blockquote><h4 id="引出学习的新技术和知识点">3 引出学习的新技术和知识点</h4><h4 id="学习新技术或知识点的基本原理和基本语法不要考虑细节">4学习新技术或知识点的基本原理和基本语法（不要考虑细节）</h4><h4 id="快速入门完成一个基本程序crud能跑起来给老板看">5快速入门（完成一个基本程序，crud）（能跑起来给老板看）</h4><h4 id="开始研究技术的注意事项使用细节使用规范如何优化无穷无尽">6开始研究技术的注意事项，使用细节，使用规范，如何优化（无穷无尽）</h4><h3 id="dos只要了解">DOS（只要了解）</h3><blockquote><p>DOS：Disk Operating System（磁盘操作系统）</p></blockquote><h4 id="dos-的基本原理">DOS 的基本原理</h4><blockquote><p>在 cmd（控制台）输入指令 — DOS系统 接受指令 — 解析指令 — 执行指令</p></blockquote><ul><li><p>相对路径和绝对路径（举例从 JDK8访问到 JDK8）</p><blockquote><p>相对路径：从当前目录开始定位，形成的路径<code>..\jre\bin\LICENSE</code></p><p>返回上一级：<code>..\</code></p><p>绝对路径：从顶级目录开始定位，形成的路径<code>d:\Program\JDK8\jre\bin</code></p></blockquote></li></ul><h4 id="常用的-dos-命令">常用的 DOS 命令</h4><blockquote><p>查看帮助：<code>help</code> 或 <code>help cd</code> 等</p><p>查看目录内容：<code>dir</code> 查看当前目录</p><p>​ 或 <code>dir d:\Program\JDK8\bin</code> 查看指定目录</p><p>切换到其他盘：<code>cd /D d:</code> 从 C盘 切换至 D盘</p><p>切换到当前盘的其他目录：<code>cd d:\Program\JDK8\jre\bin</code></p><p>返回上级目录：<code>cd ..</code></p><p>切换至根目录：<code>cd \</code></p><p>查看子集目录：<code>tree</code> 当前目录</p><p>​ 或 <code>tree d:/Program</code> 指定目录</p><p>清屏：<code>cls</code></p><p>退出：<code>exit</code></p><p>创建/删除目录：<code>md 目录名</code> <code>rd 目录名</code></p><p>拷贝/删除文件：<code>copy 文件名 目录</code><code>del 文件名</code></p><p>移动文件：<code>move 文件名 目录</code></p><p>...</p><p><a href="https://baike.baidu.com/item/DoS/6672671"title="百度，请">更多</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt;目录</title>
    <link href="/2021/11/20/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/0%20%E7%9B%AE%E5%BD%95/"/>
    <url>/2021/11/20/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/0%20%E7%9B%AE%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="目录">目录</h1><hr /><p><ahref="https://www.bilibili.com/video/BV1fh411y7R8?share_source=copy_web">Java入门教学（韩顺平）</a></p><h2 id="java-概述">1 <ahref="../../../../../../2021/11/21/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/1%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">Java概述</a></h2><ul><li><h3 id="java-历史">1.1 <ahref="../../../../../../2021/11/21/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/1%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#1-1-Java-%E5%8E%86%E5%8F%B2">Java历史</a></h3></li><li><h3 id="java-重要特点">1.2 <ahref="../../../../../../2021/11/21/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/1%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#1-2-Java-%E9%87%8D%E8%A6%81%E7%89%B9%E7%82%B9">Java重要特点</a></h3></li><li><h3 id="java-的开发工具">1.3 <ahref="../../../../../../2021/11/21/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/1%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#1-3-Java-%E7%9A%84%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7">Java的开发工具</a></h3></li><li><h3 id="java-运行基础">1.4 <ahref="../../../../../../2021/11/21/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/1%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#1-4-Java-%E8%BF%90%E8%A1%8C%E5%9F%BA%E7%A1%80">Java运行基础</a></h3></li><li><h3 id="java-执行流程分析">1.5 <ahref="../../../../../../2021/11/21/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/1%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#1-5-Java-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90">Java执行流程分析</a></h3><ul><li><h4 id="编译">1.5.1 编译</h4></li><li><h4 id="运行">1.5.2 运行</h4></li></ul></li><li><h3 id="java-开发注意事项和细节说明">1.6 <ahref="../../../../../../2021/11/21/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/1%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#1-6-Java-%E5%BC%80%E5%8F%91%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82%E8%AF%B4%E6%98%8E">Java开发注意事项和细节说明</a></h3></li><li><h3 id="代码规范">1.7 <ahref="../../../../../../2021/11/21/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/1%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#1-7-%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83">代码规范</a></h3></li><li><h3 id="java-转义字符">1.8 <ahref="../../../../../../2021/11/21/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/1%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#1-8-Java-%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6">Java转义字符</a></h3></li><li><h3 id="注释">1.9 <ahref="../../../../../../2021/11/21/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/1%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#1-9-%E6%B3%A8%E9%87%8A">注释</a></h3><ul><li><h4 id="注释类型">1.9.1 注释类型</h4></li><li><h4 id="文档注释">1.9.2 文档注释</h4></li></ul></li><li><h3 id="jshell">1.10 <ahref="../../../../../../2021/11/21/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/1%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#1-10-JShell">JShell</a></h3></li><li><h3 id="附录">附录</h3><h3 id="如何快速学习技术和知识点"><ahref="../../../../../../2021/11/21/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/1%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%92%8C%E7%9F%A5%E8%AF%86%E7%82%B9">如何快速学习技术和知识点</a></h3><h3 id="dos"><ahref="../../../../../../2021/11/21/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/1%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#DOS%EF%BC%88%E5%8F%AA%E8%A6%81%E4%BA%86%E8%A7%A3%EF%BC%89">DOS</a></h3></li></ul><hr /><h2 id="变量">2 <ahref="../../../../../../2021/11/22/Java/入门阶段/2%20%E5%8F%98%E9%87%8F/">变量</a></h2><ul><li><h3 id="变量使用注意事项">2.1 <ahref="../../../../../../2021/11/22/Java/入门阶段/2%20%E5%8F%98%E9%87%8F/#2-1-%E5%8F%98%E9%87%8F%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">变量使用注意事项</a></h3></li><li><h3 id="程序中-的使用">2.2 <ahref="../../../../../../2021/11/22/Java/入门阶段/2%20%E5%8F%98%E9%87%8F/#2-2-%E7%A8%8B%E5%BA%8F%E4%B8%AD-%E7%9A%84%E4%BD%BF%E7%94%A8">程序中<code>+</code> 的使用</a></h3></li><li><h3 id="java-数据类型">2.3 <ahref="../../../../../../2021/11/22/Java/入门阶段/2%20%E5%8F%98%E9%87%8F/#2-3-Java-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">Java数据类型</a></h3></li><li><h3 id="整数类型">2.4 <ahref="../../../../../../2021/11/22/Java/入门阶段/2%20%E5%8F%98%E9%87%8F/#2-4-%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B">整数类型</a></h3></li><li><h3 id="浮点类型">2.5 <ahref="../../../../../../2021/11/22/Java/入门阶段/2%20%E5%8F%98%E9%87%8F/#2-5-%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B">浮点类型</a></h3><ul><li><h4 id="使用细节">2.5.1 使用细节</h4></li></ul></li><li><h3 id="字符类型">2.6 <ahref="../../../../../../2021/11/22/Java/入门阶段/2%20%E5%8F%98%E9%87%8F/#2-6-%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B">字符类型</a></h3><ul><li><h4 id="使用细节-1">2.6.1 使用细节</h4></li><li><h4 id="字符本质与编码表">2.6.2 字符本质与编码表</h4></li></ul></li><li><h3 id="布尔类型">2.7 <ahref="../../../../../../2021/11/22/Java/入门阶段/2%20%E5%8F%98%E9%87%8F/#2-7-%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B">布尔类型</a></h3></li><li><h3 id="基本数据类型转换">2.8 <ahref="../../../../../../2021/11/22/Java/入门阶段/2%20%E5%8F%98%E9%87%8F/#2-8-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">基本数据类型转换</a></h3><ul><li><h4 id="自动类型转换">2.8.1 自动类型转换</h4></li><li><h4 id="强制类型转换">2.8.2 强制类型转换</h4><ul><li><h5 id="使用细节-2">2.8.2.1 使用细节</h5></li></ul></li><li><h4 id="基本数据类型和-string-的转换">2.8.3 基本数据类型和 String的转换</h4><ul><li><h5 id="使用细节-3">2.8.3.1 使用细节</h5></li></ul></li></ul></li></ul><hr /><h2 id="运算符">3 <ahref="../../../../../../2021/11/23/Java/入门阶段/3%20%E8%BF%90%E7%AE%97%E7%AC%A6/">运算符</a></h2><ul><li><h3 id="算术运算符">3.1 <ahref="../../../../../../2021/11/23/Java/入门阶段/3%20%E8%BF%90%E7%AE%97%E7%AC%A6/#3-1-%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6">算术运算符</a></h3></li><li><h3 id="关系运算符比较运算符">3.2 <ahref="../../../../../../2021/11/23/Java/入门阶段/3%20%E8%BF%90%E7%AE%97%E7%AC%A6/#3-2-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%89">关系运算符（比较运算符）</a></h3><ul><li><h4 id="使用细节-4">3.2.1 使用细节</h4></li></ul></li><li><h3 id="逻辑运算符">3.3 <ahref="../../../../../../2021/11/23/Java/入门阶段/3%20%E8%BF%90%E7%AE%97%E7%AC%A6/#3-3-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6">逻辑运算符</a></h3></li><li><h3 id="赋值运算符">3.4 <ahref="../../../../../../2021/11/23/Java/入门阶段/3%20%E8%BF%90%E7%AE%97%E7%AC%A6/#3-4-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6">赋值运算符</a></h3><ul><li><h4 id="使用细节-5">3.4.1 使用细节</h4></li></ul></li><li><h3 id="三元运算符">3.5 <ahref="../../../../../../2021/11/23/Java/入门阶段/3%20%E8%BF%90%E7%AE%97%E7%AC%A6/#3-5-%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6">三元运算符</a></h3><ul><li><h4 id="使用细节-6">3.5.1 使用细节</h4></li></ul></li><li><h3 id="运算符优先级">3.6 <ahref="../../../../../../2021/11/23/Java/入门阶段/3%20%E8%BF%90%E7%AE%97%E7%AC%A6/#3-6-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7">运算符优先级</a></h3></li><li><h3 id="标识符">3.7 <ahref="../../../../../../2021/11/23/Java/入门阶段/3%20%E8%BF%90%E7%AE%97%E7%AC%A6/#3-7-%E6%A0%87%E8%AF%86%E7%AC%A6">标识符</a></h3><ul><li><h4 id="命名规则">3.7.1 命名规则</h4></li><li><h4 id="命名规范">3.7.2 命名规范</h4></li></ul></li><li><h3 id="输入与输出">3.8 <ahref="../../../../../../2021/11/23/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/3%20%E8%BF%90%E7%AE%97%E7%AC%A6/#3-8-%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA">输入与输出</a></h3><ul><li><h4 id="scanner-类">3.8.1 Scanner 类</h4></li><li><h4 id="格式化输出">3.8.2 格式化输出</h4></li><li><h4 id="numberformat-类">3.8.3 NumberFormat 类</h4></li><li><h4 id="decimalformat-类">3.8.4 DecimalFormat 类</h4></li></ul></li><li><h3 id="进制">3.9 <ahref="../../../../../../2021/11/23/Java/入门阶段/3%20%E8%BF%90%E7%AE%97%E7%AC%A6/#3-9-%E8%BF%9B%E5%88%B6">进制</a></h3><ul><li><h4 id="进制的转换">3.9.1 进制的转换</h4></li><li><h4 id="原码反码补码">3.9.2 原码、反码、补码</h4></li></ul></li><li><h3 id="位运算符">3.10 <ahref="../../../../../../2021/11/23/Java/入门阶段/3%20%E8%BF%90%E7%AE%97%E7%AC%A6/#3-10-%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6">位运算符</a></h3></li><li><h3 id="附录-1">附录</h3><h3 id="java-api-文档"><ahref="../../../../../../2021/11/23/Java/入门阶段/3%20%E8%BF%90%E7%AE%97%E7%AC%A6/#Java-API-%E6%96%87%E6%A1%A3">JavaAPI 文档</a></h3></li></ul><hr /><h2 id="程序控制结构">4 <ahref="../../../../../../2021/11/24/Java/入门阶段/4%20%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/">程序控制结构</a></h2><ul><li><h3 id="顺序控制">4.1 <ahref="../../../../../../2021/11/24/Java/入门阶段/4%20%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/#4-1-%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6">顺序控制</a></h3></li><li><h3 id="if---else-分支控制">4.2 <ahref="../../../../../../2021/11/24/Java/入门阶段/4%20%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/#4-2-%E5%88%86%E6%94%AF%E6%8E%A7%E5%88%B6-if-else">if- else 分支控制</a></h3><ul><li><h4 id="单分支控制">4.2.1 单分支控制</h4></li><li><h4 id="双分支控制">4.2.2 双分支控制</h4></li><li><h4 id="多分支控制">4.2.3 多分支控制</h4></li><li><h4 id="嵌套分支">4.2.4 嵌套分支</h4></li></ul></li><li><h3 id="switch-分支控制">4.3 <ahref="../../../../../../2021/11/24/Java/入门阶段/4%20%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/#4-3-switch-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84">switch分支控制</a></h3><ul><li><h4 id="使用细节-7">4.3.1 使用细节</h4></li><li><h4 id="与-if-else-分支结构的取舍">4.3.2 与 <code>if-else</code>分支结构的取舍</h4></li></ul></li><li><h3 id="for-循环控制">4.4 <ahref="../../../../../../2021/11/24/Java/入门阶段/4%20%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/#4-4-for-%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6">for循环控制</a></h3><ul><li><h4 id="使用细节-8">4.4.1 使用细节</h4></li><li><h4 id="for-each增强-for-循环">4.4.2 for each（增强 for循环）</h4></li></ul></li><li><h3 id="while-循环控制">4.5 <ahref="../../../../../../2021/11/24/Java/入门阶段/4%20%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/#4-5-while-%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6">while循环控制</a></h3><ul><li><h4 id="使用细节-9">4.5.1 使用细节</h4></li></ul></li><li><h3 id="do..while-循环控制">4.6 <ahref="../../../../../../2021/11/24/Java/入门阶段/4%20%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/#4-6-do-while-%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6">do..while循环控制</a></h3><ul><li><h4 id="使用细节-10">4.6.1 使用细节</h4></li></ul></li><li><h3 id="多重循环控制">4.7 <ahref="../../../../../../2021/11/24/Java/入门阶段/4%20%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/#4-7-%E5%A4%9A%E9%87%8D%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6">多重循环控制</a></h3></li><li><h3 id="跳转控制语句">4.8 <ahref="../../../../../../2021/11/24/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/4%20%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/#4-8-%E8%B7%B3%E8%BD%AC%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5">跳转控制语句</a></h3><ul><li><h4 id="标签">4.8.1 标签</h4></li><li><h4 id="break">4.8.2 break</h4></li><li><h4 id="continue">4.8.3 continue</h4></li><li><h4 id="return">4.8.4 return</h4></li></ul></li></ul><hr /><h2 id="数组排序和查找">5 <ahref="../../../../../../2021/11/27/Java/入门阶段/5%20%E6%95%B0%E7%BB%84%E3%80%81%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/">数组、排序和查找</a></h2><ul><li><h3 id="一维数组">5.1 <ahref="../../../../../../2021/11/27/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/5%20%E6%95%B0%E7%BB%84%E3%80%81%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/#5-1-%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84">一维数组</a></h3><ul><li><h4 id="数组赋值机制">5.1.1 <ahref="../../../../../../2021/11/27/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/5%20%E6%95%B0%E7%BB%84%E3%80%81%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/#5-1-1-%E6%95%B0%E7%BB%84%E8%B5%8B%E5%80%BC%E6%9C%BA%E5%88%B6">数组赋值机制</a></h4></li><li><h4 id="数组的扩容">5.1.2 <ahref="../../../../../../2021/11/27/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/5%20%E6%95%B0%E7%BB%84%E3%80%81%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/#5-1-2-%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%AE%B9">数组的扩容</a></h4></li></ul></li><li><h3 id="二维数组">5.2 <ahref="../../../../../../2021/11/27/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/5%20%E6%95%B0%E7%BB%84%E3%80%81%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/#5-2-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84">二维数组</a></h3></li><li><h3 id="查找算法">5.3 <ahref="../../../../../../2021/11/27/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/5%20%E6%95%B0%E7%BB%84%E3%80%81%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/#5-3-%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95">查找算法</a></h3><ul><li><h4 id="线性查找">5.3.1 <ahref="../../../../../../2021/11/27/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/5%20%E6%95%B0%E7%BB%84%E3%80%81%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/#5-3-1-%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE">线性查找</a></h4></li><li><h4 id="二分查找">5.3.2 <ahref="../../../../../../2021/11/27/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/5%20%E6%95%B0%E7%BB%84%E3%80%81%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/#5-3-2-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">二分查找</a></h4></li><li><h4 id="插值查找">5.3.3 <ahref="../../../../../../2021/11/27/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/5%20%E6%95%B0%E7%BB%84%E3%80%81%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/#5-3-3-%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE">插值查找</a></h4></li><li><h4 id="斐波那契查找">5.3.4 <ahref="../../../../../../2021/11/27/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/5%20%E6%95%B0%E7%BB%84%E3%80%81%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/#5-3-4-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE">斐波那契查找</a></h4></li></ul></li><li><h3 id="排序算法">5.4 <ahref="../../../../../../2021/11/27/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/5%20%E6%95%B0%E7%BB%84%E3%80%81%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/#5-4-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">排序算法</a></h3><ul><li><h4 id="冒泡排序">5.4.1 <ahref="../../../../../../2021/11/27/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/5%20%E6%95%B0%E7%BB%84%E3%80%81%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/#5-4-1-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">冒泡排序</a></h4></li><li><h4 id="选择排序">5.4.2 <ahref="../../../../../../2021/11/27/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/5%20%E6%95%B0%E7%BB%84%E3%80%81%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/#5-4-2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">选择排序</a></h4></li><li><h4 id="插入排序">5.4.3 <ahref="../../../../../../2021/11/27/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/5%20%E6%95%B0%E7%BB%84%E3%80%81%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/#5-4-3-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">插入排序</a></h4></li><li><h4 id="希尔排序">5.4.4 <ahref="../../../../../../2021/11/27/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/5%20%E6%95%B0%E7%BB%84%E3%80%81%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/#5-4-4-%E5%B8%8C%E5%84%BF%E6%8E%92%E5%BA%8F">希尔排序</a></h4></li><li><h4 id="快速排序">5.4.5 <ahref="../../../../../../2021/11/27/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/5%20%E6%95%B0%E7%BB%84%E3%80%81%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/#5-4-5-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a></h4></li><li><h4 id="归并排序">5.4.6 <ahref="../../../../../../2021/11/27/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/5%20%E6%95%B0%E7%BB%84%E3%80%81%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/#5-4-6-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">归并排序</a></h4></li><li><h4 id="基数排序">5.4.7 <ahref="../../../../../../2021/11/27/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/5%20%E6%95%B0%E7%BB%84%E3%80%81%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/#5-4-7-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F">基数排序</a></h4></li><li><h4 id="堆排序">5.4.8 <ahref="../../../../../../2021/11/27/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/5%20%E6%95%B0%E7%BB%84%E3%80%81%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/#5-4-8-%E5%A0%86%E6%8E%92%E5%BA%8F">堆排序</a></h4></li></ul></li></ul><hr /><h2 id="面向对象编程基础">6 <ahref="../../../../../../2021/11/29/Java/入门阶段/6%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/">面向对象编程（基础）</a></h2><ul><li><h3 id="类与对象oop">6.1 <ahref="../../../../../../2021/11/29/Java/入门阶段/6%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/#6-1-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88OOP%EF%BC%89">类与对象（OOP）</a></h3><ul><li><h4 id="属性成员变量">6.1.1 属性/成员变量</h4></li><li><h4 id="创建对象">6.1.2 创建对象</h4></li><li><h4 id="类与对象的内存访问机制">6.1.3类与对象的内存访问机制</h4></li></ul></li><li><h3 id="成员方法">6.2 <ahref="../../../../../../2021/11/29/Java/入门阶段/6%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/#6-2-%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95">成员方法</a></h3><ul><li><h4 id="方法的调用机制">6.2.1 方法的调用机制</h4></li><li><h4 id="使用细节-11">6.2.2 使用细节</h4></li><li><h4 id="成员方法传参机制">6.2.3 成员方法传参机制</h4></li></ul></li><li><h3 id="方法递归调用">6.3 <ahref="../../../../../../2021/11/29/Java/入门阶段/6%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/#6-3-%E6%96%B9%E6%B3%95%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8">方法递归调用</a></h3><ul><li><h4 id="使用细节-12">6.3.1 使用细节</h4></li></ul></li><li><h3 id="方法重载">6.4 <ahref="../../../../../../2021/11/29/Java/入门阶段/6%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/#6-4-%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD">方法重载</a></h3></li><li><h3 id="可变参数">6.5 <ahref="../../../../../../2021/11/29/Java/入门阶段/6%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/#6-5-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0">可变参数</a></h3><ul><li><h4 id="使用细节-13">6.5.1 使用细节</h4></li></ul></li><li><h3 id="作用域">6.6 <ahref="../../../../../../2021/11/29/Java/入门阶段/6%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/#6-6-%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89">作用域</a></h3><ul><li><h4 id="使用细节-14">6.6.1 使用细节</h4></li></ul></li><li><h3 id="构造方法构造器">6.7 <ahref="../../../../../../2021/11/29/Java/入门阶段/6%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/#6-7-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E3%80%81%E6%9E%84%E9%80%A0%E5%99%A8">构造方法、构造器</a></h3><ul><li><h4 id="使用细节-15">6.7.1 使用细节</h4></li><li><h4 id="流程分析">6.7.2 流程分析</h4></li></ul></li><li><h3 id="this-关键字">6.8 <ahref="../../../../../../2021/11/29/Java/入门阶段/6%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/#6-8-this-%E5%85%B3%E9%94%AE%E5%AD%97">this关键字</a></h3><ul><li><h4 id="使用方法">6.8.1 使用方法</h4></li></ul></li><li><h3 id="附录-2">附录</h3><h3 id="迷宫游戏代码"><ahref="../../../../../../2021/11/29/Java/入门阶段/6%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/#%E8%BF%B7%E5%AE%AB%E6%B8%B8%E6%88%8F%E4%BB%A3%E7%A0%81">迷宫游戏代码</a></h3><h3 id="八皇后代码"><ahref="../../../../../../2021/11/29/Java/入门阶段/6%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/#%E5%85%AB%E7%9A%87%E5%90%8E%E4%BB%A3%E7%A0%81">八皇后代码</a></h3></li></ul><hr /><h2 id="面向对象编程中级">7 <ahref="../../../../../../2021/12/05/Java/入门阶段/7%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%AD%E7%BA%A7%EF%BC%89/">面向对象编程（中级）</a></h2><ul><li><h3 id="idea-的使用">7.1 <ahref="../../../../../../2021/12/05/Java/入门阶段/7%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%AD%E7%BA%A7%EF%BC%89/#7-1-IDEA-%E7%9A%84%E4%BD%BF%E7%94%A8">IDEA的使用</a></h3><ul><li><h4 id="常用快捷键">7.1.1 常用快捷键</h4></li><li><h4 id="模板快捷键">7.1.2 模板快捷键</h4></li></ul></li><li><h3 id="包">7.2 <ahref="../../../../../../2021/12/05/Java/入门阶段/7%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%AD%E7%BA%A7%EF%BC%89/#7-2-%E5%8C%85">包</a></h3></li><li><h3 id="访问修饰符">7.3 <ahref="../../../../../../2021/12/05/Java/入门阶段/7%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%AD%E7%BA%A7%EF%BC%89/#7-3-%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6">访问修饰符</a></h3><ul><li><h4 id="访问权限特点">7.3.1 访问权限特点</h4></li><li><h4 id="使用说明">7.3.2 使用说明</h4></li></ul></li><li><h3 id="封装">7.4 <ahref="../../../../../../2021/12/05/Java/入门阶段/7%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%AD%E7%BA%A7%EF%BC%89/#7-4-%E5%B0%81%E8%A3%85%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89">封装</a></h3><ul><li><h4 id="静态导入">7.4.1 静态导入</h4></li><li><h4 id="jar-文件">7.4.2 JAR 文件</h4></li></ul></li><li><h3 id="继承">7.5 <ahref="../../../../../../2021/12/05/Java/入门阶段/7%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%AD%E7%BA%A7%EF%BC%89/#7-5-%E7%BB%A7%E6%89%BF%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89">继承</a></h3><ul><li><h4 id="使用细节-16">7.5.1 使用细节</h4></li><li><h4 id="继承的本质">7.5.2 继承的本质</h4></li><li><h4 id="super-关键字">7.5.3 <code>super</code> 关键字</h4></li><li><h4 id="方法重写覆盖">7.5.4 方法重写/覆盖</h4></li></ul></li><li><h3 id="多态">7.6 <ahref="../../../../../../2021/12/05/Java/入门阶段/7%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%AD%E7%BA%A7%EF%BC%89/#7-6-%E5%A4%9A%E6%80%81%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89">多态</a></h3><ul><li><h4 id="多态的体现">7.6.1 多态的体现</h4></li><li><h4 id="使用细节-17">7.6.2 使用细节</h4></li><li><h4 id="理解方法调用">7.6.3 理解方法调用</h4></li></ul></li><li><h3 id="object-类">7.7 <ahref="../../../../../../2021/12/05/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/7%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%AD%E7%BA%A7%EF%BC%89/#7-7-Object-%E7%B1%BB">Object类</a></h3><ul><li><h4 id="equals-方法">7.7.1 equals 方法</h4></li><li><h4 id="hashcode-方法">7.7.2 hashCode 方法</h4></li><li><h4 id="tostring-方法">7.7.3 toString 方法</h4></li><li><h4 id="finalize-方法">7.7.4 finalize 方法</h4></li></ul></li><li><h3 id="断点调试debug">7.8 <ahref="../../../../../../2021/12/05/Java/入门阶段/7%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%AD%E7%BA%A7%EF%BC%89/#7-8-%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95%EF%BC%88Debug%EF%BC%89">断点调试（Debug）</a></h3></li><li><h3 id="附录-3">附录</h3><h3 id="零钱通程序"><ahref="../../../../../../2021/12/05/Java/入门阶段/7%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%AD%E7%BA%A7%EF%BC%89/#%E9%9B%B6%E9%92%B1%E9%80%9A%E7%A8%8B%E5%BA%8F">零钱通程序</a></h3></li></ul><hr /><h2 id="项目房屋出租系统">8 <ahref="../../../../../../2021/12/13/Java/入门阶段/8%20%E9%A1%B9%E7%9B%AE%EF%BC%9A%E6%88%BF%E5%B1%8B%E5%87%BA%E7%A7%9F%E7%B3%BB%E7%BB%9F/">项目：房屋出租系统</a></h2><p>2021.12.13 20:12 第一阶段完成</p><hr /><h2 id="面向对象编程高级">9 <ahref="../../../../../../2021/12/14/Java/入门阶段/9%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/">面向对象编程（高级）</a></h2><ul><li><h3 id="类变量和类方法">9.1 <ahref="../../../../../../2021/12/14/Java/入门阶段/9%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/#9-1-%E7%B1%BB%E5%8F%98%E9%87%8F%E5%92%8C%E7%B1%BB%E6%96%B9%E6%B3%95">类变量和类方法</a></h3><ul><li><h4 id="类变量">9.1.1 类变量</h4></li><li><h4 id="类方法">9.1.2 类方法</h4></li></ul></li><li><h3 id="理解-main-方法语法">9.2 <ahref="../../../../../../2021/12/14/Java/入门阶段/9%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/#9-2-%E7%90%86%E8%A7%A3-main-%E6%96%B9%E6%B3%95%E8%AF%AD%E6%B3%95">理解<code>main</code> 方法语法</a></h3></li><li><h3 id="代码块">9.3 <ahref="../../../../../../2021/12/14/Java/入门阶段/9%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/#9-3-%E4%BB%A3%E7%A0%81%E5%9D%97">代码块</a></h3><ul><li><h4 id="使用细节-18">9.3.1 使用细节</h4></li></ul></li><li><h3 id="单例设计模式">9.4 <ahref="../../../../../../2021/12/14/Java/入门阶段/9%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/#9-4-%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">单例设计模式</a></h3><ul><li><h4 id="应用实例">9.4.1 应用实例</h4><ul><li><h5 id="饿汉式">9.4.1.1 饿汉式</h5></li><li><h5 id="懒汉式">9.4.1.2 懒汉式</h5></li><li><h5 id="两种方法对比">9.4.1.3 两种方法对比</h5></li></ul></li></ul></li><li><h3 id="final-关键字">9.5 <ahref="../../../../../../2021/12/14/Java/入门阶段/9%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/#9-5-final-%E5%85%B3%E9%94%AE%E5%AD%97"><code>final</code>关键字</a></h3><ul><li><h4 id="使用细节-19">9.5.1 使用细节</h4></li></ul></li><li><h3 id="抽象类">9.6 <ahref="../../../../../../2021/12/14/Java/入门阶段/9%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/#9-6-%E6%8A%BD%E8%B1%A1%E7%B1%BB">抽象类</a></h3><ul><li><h4 id="使用细节-20">9.6.1 使用细节</h4></li><li><h4 id="模板设计模式">9.6.2 模板设计模式</h4></li></ul></li><li><h3 id="接口">9.7 <ahref="../../../../../../2021/12/14/Java/入门阶段/9%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/#9-7-%E6%8E%A5%E5%8F%A3">接口</a></h3><ul><li><h4 id="使用细节-21">9.7.1 使用细节</h4></li><li><h4 id="实现接口-vs-继承类">9.7.2 实现接口 vs 继承类</h4></li><li><h4 id="接口的多态特性">9.7.3 接口的多态特性</h4></li></ul></li><li><h3 id="内部类">9.8 <ahref="../../../../../../2021/12/14/Java/入门阶段/9%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/#9-8-%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88%E9%87%8D%E9%9A%BE%E7%82%B9%EF%BC%89">内部类</a></h3><ul><li><h4 id="四种内部类">9.8.1 四种内部类</h4></li><li><h4 id="局部内部类">9.8.2 局部内部类</h4><ul><li><h5 id="使用细节-22">9.8.2.1 使用细节</h5></li></ul></li><li><h4 id="匿名内部类">9.8.3 匿名内部类</h4><ul><li><h5 id="使用细节-23">9.8.3.1 使用细节</h5></li><li><h5 id="使用场景">9.8.3.2 使用场景</h5></li></ul></li><li><h4 id="成员内部类">9.8.4 成员内部类</h4><ul><li><h5 id="使用细节-24">9.8.4.1 使用细节</h5></li></ul></li><li><h4 id="静态内部类">9.8.5 静态内部类</h4><ul><li><h5 id="使用细节-25">9.8.5.1 使用细节</h5></li></ul></li></ul></li></ul><hr /><h2 id="枚举和注解">10 <ahref="../../../../../../2021/12/17/Java/入门阶段/10%20%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3/">枚举和注解</a></h2><ul><li><h3 id="枚举">10.1 <ahref="../../../../../../2021/12/17/Java/入门阶段/10%20%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3/#10-1-%E6%9E%9A%E4%B8%BE">枚举</a></h3><ul><li><h4 id="自定义枚举">10.1.1 自定义枚举</h4></li><li><h4 id="enum-关键字">10.1.2 enum 关键字</h4><ul><li><h5 id="使用细节-26">10.1.2.1 使用细节</h5></li><li><h5 id="enum-类中的常用方法">10.1.2.2 Enum 类中的常用方法</h5></li></ul></li></ul></li><li><h3 id="注解">10.2 <ahref="../../../../../../2021/12/17/Java/入门阶段/10%20%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3/#10-2-%E6%B3%A8%E8%A7%A3">注解</a></h3><ul><li><h4 id="override">10.2.1 <span class="citation"data-cites="Override">@Override</span></h4></li><li><h4 id="deprecated">10.2.2 <span class="citation"data-cites="Deprecated">@Deprecated</span></h4></li><li><h4 id="suppresswarnings">10.2.3 <span class="citation"data-cites="SuppressWarnings">@SuppressWarnings</span>()</h4></li><li><h4 id="jdk-的元注解了解即可">10.2.4 JDK的元注解（了解即可）</h4></li></ul></li></ul><hr /><h2 id="异常">11 <ahref="../../../../../../2021/12/18/Java/入门阶段/11%20%E5%BC%82%E5%B8%B8/">异常</a></h2><ul><li><h3 id="异常体系图">11.1 <ahref="../../../../../../2021/12/18/Java/入门阶段/11%20%E5%BC%82%E5%B8%B8/#11-1-%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E5%9B%BE%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89">异常体系图</a></h3><ul><li><h4 id="常见的运行时异常">11.1.1 常见的运行时异常</h4></li><li><h4 id="常见的编译异常">11.1.2 常见的编译异常</h4></li></ul></li><li><h3 id="异常处理">11.2 <ahref="../../../../../../2021/12/18/Java/入门阶段/11%20%E5%BC%82%E5%B8%B8/#11-2-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">异常处理</a></h3><ul><li><h4 id="try---catch-异常处理">11.2.1 try - catch 异常处理</h4><ul><li><h5 id="使用细节-27">11.2.1.1 使用细节</h5></li></ul></li><li><h4 id="throws-异常处理">11.2.2 throws 异常处理</h4><ul><li><h5 id="使用细节-28">11.2.2.1 使用细节</h5></li></ul></li></ul></li><li><h3 id="自定义异常">11.3 <ahref="../../../../../../2021/12/18/Java/入门阶段/11%20%E5%BC%82%E5%B8%B8/#11-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8">自定义异常</a></h3><ul><li><h4 id="throw-和-throws">11.3.1 throw 和 throws</h4></li></ul></li></ul><hr /><h2 id="常用类">12 <ahref="../../../../../../2021/12/19/Java/入门阶段/12%20%E5%B8%B8%E7%94%A8%E7%B1%BB/">常用类</a></h2><ul><li><h3 id="包装类">12.1 <ahref="../../../../../../2021/12/19/Java/入门阶段/12%20%E5%B8%B8%E7%94%A8%E7%B1%BB/#12-1-%E5%8C%85%E8%A3%85%E7%B1%BB">包装类</a></h3><ul><li><h4 id="装箱和拆箱">12.1.1 装箱和拆箱</h4></li><li><h4 id="包装类和-string-的相互转换">12.1.2 包装类和 String的相互转换</h4></li><li><h4 id="包装类的常用方法">12.1.3 包装类的常用方法</h4></li><li><h4 id="strictfp-关键字">12.1.4 strictfp 关键字</h4></li></ul></li><li><h3 id="string-类">12.2 <ahref="../../../../../../2021/12/19/Java/入门阶段/12%20%E5%B8%B8%E7%94%A8%E7%B1%BB/#12-2-String-%E7%B1%BB">String类</a></h3><ul><li><h4 id="string-构造方法">12.2.1 String 构造方法</h4></li><li><h4 id="字符串的特性">12.2.2 字符串的特性</h4></li><li><h4 id="string-的常用方法">12.2.3 String 的常用方法</h4></li></ul></li><li><h3 id="stringbuffer-类">12.3 <ahref="../../../../../../2021/12/19/Java/入门阶段/12%20%E5%B8%B8%E7%94%A8%E7%B1%BB/#12-3-StringBuffer-%E7%B1%BB">StringBuffer类</a></h3><ul><li><h4 id="stringbuffer-构造方法">12.3.1 StringBuffer构造方法</h4></li><li><h4 id="string-和-stringbuffer-的转换">12.3.2 String 和 StringBuffer的转换</h4></li><li><h4 id="stringbuffer-的常用方法">12.3.3 StringBuffer的常用方法</h4></li></ul></li><li><h3 id="stringbuilder-类">12.4 <ahref="../../../../../../2021/12/19/Java/入门阶段/12%20%E5%B8%B8%E7%94%A8%E7%B1%BB/#12-4-StringBuilder-%E7%B1%BB">StringBuilder类</a></h3><ul><li><h4 id="stringstringbufferstringbuilder-的对比">12.4.1String、StringBuffer、StringBuilder 的对比</h4></li></ul></li><li><h3 id="math-类">12.5 <ahref="../../../../../../2021/12/19/Java/入门阶段/12%20%E5%B8%B8%E7%94%A8%E7%B1%BB/#12-5-Math-%E7%B1%BB">Math类</a></h3></li><li><h3 id="arrays-类">12.6 <ahref="../../../../../../2021/12/19/Java/入门阶段/12%20%E5%B8%B8%E7%94%A8%E7%B1%BB/#12-6-Arrays-%E7%B1%BB">Arrays类</a></h3></li><li><h3 id="system-类">12.7 <ahref="../../../../../../2021/12/19/Java/入门阶段/12%20%E5%B8%B8%E7%94%A8%E7%B1%BB/#12-7-System-%E7%B1%BB">System类</a></h3></li><li><h3 id="biginteger-和-bigdecimal-类">12.8 <ahref="../../../../../../2021/12/19/Java/入门阶段/12%20%E5%B8%B8%E7%94%A8%E7%B1%BB/#12-8-BigInteger-%E5%92%8C-BigDecimal-%E7%B1%BB">BigInteger和 BigDecimal 类</a></h3></li><li><h3 id="日期类">12.9 <ahref="../../../../../../2021/12/19/Java/入门阶段/12%20%E5%B8%B8%E7%94%A8%E7%B1%BB/#12-9-%E6%97%A5%E6%9C%9F%E7%B1%BB">日期类</a></h3><ul><li><h4 id="第一代日期类">12.9.1 第一代日期类</h4></li><li><h4 id="第二代日期类">12.9.2 第二代日期类</h4></li><li><h4 id="第三代日期类">12.9.3 第三代日期类</h4></li></ul></li><li><h3 id="泛型">12.10 <ahref="../../../../../../2021/12/19/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/12%20%E5%B8%B8%E7%94%A8%E7%B1%BB/#12-10-%E6%B3%9B%E5%9E%8B">泛型</a></h3></li></ul><hr /><h2 id="java-数据结构">13 <ahref="../../../../../../2022/05/29/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/13%20Java%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">Java数据结构</a></h2><ul><li><h3 id="集合的框架体系">13.1 <ahref="../../../../../../2022/05/29/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/13%20Java%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#13-1-%E9%9B%86%E5%90%88%E7%9A%84%E6%A1%86%E6%9E%B6%E4%BD%93%E7%B3%BB">集合的框架体系</a></h3></li><li><h3 id="单列集合接口-collection">13.2 <ahref="../../../../../../2022/05/29/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/13%20Java%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#13-2-%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88%E6%8E%A5%E5%8F%A3-Collection">单列集合接口Collection</a></h3><ul><li><h4 id="迭代器-iterator">13.2.1 <ahref="../../../../../../2022/05/29/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/13%20Java%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#13-2-1-%E8%BF%AD%E4%BB%A3%E5%99%A8-Iterator">迭代器Iterator</a></h4></li></ul></li><li><h3 id="有序集合接口-list">13.3 <ahref="../../../../../../2022/05/29/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/13%20Java%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#13-3-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E6%8E%A5%E5%8F%A3-List">有序集合接口List</a></h3><ul><li><h4 id="可变数组-arraylist">13.3.1 <ahref="../../../../../../2022/05/29/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/13%20Java%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#13-3-1-%E5%8F%AF%E5%8F%98%E6%95%B0%E7%BB%84-ArrayList">可变数组ArrayList</a></h4></li><li><h4 id="可变数组-vector">13.3.2 <ahref="../../../../../../2022/05/29/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/13%20Java%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#13-3-2-%E5%8F%AF%E5%8F%98%E6%95%B0%E7%BB%84-Vector">可变数组Vector</a></h4></li><li><h4 id="链表-linkedlist">13.3.3 <ahref="../../../../../../2022/05/29/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/13%20Java%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#13-3-3-%E9%93%BE%E8%A1%A8-LinkedList">链表LinkedList</a></h4></li><li><h4 id="稀疏数组">13.3.4 <ahref="../../../../../../2022/05/29/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/13%20Java%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#13-3-4-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84">稀疏数组</a></h4></li><li><h4 id="栈-stack">13.3.5 <ahref="../../../../../../2022/05/29/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/13%20Java%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#13-3-5-%E6%A0%88-Stack">栈Stack</a></h4><ul><li><h5 id="栈模拟计算器">13.3.5.1 <ahref="../../../../../../2022/05/29/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/13%20Java%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#13-3-5-1-%E6%A0%88%E6%A8%A1%E6%8B%9F%E8%AE%A1%E7%AE%97%E5%99%A8">栈模拟计算器</a></h5></li></ul></li><li><h4 id="跳表-skiplist">13.3.6 <ahref="../../../../../../2022/05/29/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/13%20Java%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#13-3-6-跳表-SkipList">跳表SkipList</a></h4></li></ul></li><li><h3 id="队列接口-queue">13.4 <ahref="../../../../../../2022/05/29/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/13%20Java%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#13-4-%E9%98%9F%E5%88%97%E6%8E%A5%E5%8F%A3-Queue">队列接口Queue</a></h3><ul><li><h4 id="优先级队列-priorityqueue">13.4.1 <ahref="../../../../../../2022/05/29/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/13%20Java%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#13-4-1-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97-PriorityQueue">优先级队列PriorityQueue</a></h4></li><li><h4 id="阻塞队列接口-blockingqueue">13.4.2 <ahref="../../../../../../2022/05/29/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/13%20Java%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#13-4-2-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E6%8E%A5%E5%8F%A3-BlockingQueue">阻塞队列接口BlockingQueue</a></h4></li></ul></li><li><h3 id="双列集合接口-map">13.5 <ahref="../../../../../../2022/05/29/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/13%20Java%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#13-5-%E5%8F%8C%E5%88%97%E9%9B%86%E5%90%88%E6%8E%A5%E5%8F%A3-Map">双列集合接口Map</a></h3><ul><li><h4 id="散列表-hashmap">13.5.1 <ahref="../../../../../../2022/05/29/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/13%20Java%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#13-5-1-%E6%95%A3%E5%88%97%E8%A1%A8-HashMap">散列表HashMap</a></h4></li><li><h4 id="散列表-hashtable">13.5.2 <ahref="../../../../../../2022/05/29/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/13%20Java%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#13-5-2-%E6%95%A3%E5%88%97%E8%A1%A8-Hashtable">散列表Hashtable</a></h4></li><li><h4 id="红黑树-treemap">13.5.3 <ahref="../../../../../../2022/05/29/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/13%20Java%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#13-5-3-%E7%BA%A2%E9%BB%91%E6%A0%91-TreeMap">红黑树TreeMap</a></h4><ul><li><h5 id="二叉树">13.5.3.1 <ahref="../../../../../../2022/05/29/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/13%20Java%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#13-5-3-1-%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A">二叉树</a></h5></li></ul></li><li><h4 id="properties">13.5.4 <ahref="../../../../../../2022/05/29/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/13%20Java%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#13-5-4-Properties">Properties</a></h4></li></ul></li><li><h3 id="无序集合接口-set">13.6 <ahref="../../../../../../2022/05/29/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/13%20Java%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#13-6-%E6%97%A0%E5%BA%8F%E9%9B%86%E5%90%88%E6%8E%A5%E5%8F%A3-Set">无序集合接口Set</a></h3><ul><li><h4 id="hashset">13.6.1 <ahref="../../../../../../2022/05/29/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/13%20Java%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#13-6-1-HashSet">HashSet</a></h4></li><li><h4 id="linkedhashset">13.6.2 <ahref="../../../../../../2022/05/29/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/13%20Java%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#13-6-2-LinkedHashSet">LinkedHashSet</a></h4></li><li><h4 id="treeset">13.6.3 <ahref="../../../../../../2022/05/29/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/13%20Java%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#13-6-3-TreeSet">TreeSet</a></h4></li></ul></li><li><h3 id="集合的选择">13.7 <ahref="../../../../../../2022/05/29/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/13%20Java%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#13-7-%E9%9B%86%E5%90%88%E7%9A%84%E9%80%89%E6%8B%A9">集合的选择</a></h3></li><li><h3 id="工具类-collections">13.8 <ahref="../../../../../../2022/05/29/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/13%20Java%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#13-8-%E5%B7%A5%E5%85%B7%E7%B1%BB-Collections">工具类Collections</a></h3></li><li><h3 id="junit">13.9 <ahref="../../../../../../2022/05/29/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/13%20Java%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#13-9-JUnit">JUnit</a></h3></li></ul><hr /><h2 id="树">14 <ahref="../../../../../../2022/06/02/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/14%20%E6%A0%91/">树</a></h2><ul><li><h3 id="二叉树-1">14.1 <ahref="../../../../../../2022/06/02/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/14%20%E6%A0%91/#14-1-%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A">二叉树</a></h3><ul><li><h4 id="顺序存储二叉树">14.1.1 <ahref="../../../../../../2022/06/02/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/14%20%E6%A0%91/#14-1-1-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91">顺序存储二叉树</a></h4></li><li><h4 id="线索化二叉树">14.1.2 <ahref="../../../../../../2022/06/02/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/14%20%E6%A0%91/#14-1-2-%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91">线索化二叉树</a></h4></li><li><h4 id="赫夫曼树">14.1.3 <ahref="../../../../../../2022/06/02/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/14%20%E6%A0%91/#14-1-3-%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91">赫夫曼树</a></h4></li><li><h4 id="二叉排序树">14.1.4 <ahref="../../../../../../2022/06/02/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/14%20%E6%A0%91/#14-1-4-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91">二叉排序树</a></h4><ul><li><h5 id="平衡二叉树">14.1.4.1 <ahref="../../../../../../2022/06/02/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/14%20%E6%A0%91/#14-1-4-1-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91">平衡二叉树</a></h5></li></ul></li><li><h4 id="线段树">14.1.5 <ahref="../../../../../../2022/06/02/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/14%20%E6%A0%91/#14-1-4-线段树">线段树</a></h4></li></ul></li><li><h3 id="多路查找树">14.2 <a href="">多路查找树</a></h3><ul><li><h4 id="树-1">14.2.1 <ahref="../../../../../../2022/06/02/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/14%20%E6%A0%91/#14-2-1-2-3-%E6%A0%91">2-3树</a></h4></li><li><h4 id="b-树">14.2.2 <ahref="../../../../../../2022/06/02/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/14%20%E6%A0%91/#14-2-2-B-%E6%A0%91">B树</a></h4></li></ul></li><li><h3 id="图">14.3 <ahref="../../../../../../2022/06/02/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/14%20%E6%A0%91/#14-3-%E5%9B%BE">图</a></h3><ul><li><h4 id="深度优先搜索-dfs">14.3.1 <ahref="../../../../../../2022/06/02/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/14%20%E6%A0%91/#14-3-1-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-DFS">深度优先搜索DFS</a></h4></li><li><h4 id="广度优先搜索-bfs">14.3.2 <ahref="../../../../../../2022/06/02/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/14%20%E6%A0%91/#14-3-2-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-BFS">广度优先搜索BFS</a></h4></li></ul></li><li><h3 id="附录-4">附录</h3><ul><li><h4 id="f1-实现赫夫曼编码解码">F1 实现赫夫曼编码/解码</h4></li><li><h4 id="f2-实现平衡二叉树">F2 实现平衡二叉树</h4></li></ul></li></ul><hr /><h2 id="图形界面设计">15 <ahref="../../../../../../2022/04/22/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/15%20%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1/">图形界面设计</a></h2><ul><li><h3 id="容器">15.1 <ahref="../../../../../../2022/04/22/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/15%20%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1/#15-1-%E5%AE%B9%E5%99%A8">容器</a></h3><ul><li><h4 id="顶层容器">15.1.1 顶层容器</h4></li><li><h4 id="内容窗格">15.1.2 内容窗格</h4></li><li><h4 id="面板">15.1.3 面板</h4><ul><li><h5 id="jpanel">15.1.3.1 JPanel</h5></li><li><h5 id="jscrollpanel">15.1.3.2 JScrollPanel</h5></li><li><h5 id="scrollbar">15.1.3.3 Scrollbar</h5></li></ul></li></ul></li><li><h3 id="标签和按钮">15.2 <ahref="../../../../../../2022/04/22/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/15%20%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1/#15-2-%E6%A0%87%E7%AD%BE%E5%92%8C%E6%8C%89%E9%92%AE">标签和按钮</a></h3><ul><li><h4 id="标签-1">15.2.1 标签</h4></li><li><h4 id="按钮">15.2.2 按钮</h4><ul><li><h5 id="jbutton">15.2.2.1 JButton</h5></li><li><h5 id="jtogglebuttonjcheckbuttonjradiobutton">15.2.2.2JToggleButton、JCheckButton、JRadioButton</h5></li></ul></li></ul></li><li><h3 id="布局管理器">15.3 <ahref="../../../../../../2022/04/22/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/15%20%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1/#15-3-%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8">布局管理器</a></h3><ul><li><h4 id="flowlayout-流布局管理器">15.3.1 FlowLayout流布局管理器</h4></li><li><h4 id="borderlayout-边界布局管理器">15.3.2 BorderLayout边界布局管理器</h4></li><li><h4 id="gridlayout-网格布局管理器">15.3.3 GridLayout网格布局管理器</h4></li><li><h4 id="cardlayout-卡片式布局管理器">15.3.4 CardLayout卡片式布局管理器</h4></li><li><h4 id="boxlayout-方框布局管理器">15.3.5 BoxLayout方框布局管理器</h4></li><li><h4 id="空布局">15.3.6 空布局</h4></li></ul></li><li><h3 id="事件处理">15.4 <ahref="../../../../../../2022/04/22/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/15%20%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1/#15-4-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86">事件处理</a></h3><ul><li><h4 id="事件处理模型">15.4.1 事件处理模型</h4></li><li><h4 id="事件的种类">15.4.2 事件的种类</h4></li><li><h4 id="事件适配器">15.4.3 事件适配器</h4></li></ul></li><li><h3 id="java-绘图技术">15.5 <ahref="../../../../../../2022/04/22/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/15%20%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1/#15-5-Java-%E7%BB%98%E5%9B%BE%E6%8A%80%E6%9C%AF">Java绘图技术</a></h3><ul><li><h4 id="颜色">15.5.1 颜色</h4></li><li><h4 id="字体">15.5.2 字体</h4></li><li><h4 id="graphics-类">15.5.3 Graphics 类</h4><ul><li><h5 id="polygon-类">15.5.3.1 Polygon 类</h5></li></ul></li><li><h4 id="graphics2d-类">15.5.4 Graphics2D 类</h4><ul><li><h5 id="图形状态属性">15.5.4.1 图形状态属性</h5></li><li><h5 id="graphics2d-的绘图方法">15.5.4.2 Graphics2D的绘图方法</h5></li><li><h5 id="graphics2d-中的几何图形类">15.5.4.3 Graphics2D中的几何图形类</h5></li></ul></li></ul></li><li><h3 id="组合框与列表">15.6 <ahref="../../../../../../2022/04/22/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/15%20%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1/#15-6-%E7%BB%84%E5%90%88%E6%A1%86%E4%B8%8E%E5%88%97%E8%A1%A8">组合框与列表</a></h3><ul><li><h4 id="jcombobox-组合框">15.6.1 JComboBox 组合框</h4></li><li><h4 id="jlist-列表">15.6.2 JList 列表</h4></li></ul></li><li><h3 id="文本组件">15.7 <ahref="../../../../../../2022/04/22/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/15%20%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1/#15-7-%E6%96%87%E6%9C%AC%E7%BB%84%E4%BB%B6">文本组件</a></h3><ul><li><h4 id="jtextfield-文本域">15.7.1 JTextField 文本域</h4></li><li><h4 id="jtextarea-文本区">15.7.2 JTextArea 文本区</h4></li></ul></li><li><h3 id="菜单组件">15.8 <ahref="../../../../../../2022/04/22/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/15%20%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1/#15-8-%E8%8F%9C%E5%8D%95%E7%BB%84%E4%BB%B6">菜单组件</a></h3><ul><li><h4 id="菜单栏及菜单">15.8.1 菜单栏及菜单</h4></li><li><h4 id="jmenuitem-菜单项">15.8.2 JMenuItem 菜单项</h4></li><li><h4 id="复选菜单项和单选菜单项">15.8.3复选菜单项和单选菜单项</h4></li></ul></li><li><h3 id="对话框">15.9 <ahref="../../../../../../2022/04/22/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/15%20%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1/#15-9-%E5%AF%B9%E8%AF%9D%E6%A1%86">对话框</a></h3><ul><li><h4 id="jdialog-自定义对话框">15.9.1 JDialog 自定义对话框</h4></li><li><h4 id="joptionalpane-标准对话框">15.9.2 JOptionalPane标准对话框</h4></li><li><h4 id="jfilechooser-文件对话框">15.9.3 JFileChooser文件对话框</h4></li></ul></li></ul><hr /><h2 id="多线程">16 <ahref="../../../../../../2022/01/01/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/16%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></h2><ul><li><h3 id="线程的概念">16.1 <ahref="../../../../../../2022/01/01/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/16%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/#16-1-%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5">线程的概念</a></h3><ul><li><h4 id="线程的结构">16.1.1 线程的结构</h4></li><li><h4 id="线程的状态">16.1.2 线程的状态</h4></li></ul></li><li><h3 id="线程的使用">16.2 <ahref="../../../../../../2022/01/01/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/16%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/#16-2-%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8">线程的使用</a></h3><ul><li><h4 id="继承-thread-类">16.2.1 继承 Thread 类</h4></li><li><h4 id="实现-runable-接口">16.2.2 实现 Runable 接口</h4></li><li><h4 id="继承-thread-和-实现-runable-的区别">16.2.3 继承 Thread 和实现 Runable 的区别</h4></li><li><h4 id="线程中止">16.2.4 线程中止</h4></li><li><h4 id="线程常用方法">16.2.5 线程常用方法</h4></li><li><h4 id="用户线程和守护线程">16.2.6 用户线程和守护线程</h4></li><li><h4 id="线程的生命周期">16.2.7 线程的生命周期</h4></li></ul></li><li><h3 id="线程的互斥">16.3 <ahref="../../../../../../2022/01/01/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/16%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/#16-3-%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%92%E6%96%A5">线程的互斥</a></h3><ul><li><h4 id="互斥锁">16.3.1 互斥锁</h4></li><li><h4 id="线程死锁">16.3.2 线程死锁</h4></li></ul></li><li><h3 id="线程的同步">16.4 <ahref="../../../../../../2022/01/01/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/16%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/#16-4-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5">线程的同步</a></h3></li></ul><hr /><h2 id="io-流">17 <ahref="../../../../../../2022/01/06/Java/入门阶段/17%20IO%E6%B5%81/">IO流</a></h2><ul><li><h3 id="文件">17.1 <ahref="../../../../../../2022/01/06/Java/入门阶段/17%20IO%E6%B5%81/#17-1-%E6%96%87%E4%BB%B6">文件</a></h3><ul><li><h4 id="常用的文件操作">17.1.1 常用的文件操作</h4></li></ul></li><li><h3 id="io流">17.2 <ahref="../../../../../../2022/01/06/Java/入门阶段/17%20IO%E6%B5%81/#17-2-IO%E6%B5%81">IO流</a></h3><ul><li><h4 id="io流的分类">17.2.1 IO流的分类</h4></li><li><h4 id="io流-常用类">17.2.2 IO流 常用类</h4><ul><li><h5 id="fileinputstream文件字节输入流">17.2.2.1FileInputStream：文件字节输入流</h5></li><li><h5 id="fileoutputstream文件字节输出流">17.2.2.2FileOutputStream：文件字节输出流</h5></li><li><h5 id="filereader文件字符输入流">17.2.2.3FileReader：文件字符输入流</h5></li><li><h5 id="filewriter文件字符输出流">17.2.2.3FileWriter：文件字符输出流</h5></li><li><h5 id="转换流-inputstreamreader-和-outputstreamwriter">17.2.3.4转换流 InputStreamReader 和 OutputStreamWriter</h5></li></ul></li><li><h4 id="节点流和处理流">17.2.3 节点流和处理流</h4><ul><li><h5 id="缓冲区流">17.2.3.1 缓冲区流</h5></li><li><h5 id="数据数据流">17.2.3.2 数据数据流</h5></li><li><h5 id="对象流">17.2.3.3 对象流</h5></li><li><h5 id="标准输入-输出流">17.2.3.4 标准输入 / 输出流</h5></li><li><h5 id="打印流-paintstream-和-paintwriter">17.2.3.5 打印流PaintStream 和 PaintWriter</h5></li><li><h5 id="properties-类">17.2.3.6 Properties 类</h5></li><li><h5 id="随机访问文件">17.2.3.7 随机访问文件</h5></li></ul></li></ul></li></ul><hr /><h2 id="项目坦克大战-完结">18 <ahref="../../../../../../2022/01/11/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/18%20%E9%A1%B9%E7%9B%AE%EF%BC%9A%E5%9D%A6%E5%85%8B%E5%A4%A7%E6%88%98/">项目：坦克大战[完结]</a></h2><p>2022.1.12 01:57 第二阶段完成</p><hr /><h2 id="网络编程">19 <ahref="../../../../../../2022/01/12/Java/入门阶段/19%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a></h2><ul><li><h3 id="网络的相关概念">19.1 <ahref="../../../../../../2022/01/12/Java/入门阶段/19%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/#19-1-%E7%BD%91%E7%BB%9C%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5">网络的相关概念</a></h3><ul><li><h4 id="tcp-和-udp">19.1.1 TCP 和 UDP</h4></li></ul></li><li><h3 id="inetaddress-类">19.2 <ahref="../../../../../../2022/01/12/Java/入门阶段/19%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/#19-2-InetAddress-%E7%B1%BB">InetAddress类</a></h3></li><li><h3 id="socket">19.3 <ahref="../../../../../../2022/01/12/Java/入门阶段/19%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/#19-3-Socket">Socket</a></h3><ul><li><h4 id="tcp-网络通信编程">19.3.1 TCP 网络通信编程</h4><ul><li><h5 id="netstat-指令">19.3.1.1 netstat 指令</h5></li><li><h5 id="tcp-连接秘密">19.3.1.2 TCP 连接秘密</h5></li></ul></li><li><h4 id="udp-网络通信编程">19.3.2 UDP 网络通信编程</h4></li></ul></li></ul><hr /><h2 id="项目多用户通讯系统">20 <ahref="../../../../../../2022/01/16/Java/入门阶段/20%20%E9%A1%B9%E7%9B%AE%EF%BC%9A%E5%A4%9A%E7%94%A8%E6%88%B7%E9%80%9A%E8%AE%AF%E7%B3%BB%E7%BB%9F/">项目：多用户通讯系统</a></h2><ul><li><h3 id="需求分析">20.1 需求分析</h3></li></ul><hr /><h2 id="反射">21 <ahref="../../../../../../2022/01/20/Java/入门阶段/21%20%E5%8F%8D%E5%B0%84/">反射</a></h2><ul><li><h3 id="反射相关的常用类">21.1 <ahref="../../../../../../2022/01/20/Java/入门阶段/21%20%E5%8F%8D%E5%B0%84/#21-1-%E5%8F%8D%E5%B0%84%E7%9B%B8%E5%85%B3%E7%9A%84%E5%B8%B8%E7%94%A8%E7%B1%BB">反射相关的常用类</a></h3></li><li><h3 id="class-类">21.2 <ahref="../../../../../../2022/01/20/Java/入门阶段/21%20%E5%8F%8D%E5%B0%84/#21-2-Class-%E7%B1%BB">Class类</a></h3><ul><li><h4 id="class-类的常用方法">21.2.1 Class 类的常用方法</h4></li><li><h4 id="获取-class-对象">21.2.2 获取 Class 对象</h4></li><li><h4 id="哪些类有-class-对象">21.2.3 哪些类有 Class 对象</h4></li></ul></li><li><h3 id="类的加载">21.3 <ahref="../../../../../../2022/01/20/Java/入门阶段/21%20%E5%8F%8D%E5%B0%84/#21-3-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD">类的加载</a></h3><ul><li><h4 id="类加载的五个阶段">21.3.1 类加载的五个阶段</h4></li></ul></li><li><h3 id="通过反射获取类的结构信息">21.4 <ahref="../../../../../../2022/01/20/Java/入门阶段/21%20%E5%8F%8D%E5%B0%84/#21-4-%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E4%BF%A1%E6%81%AF">通过反射获取类的结构信息</a></h3></li><li><h3 id="通过反射创建对象">21.5 <ahref="../../../../../../2022/01/20/Java/入门阶段/21%20%E5%8F%8D%E5%B0%84/#21-5-%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1">通过反射创建对象</a></h3></li><li><h3 id="通过反射访问成员">21.6 <ahref="../../../../../../2022/01/20/Java/入门阶段/21%20%E5%8F%8D%E5%B0%84/#21-6-%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98">通过反射访问成员</a></h3></li></ul><hr /><h2 id="mysql">22 <ahref="../../../../../../2022/01/22/Java/入门阶段/22%20MySQL/">MySQL</a></h2><ul><li><h3 id="数据库">22.1 <ahref="../../../../../../2022/01/22/Java/入门阶段/22%20MySQL/#22-1-%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a></h3><ul><li><h4 id="创建数据库">22.1.1 创建数据库</h4></li><li><h4 id="查看-删除数据库">22.1.2 查看 · 删除数据库</h4></li><li><h4 id="备份-恢复数据库">22.1.3 备份 · 恢复数据库</h4></li></ul></li><li><h3 id="mysql-常用数据类型列类型">22.2 <ahref="../../../../../../2022/01/22/Java/入门阶段/22%20MySQL/#22-2-MySQL-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88%E5%88%97%E7%B1%BB%E5%9E%8B%EF%BC%89">MySQL常用数据类型（列类型）</a></h3><ul><li><h4 id="数组类型">22.2.1 数组类型</h4><ul><li><h5 id="整形">22.2.1.1 整形</h5></li><li><h5 id="bit位类型">22.2.1.2 bit（位类型）</h5></li><li><h5 id="小数类型">22.2.1.3 小数类型</h5></li></ul></li><li><h4 id="文本类型">22.2.2 文本类型</h4></li><li><h4 id="时间日期类型">22.2.3 时间日期类型</h4></li></ul></li><li><h3 id="表">22.3 <ahref="../../../../../../2022/01/22/Java/入门阶段/22%20MySQL/#22-3-%E8%A1%A8">表</a></h3><ul><li><h4 id="创建表">22.2.1 创建表</h4></li><li><h4 id="删除-修改表">22.2.2 删除 · 修改表</h4></li></ul></li><li><h3 id="数据库的增删改查">22.4 <ahref="../../../../../../2022/01/22/Java/入门阶段/22%20MySQL/#22-4-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5">数据库的增删改查</a></h3><ul><li><h4 id="insert-语句">22.4.1 INSERT 语句</h4></li><li><h4 id="update-语句">22.4.2 UPDATE 语句</h4></li><li><h4 id="delete-语句">22.4.3 DELETE 语句</h4></li><li><h4 id="select-语句单表">22.4.4 SELECT 语句（单表）</h4></li><li><h4 id="常用的运算符">22.4.5 常用的运算符</h4></li></ul></li><li><h3 id="函数">22.5 <ahref="../../../../../../2022/01/22/Java/入门阶段/22%20MySQL/#22-5-%E5%87%BD%E6%95%B0">函数</a></h3><ul><li><h4 id="统计函数">22.5.1 统计函数</h4></li><li><h4 id="字符串函数">22.5.2 字符串函数</h4></li><li><h4 id="数学函数">22.5.3 数学函数</h4></li><li><h4 id="时间和日期函数">22.5.4 时间和日期函数</h4></li><li><h4 id="加密和系统函数">22.5.5 加密和系统函数</h4></li><li><h4 id="流程控制函数">22.5.6 流程控制函数</h4></li></ul></li><li><h3 id="mysql-多表查询">22.6 <ahref="../../../../../../2022/01/22/Java/入门阶段/22%20MySQL/#22-6-MySQL-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2">MySQL多表查询</a></h3><ul><li><h4 id="自连接">22.6.1 自连接</h4></li><li><h4 id="子查询">22.6.2 子查询</h4></li></ul></li><li><h3 id="外连接">22.7 <ahref="../../../../../../2022/01/22/Java/入门阶段/22%20MySQL/#22-7-%E5%A4%96%E8%BF%9E%E6%8E%A5">外连接</a></h3></li><li><h3 id="约束">22.8 <ahref="../../../../../../2022/01/22/Java/入门阶段/22%20MySQL/#22-8-%E7%BA%A6%E6%9D%9F">约束</a></h3><ul><li><h4 id="primary-key主键">22.8.1 primary key（主键）</h4><ul><li><h5 id="使用细节-29">22.8.1.1 使用细节</h5></li></ul></li><li><h4 id="not-null非空">22.8.2 not null（非空）</h4></li><li><h4 id="unique唯一">22.8.3 unique（唯一）</h4></li><li><h4 id="foreign-key外键">22.8.4 foreign key（外键）</h4><ul><li><h5 id="使用细节-30">22.8.4.1 使用细节</h5></li></ul></li><li><h4 id="check">22.8.5 check</h4></li><li><h4 id="自增长">22.8.6 自增长</h4><ul><li><h5 id="使用细节-31">22.8.6.1 使用细节</h5></li></ul></li></ul></li><li><h3 id="索引">22.9 <ahref="../../../../../../2022/01/22/Java/入门阶段/22%20MySQL/#22-9-%E7%B4%A2%E5%BC%95">索引</a></h3><ul><li><h4 id="索引的操作">22.9.1 索引的操作</h4></li><li><h4 id="创建规则">22.9.2 创建规则</h4></li></ul></li><li><h3 id="事务">22.10 <ahref="../../../../../../2022/01/22/Java/入门阶段/22%20MySQL/#22-10-%E4%BA%8B%E5%8A%A1">事务</a></h3><ul><li><h4 id="事务的操作">22.10.1 事务的操作</h4></li><li><h4 id="使用细节-32">22.10.2 使用细节</h4></li><li><h4 id="隔离级别">22.10.3 隔离级别</h4><ul><li><h5 id="隔离级别的操作">22.10.3.1 隔离级别的操作</h5></li></ul></li><li><h4 id="事务的-acid-特性">22.10.4 事务的 ACID 特性</h4></li></ul></li><li><h3 id="mysql-表类型和存储引擎">22.11 <ahref="../../../../../../2022/01/22/Java/入门阶段/22%20MySQL/#22-11-MySQL-%E8%A1%A8%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E">MySQL表类型和存储引擎</a></h3><ul><li><h4 id="如何选择存储引擎">22.11.1 如何选择存储引擎</h4></li></ul></li><li><h3 id="视图">22.12 <ahref="../../../../../../2022/01/22/Java/入门阶段/22%20MySQL/#22-12-%E8%A7%86%E5%9B%BE">视图</a></h3><ul><li><h4 id="基本使用">22.12.1 基本使用</h4></li><li><h4 id="使用细节-33">22.12.2 使用细节</h4></li><li><h4 id="视图最佳实践">22.12.3 视图最佳实践</h4></li></ul></li><li><h3 id="mysql-管理">22.13 <ahref="../../../../../../2022/01/22/Java/入门阶段/22%20MySQL/#22-13-MySQL-%E7%AE%A1%E7%90%86">MySQL管理</a></h3><ul><li><h4 id="用户管理">22.13.1 用户管理</h4></li><li><h4 id="权限管理">22.13.2 权限管理</h4></li></ul></li><li><h3 id="附录数据库">附录：数据库</h3></li></ul><hr /><h2 id="jdbc-和数据库连接池">23 <ahref="../../../../../../2022/02/20/Java/入门阶段/23%20JDBC%20%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/#23-JDBC-%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0">JDBC和数据库连接池</a></h2><ul><li><h3 id="连接数据库的-5-种方式">23.1 <ahref="../../../../../../2022/02/20/Java/入门阶段/23%20JDBC%20%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/#23-1-%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84-5-%E7%A7%8D%E6%96%B9%E5%BC%8F">连接数据库的5 种方式</a></h3></li><li><h3 id="reaultset-结果集">23.2 <ahref="../../../../../../2022/02/20/Java/入门阶段/23%20JDBC%20%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/#23-2-ReaultSet-%E7%BB%93%E6%9E%9C%E9%9B%86">ReaultSet结果集</a></h3></li><li><h3 id="statement">23.3 <ahref="../../../../../../2022/02/20/Java/入门阶段/23%20JDBC%20%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/#23-3-Statement">Statement</a></h3><ul><li><h4 id="preparedstatement-预处理">23.3.1 PreparedStatement预处理</h4></li></ul></li><li><h3 id="jdbcutils">23.4 <ahref="../../../../../../2022/02/20/Java/入门阶段/23%20JDBC%20%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/#23-4-JDBCUtils">JDBCUtils</a></h3></li><li><h3 id="事务-1">23.5 <ahref="../../../../../../2022/02/20/Java/入门阶段/23%20JDBC%20%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/#23-5-%E4%BA%8B%E5%8A%A1">事务</a></h3></li><li><h3 id="批处理">23.6 <ahref="../../../../../../2022/02/20/Java/入门阶段/23%20JDBC%20%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/#23-6-%E6%89%B9%E5%A4%84%E7%90%86">批处理</a></h3><ul><li><h4 id="说明">23.6.1 说明</h4></li></ul></li><li><h3 id="数据库连接池">23.7 <ahref="../../../../../../2022/02/20/Java/入门阶段/23%20JDBC%20%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/#23-7-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0">数据库连接池</a></h3><ul><li><h4 id="c3p0">23.7.1 C3P0</h4></li><li><h4 id="druid德鲁伊连接池">23.7.2 Druid（德鲁伊）连接池</h4></li></ul></li><li><h3 id="apache---dbutils">23.8 <ahref="../../../../../../2022/02/20/Java/入门阶段/23%20JDBC%20%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/#23-8-Apache-DbUtils">Apache- DbUtils</a></h3><ul><li><h4 id="apache-dbutils-常用方法">23.8.1 Apache-DbUtils常用方法</h4></li></ul></li><li><h3 id="basicdao">23.9 <ahref="../../../../../../2022/02/20/Java/入门阶段/23%20JDBC%20%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/#23-9-BasicDAO">BasicDAO</a></h3></li></ul><hr /><h2 id="项目满汉楼">24 <ahref="../../../../../../2022/02/26/Java/入门阶段/24%20%E9%A1%B9%E7%9B%AE%EF%BC%9A%E6%BB%A1%E6%B1%89%E6%A5%BC/">项目：满汉楼</a></h2><hr /><h2 id="正则表达式">25 <ahref="../../../../../../2022/03/02/Java/入门阶段/25%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a></h2><ul><li><h3 id="语法">25.1 <ahref="../../../../../../2022/03/02/Java/入门阶段/25%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/#25-1-%E8%AF%AD%E6%B3%95">语法</a></h3><ul><li><h4 id="转义符号">25.1.1 转义符号 <code>\</code></h4></li><li><h4 id="字符匹配符">25.1.2 字符匹配符</h4></li><li><h4 id="选择匹配符">25.1.3 选择匹配符 <code>|</code></h4></li><li><h4 id="限定符">25.1.4 限定符</h4></li><li><h4 id="定位符">25.1.5 定位符</h4></li><li><h4 id="分组">25.1.6 分组</h4></li><li><h4 id="非捕获分组">25.1.7 非捕获分组</h4></li></ul></li><li><h3 id="常用类-1">25.2 <ahref="../../../../../../2022/03/02/Java/入门阶段/25%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/#25-2-%E5%B8%B8%E7%94%A8%E7%B1%BB">常用类</a></h3></li><li><h3 id="分组捕获反向引用">25.3 <ahref="../../../../../../2022/03/02/Java/入门阶段/25%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/#25-3-%E5%88%86%E7%BB%84%E3%80%81%E6%8D%95%E8%8E%B7%E3%80%81%E5%8F%8D%E5%90%91%E5%BC%95%E7%94%A8">分组、捕获、反向引用</a></h3></li><li><h3 id="在-string-中使用正则表达式">25.4 <ahref="../../../../../../2022/03/02/Java/入门阶段/25%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/#25-4-%E5%9C%A8-String-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">在String 中使用正则表达式</a></h3></li></ul><hr /><h2 id="算法入门">26 <ahref="../../../../../../2022/06/03/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/26%20%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/">算法入门</a></h2><ul><li><h3 id="算法的执行时间">26.1 <ahref="../../../../../../2022/06/03/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/26%20%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/#26-1-%E7%AE%97%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4">算法的执行时间</a></h3><ul><li><h4 id="时间复杂度">26.1.1 <ahref="../../../../../../2022/06/03/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/26%20%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/#26-1-1-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">时间复杂度</a></h4></li></ul></li><li><h3 id="常用的算法">26.2 <ahref="../../../../../../2022/06/03/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/26%20%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/#26-2-%E5%B8%B8%E7%94%A8%E7%9A%84%E7%AE%97%E6%B3%95">常用的算法</a></h3><ul><li><h4 id="二分查找算法">26.2.1 <ahref="../../../../../../2022/06/03/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/26%20%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/#26-2-1-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95">二分查找算法</a></h4></li><li><h4 id="分治算法">26.2.2 <ahref="../../../../../../2022/06/03/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/26%20%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/#26-2-2-%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95">分治算法</a></h4></li><li><h4 id="动态规划">26.2.3 <ahref="../../../../../../2022/06/03/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/26%20%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/#26-2-3-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划</a></h4></li><li><h4 id="kmp-算法">26.2.4 <ahref="../../../../../../2022/06/03/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/26%20%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/#26-2-4-KMP-%E7%AE%97%E6%B3%95">KMP算法</a></h4></li><li><h4 id="贪心算法">26.2.5 <ahref="../../../../../../2022/06/03/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/26%20%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/#26-2-5-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95">贪心算法</a></h4></li><li><h4 id="普里姆算法">26.2.6 <ahref="../../../../../../2022/06/03/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/26%20%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/#26-2-6-%E6%99%AE%E9%87%8C%E5%A7%86%E7%AE%97%E6%B3%95">普里姆算法</a></h4></li><li><h4 id="克鲁斯卡尔算法">26.2.7 <ahref="../../../../../../2022/06/03/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/26%20%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/#26-2-7-%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95">克鲁斯卡尔算法</a></h4></li><li><h4 id="迪杰斯特拉算法">26.2.8 <ahref="../../../../../../2022/06/03/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/26%20%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/#26-2-8-%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95">迪杰斯特拉算法</a></h4></li><li><h4 id="弗洛伊德算法">26.2.9 <ahref="../../../../../../2022/06/03/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/26%20%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/#26-2-9-%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95">弗洛伊德算法</a></h4></li></ul></li><li><h3 id="附录骑士周游问题">附录：<ahref="../../../../../../2022/06/03/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/26%20%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/#%E9%AA%91%E5%A3%AB%E5%91%A8%E6%B8%B8%E9%97%AE%E9%A2%98">骑士周游问题</a></h3></li></ul><hr /><p>Java 入门部分 结束</p><p>—— Melody 2021.11.22 5:13 ~ 2022.3.7 19:34</p><h2 id="java-8-新特性">27 <ahref="../../../../../../2022/03/09/Java/入门阶段/27%20Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/">Java8 新特性</a></h2><ul><li><h3 id="lambda-表达式">27.1 <ahref="../../../../../../2022/03/09/Java/入门阶段/27%20Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/#27-1-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F">Lambda表达式</a></h3><ul><li><h4 id="lambda-表达式的使用">27.1.1 Lambda 表达式的使用</h4></li></ul></li><li><h3 id="函数式接口">27.2 <ahref="../../../../../../2022/03/09/Java/入门阶段/27%20Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/#27-2-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3">函数式接口</a></h3><ul><li><h4 id="java-内置的函数式接口">27.2.1 Java内置的函数式接口</h4></li></ul></li><li><h3 id="方法引用和构造器引用">27.3 <ahref="../../../../../../2022/03/09/Java/入门阶段/27%20Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/#27-3-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E5%92%8C%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8">方法引用和构造器引用</a></h3><ul><li><h4 id="方法引用">27.3.1 方法引用</h4></li><li><h4 id="构造器引用">27.3.2 构造器引用</h4></li><li><h4 id="数组引用">27.3.3 数组引用</h4></li></ul></li><li><h3 id="stream-api">27.4 <ahref="../../../../../../2022/03/09/Java/入门阶段/27%20Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/#27-4-Stream-API">StreamAPI</a></h3><ul><li><h4 id="什么是-stream">27.4.1 什么是 Stream</h4></li><li><h4 id="stream-操作步骤">27.4.2 Stream 操作步骤</h4><ul><li><h5 id="创建-stream">27.4.2.1 创建 Stream</h5></li><li><h5 id="中间操作">27.4.2.2 中间操作</h5></li><li><h5 id="终止操作">27.4.2.3 终止操作</h5></li></ul></li></ul></li><li><h3 id="optional-类">27.5 <ahref="../../../../../../2022/03/09/Java/入门阶段/27%20Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/#27-5-Optional-%E7%B1%BB">Optional类</a></h3></li></ul><hr />]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>目录</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>更新日志</title>
    <link href="/2021/01/01/%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/"/>
    <url>/2021/01/01/%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h1 id="更新日志">更新日志</h1><h3 id="月8月">2022 - <ahref="../../../../../2022/07/04/更新日志/更新日志2207">7月、8月</a></h3><ul><li><p><strong>添加了新的笔记</strong></p><ul><li>&lt;Go&gt;8 goroutine 和 channel</li><li>&lt;Go&gt;9 反射、网络编程</li></ul></li><li><p><strong>对笔记内容进行了更新</strong></p><ul><li>&lt;Java&gt;7 面向对象编程[中级]</li><li>&lt;Java&gt;12 常用类</li><li>&lt;Java&gt;13 Java 数据结构</li><li>&lt;Java&gt;14 树</li><li>&lt;Java&gt;26 算法入门</li><li>&lt;Go&gt;1 Go 基础知识</li></ul></li></ul><h3 id="月">2022 - <ahref="../../../../../2022/06/30/更新日志/更新日志2206">6月</a></h3><ul><li><p><strong>添加了新的笔记</strong></p><ul><li>&lt;Go&gt;1 Go 基础知识</li><li>&lt;Go&gt;2 程序流程控制</li><li>&lt;Go&gt;3 函数、包和错误处理</li><li>&lt;Go&gt;4 数组、切片和 map</li><li>&lt;Go&gt;5 面向 "对象" 编程</li><li>&lt;Go&gt;6 项目：家庭收支记账软件</li><li>&lt;Go&gt;7 文件操作</li><li>&lt;Java&gt;14 树</li><li>&lt;Java&gt;26 算法入门</li><li>&lt;C++&gt;8 I/O 流</li></ul></li><li><p><strong>对笔记内容进行了更新</strong></p><ul><li>&lt;C++&gt;1 C++ 基础知识</li><li>&lt;C++&gt;3 函数和数组</li><li>&lt;C++&gt;7 类和对象</li><li>&lt;Java&gt;12 常用类</li><li>&lt;Java&gt;13 Java 数据结构</li><li><del>&lt;Java&gt;14 泛型</del><div class="code-wrapper"><pre><code class="hljs">→   \&lt;Java\&gt;14 树</code></pre></div></li><li><del>&lt;Java&gt;26 骑士周游问题</del><div class="code-wrapper"><pre><code class="hljs">→   \&lt;Java\&gt;26 算法入门</code></pre></div></li><li><del>&lt;C++&gt;8 文件操作</del><div class="code-wrapper"><pre><code class="hljs">→   \&lt;C++\&gt;8 I/O 流</code></pre></div></li></ul></li><li><p><strong>更新了博客样式</strong></p></li><li><p><strong>修改了所有笔记中的导航方式</strong></p></li></ul><h3 id="月-1">2022 - <ahref="../../../../../2022/05/31/更新日志/更新日志2205">5月</a></h3><ul><li><p><strong>添加了新的笔记</strong></p><ul><li>&lt;C++&gt;10 模板</li><li>&lt;C++&gt;11 STL</li><li>&lt;C++&gt;12 项目：演讲比赛管理系统</li><li>&lt;C++&gt;13 项目：机房预约系统</li><li>&lt;Java Web&gt;1 HTML 和 CSS</li><li>&lt;Java&gt;13 Java 数据结构</li></ul></li><li><p><strong>对笔记内容进行了更新</strong></p><ul><li>&lt;Java&gt;1 Java 概述</li><li>&lt;Java&gt;2 变量</li><li>&lt;Java&gt;3 运算符</li><li>&lt;Java&gt;5 数组、排序和查找</li><li>&lt;Java&gt;7 面向对象编程[中级]</li><li>&lt;Java&gt;12 常用类</li><li><del>&lt;Java&gt;13 集合</del><div class="code-wrapper"><pre><code class="hljs">→   \&lt;Java\&gt;13 Java 数据结构</code></pre></div></li></ul></li></ul><h3 id="月-2">2022 - <ahref="../../../../../2022/04/30/更新日志/更新日志2204">4月</a></h3><ul><li><p><strong>添加了新的笔记</strong></p><ul><li>&lt;C++&gt;7 类和对象</li><li>&lt;C++&gt;8 文件操作</li><li>&lt;C++&gt;9 项目：职工管理系统</li><li>&lt;Java&gt;15 图形界面设计</li></ul></li><li><p><strong>对笔记内容进行了更新</strong></p><ul><li>&lt;Java&gt;1 基础知识</li><li>&lt;Java&gt;2 变量</li><li>&lt;Java&gt;3 运算符</li><li>&lt;Java&gt;4 流程控制语句</li><li>&lt;Java&gt;6 面向对象编程[基础]</li><li>&lt;Java&gt;7 面向对象编程[中级]</li><li>&lt;Java&gt;12 常用类</li><li>&lt;Java&gt;16 多线程</li><li>&lt;Java&gt;17 IO流</li><li><del>&lt;Java&gt;15 项目：坦克大战 [初期]</del>→ &lt;Java&gt;15 图形界面设计</li></ul></li><li><p><strong>更新了博客样式</strong></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>更新日志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>更新日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
