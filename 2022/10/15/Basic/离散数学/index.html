

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Melody">
  <meta name="keywords" content="">
  
    <meta name="description" content="离散数学（1） 0 逻辑关系 0.1 联结词 \[p\]、\[q\]、\[r\] 表示原子命题（简单命题、变元、常元）。\[1\] 表示命题的真值为真，\[0\] 表示假  \[¬p\]：否定联结词（非运算）    p   ¬p     1   0     0   1    \[p\and q\]：合取联结词（与运算）">
<meta property="og:type" content="article">
<meta property="og:title" content="离散数学（1）">
<meta property="og:url" content="https://i-melody.github.io/2022/10/15/Basic/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/index.html">
<meta property="og:site_name" content="Melody 的小纸箱">
<meta property="og:description" content="离散数学（1） 0 逻辑关系 0.1 联结词 \[p\]、\[q\]、\[r\] 表示原子命题（简单命题、变元、常元）。\[1\] 表示命题的真值为真，\[0\] 表示假  \[¬p\]：否定联结词（非运算）    p   ¬p     1   0     0   1    \[p\and q\]：合取联结词（与运算）">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-10-14T16:00:00.000Z">
<meta property="article:modified_time" content="2022-10-15T13:46:49.097Z">
<meta property="article:author" content="Melody">
<meta property="article:tag" content="基础课目">
<meta property="article:tag" content="数学">
<meta property="article:tag" content="离散数学">
<meta name="twitter:card" content="summary_large_image">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>离散数学（1） ★ Melody 的小纸箱</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"i-melody.github.io","root":"/","version":"1.9.0","typing":{"enable":true,"typeSpeed":15,"cursorChar":"★","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":"♪(´▽｀)"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":false},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 85vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>箱庭</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/post.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="离散数学（1）"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-10-15 00:00" pubdate>
          2022年10月15日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          56k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          155 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
        <div class="scroll-down-bar">
          <i class="iconfont icon-arrowdown"></i>
        </div>
      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">离散数学（1）</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2022年10月15日 晚上
                  
                
              </p>
            
            <div class="markdown-body">
              
              <h1 id="离散数学1">离散数学（1）</h1>
<h2 id="逻辑关系">0 逻辑关系</h2>
<h3 id="联结词">0.1 联结词</h3>
<p><span class="math display">\[p\]</span>、<span
class="math display">\[q\]</span>、<span
class="math display">\[r\]</span>
表示原子命题（简单命题、变元、常元）。<span
class="math display">\[1\]</span> 表示命题的真值为真，<span
class="math display">\[0\]</span> 表示假</p>
<ul>
<li><p><span
class="math display">\[¬p\]</span>：否定联结词（非运算）</p>
<table>
<tr>
<th>
<p>p</p>
</th>
<th>
<p>¬p</p>
</th>
</tr>
<tr>
<td>
<p>1</p>
</td>
<td>
<p>0</p>
</td>
</tr>
<tr>
<td>
<p>0</p>
</td>
<td>
<p>1</p>
</td>
</tr>
</table></li>
<li><p><span class="math display">\[p\and
q\]</span>：合取联结词（与运算）</p>
<table>
<tr>
<th>
<p>p</p>
</th>
<th>
<p>q</p>
</th>
<th>
<p>p∧q</p>
</th>
</tr>
<tr>
<td>
<p>0</p>
</td>
<td>
<p>0</p>
</td>
<td>
<p>0</p>
</td>
</tr>
<tr>
<td>
<p>0</p>
</td>
<td>
<p>1</p>
</td>
<td>
<p>0</p>
</td>
</tr>
<tr>
<td>
<p>1</p>
</td>
<td>
<p>0</p>
</td>
<td>
<p>0</p>
</td>
</tr>
<tr>
<td>
<p>1</p>
</td>
<td>
<p>1</p>
</td>
<td>
<p>1</p>
</td>
</tr>
</table></li>
<li><p><span class="math display">\[p\or
q\]</span>：析取联结词（或运算）</p>
<table>
<tr>
<th>
<p>p</p>
</th>
<th>
<p>q</p>
</th>
<th>
<p>p∨q</p>
</th>
</tr>
<tr>
<td>
<p>0</p>
</td>
<td>
<p>0</p>
</td>
<td>
<p>0</p>
</td>
</tr>
<tr>
<td>
<p>0</p>
</td>
<td>
<p>1</p>
</td>
<td>
<p>1</p>
</td>
</tr>
<tr>
<td>
<p>1</p>
</td>
<td>
<p>0</p>
</td>
<td>
<p>1</p>
</td>
</tr>
<tr>
<td>
<p>1</p>
</td>
<td>
<p>1</p>
</td>
<td>
<p>1</p>
</td>
</tr>
</table></li>
<li><p><span class="math display">\[p→q\]</span>：蕴含联结词（<span
class="math display">\[p\]</span> 是 <span
class="math display">\[q\]</span> 的充分条件，<span
class="math display">\[q\]</span> 是 <span
class="math display">\[p\]</span> 的必要条件）</p>
<table>
<tr>
<th>
<p>p</p>
</th>
<th>
<p>q</p>
</th>
<th>
<p>p→q</p>
</th>
</tr>
<tr>
<td>
<p>0</p>
</td>
<td>
<p>0</p>
</td>
<td>
<p>1</p>
</td>
</tr>
<tr>
<td>
<p>0</p>
</td>
<td>
<p>1</p>
</td>
<td>
<p>1</p>
</td>
</tr>
<tr>
<td>
<p>1</p>
</td>
<td>
<p>0</p>
</td>
<td>
<p>0</p>
</td>
</tr>
<tr>
<td>
<p>1</p>
</td>
<td>
<p>1</p>
</td>
<td>
<p>1</p>
</td>
</tr>
</table>
<blockquote>
<p>如果认为所有猫都爱睡觉，也就是说：如果有一只猫（<span
class="math display">\[p\]</span>），那么这只猫喜欢睡觉（<span
class="math display">\[p\rarr q\]</span>）。</p>
<p>这样的话：</p>
<p>如果不是一只猫（<span
class="math display">\[p=0\]</span>），那么它可以不爱睡觉（<span
class="math display">\[q=0\]</span>），也可以爱睡觉（<span
class="math display">\[q=1\]</span>）</p>
<p>如果是一只猫（<span
class="math display">\[p=1\]</span>），那么它不可以不爱睡觉（<span
class="math display">\[q=0\]</span>），只可以爱睡觉（<span
class="math display">\[q=1\]</span>）</p>
</blockquote></li>
<li><p><span
class="math display">\[p↔q\]</span>：等价联结词（等于，充分必要条件）</p>
<table>
<tr>
<th>
<p>p</p>
</th>
<th>
<p>q</p>
</th>
<th>
<p>p↔︎q</p>
</th>
</tr>
<tr>
<td>
<p>0</p>
</td>
<td>
<p>0</p>
</td>
<td>
<p>1</p>
</td>
</tr>
<tr>
<td>
<p>0</p>
</td>
<td>
<p>1</p>
</td>
<td>
<p>0</p>
</td>
</tr>
<tr>
<td>
<p>1</p>
</td>
<td>
<p>0</p>
</td>
<td>
<p>0</p>
</td>
</tr>
<tr>
<td>
<p>1</p>
</td>
<td>
<p>1</p>
</td>
<td>
<p>1</p>
</td>
</tr>
</table></li>
</ul>
<h3 id="命题公式">0.2 命题公式</h3>
<p>单个命题变元（或常元）是命题公式。</p>
<p>若 <span class="math display">\[p\]</span>、<span
class="math display">\[q\]</span> 是命题公式，那么 <span
class="math display">\[¬p\]</span>、<span class="math display">\[p\and
q\]</span>、<span class="math display">\[p\or q\]</span>、<span
class="math display">\[p→q\]</span>、<span
class="math display">\[p↔q\]</span>
都是命题公式。命题公式的长度是有限的。</p>
<p>联结词的优先级是： <span class="math display">\[¬\]</span>、<span
class="math display">\[\and \or\]</span>、<span
class="math display">\[→↔\]</span></p>
<p>将值永远为 <span class="math display">\[0\]</span>
的命题公式称为矛盾式（永假式），如 <span class="math display">\[p \and
¬p\]</span></p>
<p>将值可能为 <span class="math display">\[1\]</span>
的命题公式称为可满足式。</p>
<p>将值永远为 <span class="math display">\[1\]</span>
的命题公式称为重言式（永真式），如 <span
class="math display">\[p\and(p\or
q)↔p\]</span>。永真式是可满足式的一种</p>
<h3 id="等值式">0.3 等值式</h3>
<p>等值式：如果 <span class="math display">\[p↔q\]</span> 是永真式，则
<span class="math display">\[p⇔q\]</span>，表示 <span
class="math display">\[p\]</span> 与 <span
class="math display">\[q\]</span> 的取值完全相同，可以互相代替</p>
<table>
<tr>
<th>
p
</th>
<th>
q
</th>
<th>
p→q
</th>
<th>
¬p∨q
</th>
<th>
(p→q)↔︎(¬p∨q)
</th>
</tr>
<tr>
<td>
0
</td>
<td>
0
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
</tr>
<tr>
<td>
0
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
</tr>
<tr>
<td>
1
</td>
<td>
0
</td>
<td>
0
</td>
<td>
0
</td>
<td>
1
</td>
</tr>
<tr>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
</tr>
</table>
<p><span class="math display">\[∴p→q⇔¬p∨q\]</span></p>
<p><strong>基本的等值式</strong></p>
<ul>
<li><p>幂等率：<span class="math display">\[p⇔p\or p{\qquad}p⇔p\and
p\]</span></p></li>
<li><p>交换律：<span class="math display">\[p\or q⇔p\or q{\qquad}p\and
q⇔q\and p\]</span></p></li>
<li><p>结合律：<span class="math display">\[(p\or q)\or r⇔p\or(q\or
r){\qquad}(p\and q)\and r⇔p\and(q\and r)\]</span></p></li>
<li><p>分配律：<span class="math display">\[p\or(q\and r)⇔(p\or
q)\and(p\or r){\qquad}p\and(q\or r)⇔(p\and q)\or(p\and
r)\]</span></p></li>
<li><p>德·摩根律：<span class="math display">\[¬(p\or q)⇔¬p\and
¬q{\qquad}¬(p\and q)⇔¬p\or ¬q\]</span></p></li>
<li><p>吸收律：<span class="math display">\[p\or(p\and
q)⇔p{\qquad}p\and(p\or q)⇔p\]</span></p></li>
<li><p>零律：<span
class="math display">\[p\or1⇔1{\qquad}p\and0⇔0\]</span></p></li>
<li><p>同一律：<span
class="math display">\[p\or0⇔p{\qquad}p\and1⇔p\]</span></p></li>
<li><p>排中律：<span class="math display">\[p\or¬p⇔1\]</span></p></li>
<li><p>矛盾律：<span class="math display">\[p\and¬p⇔0\]</span></p></li>
<li><p>双重否定律：<span class="math display">\[¬¬p⇔p\]</span></p></li>
<li><p>蕴含等值式：<span
class="math display">\[p→q⇔¬p∨q\]</span></p></li>
<li><p>等价等值式：<span
class="math display">\[p↔q⇔(p→q)\and(q→p)\]</span></p></li>
<li><p>等价否定等值式（否命题）：<span
class="math display">\[p↔q⇔¬p↔¬q\]</span></p></li>
<li><p>假言易位（逆否）：<span
class="math display">\[p→q⇔¬q→¬p\]</span></p></li>
<li><p>归谬论（反证法）：<span
class="math display">\[(p→q)\and(p→¬q)⇔¬p\]</span></p></li>
</ul>
<h3 id="命题逻辑推理">0.4 命题逻辑推理</h3>
<p>前提：<span
class="math display">\[A_1，A_2，A_3,...，A_k\]</span></p>
<p>结论：<span class="math display">\[B\]</span></p>
<p>推理的形式结构：<span class="math display">\[(A_1\and A_2\and A_3\and
... \and A_k)→B\]</span></p>
<p>如果 <span class="math display">\[A→B\]</span> 是永真式，则可以记为
<span class="math display">\[A⇒B\]</span></p>
<p><strong>重要的推理定律</strong></p>
<ul>
<li><p>附加律：<span class="math display">\[A⇒(A\or B)\]</span></p></li>
<li><p>化简律：<span class="math display">\[(A\and B)⇒A{\qquad}(A\and
B)⇒B\]</span></p></li>
<li><p>假言推理：<span class="math display">\[(A→B)\and
A⇒B\]</span></p></li>
<li><p>拒取式：<span class="math display">\[(A→B)\and
¬B⇒¬A\]</span></p></li>
<li><p>析取三段论：<span class="math display">\[(A\or
B)\or¬A⇒B{\qquad}(A\or B)\or¬B⇒A\]</span></p></li>
<li><p>假言三段论：<span
class="math display">\[(A→B)\and(B→C)⇒(A→C)\]</span></p></li>
<li><p>等价三段论：<span
class="math display">\[(A↔B)\and(B↔C)⇒(A↔C)\]</span></p></li>
<li><p>构造性两难：<span class="math display">\[(A→B)\and(C→D)\and(A\or
C)⇒(B\or D)\]</span></p></li>
</ul>
<h3 id="谓词">0.5 谓词</h3>
<p><strong>基本概念</strong></p>
<ul>
<li><p>个体：表示客体的词。</p>
<p>使用 <span class="math display">\[a,b,c,\ldots\]</span> 表示
<strong>个体常元</strong>，使用 <span
class="math display">\[x,y,z,\ldots\]</span> 表示
<strong>个体变元</strong>。</p>
<p>个体的函数仍是个体。将个体变元的取值范围称为
<strong>个体域</strong>。</p></li>
<li><p>谓词：表示个体间关系或性质的词。</p>
<p>常用 <span class="math display">\[F,G,H,\ldots\]</span> 表示
<strong>谓词常元</strong> 或 <strong>谓词变元</strong>。</p>
<p><span class="math display">\[F(x)\]</span> 表示 <span
class="math display">\[x\]</span> 具有性质 <span
class="math display">\[F\]</span>。如：<span
class="math display">\[F(x)\]</span> 表示 " 是黑色的"，而 <span
class="math display">\[a\]</span> 表示 "黑板"，则 <span
class="math display">\[F(a)\]</span> 表示 "黑板是黑色的"</p>
<p><span class="math display">\[F(x,y)\]</span> 表示 <span
class="math display">\[x\]</span> 和 <span
class="math display">\[y\]</span> 具有关系 <span
class="math display">\[F\]</span>。如：<span
class="math display">\[F(x,y)\]</span> 表示 "<span
class="math display">\[x&gt;y\]</span>"，则 <span
class="math display">\[F(5,2)\]</span> 表示 <span
class="math display">\[5&gt;2\]</span></p></li>
<li><p>量词：表示数量的词</p>
<p>全称量词：<span class="math display">\[∀\]</span>
表示任意、全部。如：<span class="math display">\[∀x\]</span>
表示个体域中的所有 <span class="math display">\[x\]</span>；<span
class="math display">\[∀xF(x)\]</span> 表示个体域中所有 <span
class="math display">\[x\]</span> 都有性质 <span
class="math display">\[F\]</span></p>
<p>存在量词：<span class="math display">\[∃\]</span>
表示存在、有一个。如：<span class="math display">\[∃x\]</span>
表示存在个体域里的 <span class="math display">\[x\]</span>；<span
class="math display">\[∃xF(x)\]</span> 表示在个体域中存在 <span
class="math display">\[x\]</span> 有性质 <span
class="math display">\[F\]</span></p></li>
</ul>
<p><strong>命题符号化</strong></p>
<p>一阶逻辑中命题逻辑化的两个基本公式：</p>
<ul>
<li><p><span class="math display">\[∀x(F(x)\rarr G(x))\]</span></p>
<p>个体域中所有具有性质 <span class="math display">\[F\]</span>
的个体都具有性质 <span class="math display">\[G\]</span></p></li>
<li><p><span class="math display">\[∃x(F(x)\and G(x))\]</span></p>
<p>个体域中存在同时具有性质 <span class="math display">\[F\]</span>
和性质 <span class="math display">\[G\]</span> 的个体</p></li>
</ul>
<p><strong>一阶谓词逻辑公式及其分类</strong></p>
<p>一阶谓词逻辑公式，简称公式。其形成逻辑类似于命题逻辑公式。而且，<span
class="math display">\[A\]</span> 是公式时，<span
class="math display">\[∀xA\]</span> 及 <span
class="math display">\[∃xA\]</span> 也是公式</p>
<p>在公式 <span class="math display">\[∀xA\]</span> 及 <span
class="math display">\[∃xA\]</span> 中，称 <span
class="math display">\[x\]</span> 为 <strong>指导变元</strong>，称 <span
class="math display">\[A\]</span> 为相应量词的
<strong>辖域</strong>。在该辖域中，<span
class="math display">\[x\]</span> 的所有出现都是
<strong>约束出现</strong>。所有非约束出现的变元都是
<strong>自由出现</strong></p>
<p><strong>解释</strong></p>
<p>对于给定的公式 <span class="math display">\[A\]</span>，如果指定
<span class="math display">\[A\]</span> 的个体域是已知的 <span
class="math display">\[D\]</span>，使用特定的个体常元取代 <span
class="math display">\[A\]</span> 中的个体常元，用特定函数取代 <span
class="math display">\[A\]</span> 中的函数变元，用特定的谓词取代 <span
class="math display">\[A\]</span> 中的谓词变元，就构成了 <span
class="math display">\[A\]</span> 的一个解释。</p>
<p>一个公式 <span class="math display">\[A\]</span>
可以有多种解释。当给出一种解释后，就能判断该解释的真假。</p>
<p>若 <span class="math display">\[A\]</span>
在任何解释下都为真，称之为永真式。还有永假式、可满足式。</p>
<p>若 <span class="math display">\[A\harr B\]</span> 是永真式，则称
<span class="math display">\[A\]</span> 与 <span
class="math display">\[B\]</span> 等值，记为 <span
class="math display">\[A⇔B\]</span>，并称之为等值式。</p>
<p>以下是一些基本的等值式</p>
<ul>
<li><p>在有限个体域 <span class="math display">\[D=\lbrace
a_1,a_2,\ldots,a_n\rbrace\]</span> 中消去量词等值式</p>
<p><span class="math display">\[\quad ∀xA(x)⇔A(a_1)\and A(a_2)\and
\ldots \and A(a_n)\]</span></p>
<p><span class="math display">\[\quad ∃xA(x)⇔A(a_1)\or A(a_2)\or \ldots
\or A(a_n)\]</span></p></li>
<li><p>量词否定等值式</p>
<p><span class="math display">\[\quad ¬∀xA(x)⇔∃x¬A(x)\]</span></p>
<p><span class="math display">\[\quad ¬∃xA(x)⇔∀x¬A(x)\]</span></p></li>
<li><p>量词辖域收缩和扩张等值式（<span class="math display">\[B\]</span>
中不含 <span class="math display">\[x\]</span>）</p>
<p><span class="math display">\[\quad ∀x(A(x)\or B)⇔∀xA(x)\or
B\]</span></p>
<p><span class="math display">\[\quad ∃x(A(x)\or B)⇔∃xA(x)\or
B\]</span></p>
<p><span class="math display">\[\quad ∀x(A(x)\and B)⇔∀xA(x)\and
B\]</span></p>
<p><span class="math display">\[\quad ∃x(A(x)\and B)⇔∃xA(x)\and
B\]</span></p>
<p><span class="math display">\[\quad ∀x(A(x)\rarr B)⇔∃xA(x)\rarr
B\]</span></p>
<p><span class="math display">\[\quad ∃x(A(x)\rarr B)⇔∀xA(x)\rarr
B\]</span></p>
<p><span class="math display">\[\quad ∀x(B\rarr A(x))⇔B\rarr
∀xA(x)\]</span></p>
<p><span class="math display">\[\quad ∃x(B\rarr A(x))⇔B\rarr
∃xA(x)\]</span></p></li>
<li><p>量词分配等值式</p>
<p><span class="math display">\[\quad ∀x(A(x)\and B(x))⇔∀xA(x)\and
B(x)\]</span></p>
<p><span class="math display">\[\quad ∃x(A(x)\or B(x))⇔∃xA(x)\or
B(x)\]</span></p></li>
</ul>
<p><strong>前束范式</strong></p>
<p>若公式具有形式 <span class="math display">\[Q_1 x_1 Q_2 x_2\ldots Q_k
x_k B\]</span>，则称其为 <strong>前束范式</strong>。其中 <span
class="math display">\[Q_i(i\le i \le k)\]</span> 为 <span
class="math display">\[∃\]</span> 或 <span
class="math display">\[∀\]</span>，<span
class="math display">\[B\]</span> 中不含量词</p>
<p>换名规则：将公式 <span class="math display">\[A\]</span>
中某量词辖域中出现的某个约束的个体变元及相应指导变元 <span
class="math display">\[x_i\]</span> 都改成公式中没有出现过的 <span
class="math display">\[x_j\]</span>，所得公式 <span
class="math display">\[A&#39;⇔A\]</span></p>
<p>一些重要的推理定律（注意：不是等值式）</p>
<ul>
<li><span class="math display">\[∀xA(x)\or ∀xB(x)⇒∀xA(x)\or
B(x)\]</span></li>
<li><span class="math display">\[∃x(A(x)\and B(x))⇒∃xA(x)\and
∃xB(x)\]</span></li>
<li><span class="math display">\[∀x(A(x)\rarr B(x))⇒∀xA(x)\rarr
∀xB(x)\]</span></li>
<li><span class="math display">\[∀x(A(x)\rarr B(x))⇒∃xA(x)\rarr
∃xB(x)\]</span></li>
</ul>
<h2 id="集合论">1 集合论</h2>
<h3 id="集合">1.1 集合</h3>
<p>集合：指定范围内所有满足给定条件的对象的聚集。其中的每个对象称为该集合的元素。集合中的元素是无序且不同的。</p>
<p>通常用大写英文字母表示集合（<span
class="math display">\[A\]</span>、<span
class="math display">\[A_1\]</span>），用小写字母表示元素（<span
class="math display">\[a\]</span>、<span
class="math display">\[a_1\]</span>）</p>
<p>常用集合：</p>
<ul>
<li><span
class="math display">\[N\]</span>：自然数集，也就是全体非负整数集</li>
<li><span class="math display">\[Z\]</span>：整数集</li>
<li><span class="math display">\[Q\]</span>：有理数集</li>
<li><span class="math display">\[R\]</span>：实数集</li>
</ul>
<p><strong>如何描述一个集合</strong></p>
<ul>
<li><p>枚举法</p>
<p>列举出集合中的全部或部分元素，其余元素使用省略号表示</p>
<p>如：<span class="math display">\[A =
\lbrace1,2,3,4\rbrace\]</span>、<span class="math display">\[B = \lbrace
a,b,c,d,\ldots\rbrace\]</span></p></li>
<li><p>叙述法</p>
<p>通过刻画集合中元素具有的某种性质来表示一个集合</p>
<p>如：<span class="math display">\[P=\lbrace
x|P(x)\rbrace\]</span>、<span class="math display">\[L=\lbrace
x|x是英文字母中的所有元音字母\rbrace\]</span></p></li>
<li><p>文氏图</p>
<p>利用平面上的点来做成对集合的图解方法。一般用平面上的方形或圆形表示集合，用平面上的圆点来表示元素</p></li>
</ul>
<p><strong>集合的基本概念</strong></p>
<ul>
<li><p><strong>属于</strong></p>
<p>若 <span class="math display">\[a\]</span> 是 <span
class="math display">\[A\]</span> 中的元素，则称 <span
class="math display">\[a\]</span> 属于 <span
class="math display">\[A\]</span>。记为 <span
class="math display">\[a\in A\]</span>。否则，称 a 不属于 A，记为 <span
class="math display">\[a\notin A\]</span></p></li>
<li><p><strong>子集</strong></p>
<p>如果一个集合中的所有元素都是另一集合的元素，这种关系称为包含关系。记为
<span class="math display">\[A \subseteq B\]</span>。否则记为 <span
class="math display">\[A \not\subseteq B\]</span>。</p>
<p>符号化形式：</p>
<p><span class="math display">\[\quad B\subseteq A⇔∀x(x\in B \rarr x\in
A)\]</span></p>
<p><span class="math display">\[\quad B\not\subseteq A⇔∃x(x\in B \and
x\not\in A)\]</span></p></li>
<li><p><strong>相等</strong></p>
<p>当且仅当两个集合的元素完全相同时，称两个集合相等。记为 <span
class="math display">\[A = B\]</span>。否则，称两个集合不相等，记为
<span class="math display">\[A\neq B\]</span>。</p>
<p>符号化形式：</p>
<p><span class="math display">\[\quad A=B ⇔ (A \subseteq B)\and (B
\subseteq A)\]</span></p>
<p><span class="math display">\[\quad A=B ⇔∀x(x\in B \and x\in
A)\]</span></p></li>
<li><p><strong>真子集</strong></p>
<p>如果 <span class="math display">\[A \subseteq B\]</span> 并且 <span
class="math display">\[A \neq B\]</span> 则称 A 是 B 的真子集，记为
<span class="math display">\[A \subset B\]</span>。否则记为 <span
class="math display">\[A \not\subset B\]</span></p>
<p>符号化形式：</p>
<p><span class="math display">\[\quad B\subset A⇔A\subseteq B \and A
\neq B\]</span></p>
<p><span class="math display">\[\quad B\not\subset A⇔∃x(x\in A\and
x\not\in B)\and A \neq B\]</span></p></li>
<li><p><strong>基数</strong></p>
<p>集合中的元素个数称为集合的基数。A 的基数记为 <span
class="math display">\[|A|\]</span></p>
<p><span class="math display">\[\emptyset\]</span> 是 0
元集，只含一个元素的集合是 1 元集，以此类推。</p>
<p>若一个集合的基数是有限的，称该集合为有限集。否则为无限集。</p></li>
<li><p><strong>空集</strong></p>
<p>不含任何元素的集合称为空集，记为 <span
class="math display">\[\emptyset\]</span>。空集是最小的集合</p>
<p>空集是唯一的（<span class="math display">\[\emptyset _1=\emptyset
_2\]</span>）</p>
<p>空集是一切集合的子集（<span class="math display">\[\emptyset\subseteq
A\]</span>）</p></li>
<li><p><strong>全集</strong></p>
<p>针对一个具体范围，我们考虑的所有对象的集合叫做全集，记为 <span
class="math display">\[U\]</span> 或 <span
class="math display">\[E\]</span>。全集是相对的。</p></li>
<li><p><strong>幂集</strong></p>
<p>由一个集合的所有子集组成的集合称为其幂集。记为 <span
class="math display">\[P(A)\]</span>。用描述法表示为 <span
class="math display">\[P(A)=\lbrace x|x\subseteq
A\rbrace\]</span></p></li>
<li><p><strong>集族</strong></p>
<p>除幂集外，其他形式的由集合构成的集合称为集族</p></li>
<li><p><strong>多重集</strong></p>
<p>设全集为 <span class="math display">\[E\]</span>，<span
class="math display">\[E\]</span> 中元素可以多次出现的集合 <span
class="math display">\[A\]</span> 称为多重集。那个出现次数称为 <span
class="math display">\[A\]</span> 的重复度。</p>
<p>集合可以视为是重复度为 1 的多重集</p></li>
<li><p><strong>并集</strong></p>
<p>由两个集合 <span class="math display">\[A,B\]</span>
所有元素构成的集合为其并集，记作 <span class="math display">\[A\cup
B\]</span></p>
<p>其描述法表示为：<span class="math display">\[A\cup B=\lbrace x|x\in
A\or x\in B\rbrace\]</span></p>
<p>并运算可以推广到有限个或可数个集合（初级并）</p>
<p><span class="math display">\[\quad
A_1{\cup}A_2{\cup}{\ldots}{\cup}A_n={\lbrace}x|∃i(1{\le}i{\le}n{\and}x{\in}A_i){\rbrace}\]</span></p>
<p><span class="math display">\[\quad
{\bigcup_{i=1}^{n}\\}{A_i=A_1{\cup}A_2{\cup}{\ldots}{\cup}A_n}\]</span></p></li>
<li><p><strong>交集</strong></p>
<p>由两个集合 <span class="math display">\[A,B\]</span>
共有的元素构成的集合为其交集，记作 <span class="math display">\[A\cap
B\]</span></p>
<p>其描述法表示为：<span class="math display">\[A\cap B=\lbrace x|x\in
A\and x\in B\rbrace\]</span></p>
<p>交运算可以推广到有限个或可数个集合（初级交）</p>
<p><span class="math display">\[\quad
A_1{\cap}A_2{\cap}{\ldots}{\cap}A_n={\lbrace}x|∀i(1{\le}i{\le}n{\rarr}x{\in}A_i){\rbrace}\]</span></p>
<p><span class="math display">\[\quad
{\bigcap_{i=1}^{n}\\}A_i=A_1{\cap}A_2{\cap}{\ldots}{\cap}A_n\]</span></p></li>
<li><p><strong>不相交</strong></p>
<p>如果 <span class="math display">\[A{\cap}B=\emptyset\]</span>，则称
<span class="math display">\[A\]</span> 和 <span
class="math display">\[B\]</span> 是不相交的</p></li>
<li><p><strong>相对补</strong></p>
<p>对于集合 <span class="math display">\[A,B\]</span>，由属于 <span
class="math display">\[A\]</span> 但不属于 <span
class="math display">\[B\]</span> 的元素组成的集合称为 <span
class="math display">\[B\]</span> 对 <span
class="math display">\[A\]</span> 的相对补集。记作 <span
class="math display">\[A-B\]</span></p>
<p>描述法表示为：<span
class="math display">\[A-B={\lbrace}x|x{\in}A{\and}x{\not\in}B{\rbrace}\]</span></p></li>
<li><p><strong>对称差</strong></p>
<p>由属于 <span class="math display">\[A\]</span> 但不属于 <span
class="math display">\[B\]</span>，或属于 <span
class="math display">\[B\]</span> 却不属于 <span
class="math display">\[A\]</span> 的元素组成的集合称为 <span
class="math display">\[B\]</span> 对 <span
class="math display">\[A\]</span> 的对称差。记为 <span
class="math display">\[A{\oplus}B\]</span></p>
<p>描述法表示为：<span
class="math display">\[A{\oplus}B={\lbrace}x|(x{\in}A{\and}x{\not\in}B){\or}(x{\in}B{\and}x{\not\in}A){\rbrace}\]</span></p>
<p><span
class="math display">\[A{\oplus}B=(A-B){\cup}(B-A)=(A{\cup}B)-(A{\cap}B)\]</span></p></li>
<li><p><strong>绝对补集</strong></p>
<p>设 <span class="math display">\[E\]</span> 为全集，<span
class="math display">\[A{\subseteq}E\]</span>，称 <span
class="math display">\[A\]</span> 对 <span
class="math display">\[E\]</span> 的相对补集为 <span
class="math display">\[A\]</span> 的绝对补集。记为 <span
class="math display">\[\tilde\ {A}\]</span></p>
<p>描述法表示为：<span class="math display">\[\tilde\
{A}={\lbrace}x|x{\in}E{\and}x{\notin}A{\rbrace}\]</span>，由于 <span
class="math display">\[x{\in}E=1\]</span> 又有 <span
class="math display">\[\tilde\ A
={\lbrace}x|x{\notin}A{\rbrace}\]</span></p></li>
<li><p><strong>广义并集</strong></p>
<p>由一个集族 <span class="math display">\[{\mathcal A}\]</span>
中全体元素的元素组成的集合为其广义并，记为 <span
class="math display">\[{\bigcup}{\mathcal A}\]</span>（大并 <span
class="math display">\[{\mathcal A}\]</span>）</p>
<p>描述法表示为：<span class="math display">\[{\bigcup}{\mathcal
A}={\lbrace}x|{\exist}z(x{\in}z{\and}z{\in}{\mathcal
A}){\rbrace}\]</span></p></li>
<li><p><strong>广义交集</strong></p>
<p>由一个集族 <span class="math display">\[{\mathcal A}\]</span>
中全体元素的共有元素组成的集合为其广义交，记为 <span
class="math display">\[{\bigcap}{\mathcal A}\]</span>（大交 <span
class="math display">\[{\mathcal A}\]</span>）</p>
<p>描述法表示为：<span class="math display">\[{\bigcap}{\mathcal
A}={\lbrace}x|{\forall}z(x{\in}{\mathcal
A}{\rarr}z{\in}z){\rbrace}\]</span></p>
<p>空集不能求广义交。即 <span
class="math display">\[{\cap}{\emptyset}\]</span> 无意义</p></li>
</ul>
<p><strong>集合运算的优先级</strong></p>
<table>
<tr>
<th>
优先级
</th>
<th>
运算
</th>
<th>
类型
</th>
<th>
顺序
</th>
</tr>
<tr>
<th>
1
</th>
<td>
绝对补、幂集、广义交、广义并
</td>
<td>
一元运算
</td>
<td>
从右向左
</td>
</tr>
<tr>
<th>
2
</th>
<td>
初级并、初级交、相对补、对称差等
</td>
<td>
二元运算
</td>
<td>
从左向右
</td>
</tr>
</table>
<p><strong>容斥原理</strong></p>
<p>设 <span class="math display">\[A_1,A_2,{\dots},A_n\]</span> 为 n
个集合，则有</p>
<p><span
class="math display">\[\quad|{\bigcup_{i=1}^{n}\\}A_i|={\sum_{i=1}^{n}\\}|A_i|-{\sum_{i&lt;
j}\\}|A_i{\cap}A_j|+{\sum_{i&lt;j&lt;k}\\}|A_i{\cap}A_j{\cap}A_k|-{\ldots}+(-1)^{n-1}|A_1{\cap}A_2{\cap}{\ldots}{\cap}A_n|\]</span></p>
<h3 id="基本的集合恒等式">1.2 基本的集合恒等式</h3>
<p>设 <span class="math display">\[E\]</span> 为全集，<span
class="math display">\[A,B,C\]</span> 是 <span
class="math display">\[E\]</span> 的任意子集。则有：</p>
<ul>
<li><p>幂等律：<span
class="math display">\[A{\cup}A=A{\qquad}A{\cap}A=A\]</span></p></li>
<li><p>交换律：<span
class="math display">\[A{\cup}B=B{\cup}A{\qquad}A{\cap}B=B{\cap}A\]</span></p></li>
<li><p>结合律：<span
class="math display">\[A{\cup}(B{\cup}C)=(A{\cup}B){\cup}C{\qquad}A{\cap}(B{\cap}C)=(A{\cap}B){\cap}C\]</span></p></li>
<li><p>分配律：<span
class="math display">\[A{\cup}(B{\cap}C)=(A{\cup}B){\cap}(A{\cup}C){\qquad}A{\cap}(B{\cup}C)=(A{\cap}B){\cup}(A{\cap}C)\]</span></p></li>
<li><p>德·摩根定律：<span class="math display">\[\tilde\
(A{\cup}B)=\tilde\ A{\cap}\tilde\ B{\qquad}\tilde\ (A{\cap}B)=\tilde\
A{\cup}\tilde\ B\]</span></p>
<p><span
class="math display">\[E-(A{\cup}B)=(E-A){\cap}(E-B){\qquad}E-(A{\cap}B)=(E-A){\cup}(E-B)\]</span></p>
<p><span class="math display">\[\tilde\
(A_1{\cup}A_2{\cup\ldots\cup}A_n)=\tilde\ A_1{\cap}\tilde\
A_2{\cap\ldots\cap}\tilde\ A_n{\qquad}\tilde\
(A_1{\cap}A_2{\cap\ldots\cap}A_n)=\tilde\ A_1{\cup}\tilde\
A_2{\cup\ldots\cup}\tilde\ A_n\]</span></p></li>
<li><p>吸收律：<span
class="math display">\[A{\cup}(A{\cap}B)=A{\qquad}A{\cap}(A{\cup}B)=A\]</span></p></li>
<li><p>零律：<span
class="math display">\[A{\cup}E=E{\qquad}A{\cap\emptyset}={\emptyset}\]</span></p></li>
<li><p>同一律：<span
class="math display">\[A{\cap}E=A{\qquad}A{\cup\emptyset}=A\]</span></p></li>
<li><p>排中律：<span class="math display">\[A{\cup}\tilde\
A=E\]</span></p></li>
<li><p>矛盾律：<span class="math display">\[A{\cap}\tilde\
A={\emptyset}\]</span></p></li>
<li><p>余补律：<span class="math display">\[{\tilde\
E}={\emptyset}{\qquad}{\tilde\ \emptyset}=E\]</span></p></li>
<li><p>双重否定律：<span class="math display">\[{\tilde\ \tilde\
A}=A\]</span></p></li>
<li><p>补交转换律：<span class="math display">\[A-B=A{\cap}{\tilde\
B}\]</span></p></li>
</ul>
<p>设 <span
class="math display">\[{\lbrace}A_{\alpha}{\rbrace}_{\alpha\in
S}\]</span> 为集族，<span class="math display">\[B\]</span>
为一集合。则有：</p>
<ul>
<li><p>分配律：<span
class="math display">\[B{\cup}(\bigcap{\lbrace{A_{\alpha}}\rbrace}_{\alpha\in
S})={\bigcap_{\alpha\in
S}\\}(B{\cup}A_{\alpha}){\qquad}B{\cap}(\bigcup{\lbrace{A_{\alpha}}\rbrace}_{\alpha\in
S})={\bigcup_{\alpha\in S}\\}(B{\cap}A_{\alpha})\]</span></p></li>
<li><p>德·摩根律：<span
class="math display">\[{\tilde\\}(\bigcup{\lbrace{A_{\alpha}}\rbrace}_{\alpha\in
S})={\bigcap_{\alpha\in
S}\\}{\tilde\\A_{\alpha}}{\qquad}{\tilde\\}(\bigcap{\lbrace{A_{\alpha}}\rbrace}_{\alpha\in
S})={\bigcup_{\alpha\in S}\\}{\tilde\\A_{\alpha}}\]</span></p>
<p><span class="math display">\[\quad
B-({\bigcup{\lbrace{A_{\alpha}}\rbrace}_{\alpha\in
S}})={\bigcap_{\alpha\in
S}\\}(B-A_{\alpha}){\qquad}B-({\bigcap{\lbrace{A_{\alpha}}\rbrace}_{\alpha\in
S}})={\bigcup_{\alpha\in S}\\}(B-A_{\alpha})\]</span></p></li>
<li><p>幂集：<span
class="math display">\[A{\subseteq}B{\Harr}P(A){\subseteq}P(B){\qquad}P(A-B){\subseteq}(P(A)-P(B)){\cup}{\lbrace\empty\rbrace}\]</span></p></li>
</ul>
<h3 id="有序对和笛卡尔积">1.3 有序对和笛卡尔积</h3>
<ul>
<li><p><strong>有序对</strong></p>
<p><span class="math display">\[\quad
{\langle}a,b{\rangle}={\lbrace}{\lbrace}a{\rbrace},{\lbrace}a,b{\rbrace}{\rbrace}\]</span></p>
<p>其中 <span class="math display">\[a\]</span> 为第一元素，<span
class="math display">\[b\]</span> 为第二元素。<span
class="math display">\[{\langle}a,b{\rangle}\]</span> 也记作 <span
class="math display">\[(a,b)\]</span></p>
<p>有定理：<span
class="math display">\[{\langle}a,b{\rangle}={\langle}c,d{\rangle}{\Harr}(a=c){\and}(b=d)\]</span></p></li>
<li><p><strong>有序三元组</strong></p>
<p><span class="math display">\[\quad
{\langle}a,b,c{\rangle}={\langle}{\langle}a,b{\rangle},c{\rangle}\]</span></p></li>
<li><p><strong>有序 n 元组</strong></p>
<p><span class="math display">\[\quad
{\langle}a_1,a_2,{\ldots},a_n{\rangle}={\langle}{\langle}a_1,a_2,{\ldots},a_{n-1}{\rangle},a_n{\rangle}\]</span></p>
<p>有定理：<span
class="math display">\[{\langle}a_1,a_2,{\ldots},a_n{\rangle}={\langle}b_1,b_2,{\ldots},b_n{\rangle}{\Harr}a_i=b_i,i=1,2,{\ldots},n\]</span></p></li>
<li><p><strong>笛卡尔积</strong></p>
<p>有集合 <span class="math display">\[A,B\]</span>，由 <span
class="math display">\[A\]</span> 中的每个元素（做第一元素）与 <span
class="math display">\[B\]</span>
中的每个元素（做第二元素）组合，形成的所有有序对的集合称为笛卡尔积（卡式积），记为
<span class="math display">\[A{\times}B\]</span></p>
<p>笛卡尔积的性质：</p>
<ul>
<li><p>非交换性：<span
class="math display">\[(A{\not=}B{\and}A{\not=\empty\and}B{\not=\empty}){\Harr}(A{\times}B{\not
=}B{\times}A)\]</span></p></li>
<li><p>非结合性：<span
class="math display">\[(A{\not=\empty\and}B{\not=\empty\and}C{\not=\empty}){\Harr}((A{\times}B){\times}C{\not
=}A{\times}(B{\times}C))\]</span></p></li>
<li><p>分配律：<span class="math display">\[A\times (B\cup C)=(A\times
B)\cup(A\times C)\quad\]</span> 等</p></li>
<li><p>其他：<span
class="math display">\[A{\times}B={\empty}{\Harr}A={\empty\or}B={\empty}\qquad
A\not=\empty\and A\times B\subseteq A\times C\Harr B\subseteq
C\]</span></p>
<p><span class="math display">\[\quad A\subseteq C\and B\subseteq D\Rarr
A\times B\subseteq C\times D\]</span></p></li>
</ul></li>
<li><p><strong>n 维笛卡尔积</strong></p>
<p><span class="math display">\[\quad A_1\times A_2\times\ldots\times
A_n=\lbrace\langle x_1,x_2,\ldots,x_n\rangle|x_1\in A_1\and x_2\in
A_2\and\ldots\and x_n\in A_n\rbrace\]</span></p>
<p><span class="math display">\[\quad A^n=A\times A\times A\ldots\times
A\]</span></p>
<p><span class="math display">\[\quad
|A_i|=n_i,i=1,2,\ldots,n\Rarr|A_1\times A_2\times\ldots\times
A_n|=n_1\times n_2\times\ldots\times n_n\]</span></p>
<p>n 维卡式积的性质与二维卡式积相似</p></li>
</ul>
<h3 id="二元关系">1.4 二元关系</h3>
<ul>
<li><p><strong>n 元关系</strong></p>
<p>元素全是有序 n 元组的集合称为 n 元关系。</p>
<p>对于二元关系，有几种表示方法。设 <span
class="math display">\[F\]</span> 是二元关系，有：</p>
<ul>
<li>中缀记法：<span class="math display">\[xFy\qquad\]</span>如 <span
class="math display">\[2&lt;15\]</span></li>
<li>前缀记法：<span class="math display">\[F(x,y)\quad
Fxy\qquad\]</span>如 <span
class="math display">\[&lt;(2,15)\]</span></li>
<li>后缀记法：<span class="math display">\[\langle x,y\rangle\in F\quad
xyF\qquad\]</span>如 <span class="math display">\[\langle 2,15\rangle\in
&lt;\]</span></li>
</ul></li>
<li><p>任何 <span class="math display">\[A\times B\]</span> 的子集就是
<span class="math display">\[A\]</span> 到 <span
class="math display">\[B\]</span> 的<strong>二元关系</strong>。</p>
<p><span class="math display">\[\quad R\,是\,A\,到\,B\,的二元关系\Harr
R\subseteq A\times B\Harr R\in P(A\times B)\]</span></p>
<p>若 <span class="math display">\[|A|=m,|B|=n,|A\times
B|=mn\]</span>，故 <span class="math display">\[|P(A\times
B)|=2^{mn}\]</span>，即 <span class="math display">\[A\]</span> 到 <span
class="math display">\[B\]</span> 的不同二元关系有 <span
class="math display">\[2^{mn}\]</span> 个</p></li>
<li><p>任何 <span class="math display">\[A\times A\]</span> 的子集就是
<span class="math display">\[A\]</span> 上的二元关系。</p>
<p><span class="math display">\[\quad R\,是\,A\,上的二元关系\Harr
R\subseteq A\times A\Harr R\in P(A\times A)\]</span></p>
<p>若 <span class="math display">\[|A|=m,|A\times A|=m^2\]</span>，故
<span class="math display">\[|P(A\times A)|=2^{m^2}\]</span>，即不同的
<span class="math display">\[A\]</span> 上二元关系有 <span
class="math display">\[2^{m^2}\]</span> 个</p></li>
<li><p><strong>一些特殊关系</strong></p>
<p>设 <span class="math display">\[A\]</span> 是集合，则可定义 <span
class="math display">\[A\]</span> 上的：</p>
<ul>
<li>空关系：<span class="math display">\[\empty\]</span></li>
<li>恒等关系：<span class="math display">\[I_A=\lbrace\langle
x,x\rangle|x\in A\rbrace\]</span></li>
<li>全域关系：<span class="math display">\[E_A=A\times A=\lbrace\langle
x,y\rangle|x\in A\and y\in A\rbrace\]</span></li>
</ul>
<p>设 <span class="math display">\[A\subseteq Z\]</span>，则可定义 <span
class="math display">\[A\]</span> 上的：</p>
<ul>
<li><p>整除关系：<span class="math display">\[D_A=\lbrace\langle
x,y\rangle|x\in A\and y\in A\and x|y\rbrace\]</span></p></li>
<li><p>小于等于关系：<span class="math display">\[{LE}_A\]</span></p>
<p>小于关系：<span class="math display">\[L_A\]</span></p>
<p>大于等于关系：<span class="math display">\[{GE}_A\]</span></p>
<p>大于关系：<span class="math display">\[G_A\]</span></p></li>
</ul>
<p>设 <span class="math display">\[A\]</span> 是集合，则可定义 <span
class="math display">\[P(A)\]</span> 上的：</p>
<ul>
<li>包含关系</li>
<li>真包含关系</li>
</ul></li>
<li><p><strong>定义域、值域、域</strong></p>
<p>对于任意集合 <span class="math display">\[R\]</span>，可以定义</p>
<p>其定义域：<span class="math display">\[\operatorname{dom}R=\lbrace
x|\exist y(xRy)\rbrace\]</span></p>
<p>其值域：<span class="math display">\[\operatorname{ran}R=\lbrace
y|\exist y(xRy)\rbrace\]</span></p>
<p>其域：<span
class="math display">\[\operatorname{fld}R=\operatorname{dom}R\cup\operatorname{ran}R\]</span></p>
<p>如：集合 <span class="math display">\[R_1=\lbrace
a,b\rbrace,R_2=\lbrace a,b,\langle c,d\rangle,\langle
e,f\rangle\rbrace\]</span>，当 <span class="math display">\[a,b\]</span>
不是有序对时，<span class="math display">\[R_1,R_2\]</span>
不是关系。</p>
<p><span
class="math display">\[\quad\operatorname{dom}R_1=\empty\qquad\operatorname{ran}R_1=\empty\qquad\operatorname{fld}R_1=\empty\]</span></p>
<p><span class="math display">\[\quad\operatorname{dom}R_2=\lbrace
c,e\rbrace\qquad\operatorname{ran}R_2=\lbrace
d,f\rbrace\qquad\operatorname{fld}R_2=\lbrace
c,d,e,f\rbrace\]</span></p></li>
<li><p><strong>逆、合成</strong></p>
<p>对于任意集合 <span class="math display">\[F,G\]</span> 可以定义</p>
<p>逆：<span class="math display">\[F^{-1}=\lbrace\langle
x,y\rangle|yFx\rbrace\]</span></p>
<p>合成（逆序合成、左合成）：<span class="math display">\[F\circ
G=\lbrace\langle x,y\rangle|\exist z(xGz\and zFy)\rbrace\]</span></p>
<p>有以下定理：</p>
<ul>
<li><span class="math display">\[(R_1\circ R_2)\circ R_3=R_1\circ
(R_2\circ R_3)\]</span></li>
<li><span class="math display">\[(F\circ G)^{-1}=F^{-1}\circ
G^{-1}\]</span></li>
</ul></li>
<li><p><strong>限制、象</strong></p>
<p>对于任意集合 <span class="math display">\[F,A\]</span> 可以定义</p>
<p>限制：<span class="math display">\[F\restriction A=\lbrace\langle
x,y\rangle|xFy\and x\in A\rbrace\]</span></p>
<p>象：<span
class="math display">\[F[A]=\operatorname{ran}(F\restriction
A)\]</span></p></li>
<li><p><strong>单根</strong></p>
<p>对于集合 <span class="math display">\[F\]</span> 可以定义单根</p>
<p><span class="math display">\[\quad F\,是单根的\Harr\forall
y(y\in\operatorname{ran}F\rarr \exist!x(x\in\operatorname{dom}F\and
xFy))\Harr(\forall
y\in\operatorname{ran}F)(\exist!x\in\operatorname{dom}F)(xFy)\]</span></p>
<p>上面的 <span class="math display">\[\exist!\]</span>
表示：存在唯一的</p>
<p><span class="math display">\[\forall x(x\in A\rarr B(x))\]</span>
缩写为 <span class="math display">\[(\forall x\in A)B(x)\]</span></p>
<p><span class="math display">\[\exist x(x\in A\and B(x))\]</span>
缩写为 <span class="math display">\[(\exist x\in
A)B(x)\]</span></p></li>
<li><p><strong>单值</strong></p>
<p>对于集合 <span class="math display">\[F\]</span> 可以定义单根</p>
<p><span class="math display">\[\quad F\,是单值的\Harr\forall
x(x\in\operatorname{dom}F\rarr \exist!y(y\in\operatorname{ran}F\and
xFy))\Harr(\forall
x\in\operatorname{dom}F)(\exist!y\in\operatorname{ran}F)(xFy)\]</span></p>
<p>函数就可以被视作单值的二元关系</p></li>
</ul>
<h3 id="关系的表示">1.5 关系的表示</h3>
<p>关系的表示有三种方法</p>
<ul>
<li>集合</li>
<li>关系矩阵</li>
<li>关系图</li>
</ul>
<h4 id="关系矩阵">关系矩阵</h4>
<p><span class="math display">\[\quad A=\lbrace
a_1,a_2,\ldots,a_n\rbrace,\,B=\lbrace
b_1,b_2,\ldots,b_m\rbrace,\,R=A\times B\]</span></p>
<p>则 <span class="math display">\[R\]</span> 的关系矩阵有</p>
<p><span class="math display">\[\quad M(R)=(r_{ij})_{n\times m}\qquad
M(R)(i,j)=r_{ij}=\begin{cases}1,\quad a_iRb_j\\0,\quad
否则\end{cases}\]</span></p>
<blockquote>
<p>如，<span class="math display">\[A=\lbrace a,b,c\rbrace,\,B=\lbrace
d,e,f\rbrace,\,R=\lbrace\langle a,d\rangle,\langle a,f\rangle,\langle
b,f\rangle,\langle c,e\rangle\rbrace\]</span></p>
<p>则 <span class="math display">\[M(R)=\left[ \begin{matrix}1\quad
0\quad 1\\0\quad 0\quad 1\\0\quad 1\quad
0\end{matrix}\right]\]</span></p>
</blockquote>
<p>集合表达式与关系矩阵可以唯一相互确定</p>
<ul>
<li><p><strong>矩阵转置</strong>：<span
class="math display">\[M(R^{-1})=(M(R))^{T}\]</span></p></li>
<li><p><strong>逻辑乘</strong>：<span class="math display">\[M(R_1\circ
R_2)=M(R_2)\bullet M(R_1)\]</span>，其中乘法对应逻辑的 <span
class="math display">\[\and\]</span>，加法对应逻辑的 <span
class="math display">\[\or\]</span></p>
<blockquote>
<p><strong><em>有关矩阵的乘法</em></strong></p>
<p>设 <span class="math display">\[A\]</span> 为 <span
class="math display">\[m\times p\]</span> 的矩阵，<span
class="math display">\[B\]</span> 为 <span
class="math display">\[p\times n\]</span> 的矩阵，那么称 <span
class="math display">\[m\times n\]</span> 的矩阵 <span
class="math display">\[C\]</span> 为矩阵 <span
class="math display">\[A\]</span> 与 <span
class="math display">\[B\]</span> 的乘积，记作 <span
class="math display">\[C=AB\]</span> 或 <span
class="math display">\[C=A\times B\]</span></p>
<p>此时，矩阵 <span class="math display">\[C\]</span> 中第 <span
class="math display">\[i\]</span> 行 <span
class="math display">\[j\]</span> 列的元素有：<span
class="math display">\[\quad c_{ij}={\sum_{k=1}^{p}\\}(a_{ik}\times
b_{kj})=a_{i1}\times b_{1j}+a_{i2}\times b_{2j}+\ldots+a_{ip}\times
b_{pj}\]</span></p>
<p>对于矩阵 <span class="math display">\[A,B\]</span> 仅当 <span
class="math display">\[A\,的行数\,=\,B\,的列数\]</span>
时才能进行矩阵相乘。</p>
<p>如存在矩阵 <span
class="math display">\[A=\left[\begin{matrix}a_1\quad a_2\quad
a_3\end{matrix}\right],\,B=\left[\begin{matrix}b_1\\b_2\\b_3\end{matrix}\right]\]</span></p>
<p>则 <span class="math display">\[A\times B
=\left[\begin{matrix}a_1\times b_1\quad a_1\times b_2\quad a_1\times
b_3\\a_2\times b_1\quad a_2\times b_2\quad a_2\times b_3\\a_3\times
b_1\quad a_3\times b_2\quad a_3\times
b_3\end{matrix}\right]\]</span></p>
</blockquote></li>
</ul>
<h4 id="关系图">关系图</h4>
<p><span class="math display">\[\quad A=\lbrace
a_1,a_2,\ldots,a_n\rbrace,\,B=\lbrace
b_1,b_2,\ldots,b_m\rbrace,\,R=A\times B\]</span></p>
<p>则 <span class="math display">\[R\]</span> 的关系图 <span
class="math display">\[G(R)\]</span>：</p>
<ul>
<li>以 <span class="math display">\[∘\]</span> 表示 <span
class="math display">\[A,B\]</span> 中元素（称为顶点），以 <span
class="math display">\[\rarr\]</span> 表示 <span
class="math display">\[R\]</span> 中元素</li>
<li>若 <span class="math display">\[a_iRb_j\]</span> 则从顶点 <span
class="math display">\[a_i\]</span> 向顶点 <span
class="math display">\[b_j\]</span> 引有向边 <span
class="math display">\[\langle a_i,b_j\rangle\]</span></li>
</ul>
<p>下面是 <span class="math display">\[A=\lbrace
a,b,c\rbrace,\,R=\lbrace{\langle a,a\rangle},{\langle
a,b\rangle},{\langle b,a\rangle},{\langle b,c\rangle}\rbrace\]</span>
的关系图 <span class="math display">\[G(R)\]</span>（我尽力了）</p>
<pre><code class=" mermaid">graph LR
a((a)) --&gt; b((b)) --&gt; c((c))
b --&gt; a
a --&gt; a</code></pre>
<p>关系图、关系矩阵、关系表达式间都能相互确定。</p>
<p>对于 <span class="math display">\[G(A\times
B)\]</span>，关系图中的边都是由 <span class="math display">\[A\]</span>
中元素指向 <span class="math display">\[B\]</span> 的</p>
<h3 id="关系的性质">1.6 关系的性质</h3>
<ul>
<li><p><strong>自反性</strong></p>
<p>对于关系 <span class="math display">\[R\subseteq A\times
A\]</span>，其自反性有：</p>
<p><span class="math display">\[\quad R\,是自反的\Harr\forall x(x\in
A\rarr xRx)\Harr(\forall x\in A)xRx\]</span></p>
<p>相反地有</p>
<p><span class="math display">\[\quad R\,是非自反的\Harr\exist x(x\in
A\and\neg xRx)\]</span></p>
<p>关于自反性有如下定理：</p>
<p><span class="math display">\[\quad\begin{align}
&amp;R\,是自反的\\\Harr\,&amp;I_A\subseteq
R\\\Harr\,&amp;R^{-1}\,是自反的\\\Harr\,&amp;M(R)\,主对角线上的元素全是\,1\\\Harr\,&amp;G(R)的每个顶点处都有环\end{align}\]</span></p></li>
<li><p><strong>反自反性</strong></p>
<p>对于关系 <span class="math display">\[R\subseteq A\times
A\]</span>，其反自反性有：</p>
<p><span class="math display">\[\quad R\,是反自反的\Harr\forall x(x\in
A\rarr \neg xRx)\Harr(\forall x\in A)\neg xRx\]</span></p>
<p>相反地有</p>
<p><span class="math display">\[\quad R\,是非反自反的\Harr\exist x(x\in
A\and xRx)\]</span></p>
<p>可以想见，对于 <span class="math display">\[R\subseteq A\times
A,\,Q=(A\times A)-R\]</span>，如果 <span
class="math display">\[R\]</span> 是反自反的，那么 <span
class="math display">\[Q\]</span> 就是自反的</p>
<p>关于反自反性有如下定理：</p>
<p><span
class="math display">\[\quad\begin{align}&amp;R\,是反自反的\\\Harr\,&amp;I_A\cap
R=\emptyset\\\Harr\,&amp;R^{-1}\,是反自反的\\\Harr\,&amp;M(R)\,主对角线上的元素全是\,0\\\Harr\,&amp;G(R)的每个顶点处都无环\end{align}\]</span></p></li>
<li><p><strong>对称性</strong></p>
<p>对于关系 <span class="math display">\[R\subseteq A\times
A\]</span>，其对称性有：</p>
<p><span
class="math display">\[\quad\begin{align}&amp;R\,是对称的\\\Harr\,&amp;\forall
x\forall y(x\in A\and y\in A\and xRy\rarr yRx)\Harr(\forall x\in
A)(\forall y\in A)[xRy\rarr yRx]\end{align}\]</span></p>
<p>相反地有</p>
<p><span class="math display">\[\quad R\,是非对称的\Harr\exist x\exist
y(x\in A\and y\in A\and xRy\and\neg yRx)\]</span></p>
<p>关于对称性有如下定理：</p>
<p><span class="math display">\[\quad\begin{align}&amp;
R\,是对称的\\\Harr\,&amp;R^{-1}=R\\\Harr\,&amp;R^{-1}\,是对称的\\\Harr\,&amp;M(R)\,是对称的\\\Harr\,&amp;G(R)\,的所有边都有反向边\end{align}\]</span></p></li>
<li><p><strong>反对称性</strong></p>
<p>对于关系 <span class="math display">\[R\subseteq A\times
A\]</span>，其反对称性有：</p>
<p><span class="math display">\[\quad
\begin{align}&amp;R\,是反对称的\\\Harr\,&amp;\forall x\forall y(x\in
A\and y\in A\and xRy\and yRx\rarr A=B)\\\Harr\,&amp;(\forall x\in
A)(\forall y\in A)[xRy\and yRx\rarr A=B]\end{align}\]</span></p>
<p>相反地有</p>
<p><span class="math display">\[\quad R\,是非反对称的\Harr\exist x\exist
y(x\in A\and y\in A\and xRy\and yRx \and A\not=B)\]</span></p>
<p>可见，反对称性可能与对称性同时存在</p>
<p>关于非反对称性有如下定理：</p>
<p><span class="math display">\[\quad
\begin{align}&amp;R\,是反对称的\\\Harr\,&amp;R^{-1}\cap R\subseteq
I_A\\\Harr\,&amp;R^{-1}\,是反对称的\\\Harr\,&amp;在\,M(R)\,中，\forall
i\forall j(i\not=j\and r_{ij}=1\rarr
r_{ji}=0)\\\Harr\,&amp;G(R)\,的所有不同点间有不多于\,1\,条边\end{align}\]</span></p></li>
<li><p><strong>传递性</strong></p>
<p>对于关系 <span class="math display">\[R\subseteq A\times
A\]</span>，其传递性有：</p>
<p><span
class="math display">\[\quad\begin{align}&amp;R\,是传递的\\\Harr\,&amp;\forall
x\forall y\forall z(x\in A\and y\in A\and z\in A\and xRy\and yRz\rarr
xRz)\\\Harr\,&amp;(\forall x\in A)(\forall y\in A)(\forall z\in
A)[xRy\and yRz\rarr xRz]\end{align}\]</span></p>
<p>相反地有</p>
<p><span
class="math display">\[\begin{align}\quad&amp;R\,是非传递的\Harr\exist
x\exist y\exist z(x\in A\and y\in A\and z\in A\and xRy\and yRz\and \neg
xRz)\end{align}\]</span></p>
<p>关于传递性有如下定理：</p>
<p><span
class="math display">\[\quad\begin{align}&amp;R\,是传递的\\\Harr\,&amp;R\circ
R\subseteq R\\\Harr\,&amp;R^{-1}\,是传递的\\\Harr\,&amp;\forall i\forall
j,M(R\circ R)(i,j)\le M(R)(i,j)\\\Harr\,&amp;在\,G(R)\,中，\forall
a_i\forall a_j\forall a_k，若有有向边\,\langle
a_i,a_j\rangle\,和\,\langle a_j,a_k\rangle ，则必有有向边\,\langle
a_i,a_k\rangle\end{align}\]</span></p></li>
</ul>
<h3 id="关系的幂运算和闭包">1.7 关系的幂运算和闭包</h3>
<ul>
<li><p><strong>关系的 n 次幂</strong></p>
<p>对于关系 <span class="math display">\[R\subseteq A\times A,n\in
N\]</span>，有 <span
class="math display">\[\begin{cases}R^0=I_A\\R^{n+1}=R^n\circ
R(n\ge0)\end{cases}\]</span></p>
<p>显然 <span class="math display">\[R^n\subseteq A\times A,n\in
N\]</span></p>
<p>对于 <span class="math display">\[R\subseteq A\times A,\, m,n\in
N\]</span>，有如下定理：</p>
<p><span class="math display">\[\quad R^m\circ R^n=R^{m+n}\qquad
(R^m)^n=R^{mn}\]</span></p></li>
<li><p><strong>闭包</strong></p>
<p>包含给定元素，并具有指定性质的最小集合称为闭包</p>
<p>闭包是任何 <span class="math display">\[包含\,R\,的某种集合\]</span>
的子集合，或者所有 <span
class="math display">\[包含\,R\,的某种集合\]</span> 的交集。</p>
<ul>
<li><p>自反闭包：<span class="math display">\[r(R)\]</span>，包含 <span
class="math display">\[R\]</span> 的具有自反性的闭包</p>
<p><span class="math display">\[\quad R\subseteq r(R)\qquad
r(R)是自反的\qquad \forall S((R\subseteq S\and S 自反)\rarr
r(r)\subseteq S)\]</span></p>
<p><span class="math display">\[\quad r(R)=R\cup I_A\]</span></p></li>
<li><p>对称闭包：<span class="math display">\[s(R)\]</span>，包含 <span
class="math display">\[R\]</span> 的具有对称性的闭包</p>
<p><span class="math display">\[\quad R\subseteq s(R)\qquad
s(R)是对称的\qquad \forall S((R\subseteq S\and S 对称)\rarr
s(r)\subseteq S)\]</span></p>
<p><span class="math display">\[\quad s(R)=R\cup R^{-1}\]</span></p>
<p>传递关系的对称闭包不一定是传递的</p></li>
<li><p>传递闭包：<span class="math display">\[t(R)\]</span>，包含 <span
class="math display">\[R\]</span> 的具有传递性的闭包</p>
<p><span class="math display">\[\quad R\subseteq t(R)\qquad
t(R)是传递的\qquad \forall S((R\subseteq S\and S 传递)\rarr
t(r)\subseteq S)\]</span></p>
<p><span class="math display">\[\quad t(R)=R\cup R^2\cup
R^3\cup\dots\]</span></p></li>
</ul>
<p>闭包有如下定理：</p>
<p><span class="math display">\[\quad R\,是自反的\Harr r(R)=R\quad
R\,是对称的\Harr s(R)=R\quad R\,是传递的\Harr t(R)=R\]</span></p>
<p><span class="math display">\[\quad R_1\subseteq R_2\subseteq A\times
A\Rarr\quad r(R_1)\subseteq r(R_2)\quad s(R_1)\subseteq s(R_2)\quad
t(R_1)\subseteq t(R_2)\]</span></p>
<p><span class="math display">\[\quad r(R_1\cup R_2)=r(R_1)\cup
r(R_2);\quad s(R_1\cup R_2)=s(R_1)\cup s(R_2)\quad t(R_1\cup
R_2){\color{Red}{\supseteq}}t(R_1)\cup t(R_2)\]</span></p></li>
</ul>
<h3 id="等价关系和划分">1.8 等价关系和划分</h3>
<ul>
<li><p><strong>等价关系</strong></p>
<p>有 <span class="math display">\[A\not=\empty\quad R\subseteq A\times
A\]</span>，若 <span class="math display">\[R\]</span>
是自反、对称、传递的，则称 <span class="math display">\[R\]</span>
是等价关系</p>
<p>由于 <span class="math display">\[st(R)\subseteq ts(R)\]</span>，对
<span class="math display">\[R\]</span> 依次求闭包只有 <span
class="math display">\[tsr(R)=trs(R)=rts(R)\]</span> 是等价闭包</p></li>
<li><p><strong>等价类</strong></p>
<p>设 <span class="math display">\[R\]</span> 是 <span
class="math display">\[A\not=\empty\]</span> 上的等价关系，<span
class="math display">\[x\in A\]</span>，则 <span
class="math display">\[x\]</span> 关于 <span
class="math display">\[R\]</span> 的等价类是 <span
class="math display">\[[x]_R=\lbrace y|y\in A\and
xRy\rbrace\]</span></p>
<p>简称 <span class="math display">\[x\]</span> 的等价类，记为 <span
class="math display">\[[x]\]</span></p>
<p>设 <span class="math display">\[R\]</span> 是 <span
class="math display">\[A\not=\empty\]</span> 上的等价关系，<span
class="math display">\[\forall x,y\in A\]</span>，有以下定理</p>
<p><span class="math display">\[\quad [x]_R\not=\empty\]</span></p>
<p><span class="math display">\[\quad xRy\Rarr[x]_R=[y]_R\]</span></p>
<p><span class="math display">\[\quad\neg
xRy\Rarr[x]_R\cap[y]_R=\empty\]</span></p>
<p><span class="math display">\[\quad\bigcup\lbrace[x]_R|x\in A\rbrace
=A\]</span></p></li>
<li><p><strong>商集</strong></p>
<p>设 <span class="math display">\[R\]</span> 是 <span
class="math display">\[A\not=\empty\]</span> 上的等价关系，<span
class="math display">\[A\]</span> 关于 <span
class="math display">\[R\]</span> 的商集是 <span
class="math display">\[A/R=\lbrace[x]_R|x\in A\rbrace\]</span></p>
<p>若 <span class="math display">\[A=\lbrace
a_1,a_2,\ldots,a_n\rbrace\]</span> 上有等价关系 <span
class="math display">\[I_A,E_A,R_{ij}=I_A\cup\lbrace\langle
a_i,a_j\rangle,\langle a_j,a_i\rangle\rbrace,a_i,a_j\in
A,i\not=j\]</span></p>
<p><span class="math display">\[\quad A/I_A=\lbrace\lbrace
a_1\rbrace,\lbrace a_2\rbrace,\ldots,\lbrace
a_n\rbrace\rbrace\]</span></p>
<p><span class="math display">\[\quad A/E_A=\lbrace\lbrace
a_1,a_2,\ldots,a_n\rbrace\rbrace\]</span></p>
<p><span class="math display">\[\quad A/R_{ij}=A/I_A\cup\lbrace\lbrace
a_i,a_j\rbrace\rbrace-\lbrace\lbrace a_i\rbrace,\lbrace
a_j\rbrace\rbrace\]</span></p></li>
<li><p><strong>划分</strong></p>
<p><span class="math display">\[A\not=\empty\]</span> 的一个划分是 <span
class="math display">\[{\mathcal A}\subseteq P(A)\]</span> 满足</p>
<ol type="1">
<li><span class="math display">\[\empty\not\in\mathcal A\]</span></li>
<li><span class="math display">\[\forall x,y(x,y\in\mathcal A\and x\not=
y\Rarr x\cap y=\empty)\]</span></li>
<li><span class="math display">\[\bigcup\mathcal A=A\]</span></li>
</ol>
<p><span class="math display">\[\mathcal A\]</span>
中的元素称为划分块</p>
<p>若 <span class="math display">\[A\not=\empty\]</span>
则有以下定理</p>
<p><span class="math display">\[\quad R\,是\,A\,上的等价关系\Rarr
A/R\,是\,A\,的划分\]</span></p>
<p><span class="math display">\[\quad\mathcal A\,是\,A\,的划分\Rarr
同块关系\,R_{\mathcal A}\,是\,A上的等价关系\quad xR_{\mathcal
A}y\Harr\exist z(z\in\mathcal A\and x\in z\and y\in z)\]</span>，此时
<span class="math display">\[R_{\mathcal A}\]</span> 称为 <span
class="math display">\[\mathcal A\]</span> 所定义的等价关系</p></li>
<li><p><strong>Stirling 子集数</strong></p>
<p>把 n 个编号的球放到 k 个相同的箱子里，不同放法的总数 <span
class="math display">\[\begin{Bmatrix}n\\k\end{Bmatrix}\]</span> 称为
Stirling 子集数</p>
<p>Srirling 子集数也是将 n 元集分成 k 个非空子集的分法总数</p>
<p>递推公式有 <span
class="math display">\[\begin{Bmatrix}n\\k\end{Bmatrix}=\begin{cases}\begin{align}&amp;0\quad
&amp;k=0\\&amp;1\quad &amp;n=k\or k=1\\&amp;2^{n-1}-1\quad
&amp;k=2\\&amp;C_n^2\quad
&amp;n=k+1\\&amp;k\begin{Bmatrix}n-1\\k\end{Bmatrix}+\begin{Bmatrix}n-1\\k-1\end{Bmatrix}\quad
&amp;k &gt; 1\end{align}\end{cases}\]</span></p>
<p>k&gt;1 时，可以让 n-1 个元素分成 k 个子集后，加入第 n 个元素。或者让
n-1 个元素分成 k 个子集后，让第 n 个元素自成一个子集。</p></li>
<li><p><strong>加细</strong></p>
<p>有 <span class="math display">\[\mathcal{A,B}\]</span> 是 <span
class="math display">\[A\]</span> 的划分。若 <span
class="math display">\[\mathcal A\]</span> 的划分块都含于 <span
class="math display">\[\mathcal B\]</span> 的某个划分块中，则称 <span
class="math display">\[\mathcal A\]</span> 是 <span
class="math display">\[\mathcal B\]</span> 的加细</p></li>
</ul>
<h3 id="序关系">1.9 序关系</h3>
<ul>
<li><p><strong>偏序关系、偏序集</strong></p>
<p>设 <span class="math display">\[A\not=\empty,\,R\subseteq A\times
A\]</span>，若 <span class="math display">\[R\]</span> 是
<strong>自反、反对称、传递的</strong>，则称 <span
class="math display">\[R\]</span> 是 <span
class="math display">\[A\]</span> 上的偏序关系。用 <span
class="math display">\[\preccurlyeq\]</span> 表示偏序关系，读作
“小于等于”</p>
<p><span class="math display">\[\quad\langle x,y\rangle\in R\Harr
xRy\Harr x\preccurlyeq y\]</span></p>
<p>设 <span class="math display">\[\preccurlyeq\]</span> 是 <span
class="math display">\[A\]</span> 上的偏序关系，则称 <span
class="math display">\[\langle A,\preccurlyeq\rangle\]</span>
为偏序集</p></li>
<li><p><strong>可比、严格小于、覆盖</strong></p>
<p>对于 <span class="math display">\[\langle
A,\preccurlyeq\rangle,\,x,y\in A\]</span>，存在 <span
class="math display">\[x\preccurlyeq y\or y\preccurlyeq x\]</span>，则称
<span class="math display">\[x\]</span> 和 <span
class="math display">\[y\]</span> 可比</p>
<p>若 <span class="math display">\[x\not= y\]</span>，则称 <span
class="math display">\[x\]</span> 严格小于 <span
class="math display">\[y\]</span>，即 <span
class="math display">\[x\preccurlyeq y\and x\not=y\Harr x\prec
y\]</span></p>
<p>若不存在 <span class="math display">\[z\]</span> 使 <span
class="math display">\[x\prec z\]</span> 且 <span
class="math display">\[z\prec y\]</span>，则称 <span
class="math display">\[y\]</span> 覆盖 <span
class="math display">\[x\]</span>，即 <span
class="math display">\[x\prec y\and\neg\exist z(z\in A\and x\prec z\prec
y)\]</span></p></li>
<li><p><strong>哈斯图</strong></p>
<p>对于 <span class="math display">\[\langle
A,\preccurlyeq\rangle,\,x,y\in A\]</span></p>
<p>用顶点表示 <span class="math display">\[A\]</span> 中元素，当且仅当
<span class="math display">\[y\]</span> 覆盖 <span
class="math display">\[x\]</span> 时，<span
class="math display">\[y\]</span> 在 <span
class="math display">\[x\]</span> 上方，在 <span
class="math display">\[x,y\]</span> 间画无向边，即形成哈斯图</p></li>
<li><p><strong>全序关系（线序关系）</strong></p>
<p>对于偏序集 <span class="math display">\[\langle
A,\preccurlyeq\rangle\]</span>，若其中任意元素 <span
class="math display">\[x,y\]</span> 都可比，则称 <span
class="math display">\[\preccurlyeq\]</span> 是 <span
class="math display">\[A\]</span> 上从全序关系，称 <span
class="math display">\[\langle A,\preccurlyeq\rangle\]</span>
为全序集</p>
<p><span class="math display">\[\quad \langle
A,\preccurlyeq\rangle\,是全序集\Harr 哈斯图是一条直线\]</span></p></li>
<li><p><strong>拟序关系</strong></p>
<p>有 <span class="math display">\[A\not=\empty,\,R\subseteq A\times
A\]</span>，若 <span class="math display">\[R\]</span> 是
<strong>反自反、传递的（反自反性与传递性蕴含反对称性）</strong>，则称
<span class="math display">\[R\]</span> 为 <span
class="math display">\[A\]</span> 上的拟序关系。用 <span
class="math display">\[\prec\]</span> 表示拟序关系，称 <span
class="math display">\[\langle A,\prec\rangle\]</span> 为拟序集</p>
<p>若 <span class="math display">\[\preccurlyeq\]</span> 是 <span
class="math display">\[A\]</span> 上的偏序关系，<span
class="math display">\[\prec\]</span> 是 <span
class="math display">\[A\]</span> 上的拟序关系，则</p>
<ul>
<li><span class="math display">\[\prec\]</span> 是反对称的</li>
<li><span class="math display">\[\preccurlyeq-I_A\]</span> 是 <span
class="math display">\[A\]</span> 上的拟序关系</li>
<li><span class="math display">\[\prec\cup I_A\]</span> 是 <span
class="math display">\[A\]</span> 上的偏序关系</li>
</ul>
<p>若 <span class="math display">\[\prec\]</span> 是 <span
class="math display">\[A\]</span> 上的拟序关系，则</p>
<ul>
<li><span class="math display">\[x\prec y,\,x=y,\,y\prec x\]</span>
中最多只有一个式子成立</li>
<li><span class="math display">\[(x\prec y\or x=y)\and(y\prec x\or
x=y)\Rarr x=y\]</span></li>
</ul></li>
<li><p><strong>三歧性、拟线序</strong></p>
<p>有 <span class="math display">\[A\not=\empty\]</span>，<span
class="math display">\[\prec\]</span> 是 <span
class="math display">\[A\]</span> 上的拟序关系，若 <span
class="math display">\[x\prec y,\,x=y,\,y\prec x\]</span> 中
<strong>有且仅有</strong> 一式成立，则称 <span
class="math display">\[\prec\]</span> 具有三歧性。同时称 <span
class="math display">\[\prec\]</span> 为 <span
class="math display">\[A\]</span> 上的拟线序关系，称 <span
class="math display">\[\langle A,\prec\rangle\]</span>
为拟线序集</p></li>
<li><p><strong>最大（小）元、极大（小）元、上（下）界</strong></p>
<p>对于偏序集 <span class="math display">\[\langle
A,\preccurlyeq\rangle,B\subseteq A,y\in B\]</span></p>
<p><span class="math display">\[\quad y\,是\,B\,的最大元\Harr\forall
x(x\in B\rarr x\preccurlyeq y)\]</span></p>
<p><span class="math display">\[\quad y\,是\,B\,的最小元\Harr\forall
x(x\in B\rarr y\preccurlyeq x)\]</span></p>
<p><span class="math display">\[\quad y\,是\,B\,的极小元\Harr\forall
x(x\in B\and y\preccurlyeq x\rarr x= y)\]</span></p>
<p><span class="math display">\[\quad y\,是\,B\,的极大元\Harr\forall
x(x\in B\and x\preccurlyeq y\rarr x= y)\]</span></p>
<p>对于 <span class="math display">\[z\in A\]</span></p>
<p><span class="math display">\[\quad z\,是\,A\,的上界\Harr\forall
x(x\in B\rarr x\preccurlyeq z)\]</span></p>
<p><span class="math display">\[\quad z\,是\,A\,的下界\Harr\forall
x(x\in B\rarr z\preccurlyeq x)\]</span></p></li>
<li><p><strong>良序</strong></p>
<p>任何非空子集都有最小元的偏序关系</p>
<p>公理：任何集合都能被赋予一个良序</p>
<p>良序中的序数分为三类</p>
<ul>
<li><span class="math display">\[0\]</span></li>
<li>后继序数（有头有尾）：<span
class="math display">\[1,2,\dots,\omega+1,\omega+2,\dots\]</span></li>
<li>极限序数（有头无尾）：<span
class="math display">\[\omega,2\omega,\omega^2,\omega^\omega,\dots\]</span></li>
</ul></li>
<li><p><strong>链、反链</strong></p>
<p>设 <span class="math display">\[\langle
A,\preccurlyeq\rangle\]</span> 为偏序集，<span
class="math display">\[B\subseteq A\]</span></p>
<p><span class="math display">\[\quad B\,是\,A\,中的链\Harr\forall
x\forall y(x\in B\and y\in B\rarr x\,与\,y\,可比)\]</span></p>
<p><span class="math display">\[\quad B\,是\,A\,中的反链\Harr\forall
x\forall y(x\in B\and y\in B\and x\not= y\rarr
x\,与\,y\,不可比)\]</span></p>
<p><span class="math display">\[\quad|B|\]</span> 称为（反）链的长度</p>
<p>设 <span class="math display">\[\langle
A,\preccurlyeq\rangle\]</span> 为偏序集，<span
class="math display">\[A\]</span> 中最长链长度为 <span
class="math display">\[n\]</span>，则</p>
<ul>
<li><span class="math display">\[A\]</span> 中存在极大元</li>
<li><span class="math display">\[A\]</span> 存在 <span
class="math display">\[n\]</span>
个划分块的划分，使每个划分块都是反链</li>
<li>若 <span class="math display">\[|A|=mn+1\]</span>，则 <span
class="math display">\[A\]</span> 中要么有长度为 <span
class="math display">\[m+1\]</span> 的反链，要么有长度为 <span
class="math display">\[n+1\]</span> 的链</li>
</ul></li>
</ul>
<h3 id="函数">1.10 函数</h3>
<p>函数：也称映射。单值的二元关系。<span class="math display">\[\forall
x\in\operatorname{dom}F,\,\forall y,z\in\operatorname{ran}F,\,xFy\and
xFz\rarr y=z\]</span></p>
<p>函数的记号：<span class="math display">\[F(x)=y\Harr \langle
x,y\rangle\in F\Harr xFy\]</span></p>
<ul>
<li><p><strong>偏函数</strong></p>
<p>设 <span class="math display">\[F\]</span> 是函数，<span
class="math display">\[\operatorname{dom}F\subseteq
A\and\operatorname{ran}F\subseteq B\]</span> 则称之为 <span
class="math display">\[A\]</span> 到 <span
class="math display">\[B\]</span> 的偏函数。记作 <span
class="math display">\[F:A\rarr B\]</span></p>
<p>其中 <span class="math display">\[A\]</span> 称为 <span
class="math display">\[F\]</span> 的前域。</p>
<p><span class="math display">\[A\]</span> 到 <span
class="math display">\[B\]</span> 的全体偏函数记为 <span
class="math display">\[A\rarr B=\lbrace F|F:A\rarr B\rbrace\]</span></p>
<p>显然 <span class="math display">\[A\rarr B\subseteq P(A\times
B)\]</span></p></li>
<li><p><strong>真偏函数</strong></p>
<p><span class="math display">\[{dom\,}F\subset A\]</span>，记作 <span
class="math display">\[F:A\shortparallel\!\!\!\rarr B\]</span>。<span
class="math display">\[A\]</span> 到 <span
class="math display">\[B\]</span> 的全体真偏函数记为 <span
class="math display">\[A\shortparallel\!\!\!\rarr B=\lbrace
F|F:A\shortparallel\!\!\!\rarr B\rbrace\]</span></p>
<p>所以，就有 <span class="math display">\[A\shortmid\!\!\!\rarr
B=A\rarr B\cup A\shortparallel\!\!\!\rarr B\qquad
F:A\shortmid\!\!\!\rarr B\Rarr F:\operatorname{dom}F\rarr
B\]</span></p></li>
<li><p><strong>全函数</strong></p>
<p><span class="math display">\[\operatorname{dom}F=A\]</span>，记作
<span class="math display">\[F:A\shortmid\!\!\!\rarr B\]</span>。<span
class="math display">\[A\]</span> 到 <span
class="math display">\[B\]</span> 的全体全函数记为 <span
class="math display">\[B^A=A\rarr B=\lbrace F|F:A\shortmid\!\!\!\rarr
B\rbrace\]</span></p>
<p><span class="math display">\[A,B\]</span> 中存在空集 <span
class="math display">\[\empty\]</span> 时，<span
class="math display">\[B^A\]</span> 分为以下几种情况</p>
<ul>
<li><span class="math display">\[A,B\]</span> 是空集：<span
class="math display">\[B^A=\empty^{\empty}=\lbrace\empty\rbrace\]</span></li>
<li>仅 <span class="math display">\[A\]</span> 是空集：<span
class="math display">\[B^A=B^{\empty}=\lbrace\empty\rbrace\]</span></li>
<li>仅 <span class="math display">\[B\]</span> 是空集：<span
class="math display">\[B^A=\empty^{A}=\empty\]</span></li>
</ul>
<p>其余时候，<span
class="math display">\[|B^A|=|B|^{|A|}\]</span></p></li>
<li><p><strong>全函数的性质</strong></p>
<ul>
<li>单射：<span class="math display">\[F\]</span> 是单根的。</li>
<li>满射：<span
class="math display">\[\operatorname{ran}F=B\]</span></li>
<li>双射：<span class="math display">\[F\]</span>
即是单射也是满射。</li>
</ul>
<p>若有 <span class="math display">\[F:A\rarr
B,\,|A|=n,\,|B|=m\]</span>，则</p>
<ul>
<li><span class="math display">\[n&lt;m\]</span> 时，<span
class="math display">\[A\rarr B\]</span> 中无满射、双射。单射数量是
<span class="math display">\[m(m-1)\ldots(m-n+1)\]</span></li>
<li><span class="math display">\[n&gt;m\]</span> 时，<span
class="math display">\[A\rarr B\]</span> 中无单射、双射。满射数量是
<span
class="math display">\[m!\begin{Bmatrix}n\\m\end{Bmatrix}\]</span></li>
<li><span class="math display">\[n=m\]</span> 时，<span
class="math display">\[A\rarr B\]</span> 中双射个数为 <span
class="math display">\[n!\]</span></li>
</ul></li>
<li><p><strong>象、原象</strong></p>
<p>给定映射 <span class="math display">\[f:A\rarr B,\,A&#39;\subseteq
A,\,B&#39;\subseteq B\]</span></p>
<p>则 <span class="math display">\[A&#39;\]</span> 的像 <span
class="math display">\[f(A&#39;)=\lbrace y|x\in
A&#39;,xfy\rbrace\]</span></p>
<p><span class="math display">\[B&#39;\]</span> 的原像 <span
class="math display">\[f^{-1}(B&#39;)=\lbrace x|y\in B&#39;,xfy\rbrace
\]</span></p>
<p>有 <span class="math display">\[f(A)=\operatorname{ran}f\quad
f^{-1}(B)=\operatorname{dom}f=A\]</span></p></li>
<li><p><strong>特殊函数</strong></p>
<ul>
<li><p>常数函数：<span class="math display">\[f:A\rarr B,\,\exist b\in
B,\,\forall x\in A,\,f(x)=b\]</span></p></li>
<li><p>恒等函数：<span class="math display">\[I_A:A\rarr
A,\,I_A(x)=x\]</span></p></li>
<li><p>特征函数：<span
class="math display">\[\chi_A:E\rarr\lbrace0,1\rbrace,\,\chi_A(x)=1\Harr
x\in A\]</span></p>
<p>此时当 <span class="math display">\[\empty\subset A\subset E\]</span>
时，<span class="math display">\[\chi_A\]</span> 是满射</p></li>
</ul></li>
<li><p><strong>单调函数</strong></p>
<p>设 <span class="math display">\[f:A\rarr B\]</span> 且 <span
class="math display">\[\lang A,\le_A\rang,\lang B,\le_B\rang\]</span>
是偏序集</p>
<p>单调增：<span class="math display">\[\forall x,y\in A,\,x\le_Ay\Rarr
f(x)\le_Bf(y)\]</span></p>
<p>单调减：<span class="math display">\[\forall x,y\in A,\,x\le_Ay\Rarr
f(y)\le_Bf(x)\]</span></p>
<p>严格单调：将上面的 <span class="math display">\[\le\]</span> 换为
<span class="math display">\[&lt;\]</span>。此时是单射</p></li>
<li><p><strong>自然映射</strong></p>
<p>设 <span class="math display">\[R\]</span> 是 <span
class="math display">\[A\]</span> 上的等价关系</p>
<p>自然映射（典型映射）：<span class="math display">\[f:A\rarr
A/R,\,f(x)=[x]_R\]</span></p>
<p>当 <span class="math display">\[R=I_A\]</span> 时，<span
class="math display">\[f\]</span> 是单射</p>
<p>又有 <span class="math display">\[f:A\rarr B,\,g:B\rarr C\]</span> 则
<span class="math display">\[f\circ g:A\rarr C,\,F\circ
g(x)=f(g(x))\]</span></p>
<p>若 <span class="math display">\[f:A\rarr B\]</span> 是双射，则 <span
class="math display">\[f^{-1}=B\rarr A\]</span> 也是双射。此时称 <span
class="math display">\[f^{-1}\]</span> 为 <span
class="math display">\[f\]</span> 的 <strong>反函数</strong></p></li>
<li><p><strong>单边逆</strong></p>
<p>若 <span class="math display">\[f:A\rarr B,\,g:B\rarr A\]</span></p>
<p>左逆：<span class="math display">\[g\,是\,f\,的左逆\Harr g\circ
f=I_A\]</span></p>
<p>右逆：<span class="math display">\[g\,是\,f\,的右逆\Harr f\circ
g=I_B\]</span></p>
<p><span class="math display">\[\quad f\,存在左逆\Harr
f\,是单射\]</span></p>
<p><span class="math display">\[\quad f\,存在右逆\Harr
f\,是满射\]</span></p>
<p><span class="math display">\[\quad f\,存在左逆、右逆\Harr
f\,是双射\Harr f\,的左逆、右逆相等\]</span></p></li>
</ul>
<h3 id="自然数">1.11 自然数</h3>
<ul>
<li><p><strong>封闭</strong></p>
<p>有函数 <span class="math display">\[F\]</span>，<span
class="math display">\[A\subseteq\operatorname{dom}F\]</span></p>
<p>则有：<span class="math display">\[A\,在函数\,F\,下封闭\Harr
F(A)\subseteq A\Harr F:A\rarr A\Harr
F\,是\,A\,上一元运算\]</span></p></li>
<li><p><strong>皮亚诺公理</strong></p>
<p>皮亚诺公理定义了自然数的集合。</p>
<p>对于三元组 <span class="math display">\[\lang M,F,e\rang,\,F:M\rarr
M\]</span></p>
<ul>
<li><p><span class="math display">\[e\in M\]</span></p></li>
<li><p><span class="math display">\[M\]</span> 在 <span
class="math display">\[F\]</span> 下封闭</p></li>
<li><p><span class="math display">\[e\notin
\operatorname{ran}F\]</span></p></li>
<li><p><span class="math display">\[F\]</span> 是单射</p></li>
<li><p><span class="math display">\[A\subseteq M\and e\in A\and
A\,在\,F\,下封闭\Rarr A=M\]</span></p>
<p>（极小性公理/数学归纳法原理。即 <span
class="math display">\[M\]</span> 是满足条件的最小集合）</p></li>
</ul></li>
<li><p><strong>后继</strong></p>
<p>对于集合 <span class="math display">\[A\]</span>，其后继 <span
class="math display">\[A^+=A\cup\lbrace A\rbrace\]</span></p>
<p><span class="math display">\[\quad A\subseteq A^+\and A\in
A^+\]</span></p></li>
<li><p><strong>归纳集</strong></p>
<p><span
class="math display">\[\quad\begin{align}&amp;A\,是归纳集\\\Harr\,&amp;\empty\in
A\and\forall x(x\in A\rarr x^+\in
A)\\\Harr\,&amp;A\,含有\,\empty\,且对后继封闭\end{align}\]</span></p></li>
<li><p><strong>后继函数</strong></p>
<p><span class="math display">\[\quad\sigma:N\rarr N,\,\forall n\in
N,\,\sigma(n)=n^+\]</span></p></li>
<li><p><strong>传递集</strong></p>
<p>对于集合 <span class="math display">\[A\]</span>，<span
class="math display">\[\forall x\in a\in A\Rarr x\in A\]</span>，则称
<span class="math display">\[A\]</span> 为传递集</p>
<p>$<span class="math display">\[$\quad\begin{align}
&amp;A\,是传递集\\
\Harr\,&amp;{\bigcup\\}A\subseteq A\\
\Harr\,&amp;\forall a(a\in A\rarr a\subseteq A)\\
\Harr\,&amp;A\subseteq P(A)\\
\Harr\,&amp;P(A)\,是传递集
\end{align}\]</span>$$</p>
<p>另外，<span
class="math display">\[A\,是传递集\Rarr{\bigcup\\}(A^+)=A\]</span></p></li>
</ul>
<h4 id="集合论中的数学归纳法">集合论中的数学归纳法</h4>
<p>目标：证明 <span class="math display">\[\forall n\in
N\]</span>，<span class="math display">\[P(n)\]</span> 为真</p>
<ol type="1">
<li><p>构造 <span class="math display">\[S=\lbrace n|n\in N\and
P(n)\rbrace\]</span></p></li>
<li><p>证明 <span class="math display">\[S\]</span> 是归纳集</p>
<p>$<span class="math display">\[$\quad\begin{align}&amp;\empty\in
S\\&amp;\forall n(n\in s\rarr n^+\in
S)\\∴\quad&amp;S=N\end{align}\]</span>$$</p></li>
</ol>
<h4 id="使用集合来构造-peano-系统">使用集合来构造 Peano 系统</h4>
<p><strong>自然数</strong>：属于每个归纳集的集合。</p>
<p><strong>自然数集（<span
class="math display">\[N\]</span>）</strong>：包含于每个归纳集的集合。</p>
<p>$<span class="math display">\[$\quad\begin{align}
&amp;0=\empty\\
&amp;1=\empty^+=\lbrace\empty\rbrace=\lbrace 0\rbrace\\
&amp;2=\empty^{++}=\lbrace\empty,\lbrace\empty\rbrace\rbrace=\lbrace0,1\rbrace\\
&amp;\dots\\
&amp;n=(n-1)^+=\lbrace0,1,2,\ldots,n-1\rbrace
\end{align}\]</span>$$</p>
<p>如此一来，让自然数作为集合，可以进行运算</p>
<p>$<span class="math display">\[$\quad\begin{align}
&amp;2\cap3=\lbrace0,1\rbrace\cap\lbrace0,1,2\rbrace=\lbrace0,1\rbrace=2=\operatorname{min}(2,3)\\
&amp;2\cup3=\lbrace0,1\rbrace\cup\lbrace0,1,2\rbrace=\lbrace0,1,2\rbrace=3=\operatorname{max}(2,3)\\
&amp;3-2=\lbrace0,1,2\rbrace-\lbrace0,1\rbrace=\lbrace2\rbrace\\
&amp;2-3=\lbrace0,1\rbrace-\lbrace0,1,2\rbrace=\empty\\
&amp;\bigcup
n=\bigcup\lbrace0,1,\dots,n-1\rbrace=n-1=\operatorname{max}(0,1,\dots,n-1)\\
&amp;\bigcap
n=\bigcap\lbrace0,1,\dots,n-1\rbrace=0=\operatorname{min}(0,1,\dots,n-1)\\
&amp;0\in1\in2\in3\in\dots\qquad0\subseteq1\subseteq2\subseteq3\subseteq\dots
\end{align}\]</span>$$</p>
<p>于是有以下定理：</p>
<ul>
<li><p>自然数集是归纳集，且是最小的归纳集</p>
<p>自然数是传递集，自然数集也是传递集</p></li>
<li><p><span class="math display">\[\lang N,\sigma,0\rang\]</span> 是
Peano 系统</p></li>
<li><p><span class="math display">\[\forall m,n\in N,m^+\in n^+\Harr
m\in n\]</span></p></li>
<li><p>任何自然数都不是自己的元素。</p></li>
<li><p><span class="math display">\[\empty\]</span> 属于 <span
class="math display">\[0\]</span> 以外的任意自然数</p></li>
<li><p>任何自然数的元素都是其子集</p>
<p><span class="math display">\[\quad n\in N\Rarr\forall x(x\in n\rarr
x\subseteq n)\]</span></p></li>
<li><p>三歧性</p>
<p>对于 <span class="math display">\[\forall m,n\in
N\]</span>，以下三式恰有一式成立</p>
<p><span class="math display">\[\quad m\in n,\quad m=n,\quad n\in
m\]</span></p></li>
<li><p><span class="math display">\[N\]</span> 上的递归定理</p>
<p>设 <span class="math display">\[A\]</span> 为集合，<span
class="math display">\[a\in A,\,F:A\rarr A\]</span></p>
<p>则存在唯一的函数 <span class="math display">\[h:N\rarr
A\]</span>，使得 <span class="math display">\[h(0)=a\]</span>，且 <span
class="math display">\[\forall n\in N,\,h(n^+)=F((h(n)))\]</span></p>
<p>如此一来，就可以递归地定义函数。如</p>
<p><span class="math display">\[\quad\begin{align}&amp;a\in A,\,F:A\rarr
A\\&amp;\begin{cases}h(0)=a\\h(n+1)=F(h(n)),\,\forall n\in
N\end{cases}\end{align}\]</span></p></li>
</ul>
<p>定义自然数集上的二元运算：</p>
<ul>
<li><p><strong>加法</strong></p>
<p><span class="math display">\[\quad +:N\times N\rarr N\]</span></p>
<p><span class="math display">\[\quad+(\lang
2,3\rang)=5,\quad2+3=5\]</span></p>
<p>将 <span class="math display">\[m\]</span>
看成固定值，就能定义一元函数 <span
class="math display">\[+m\]</span>。再将 <span
class="math display">\[m\]</span> 扩展到每个自然数，就有了所有的 <span
class="math display">\[+m\]</span></p>
<p><span class="math display">\[\quad\begin{align}&amp;m\in
N,\,A_m:N\rarr
N\\&amp;\begin{cases}A_m(0)=m\\A_m(n^+)=(A_m(n))^+\end{cases}\end{align}\]</span></p>
<p>加法有以下性质</p>
<ul>
<li><span class="math display">\[m+0=m\]</span></li>
<li><span class="math display">\[m+n^+=(m+n)^+\qquad
m^++n=(m+n)^+\]</span></li>
<li><span class="math display">\[m+n=n+m\]</span></li>
</ul></li>
<li><p><strong>乘法</strong></p>
<p><span class="math display">\[\quad\bullet:N\times N\rarr
N\]</span></p>
<p><span class="math display">\[\quad\bullet(\lang
2,3\rang)=6,\quad2\bullet3=6\]</span></p>
<p>可以定义 <span class="math display">\[\bullet m \]</span> 函数</p>
<p><span class="math display">\[\quad\begin{align}&amp;m\in
N,\,M_m:N\rarr
N\\&amp;\begin{cases}M_m(0)=0\\M_m(n^+)=M_m(n)+m\end{cases}\end{align}\]</span></p>
<p>乘法有如下性质</p>
<ul>
<li><span class="math display">\[1\bullet n=n\bullet 1=n\]</span></li>
<li><span class="math display">\[n\bullet m=m\bullet n\]</span></li>
<li><span class="math display">\[(m\bullet n)\bullet k=m\bullet
(n\bullet k)\]</span></li>
<li><span class="math display">\[k\not=0\and m\bullet k=n\bullet k\Rarr
m=n\]</span></li>
<li><span class="math display">\[m\bullet (n+k)=(m\bullet n)+(m\bullet
k)\]</span></li>
</ul></li>
</ul>
<p>自然数有两个基本性质</p>
<ul>
<li><p><strong>匹配</strong></p>
<p>在自然数集合与另一集合间建立双射，可以统计集合的大小</p>
<p><span class="math display">\[\quad\begin{align}&amp;\lbrace
a\rbrace\rarr\lbrace 0\rbrace=1\\&amp;\lbrace a,b\rbrace\rarr\lbrace
0,1\rbrace=2\\&amp;\lbrace a,b,c\rbrace\rarr\lbrace
0,1,2\rbrace=3\\&amp;\ldots\end{align}\]</span></p></li>
<li><p><strong>计数</strong></p>
<p>任意自然数集合都有最小元素，任意自然数间可以比较大小</p>
<p><span
class="math display">\[\quad\begin{align}&amp;0\rarr1\rarr2\rarr3\rarr\ldots\\&amp;a\rarr
b\\&amp;a\rarr b\rarr c\\&amp;\ldots\end{align}\]</span></p></li>
</ul>
<h3 id="等势有穷集无穷集">1.12 等势、有穷集、无穷集</h3>
<ul>
<li><p><strong>等势</strong></p>
<p><span class="math display">\[\quad A\,与\,B\,等势\Harr\exist
双射\,f:A\rarr B\]</span></p>
<p>记作 <span class="math display">\[A\approx B\]</span></p>
<p>则有：</p>
<p><span class="math display">\[\quad\begin{align}&amp;Z\approx N\qquad
N\times N\approx N\qquad N\approx Q\qquad (0,1)\approx
R\qquad[0,1]\approx(0,1)\\&amp;P(A)\approx 2^A=A\rarr 2\\&amp;A\approx
A\qquad A\approx B\Rarr B\approx A\qquad A\approx B\and B\approx C\Rarr
A\approx C\\&amp;N\not\approx R\qquad A\not\approx
P(A)\end{align}\]</span></p></li>
<li><p><strong>有穷集</strong></p>
<p>与某一自然数 <span class="math display">\[n\]</span>
等势的集合称为有穷集。</p>
<p><span class="math display">\[\quad A\,是有穷集\Harr \exist n(A\approx
n\and n\in N)\Harr B\subset A\rarr A\not\approx B\]</span></p>
<p>不存在与自身真子集等势的自然数，也不存在与自身真子集等势的有穷集</p></li>
<li><p><strong>无穷集</strong></p>
<p>不能与任何自然数 <span class="math display">\[n\]</span>
等势的集合</p>
<p><span class="math display">\[\quad A\,是无穷集\Harr n\in N\rarr
A\not\approx n\Harr B\subset A\rarr B\approx A\]</span></p>
<p>与自身真子集等势的集合是无穷集，自然数集也是无穷集</p></li>
</ul>
<h3 id="基数">1.13 基数</h3>
<ul>
<li><p><strong>基数</strong></p>
<p>对每个集合 <span class="math display">\[A\]</span>，定义 <span
class="math display">\[\operatorname{card}A\]</span></p>
<ul>
<li><span
class="math display">\[\operatorname{card}A=\operatorname{card}B\Harr
A\approx B\]</span></li>
<li>对于有穷集：<span class="math display">\[\operatorname{card}A=n\Harr
A\approx n\]</span></li>
<li>对于无穷集：<span
class="math display">\[\operatorname{card}N=\aleph_0\]</span></li>
<li>对于实数集：<span
class="math display">\[\operatorname{card}R=\aleph_1=\aleph\]</span></li>
</ul>
<p><span class="math display">\[0,1,2,\dots,\aleph_0,\aleph\]</span>
都称作基数</p>
<p>其中 <span class="math display">\[0,1,2,\ldots\]</span>
称为有穷基数；<span class="math display">\[\aleph_0,\aleph\]</span>
称为无穷基数</p>
<p>若 <span class="math display">\[{card\,}A=\aleph_i\]</span> 则 <span
class="math display">\[\operatorname{card}P(A)=\aleph_{i+1}\]</span></p>
<p>可以用希腊字符 <span
class="math display">\[\kappa,\lambda,\mu\]</span> 等表示任意基数。<span
class="math display">\[\operatorname{card}A\]</span> 是对 <span
class="math display">\[|A|\]</span> 的推广</p>
<p>有穷基数小于任何无穷基数，<span class="math display">\[0\]</span>
是有穷基数的最小值。<span
class="math display">\[\operatorname{rand}A&lt;\operatorname{rand}P(A)\]</span></p></li>
<li><p><span class="math display">\[K_\kappa\]</span></p>
<p>设 <span class="math display">\[\kappa\]</span> 是任意基数，令 <span
class="math display">\[K_\kappa=\lbrace
x|x\,是集合且\,\operatorname{card}x=\kappa\rbrace\]</span></p>
<ul>
<li><span class="math display">\[\kappa=0\]</span> 时，<span
class="math display">\[K_\kappa=\lbrace\empty\rbrace\]</span>
是集合</li>
<li><span class="math display">\[\kappa\not=0\]</span> 时，<span
class="math display">\[K_\kappa\]</span> 不是集合，而是类</li>
</ul></li>
<li><p><strong>优势、劣势</strong></p>
<p>如果存在 <span class="math display">\[A\]</span> 到 <span
class="math display">\[B\]</span> 的单射，则必然有 <span
class="math display">\[\operatorname{rand}A\le
\operatorname{rand}B\]</span></p>
<p>则称 <span class="math display">\[A\]</span> 较 <span
class="math display">\[B\]</span> 劣势（<span
class="math display">\[B\]</span> 较 <span
class="math display">\[A\]</span> 优势），记为 <span
class="math display">\[A\preccurlyeq\bullet B\]</span> 或 <span
class="math display">\[B\succcurlyeq\bullet A\]</span></p>
<p>若有 <span
class="math display">\[\operatorname{rand}A&lt;\operatorname{rand}B\]</span>
则称为绝对劣势（绝对优势），记为 <span
class="math display">\[A\prec\bullet B\]</span> 或 <span
class="math display">\[B\succ\bullet A\]</span></p>
<p>显然 <span class="math display">\[A\subseteq B\Rarr
A\preccurlyeq\bullet B\quad A\subset B\Rarr A\succcurlyeq\bullet
B\]</span></p>
<p><span class="math display">\[\quad A\preccurlyeq\bull B\and
B\preccurlyeq\bull A\Rarr A\approx B\]</span></p>
<p><span class="math display">\[\quad
\kappa\le\lambda\and\lambda\le\kappa\Rarr\kappa=\lambda\]</span></p>
<p><span class="math display">\[\quad A\subseteq B\subseteq C\and
A\approx C\Rarr A\approx B\approx C\]</span></p>
<p><span class="math display">\[\quad
R\approx(N\rarr2)=2^N\]</span></p></li>
<li><p><strong>可数集（可列集）</strong></p>
<p>基数不超过 <span class="math display">\[\aleph_0\]</span>
的集合称为可数集。<span class="math display">\[n\in N\]</span>
称为有穷可数集，<span class="math display">\[N\]</span>
称为无穷可数集</p>
<p>倘若 <span class="math display">\[A\]</span>
是有穷可数集，则其可以表示成 <span class="math display">\[A=\lbrace
a_1,a_2,\dots,a_n\}\]</span></p></li>
<li><p><strong>基数运算</strong></p>
<p>基数间也能进行运算</p>
<p>有集合 <span class="math display">\[K,L\]</span> 且 <span
class="math display">\[K\cap L=\empty\]</span>，基数 <span
class="math display">\[\kappa =
\operatorname{rand}K,\lambda=\operatorname{rand}L\]</span></p>
<p>则 <span
class="math display">\[\kappa+\lambda=\operatorname{rand}(K\cup
L)\qquad\kappa\bull\lambda=\operatorname{rand}(K\times
L)\qquad\kappa^\lambda=\operatorname{rand}\lbrace A|A:K\rarr
L\}\]</span></p>
<p>有 <span
class="math display">\[rand\,P(K)=2^\kappa\qquad\aleph=2^{\aleph_0}\]</span></p>
<p>基数运算的性质</p>
<ul>
<li><p><span
class="math display">\[\kappa+\lambda=\lambda+\kappa\qquad(\kappa+\lambda)+\mu=\kappa+(\lambda+\mu)\qquad\kappa\le\lambda\Rarr\kappa-\mu\le\lambda-\mu\]</span></p>
<p><span
class="math display">\[\kappa\bull(\lambda+\mu)=\kappa\bull\lambda+\kappa\bull\mu\qquad\kappa^\lambda\bull\kappa^\mu=\kappa^{\lambda+\mu}\]</span></p>
<p><span
class="math display">\[(\kappa\not=0\or\mu\not=0)\and\kappa\le\lambda\Rarr\mu^\kappa\le\mu^\lambda\]</span></p></li>
<li><p>若 <span class="math display">\[\kappa\]</span> 是无穷基数则有
<span class="math display">\[\kappa\bull\kappa=\kappa\]</span></p>
<p>即，对于任意无穷集都能和自身的二元关系建立双射</p></li>
<li><p>若 <span class="math display">\[\kappa\]</span> 是无穷基数，<span
class="math display">\[\lambda\]</span> 是基数，则有 <span
class="math display">\[\kappa+\lambda=\kappa\bullet\lambda=max\lbrace
\kappa,\lambda\}\]</span></p></li>
<li><p>若 <span class="math display">\[\kappa\]</span> 是无穷基数，则
<span class="math display">\[\kappa^\kappa=2^\kappa\]</span></p></li>
</ul></li>
</ul>
<h3 id="公理化集合论">1.14 公理化集合论</h3>
<blockquote>
<p>罗素悖论：罗素悖论是由罗素发现的一个集合论悖论。若有 <span
class="math display">\[A=\lbrace x|x\not\in
x\rbrace\]</span>，则无法判断 <span class="math display">\[A\in
A\]</span> 的真假。</p>
<p>罗素悖论的提出引发了第三次数学危机。为了尝试解决该危机，提出了公理化集合论。ZF
公理系统是其中的一种。</p>
</blockquote>
<h4 id="zf-公理系统">ZF 公理系统</h4>
<ul>
<li><p>空集公理：<span
class="math display">\[\empty\,是集合\]</span></p></li>
<li><p>外延公理：所含元素相同的两个集合相等</p>
<p><span class="math display">\[\quad A=B\Harr\forall x(x\in A\harr x\in
B)\]</span></p></li>
<li><p>无序对公理：<span class="math display">\[a,b\,是集合\Rarr\lbrace
a,b\rbrace\,是集合\]</span></p></li>
<li><p>子集公理：<span class="math display">\[A\,是集合\Rarr\lbrace x\in
A|P(x)\rbrace\,是集合\]</span></p></li>
<li><p>并集公理：<span class="math display">\[{\mathcal
A}\,是集族\Rarr{\bigcup\\}{\mathcal A}\,是集合\]</span></p></li>
<li><p>幂集公理：<span class="math display">\[A\,是集合\Rarr
P(A)\,是集合\]</span></p></li>
<li><p>替换公理：<span class="math display">\[F\,是\,A\,上的函数\Rarr
\lbrace f(x)|x\in A\}\,是集合\]</span></p></li>
<li><p>正则公理：<span class="math display">\[A\not=\empty\Rarr\exist
B(B\in A\and B\cap A=\empty)\]</span></p></li>
<li><p>无限公理：存在归纳集。</p>
<p><span class="math display">\[\quad A\,是归纳集\Harr(\empty\in
A)\and(a\in A\rarr a\cup\lbrace a\rbrace\in A)\]</span></p></li>
</ul>
<p>以上公理组成了 ZF 公理系统。加上下面的选择公理（策梅洛公理）即构成
ZFC 公理系统</p>
<ul>
<li><p>选择公理：<span class="math display">\[\mathcal A\]</span>
是元素互不相交的非空集族。从该集族每个元素中选择一个元素，那些选择的元素构成一个集合</p>
<p><span class="math display">\[\quad\forall a,b\in{\mathcal A}(a\cap
b\not=\empty\rarr a=b)\Rarr\exist C(\forall x\in{\mathcal A}\rarr |x\cap
C|=1)\]</span></p>
<p>以下公理都是该公理的等价形式：</p>
<ul>
<li>广义选择公理：对于任何非空集族都有选择函数 <span
class="math display">\[f:\mathcal{A\rarr\bigcup A},\,f(x)\in
x\in\mathcal A\]</span></li>
<li>良序原理：任何集合都可以良序化</li>
<li>Zorn 原理：链总有上界的非空偏序集存在极大元</li>
<li>Hausdorff 极大原理：任何链都包含于极大链</li>
<li>三歧性原理：<span
class="math display">\[A,B\,是集合\Rarr|A|\le|B|\or|B|\le|A|\]</span></li>
</ul></li>
</ul>
<h2 id="图论">2 图论</h2>
<h3 id="图">2.1 图</h3>
<ul>
<li><p><strong>无序积</strong></p>
<p><span class="math display">\[\quad A\&amp;B=\lbrace\lbrace x,y\}|x\in
A\and y\in B\}\]</span></p>
<p>其中，记 <span class="math display">\[\lbrace
x,y\}=(x,y)\]</span>，允许 <span class="math display">\[x=y\]</span>，且
<span class="math display">\[(x,y)=(y,x)\]</span></p></li>
<li><p><strong>无向图</strong></p>
<p><span class="math display">\[V(G)\]</span> 是顶点集，<span
class="math display">\[E(G)\]</span> 是边集，且 <span
class="math display">\[V\not=\empty\]</span>、<span
class="math display">\[E\subseteq V\&amp;V\]</span></p>
<p>则无向图 <span class="math display">\[G=\lang V,E\rang\]</span></p>
<p>比如：无向图 <span class="math display">\[G=\lang V,E\rang\quad
V=\lbrace a,b,c,d\}\quad E=\lbrace (a,b),(b,c),(b,c),(b,d)\}\]</span>
的样子如下所示</p>
<pre><code class=" mermaid">graph LR
A((a))---B((b))---C((c))
B---C
B---D((d))</code></pre></li>
<li><p><strong>有向图</strong></p>
<p><span class="math display">\[V(D)\]</span> 是顶点集，<span
class="math display">\[E(D)\]</span> 是边集，且 <span
class="math display">\[V\not=\empty\]</span>、<span
class="math display">\[E\subseteq V\times V\]</span></p>
<p>则有向图 <span class="math display">\[D=\lang V,E\rang\]</span></p>
<p>比如：有向图 <span class="math display">\[D=\lang V,E\rang\quad
V=\lbrace a,b,c,d\}\quad E=\lbrace \lang a,b\rang,\lang a,c\rang,\lang
b,c\rang,\lang b,d\rang\}\]</span> 的样子如下所示</p>
<pre><code class=" mermaid">graph LR
A((a))--&gt;B((b))--&gt;C((c))
C--&gt;B
B--&gt;D((d))</code></pre></li>
<li><p><strong>n 阶图</strong></p>
<p><span class="math display">\[\quad|V(G)|=n\]</span></p>
<p>当 <span class="math display">\[n&lt;\infin\]</span> 时称为
<strong>有限图</strong>。当 <span
class="math display">\[E=\empty\]</span> 时称为
<strong>零图</strong>。当 <span
class="math display">\[V=E=\empty\]</span> 时称为
<strong>空图</strong></p>
<p>1 阶的零图 <span class="math display">\[N_1\]</span> 称为平凡图</p>
<p>下面是一些例子</p>
<pre><code class=" mermaid">graph BT
subgraph 1阶图
l1(( ))
end
subgraph N4
n41(( ))
n42(( ))
n43(( ))
n4(( ))
end
subgraph N1
n1(( ))
end
subgraph 2阶图
direction LR
l2(( ))---l21(( ))
end
subgraph 3阶图
direction LR
l3(( ))---l31(( ))
l32(( ))---l32
l3
end</code></pre></li>
<li><p><strong>标定图、非标定图、底图</strong></p>
<p>标定图：顶点或边 带标记的图</p>
<p>非标定图：顶点和边 不带标记的图</p>
<p>底图（基图）：有向图去掉边的方向后得到的无向图</p></li>
<li><p><strong>相邻、邻接、关联</strong></p>
<p>有边相连的两个顶点是 <strong>相邻</strong> 的，有公共顶点的两条边是
<strong>相邻</strong> 的</p>
<p>在有向图中，有向边的起点 <strong>邻接</strong>到 终点，终点 邻接于
起点</p>
<p>一条边的端点与该边是关联的</p>
<p>关联次数：</p>
<pre><code class=" mermaid">graph TB
A1((1))---A2((1))
B1((2))---B1
C1((+1))--&gt;C2(( -1))
D1((?))--无法表示--&gt;D1</code></pre></li>
<li><p><strong>环、孤立点、平行边</strong></p>
<p>两边是同一顶点的边称为 <strong>环</strong></p>
<p>没有边相连的顶点称为 <strong>孤立点</strong></p>
<p>两端顶点相同的边称为
<strong>平行边</strong>，在有向图中，平行边的方向必须相同</p></li>
<li><p><strong>邻域、闭邻域、关联集</strong></p>
<p>邻域：一个点的相邻点构成的集合称为
<strong>邻域（开邻域）</strong></p>
<p><span class="math display">\[\quad N_G(v)=\lbrace u\in V(G)|(u,v)\in
E(G)\and u\not=v\}\]</span></p>
<p>闭邻域：一个点及其相邻点构成的集合称为 <strong>闭邻域</strong></p>
<p><span class="math display">\[\quad\overline{N_G(v)}=N_G(v)\cup\lbrace
v\}\]</span></p>
<p>关联集：一个点关联的边构成 <strong>关联集</strong></p>
<p><span class="math display">\[\quad I_G(v)=\lbrace
e|e\,与\,v\,关联\}\]</span></p>
<p>后继：在有向图中，一个点的后继点构成的集合</p>
<p><span class="math display">\[\quad{\Gamma_D}^+(v)=\lbrace u\in
V(D)|\lang v,u\rang\in E(D)\and u\not= v\}\]</span></p>
<p>前驱：在有向图中，一个点的前驱点构成的集合</p>
<p><span class="math display">\[\quad{\Gamma_D}^-(v)=\lbrace u\in
V(D)|\lang u,v\rang\in E(D)\and u\not= v\}\]</span></p>
<p>有向图的开邻域：<span
class="math display">\[N_D(v)={\Gamma_D}^+(v)\cup{\Gamma_D}^-(v)\]</span></p>
<p>有向图的闭邻域：<span
class="math display">\[\overline{N_D(v)}=N_D(v)\cup\lbrace
v\}\]</span></p></li>
<li><p><strong>顶点的度</strong></p>
<p>度：<span
class="math display">\[d_G(v)=与\,v\,关联的边的次数之和\]</span></p>
<p>出度：<span
class="math display">\[{d_D}^+(v)=与\,v\,关联的出边的次数之和\]</span></p>
<p>入度：<span
class="math display">\[{d_D}^-(v)=与\,v\,关联的入边的次数之和\]</span></p>
<p>最大度：<span
class="math display">\[\Delta(G)=\operatorname{max}\lbrace d_G(v)|v\in
V(G)\}\]</span></p>
<p>最小度：<span
class="math display">\[\delta(G)=\operatorname{min}\lbrace d_G(v)|v\in
V(G)\}\]</span></p>
<p>最大出度、最大入度、最小出度、最小入度</p></li>
<li><p><strong>握手定理</strong></p>
<p>设 <span class="math display">\[G=\lang V,E\rang\]</span>
是无向图，<span class="math display">\[V=\lbrace
v_1,v_2,\dots,v_n\},\,|E|=m\]</span></p>
<p>则 <span
class="math display">\[d(v_1)+d(v_2)+\dots+d(v_n)=2m\]</span></p>
<p>推论：任何图中，奇数度顶点的个数是偶数</p></li>
<li><p><strong>简单图</strong></p>
<p>没有环和平行边的图称为 <strong>简单图</strong></p>
<p>对于简单图，其最大度 <span class="math display">\[0\le\Delta(G)\le
n-1\]</span></p></li>
<li><p><strong>正则图</strong></p>
<p>所有顶点的度相等的图称为 <strong>正则图</strong>，度为 <span
class="math display">\[k\]</span> 则称为 <span
class="math display">\[k\,正则图\]</span></p></li>
<li><p><strong>度数列、可图化</strong></p>
<p>由所有顶点的度构成的数列称为 <strong>度数列</strong></p>
<p><span class="math display">\[\quad
d=(d(v_1),d(v_2),\dots,d(v_n))\]</span></p>
<p>若存在图 <span class="math display">\[G\]</span> 使得 <span
class="math display">\[G\]</span> 的度数列是 <span
class="math display">\[d\]</span>，则称 <span
class="math display">\[d\]</span> 是 <strong>可图化</strong> 的</p>
<p><span class="math display">\[\quad d\,可图化\Harr
d_1+d_2+\dots+d_n\equiv 0(\operatorname{mod}2)\]</span></p>
<p>若存在简单图 <span class="math display">\[G\]</span> 使得 <span
class="math display">\[G\]</span> 的度数列是 <span
class="math display">\[d\]</span>，则称 <span
class="math display">\[d\]</span> 是 <strong>可简单图化</strong> 的</p>
<p><span class="math display">\[\quad\begin{align}
&amp;d\,可简单图化\\\Harr
&amp;d&#39;=(d_2-1,d_3-1,\dots,d_n-1)\,可简单图化\\\Harr&amp;\forall
r(r\ge1\and r\le n-1)\rarr d_1+d_2+\dots+d_r\le r(r-1)+\min \lbrace
r,d_{r+1}\}+\min \lbrace r,d_{r+2}\}+\dots+\min \lbrace
r,d_{n}\}\\\Harr&amp;n-1\ge d_1\ge d_2\ge\dots\ge d_n\ge 0\Rarr
d_1+d_2+\dots+d_n\le n(n-1)\end{align}\]</span></p></li>
<li><p><strong>同构</strong></p>
<p>对于图 <span class="math display">\[G_1,G_2\]</span></p>
<p>如果存在双射 <span class="math display">\[f:V(G_1)\rarr
V(G_2)\]</span> 使得 <span class="math display">\[\forall a,b\in
V(G_1),\,(a,b)\in E(G_1)\harr (f(a),f(b))\in E(G_2)\]</span> 就称 <span
class="math display">\[G_1\]</span> 与 <span
class="math display">\[G_2\]</span> 同构。记为 <span
class="math display">\[G_1\cong G_2\]</span></p>
<p>同构的图，其图论性质完全一致</p>
<p>对于有向图 <span class="math display">\[D_1,D_2\]</span>
同理，存在双射 <span class="math display">\[f:V(D_1)\rarr
V(D_2)\]</span> 使得 <span class="math display">\[\forall a,b\in
V(D_1),\,\lang a,b\rang\in E(D_1)\harr \lang f(a),f(b)\rang\in
E(D_2)\]</span> 就称 <span class="math display">\[D_1\]</span> 与 <span
class="math display">\[D_2\]</span> 同构，记为 <span
class="math display">\[D_1\cong D_2\]</span></p>
<ul>
<li><p><strong>NAUTY 算法</strong></p>
<p>一种计算两个图是否是同构的算法</p>
<p>详见 <a
target="_blank" rel="noopener" href="https://pallini.di.uniroma1.it/Introduction.html"><strong>这个网站</strong></a></p></li>
</ul></li>
<li><p>一些图族</p>
<p>完全图：无向图的每个顶点都与所有其他顶点相邻。n 阶的完全图记为 <span
class="math display">\[K_n\]</span></p>
<p>竞赛图：完全图的每条边都是有向边</p>
<p>r 部图：该图的顶点可以分为 r
组，每条边的两个端点位于不同的组</p></li>
<li><p><strong>子图、生成子图</strong></p>
<p>对于图 <span class="math display">\[G,G&#39;\]</span>，若有 <span
class="math display">\[V&#39;\subseteq V\and E&#39;\subseteq
E\]</span>，则 <span class="math display">\[G&#39;\]</span> 是 <span
class="math display">\[G\]</span> 的<strong>子图</strong>，记为 <span
class="math display">\[G&#39;\subseteq G\]</span></p>
<p>若 <span class="math display">\[G&#39;\subseteq G\and(V&#39;\subset
V\and E&#39;\subset E)\]</span>，则 <span
class="math display">\[G&#39;\]</span> 是 <span
class="math display">\[G\]</span> 的<strong>真子图</strong>，记为 <span
class="math display">\[G&#39;\subset G\]</span></p>
<p>若 <span class="math display">\[G&#39;\subseteq G\and
V&#39;=V\]</span>，则 <span class="math display">\[G&#39;\]</span> 是
<span class="math display">\[G\]</span>
的<strong>生成子图</strong></p></li>
<li><p><strong>导出子图</strong></p>
<p>若 <span class="math display">\[V_1\subset V,\, E_1=E\cap
V_1\&amp;V_1\]</span> 则称 <span class="math display">\[G[V_1]=\lang
V_1,E_1\rang\]</span> 是由 <span class="math display">\[V_1\]</span>
<strong>导出的子图</strong></p>
<p>若 <span class="math display">\[\empty\not=E_1\subset E,\,
V_1=\lbrace v|v\,与\,E_1\,中的边关联\}\]</span> 则称 <span
class="math display">\[G[E_1]=\lang V_1,E_1\rang\]</span> 是由 <span
class="math display">\[E_1\]</span> <strong>导出的子图</strong></p></li>
<li><p><strong>补图</strong></p>
<p>对于图 <span class="math display">\[G=\lang V,E\rang\]</span>，其补图
<span class="math display">\[\overline G=\lang
V,E(K_n)-E\rang\]</span></p>
<p>如果 <span class="math display">\[G\cong\overline
G\]</span>，则称其为 <strong>自补图</strong></p></li>
<li><p><strong>删除</strong></p>
<p>删除边 <span class="math display">\[e\]</span>：<span
class="math display">\[G-e=\lang V,E-\lbrace e\}\rang\]</span></p>
<p>删除边集 <span class="math display">\[E&#39;\]</span>：<span
class="math display">\[G-E&#39;=\lang V,E-E&#39;\rang\]</span></p>
<p>删除顶点 <span class="math display">\[v\]</span>
及其关联的所有边：<span class="math display">\[G-v=\lang V-\lbrace
v\},E-I_G(v)\rang\]</span></p>
<p>删除顶点集 <span class="math display">\[V&#39;\]</span>
及关联的所有边：<span class="math display">\[G-V&#39;=\lang
V-V&#39;,E-I_G(V&#39;)\rang\]</span></p></li>
<li><p><strong>收缩、加边</strong></p>
<p>删除 <span class="math display">\[e\]</span>，合并 <span
class="math display">\[u\]</span> 与 <span
class="math display">\[v\]</span>：<span
class="math display">\[G{\setminus}e:e=(i,v)\]</span></p>
<p>在 <span class="math display">\[u,v\]</span> 间增加新边：<span
class="math display">\[G\cup(u,v)=\lang V,E\cup\lbrace
(u,v)\}\rang\]</span>，也可以写为 <span
class="math display">\[G+(u,v)\]</span></p></li>
<li><p><strong>不交</strong></p>
<p>对于 <span class="math display">\[G_1,G_2\]</span></p>
<p><span class="math display">\[\quad G_1\,与\,G_2\,不交\Harr V_1\cap
V_2=\empty\]</span></p>
<p><span class="math display">\[\quad G_1\,与\,G_2\,边不交\Harr E_1\cap
E_2=\empty\]</span></p></li>
<li><p><strong>并图、交图、差图、环和</strong></p>
<p>对于无孤立点的图 <span class="math display">\[G_1,G_2\]</span></p>
<p>并图：<span class="math display">\[G_1\cup G_2=\lang V(E_1\cup
E_2),E_1\cup E_2\rang\]</span></p>
<p>交图：<span class="math display">\[G_1\cap G_2=\lang V(E_1\cap
E_2),E_1\cap E_2\rang\]</span></p>
<p>差图：<span class="math display">\[G_1-G_2=\lang
V(E_1-E_2),E_1-E_2\rang\]</span></p>
<p>环和：<span class="math display">\[G_1\oplus G_2=\lang V(E_1\oplus
E_2),E_1\oplus E_2\rang\]</span></p></li>
<li><p><strong>联图</strong></p>
<p><span class="math display">\[G_1,G_2\]</span> 是不交的无向图</p>
<p>其联图 <span class="math display">\[G_1+G_2=\lang V_1\cup V_2,E_1\cup
E_2\cup(V_1\&amp;V_2)\rang\]</span></p>
<p><span class="math display">\[\quad K_r+K_s=K_{r+s}\quad
N_r+N_s=K_{r,s}\quad n=n_1+n_2,\,m=m_1+m_2+n_1n_2\]</span></p></li>
</ul>
<h3 id="通路回路">2.2 通路、回路</h3>
<ul>
<li><p><strong>通路、回路</strong></p>
<p>图中邻接的点与边的交替序列构成 <strong>通路</strong></p>
<p><span class="math display">\[\quad\Gamma
=v_1,e_1,v_2,e_2,\dots,v_n\]</span></p>
<p>通路的起止都是顶点。通路中边的数量称为通路的
<strong>长度</strong></p>
<p>如果通路的起止点是同一顶点，则称该通路为 <strong>回路</strong></p>
<p>没有重复边的通路（回路）称为
<strong>简单通路（简单回路）</strong></p>
<p>有重复边的通路（回路）称为 <strong>复杂通路（复杂回路）</strong></p>
<p>没有重复顶点的通路（回路）称为
<strong>初级通路/路径（初级回路/圈）</strong></p>
<p>可以只用边的序列来表示通路。简单图可以只用顶点的序列表示通路。</p>
<p>图中最长圈的长度称为图的 <strong>周长</strong>。不含圈时，长度为
<span class="math display">\[0\]</span> 或 <span
class="math display">\[\infin\]</span></p>
<p>有以下定理：</p>
<ul>
<li><p>在 <span class="math display">\[n\]</span> 阶图 <span
class="math display">\[G\]</span> 中，若从不同顶点 <span
class="math display">\[v_i\]</span> 到 <span
class="math display">\[v_j\]</span> 有通路，则从 <span
class="math display">\[v_i\]</span> 到 <span
class="math display">\[v_j\]</span> 有长度小于等于 <span
class="math display">\[n-1\]</span> 的通路</p>
<p>推论：在 <span class="math display">\[n\]</span> 阶图 <span
class="math display">\[G\]</span> 中，若从不同顶点 <span
class="math display">\[v_i\]</span> 到 <span
class="math display">\[v_j\]</span> 有通路，则从 <span
class="math display">\[v_i\]</span> 到 <span
class="math display">\[v_j\]</span> 有长度小于等于 <span
class="math display">\[n-1\]</span> 的路径</p></li>
<li><p><span class="math display">\[G\,是二部图\Harr
G\,中无奇圈\]</span></p></li>
<li><p>若无向图 <span class="math display">\[G\]</span> 是连通图，则
<span class="math display">\[G\]</span> 的边数 <span
class="math display">\[m\ge n-1\]</span></p></li>
</ul></li>
<li><p><strong>极大路径</strong></p>
<p>在无向简单图中，路径的两个端点不与路径本身以外的顶点相邻，这样的路径称为
<strong>极大路径</strong></p>
<p>在有向图中，路径起点的前驱、终点的后继，都在路径本身上，这样的路径称为
<strong>极大路径</strong></p></li>
<li><p><strong>连通图、分离图</strong></p>
<p>图中的两个顶点 <span class="math display">\[u,v\]</span>
间存在通路，则称 <span class="math display">\[u\]</span> 与 <span
class="math display">\[v\]</span> 连通。记作：<span
class="math display">\[u\sim v\]</span></p>
<p>每个顶点都与自身连通。即 <span class="math display">\[u\sim
u\]</span></p>
<p>连通关系是 自反、对称、传递
的。连通关系是等价关系。彼此联通的顶点集合构成
<strong>连通分支</strong>。记为 <span
class="math display">\[G[v_i]\]</span></p>
<p>设 <span class="math display">\[V/\sim=\lbrace
V_i|i=1,\dots,k\}\]</span>，则连通分支数 <span
class="math display">\[p(G)=|V/\sim|\]</span></p>
<p>连通分支数为 1 的图称为 <strong>连通图</strong></p>
<p>连通分支大于 1 的图称为 <strong>分离图</strong></p>
<p><span class="math display">\[u,v\]</span> 间最短的通路称为
<strong>短程线（测地线）</strong></p></li>
<li><p><strong>距离、直径</strong></p>
<p><span class="math display">\[u,v\]</span> 间短程线的长度称为其
<strong>距离</strong>，记为 <span
class="math display">\[d_G(u,v)\]</span></p>
<p>图中所有距离的最大值称为图的 <strong>直径</strong>。<span
class="math display">\[d(G)=\max(d_G(u,v)|u,v\in V(G))\]</span></p>
<p>有 <span
class="math display">\[d(K_n)=1(n\ge2),\,d(C_n)=n/2\]</span>，并且约定零图的直径：<span
class="math display">\[d(N_i)=\begin{cases}0,\quad i=1\\\infin,\quad
i&gt;1\end{cases}\]</span></p></li>
<li><p><strong>距离函数</strong></p>
<p>距离函数具有三个特征</p>
<ul>
<li>非负性：<span class="math display">\[d(u,v)\ge0\and d(u,v)=0\Harr
u=v\]</span></li>
<li>对称性：<span class="math display">\[d(u,v)=d(v,u)\]</span></li>
<li><span class="math display">\[\Delta\]</span>不等式：<span
class="math display">\[d(u,v)+d(v,w)\ge d(u,w)\]</span></li>
</ul>
<p>任何函数只要满足上述三条特征就能作为距离函数使用。</p></li>
<li><p><strong>可达、弱连通</strong></p>
<p>对于有向图 <span class="math display">\[D=\lang
V,E\rang\]</span>，若从 <span class="math display">\[u\]</span> 到 <span
class="math display">\[v\]</span> 有有向通路，则称从 <span
class="math display">\[u\]</span> <strong>可达</strong> <span
class="math display">\[v\]</span>，记作 <span
class="math display">\[u\rarr v\]</span></p>
<p>规定 <span class="math display">\[u\rarr u\]</span>。可达关系是
自反、传递的。可达关系的导出子图是 <strong>单向连通分支</strong></p>
<p>若 <span class="math display">\[u\rarr v\and v\rarr u\]</span> 则称
<span class="math display">\[u,v\]</span>
<strong>双向可达</strong>，记作 <span class="math display">\[u\harr
v\]</span></p>
<p>双向可达关系是等价关系。其等价类的导出子图称为
<strong>强连通分支（双向连通分支）</strong></p>
<p>若有向图的基图是连通图，则称其为
<strong>弱连通</strong>，其导出子图称为 <strong>弱连通分支</strong></p>
<p>有如下定理：</p>
<ul>
<li><p>对于竞赛图，一定有一条路经过每一个点恰好一次</p></li>
<li><p><span class="math display">\[有向图\,D\,强连通\Harr
D\,中有回路经过每个点至少一次\]</span></p>
<p>这个回路不一定是简单回路</p></li>
<li><p><span class="math display">\[有向图\,D\,单向连通\Harr
D\,中有通路经过每个顶点至少一次\]</span></p>
<p>这个通路不一定是简单通路</p></li>
</ul></li>
</ul>
<h3 id="连通度">2.3 连通度</h3>
<ul>
<li><p><strong>点割集、边割集</strong></p>
<p>设有图 <span class="math display">\[G\lang
V,E\rang\]</span>，非空点集 <span class="math display">\[V&#39;\subset
V\]</span>，非空边集 <span class="math display">\[E&#39;\subset
E\]</span></p>
<p>若满足 <span class="math display">\[p(G-V&#39;)&gt;p(G)\]</span>，且
<span class="math display">\[\forall V&#39;&#39;\subset
V&#39;,\,p(G-V&#39;&#39;)=p(G)\]</span> 则称 <span
class="math display">\[V&#39;\]</span> 是 <span
class="math display">\[G\]</span> 的一个 <strong>点割集</strong>。</p>
<p>若满足 <span class="math display">\[p(G-E&#39;)&gt;p(G)\]</span>，且
<span class="math display">\[\forall E&#39;&#39;\subset
E&#39;,\,p(G-E&#39;&#39;)=p(G)\]</span> 则称 <span
class="math display">\[E&#39;\]</span> 是 <span
class="math display">\[G\]</span> 的一个 <strong>边割集</strong>。</p>
<p>对于边割集，有引理：<span
class="math display">\[p(G-E&#39;)=p(G)+1\]</span></p>
<p>若 <span class="math display">\[E&#39;\subseteq I_G(v)\]</span>
则称其为 <strong>扇形割集</strong></p></li>
<li><p><strong>割点、割边（桥）</strong></p>
<p><span class="math display">\[\quad v\,是割点\Harr\lbrace
v\}\,是割集\]</span></p>
<p><span class="math display">\[\quad (u,v)\,是割边\Harr\lbrace
(u,v)\}\,是割集\]</span></p>
<p><span class="math display">\[I_G(v)\]</span>
不一定是边割集（不一定极小）。当且仅当 <span
class="math display">\[v\]</span> 不是割点时，<span
class="math display">\[I_G(v)\]</span> 是边割集</p>
<p>有如下引理：</p>
<ul>
<li>设 <span class="math display">\[E&#39;\]</span>
是<font color="#AF00A0">非完全图</font> <span
class="math display">\[G\]</span> 的最小边割集。若 <span
class="math display">\[G-E&#39;\]</span> 的两个连通分支是 <span
class="math display">\[G_1,G_2\]</span>，则存在 <span
class="math display">\[u\in V(G_1),v\in V(G_2)\]</span> 使得 <span
class="math display">\[(u,v)\not\in E(G)\]</span></li>
</ul></li>
<li><p><strong>点连通度、边连通度</strong></p>
<p>点连通度：为了破坏连通性（<span
class="math display">\[p(G-V&#39;)&gt;p(G)\]</span>），至少要破坏多少个顶点</p>
<p>边连通度：为了破坏连通性（<span
class="math display">\[p(G-E&#39;)&gt;p(G)\]</span>），至少要破坏多少条边</p>
<p>设 <span class="math display">\[G\]</span> 是无向连通非完全图</p>
<p>点连通度 <span class="math display">\[\kappa(G)=\min\lbrace
|V&#39;|\,|V&#39;\,是\,G\,的点割集\}\]</span></p>
<p>边连通度 <span class="math display">\[\lambda (G)=\min\lbrace
|E&#39;|\,|E&#39;\,是\,G\,的边割集\}\]</span></p>
<p>规定：<span class="math display">\[\kappa(K_n)=n-1\]</span>，若 <span
class="math display">\[G\]</span> 非联通则 <span
class="math display">\[\kappa(G)=0,\,\lambda(G)=0\]</span></p></li>
<li><p><strong>K-（边）连通图</strong></p>
<p>k-连通图：<span class="math display">\[\kappa(G)\ge k\]</span></p>
<p>k-边连通图：<span class="math display">\[\lambda(G)\ge k\]</span></p>
<p>有定理：</p>
<ul>
<li>对于 3-正则图 <span class="math display">\[G\]</span>，必定有 <span
class="math display">\[\kappa(G)=\lambda(G)\]</span></li>
<li>对于任意 <span class="math display">\[G\]</span>，都有 <span
class="math display">\[\kappa(G)\le\lambda(G)\le\delta(G)\]</span>，也就是说
k-连通图 一定是 k-边连通图</li>
</ul></li>
<li><p><strong>x-y 割、独立路径、边不交路径</strong></p>
<p>设 <span class="math display">\[x,y\]</span> 是 <span
class="math display">\[G\]</span> 中的不相邻顶点</p>
<p>若存在 <span class="math display">\[S\subseteq V(G)-\lbrace
x,y\}\]</span>，使得在 <span class="math display">\[G-S\]</span> 中
<span class="math display">\[x,y\]</span> 不连通，则称 <span
class="math display">\[S\]</span> 为 <span
class="math display">\[G\]</span> 中的 <strong>x-y 割</strong>。</p>
<p>两条除起点与终点外无其他公共顶点的路径称为
<strong>独立路径</strong></p>
<p>两条无公共边（但可能有公共顶点）的路径称为
<strong>边不交路径</strong></p>
<p>有如下定理：</p>
<ul>
<li><p><font color="#E020E0">最小</font>的 x-y
割包含的定点数，等于<font color="#E020E0">最大</font>的 x-y
独立路径的条数</p></li>
<li><p><strong>2-连通图</strong>
的<font color="#20AEA0">充要条件</font></p>
<p><span class="math display">\[\begin{align}
&amp;3\,阶以上无向图是\,2-连通图\\
\Harr&amp;图中任意两点都共圈\\
\Harr&amp;图中任意两顶点间都有\,2\,条以上独立路径
\end{align}\]</span></p></li>
<li><p><strong>2-边连通图</strong>
的<font color="#20AEA0">充要条件</font></p>
<p><span class="math display">\[\begin{align}
&amp;3\,阶以上无向图是\,2-边连通图\\
\Harr&amp;图中任意两点都共简单回路\\
\Harr&amp;图中任意两顶点间都有\,2\,条以上边不交路径
\end{align}\]</span></p></li>
<li><p><strong>k-连通图</strong>
的<font color="#20AEA0">充要条件</font></p>
<p><span class="math display">\[\begin{align}
&amp;3\,阶以上无向图是k-连通图\\
\Harr&amp;图中任意两顶点间都有\,k\,条以上独立路径
\end{align}\]</span></p></li>
<li><p><strong>k-边连通图</strong>
的<font color="#20AEA0">充要条件</font></p>
<p><span class="math display">\[\begin{align}
&amp;3\,阶以上无向图是k-边连通图\\
\Harr&amp;图中任意两顶点间都有\,k\,条以上边不交
\end{align}\]</span></p></li>
<li><p><strong>割点</strong> 的<font color="#20AEA0">充要条件</font></p>
<p><span class="math display">\[\begin{align}
&amp;无向连通图中顶点\,v\,是割点\\
\Harr&amp;存在\,u,w\in V(G)-\lbrace v\}，使得\,u,w\,间的路径都经过\,v
\end{align}\]</span></p></li>
<li><p><strong>桥</strong> 的<font color="#20AEA0">充要条件</font></p>
<p><span class="math display">\[\begin{align}
&amp;无向连通图中边\,e\,是桥\\
\Harr&amp;图中任意圈都不经过\,e\\\Harr&amp;可把\,V(G)\,划分为\,V_1,V_2，任意\,u\in
V_1\,和\,v\in V_2\,间的路径都经过\,e
\end{align}\]</span></p></li>
</ul></li>
<li><p><strong>块</strong></p>
<p>极大无割点的连通子图称为一个 <strong>块</strong></p>
<p>有如下定理：</p>
<ul>
<li><p><strong>块</strong> 的<font color="#20AEA0">充要条件</font></p>
<p><span class="math display">\[\begin{align}
&amp;3\,阶以上无向图是块\\
\Harr&amp;图中任意两顶点都共圈\\
\Harr&amp;图中任意顶点与任意边都共圈\\
\Harr&amp;图中任意两边都共圈\\
\Harr&amp;对于任意边，图中任意两点间都存在经过该边的路径\\
\Harr&amp;对于图中任意三点，都存在路径连接其中两点，并经过第三点\\
\Harr&amp;对于图中任意三点，都存在路径连接其中两点，且不经过第三点\\
\end{align}\]</span></p></li>
<li><p>n 阶简单连通图的 <span
class="math display">\[\kappa,\lambda,\delta\]</span>
间有且仅有三种可能：</p>
<ul>
<li><span
class="math display">\[\kappa=\lambda=\delta=n-1\]</span>（完全图）</li>
<li><span
class="math display">\[1\le2\delta-n+2\le\kappa\le\lambda=\delta\le
n-2\]</span>（即 <span class="math display">\[\delta\ge n/2\]</span>
时）</li>
<li><span
class="math display">\[n\le\kappa\le\lambda\le\delta&lt;n/2\]</span></li>
</ul></li>
</ul></li>
</ul>
<h3 id="欧拉图哈密顿图">2.4 欧拉图、哈密顿图</h3>
<ul>
<li><p><strong>欧拉图</strong></p>
<p>经过图中所有边的简单通路称为 <strong>欧拉通路</strong></p>
<p>有欧拉通路的图称为 <strong>半欧拉图</strong></p>
<p>经过图中所有边的简单回路称为 <strong>欧拉回路</strong></p>
<p>有欧拉回路的图称为 <strong>欧拉图</strong></p>
<p>有如下定理：</p>
<ul>
<li><p><strong>无向欧拉图</strong>
的<font color="#20AEA0">充要条件</font></p>
<p><span class="math display">\[\begin{align}
&amp;无向图连通图是欧拉图\\
\Harr&amp;图中所有顶点的度都是偶数\\
\Harr&amp;图是若干边不交的圈的并\end{align}\]</span></p></li>
<li><p><strong>无向半欧拉图</strong>
的<font color="#20AEA0">充要条件</font></p>
<p><span class="math display">\[\begin{align}
&amp;无向图连通图是半欧拉图\\
\Harr&amp;图中恰有两个奇数度顶点\end{align}\]</span></p></li>
<li><p><strong>有向欧拉图</strong>
的<font color="#20AEA0">充要条件</font></p>
<p><span class="math display">\[\begin{align}
&amp;有向图连通图是欧拉图\\
\Harr&amp;\forall v\in V(G),\,d^+(v)=d^-(v)\\
\Harr&amp;图是若干边不交的有向圈的并\end{align}\]</span></p></li>
<li><p><strong>有向半欧拉图</strong>
的<font color="#20AEA0">充要条件</font></p>
<p><span class="math display">\[\begin{align}
&amp;有向图连通图是半欧拉图\\
\Harr&amp;恰有一个顶点入度=出度+1，另一个顶点入度=出度-1，其余顶点入度=出度\\
\end{align}\]</span></p></li>
</ul></li>
<li><p><strong>计算欧拉图的方法</strong></p>
<ul>
<li><p><strong>避桥法</strong></p>
<p>从任意一顶点起，沿没有走过的边（优先选择非桥边）到达下一顶点。最终能得到欧拉回路，或宣布该图不是欧拉图。</p></li>
<li><p><strong>逐步插入回路法</strong></p>
<p>每次求出一个简单回路。把新求出的回路插入老回路，合并成更大回路，直到得到欧拉回路，或宣布该图不是欧拉图。</p></li>
</ul></li>
<li><p><strong>哈密顿图</strong></p>
<p>经过图中所有顶点的初级通路称为 <strong>哈密顿通路</strong></p>
<p>有哈密顿通路的图称为 <strong>半哈密顿图</strong></p>
<p>经过图中所有顶点的初级回路称为 <strong>哈密顿回路</strong></p>
<p>有哈密顿回路的图称为 <strong>哈密顿图</strong></p>
<p>有如下定理：</p>
<ul>
<li><p><strong>无向哈密顿图</strong>
的<font color="#AE20A0">必要条件</font>（不是充分条件）</p>
<p>设无向哈密顿图图 <span class="math display">\[G=\lang
V,E\rang\]</span>，则有 <span class="math display">\[\forall
V_1(V_1\not=\empty\and V_1\subset V)\rarr
p(G-V_1)\le|V_1|\]</span></p></li>
<li><p><strong>无向半哈密顿图</strong>
的<font color="#AE20A0">必要条件</font>（不是充分条件）</p>
<p>设无向半哈密顿图 <span class="math display">\[G=\lang
V,E\rang\]</span>，则有 <span class="math display">\[\forall
V_1(V_1\not=\empty\and V_1\subset V)\rarr
p(G-V_1)\le|V_1|+1\]</span></p></li>
<li><p><strong>无向哈密顿图</strong>
的<font color="#EEA000">充分条件</font>（不是必要条件）</p>
<p>对于 <span class="math display">\[n(n\ge3)\]</span>
阶无向简单图，若其中任意不相邻顶点 <span
class="math display">\[u,v\]</span> 都有 <span
class="math display">\[d(u)+d(v)\ge
n\]</span>，则该图是哈密顿图</p></li>
<li><p><strong>无向半哈密顿图</strong>
的<font color="#EEA000">充分条件</font>（不是必要条件）</p>
<p>对于 <span class="math display">\[n(n\ge2)\]</span>
阶无向简单图，若其中任意不相邻顶点 <span
class="math display">\[u,v\]</span> 都有 <span
class="math display">\[d(u)+d(v)\ge
n-1\]</span>，则该图是半哈密顿图</p></li>
<li><p><strong>有向半哈密顿图</strong>
的<font color="#EEA000">充分条件</font>（不是必要条件）</p>
<p><span class="math display">\[n(n\ge2)\]</span>
阶竞赛图是有向半哈密顿图</p></li>
<li><p><strong>有向哈密顿图</strong>
的<font color="#EEA000">充分条件</font>（不是必要条件）</p>
<p>强连通的竞赛图是有向半哈密顿图</p></li>
<li><p>完全图 <span class="math display">\[K_{2n+1}\]</span>
必定同时包含 <span class="math display">\[n\]</span>
组边不重的哈密顿回路，且这些哈密顿回路包含所有边。</p>
<p>对 <span class="math display">\[i=1,2,\dots,k\]</span>，令 <span
class="math display">\[P_i=v_i,v_{i-1},v_{i+1},v_{i-2},v_{i+2},\dots,v_{i-(k-1)},v_{i+(k-1)},v_{i-k}\]</span></p>
<p>将 <span class="math display">\[P_i\]</span> 中的下标 <span
class="math display">\[\operatorname{mod}{2k}\]</span> 后转换到 <span
class="math display">\[\lbrace 1,2,\dots,2k+1\}\]</span></p>
<p>则所有 <span
class="math display">\[C_i=v_{2k+1},P_i,v_{2k+1}\]</span>
都是哈密顿回路</p>
<p>推论：</p>
<p>完全图 <span class="math display">\[K_{2n}\]</span> 必定同时包含
<span class="math display">\[n-1\]</span> 组边不重的哈密顿回路，此外剩余
<span class="math display">\[n\]</span> 条彼此不相邻的边。</p></li>
</ul></li>
</ul>
<h3 id="树">2.5 树</h3>
<ul>
<li><p><strong>树</strong></p>
<p>连通无回路的图称为 <strong>树</strong>，记作 <span
class="math display">\[T\]</span></p>
<p>树中度为 1 的顶点称为 <strong>树叶</strong>，2 以上的顶点称为
<strong>分支点</strong></p>
<p>无树叶、无分支点的树称为 <strong>平凡树</strong></p>
<p>每个连通分支都是树的无回路图称为 <strong>森林</strong></p>
<p>有如下定理：</p>
<ul>
<li><p>对于 <span class="math display">\[n\]</span> 阶 <span
class="math display">\[m\]</span> 边无向图 <span
class="math display">\[G\]</span>，树的等价定义：</p>
<p><span class="math display">\[\quad\begin{align}
&amp;G\,是树\\
\Harr&amp;G\,中任何两个顶点间有唯一的路径\\
\Harr&amp;G\,无圈\and m=n-1\\
\Harr&amp;G\,连通\and m=n-1\\
\Harr&amp;G\,极小连通\\
\Harr&amp;G\,极大无回
\end{align}\]</span></p>
<p><strong>极小连通</strong>：连通且所有边都是桥</p>
<p><strong>极大无回</strong>：无圈且新增任何边都会产生唯一的圈</p></li>
<li><p>任何非平凡树都至少有 2 个树叶</p></li>
</ul></li>
<li><p><strong>无向树的计数</strong></p>
<p>用 <span class="math display">\[t_n\]</span> 来表示 <span
class="math display">\[n(n\ge1)\]</span> 阶非同构无向树的个数</p>
<p>除了一个点外，其他顶点都是树叶的树称为 <strong>星</strong>。记作
<span class="math display">\[S_n=K_{1,n-1}\]</span></p></li>
<li><p><strong>生成树</strong></p>
<p>对于图 <span class="math display">\[G\]</span>，若其子图 <span
class="math display">\[T\]</span> 是树，且包含 <span
class="math display">\[G\]</span> 中所有顶点，则称 <span
class="math display">\[T\]</span> 是 <span
class="math display">\[G\]</span> 的 <strong>生成树</strong></p>
<p><span class="math display">\[T\]</span> 中的边 <span
class="math display">\[e\in E(T)\]</span> 称为 <strong>树枝</strong></p>
<p>不在 <span class="math display">\[T\]</span> 中的边 <span
class="math display">\[e\in E(G)-E(T)\]</span> 称为
<strong>弦</strong></p>
<p>由弦构成的图称为 <strong>余树</strong>，记为 <span
class="math display">\[G[E(G)-E(T)]=\overline{T}\]</span></p>
<p>有如下定理</p>
<ul>
<li><p><span class="math display">\[无向图\,G\,连通\Harr
G\,有生成树\]</span></p>
<p>若 <span class="math display">\[G\]</span> 是 <span
class="math display">\[n\]</span> 阶 <span
class="math display">\[m\]</span> 边的无向连通图，则 <span
class="math display">\[m\ge n-1\]</span></p>
<p>若 <span class="math display">\[T\]</span> 是 <span
class="math display">\[n\]</span> 阶 <span
class="math display">\[m\]</span> 边无向连通图的生成树，则 <span
class="math display">\[|\overline{E(T)}|=m-n+1\]</span></p>
<p>若 <span class="math display">\[T\]</span> 是无向连通图 <span
class="math display">\[G\]</span> 的生成树，<span
class="math display">\[C\]</span> 是 <span
class="math display">\[G\]</span> 中的圈，则 <span
class="math display">\[C\]</span> 中必定有弦</p></li>
<li><p>设 <span class="math display">\[T\]</span> 是连通图 <span
class="math display">\[G\]</span> 的生成树，<span
class="math display">\[S\]</span> 是 <span
class="math display">\[G\]</span> 中的割集，则 <span
class="math display">\[S\]</span> 中必有树枝</p></li>
<li><p>设 <span class="math display">\[T\]</span> 是连通图 <span
class="math display">\[G\]</span> 的生成树，<span
class="math display">\[e\]</span> 是 <span
class="math display">\[G\]</span> 的弦，则在 <span
class="math display">\[T\cup e\]</span> 中存在包含 <span
class="math display">\[e\]</span> 的圈，且不同的 <span
class="math display">\[e\]</span> 对应不同的圈</p></li>
</ul></li>
<li><p><strong>基本回路</strong></p>
<p>设 <span class="math display">\[G\]</span> 是 <span
class="math display">\[n\]</span> 阶 <span
class="math display">\[m\]</span> 边的无向连通图，<span
class="math display">\[T\]</span> 是其生成树，<span
class="math display">\[\overline{T}=\lbrace
e&#39;_1,e&#39;_2,\dots,e&#39;_{m-n+1}\}\]</span> 是余树</p>
<p>则 <span class="math display">\[T\cup e&#39;_r\]</span> 中的唯一回路
<span class="math display">\[C_r\]</span> 称为
<strong>基本回路</strong></p>
<p>由所有 <span class="math display">\[C_r\]</span> 构成的集合 <span
class="math display">\[\lbrace C_1,C_2,\dots,C_{m-n+1}\}\]</span> 称为
<strong>基本回路系统</strong></p>
<p>基本回路系统包含的圈的个数称为 <strong>圈秩</strong>：<span
class="math display">\[\xi(G)=m-n+1\]</span></p>
<p>有如下定理</p>
<ul>
<li>设 <span class="math display">\[T\]</span> 是连通图 <span
class="math display">\[G\]</span> 的生成树，<span
class="math display">\[e\]</span> 是其树枝，则 <span
class="math display">\[G\]</span> 中存在由树枝 <span
class="math display">\[e\]</span>
和其他弦组成的割集，且不同树枝对应不同的割集</li>
</ul></li>
<li><p><strong>基本割集</strong></p>
<p>设 <span class="math display">\[G\]</span> 是 <span
class="math display">\[n\]</span> 阶 <span
class="math display">\[m\]</span> 边的无向连通图，<span
class="math display">\[T=\lbrace e_1,e_2,\dots,e_{n-1}\}\]</span>
是其生成树</p>
<p>则 <span class="math display">\[e_r\]</span> 对应的唯一割集 <span
class="math display">\[S_r\]</span> 称为 <strong>基本割集</strong></p>
<p>由所有 <span class="math display">\[S_r\]</span> 构成的集合称为
<strong>基本割集系统</strong></p>
<p><strong>割集的秩</strong>：<span
class="math display">\[\eta(G)=n-1\]</span></p></li>
<li><p><strong>生成树的计数</strong></p>
<p>对于标定图，其生成树的计数记为 <span
class="math display">\[\tau(G)\]</span>。<span
class="math display">\[T_1\not= T_2:E(T_1)\not=E(T_2)\]</span></p>
<p>删除边记为 <span class="math display">\[G-e\]</span>，收缩记为 <span
class="math display">\[G\setminus e\]</span></p>
<p>有如下定理：</p>
<ul>
<li><p><span class="math display">\[\tau(G)=\tau(G-e)+\tau(G\setminus
e)\]</span></p>
<p>即，<span class="math display">\[\tau(G)\]</span> 是所有不过边 <span
class="math display">\[e\]</span> 的生成树，加上过边 <span
class="math display">\[e\]</span> 的生成树</p></li>
<li><p><span class="math display">\[n\ge
2\Rarr\tau(K_n)=n^{n-2}\]</span></p></li>
</ul></li>
</ul>
<h3 id="图的矩阵表示">2.6 图的矩阵表示</h3>
<ul>
<li><p><strong>有向图关联矩阵</strong></p>
<p>设 <span class="math display">\[D=\lang V,E\rang\]</span>
是无环有向图，<span class="math display">\[V=\lbrace
v_1,v_2,\dots,v_n\},\,E=\lbrace e_1,e_2,\dots,e_m\}\]</span></p>
<p>则关联矩阵 <span class="math display">\[M(D)=[m_{ij}]_{n\times
m}\]</span> 有 <span class="math display">\[m_{ij}=\begin{cases}1,\quad
v_i\,是\,e_j\,的起点\\0,\quad v_i\,与\,e_j\,不关联\\-1\,\quad
v_i\,是\,e_j\,的终点\end{cases}\]</span></p>
<p>示范一个关联矩阵：<span
class="math display">\[M(D)=\begin{align}\begin{bmatrix}-1&amp;-1&amp;1&amp;0&amp;0&amp;0\\1&amp;1&amp;0&amp;1&amp;0&amp;0\\0&amp;0&amp;-1&amp;-1&amp;1&amp;-1\\0&amp;0&amp;0&amp;0&amp;-1&amp;1\end{bmatrix}\end{align}\]</span>，可见每条边都有一个起点和终点</p>
<p>有向图关联矩阵的性质如下：</p>
<ul>
<li><p>每列和为零：<span
class="math display">\[\sum^n_{i=1}m_{ij}=0\]</span></p></li>
<li><p>每一行的绝对值的和为 <span
class="math display">\[d(v)\]</span>：<span
class="math display">\[d(v_i)=\sum^m_{j=1}m_{ij}\]</span></p>
<p>其中 <span class="math display">\[1\]</span> 的个数为 <span
class="math display">\[d^+(v)\]</span>，<span
class="math display">\[-1\]</span> 的个数为 <span
class="math display">\[d^-(v)\]</span></p></li>
<li><p>握手定理（矩阵和为零）：<span
class="math display">\[\sum^n_{i=1}\sum^m_{j=1}m_{ij}=0\]</span></p></li>
<li><p>相同的两列是平行边</p></li>
</ul></li>
<li><p><strong>无向图的关联矩阵</strong></p>
<p>设 <span class="math display">\[G=\lang V,E\rang\]</span>
是无环无向图，<span class="math display">\[V=\lbrace
v_1,v_2,\dots,v_n\},\,E=\lbrace e_1,e_2,\dots,e_m\}\]</span></p>
<p>则关联矩阵 <span class="math display">\[M(G)=[m_{ij}]_{n\times
m}\]</span> 有 <span class="math display">\[m_{ij}=\begin{cases}1,\quad
v_i\,与\,e_j\,关联\\0,\quad v_i\,与\,e_j\,不关联\end{cases}\]</span></p>
<p>无向图关联矩阵有如下性质：</p>
<ul>
<li><p>每列和为 <span class="math display">\[2\]</span>：<span
class="math display">\[\sum^n_{i=1}m_{ij}=2\]</span></p></li>
<li><p>每一行的绝对值的和为 <span
class="math display">\[d(v)\]</span>：<span
class="math display">\[d(v_i)=\sum^m_{j=1}m_{ij}\]</span></p></li>
<li><p>平行所有 <span class="math display">\[1\]</span> 对应的边构成
<strong>断集</strong>：<span class="math display">\[[\lbrace
v_i\},\overline{\lbrace v_i\}}]\]</span></p></li>
<li><p>相同的两列是平行边</p></li>
<li><p>在非连通图中，连通分支能形成对角块，这样的矩阵叫做
<strong>伪对角阵</strong></p>
<p><span class="math display">\[\quad
M(G)=\begin{bmatrix}M(G_1)\\&amp;M(G_2)\\&amp;&amp;\ddots\\&amp;&amp;&amp;M(G_i)\end{bmatrix}\]</span></p></li>
<li><p>无向连通图的图关联矩阵的秩是 <span
class="math display">\[n-1\]</span>：<span
class="math display">\[G\,连通\Rarr r(M(G))=n-1\]</span></p>
<blockquote>
<p><strong><em>有关矩阵的秩</em></strong></p>
<p>若矩阵的某一行（列）的元素都是 <span
class="math display">\[0\]</span>，则该行（列）称为
<strong>零行（列）</strong></p>
<p>对矩阵进行如下变换称为 <strong>初等变换</strong></p>
<ul>
<li>对调两行</li>
<li>将一行的元素全部乘 <span
class="math display">\[k\,(k\not=0)\]</span></li>
<li>把某一行元素的 <span class="math display">\[k\,(k\not=0)\]</span>
倍加到另一行上</li>
</ul>
<p>对一个矩阵进行初等变换后，矩阵中非零行（列）的个数就是该矩阵的
<strong>秩</strong>，记为 <span class="math display">\[r(A)\]</span></p>
<p>对于矩阵 <span class="math display">\[A_{m\times n}\]</span>，若
<span class="math display">\[r(A)=m\]</span> 则称为行满秩矩阵，若 <span
class="math display">\[r(A)=n\]</span> 则称为列满秩矩阵</p>
</blockquote>
<p>可知，删除任意顶点后，该关联矩阵变为满秩。那个删除的顶点称为
<strong>参考点</strong>，得到的矩阵称为
<strong>基本关联矩阵</strong>，记作 <span
class="math display">\[M_f(G)\]</span></p>
<p>有以下推论：</p>
<p><span class="math display">\[\quad G,有\,p\,个连通分支\Rarr
r(M_f(G))=n-p\]</span></p>
<p><span class="math display">\[\quad G\,连通\Harr
r(M(G))=r(M_f(G))=n-1\]</span></p></li>
<li><p>对于连通图 <span class="math display">\[G\]</span>，设 <span
class="math display">\[M&#39;_f\]</span> 是 <span
class="math display">\[M(G)\]</span> 中任意 <span
class="math display">\[n-1\]</span> 列（<span
class="math display">\[M(G)\]</span> 本就有 <span
class="math display">\[n-1\]</span> 行）组成的方阵</p>
<p><span class="math display">\[M&#39;_f=\lbrace
e_{i1},e_{i2},\dots,e_{i(n-1)}\}\]</span> ，导出子图 <span
class="math display">\[T=G[\lbrace
e_{i1},e_{i2},\dots,e_{i(n-1)}\}]\]</span></p>
<p>则 <span
class="math display">\[M&#39;_f\,的行列式\,|M&#39;_f|\not=0\Harr
T\,是\,G\,的生成树\]</span></p>
<blockquote>
<p><strong><em>有关方阵的行列式</em></strong></p>
<p>行列式是由 <span class="math display">\[n\times n\]</span>
的方阵，所有取自不同行不同列的 <span class="math display">\[n\]</span>
个元素的不同取法各自乘积的代数和</p>
<p><span class="math display">\[\quad {\sum_{j_1j_2\dots
j_n}\\}(-1)^{\tau(j_1j_2\dots j_n)}a_{1j_1}a_{1j_2}\dots
a_{1j_n}\]</span></p>
<p>其中 <span class="math display">\[\tau(j_1j_2\dots j_n)\]</span>
是排列 <span class="math display">\[j_1j_2\dots j_n\]</span>
的逆序数。<strong>逆序数</strong>
是从一个排列中任取两个元素，其组合为逆序的取法的数量。如排列 <span
class="math display">\[1423\]</span> 中，逆序组合有 <span
class="math display">\[42、43\]</span>，故逆序数为 <span
class="math display">\[2\]</span></p>
<p>举例来说，对于三阶方阵 <span
class="math display">\[\begin{bmatrix}a_{11}&amp;a_{12}&amp;a_{13}\\a_{21}&amp;a_{22}&amp;a_{23}\\a_{31}&amp;a_{32}&amp;a_{33}\end{bmatrix}\]</span>，其取法有六种（<span
class="math display">\[123,132,213,231,312,321\]</span>）</p>
<p>故其行列式为：<span
class="math display">\[a_{11}a_{22}a_{33}-a_{11}a_{23}a_{32}-a_{12}a_{21}a_{33}+a_{12}a_{23}a_{31}+a_{13}a_{21}a_{32}-a_{13}a_{22}a_{31}\]</span></p>
<p>对于三阶以上的行列式，正常情况只能通过定义来求解</p>
</blockquote>
<p>于是就能用关联矩阵求生成树：</p>
<ol type="1">
<li>忽略环，求关联矩阵</li>
<li>任选参考点，求出基本关联矩阵</li>
<li>求所有 <span class="math display">\[n-1\]</span>
阶的子方阵，行列式非零的是生成树</li>
</ol></li>
</ul></li>
<li><p><strong>有向图邻接矩阵</strong></p>
<p>设 <span class="math display">\[D=\lang V,E\rang\]</span>
是无环有向图，<span class="math display">\[V=\lbrace
v_1,v_2,\dots,v_n\},E=\lbrace e_1,e_2,\dots,e_m\}\]</span></p>
<p>邻接矩阵 <span class="math display">\[A(D)=[a_{ij}]_{n\times
n}\]</span> 有 <span
class="math display">\[a_{ij}=从\,v_i\,到\,v_j\,的边数\]</span></p>
<p>有向图邻接矩阵有如下性质：</p>
<ul>
<li><p>每一行的和为点的出度：<span
class="math display">\[\sum^n_{j=1}a_{ij}=d^+(v_i)\]</span></p></li>
<li><p>每一列的和为点的入度：<span
class="math display">\[\sum^n_{i=1}a_{ij}=d^-(v_j)\]</span></p></li>
<li><p>握手定理（矩阵和等于边数）：<span
class="math display">\[\sum^n_{i=1}\sum^n_{j=1}a_{ij}=\sum^n_{i=1}d^-(v_j)=m\]</span></p></li>
<li><p>环的个数为：<span
class="math display">\[\sum^n_{i=1}a_{ii}\]</span></p></li>
<li><p>若 <span class="math display">\[A^r=A^{r-1}\bullet
A,\,(r\ge2),\,A^r=[a^r_{ij}]_{n\times n}\]</span>，<span
class="math display">\[B^r=A+A^2+\dots+A^r=[b^r_{ij}]_{n\times
n}\]</span></p>
<p>则 <span class="math display">\[a^r_{ij}\]</span> 表示从 <span
class="math display">\[v_i\]</span> 到 <span
class="math display">\[v_j\]</span> 的长度为 <span
class="math display">\[r\]</span> 的通路总数</p>
<p><span
class="math display">\[\sum^n_{i=1}\sum^n_{j=1}a^r_{ij}\]</span>
即长度为 <span class="math display">\[r\]</span> 的通路总数，<span
class="math display">\[\sum^n_{i=1}a^r_{ii}\]</span> 是长度为 <span
class="math display">\[r\]</span> 的回路总数</p>
<p>另外 <span class="math display">\[b^r_{ij}\]</span> 表示从 <span
class="math display">\[v_i\]</span> 到 <span
class="math display">\[v_j\]</span> 的长度不超过 <span
class="math display">\[r\]</span> 的通路总数</p>
<p><span
class="math display">\[\sum^n_{i=1}\sum^n_{j=1}b^r_{ij}\]</span>
即这样的通路总数，<span
class="math display">\[\sum^n_{i=1}b^r_{ii}\]</span>
是这样的回路总数</p></li>
</ul></li>
<li><p><strong>有向图可达矩阵</strong></p>
<p>设 <span class="math display">\[D=\lang V,E\rang\]</span> 是有向图
<span class="math display">\[V=\lbrace v_1,v_2,\dots,v_n\}\]</span></p>
<p>则可达矩阵 <span class="math display">\[P(D)=[p_{ij}]_{n\times
n}\]</span> 有 <span
class="math display">\[p_{ij}=\begin{cases}1,&amp;从\,v_i\,可达\,v_j\\1,&amp;从\,v_i\,不可达\,v_j\end{cases}\]</span></p>
<p>可达矩阵的性质：</p>
<ul>
<li>主对角线都是 <span class="math display">\[1\]</span></li>
<li>对于强连通图，所有元素都是 <span
class="math display">\[1\]</span></li>
<li>对角块是连通分支的可达矩阵称为伪对角阵</li>
<li><span class="math display">\[\forall i\not=j,\,p_{ij}=1\Harr
b^{n-1}_{ij}&gt;0\]</span></li>
</ul></li>
<li><p><strong>无向图相邻矩阵</strong></p>
<p>设 <span class="math display">\[G=\lang V,E\rang\]</span>
是无环无向图，<span class="math display">\[V=\lbrace
v_1,v_2,\dots,v_n\},E=\lbrace e_1,e_2,\dots,e_m\}\]</span></p>
<p>相邻矩阵 <span class="math display">\[A(G)=[a_{ij}]_{n\times
n},\,a_{ii}=0\]</span> 有 <span
class="math display">\[a_{ij}=\begin{cases}1,&amp;v_i\,与\,v_j\,相邻且\,i\not=j\\0,&amp;v_i\,与\,v_j\,不相邻\end{cases}\]</span></p>
<p>相邻矩阵的性质：</p>
<ul>
<li><p><span class="math display">\[A(G)\]</span> 对称：<span
class="math display">\[a_{ij}=a_{ji}\]</span></p></li>
<li><p>每行（列）的和为顶点的度：<span
class="math display">\[\sum^n_{i=1}a_{ij}=d(v_j)\]</span></p></li>
<li><p>握手定理：<span
class="math display">\[\sum^n_{i=1}\sum^n_{j=1}a_{ij}=\sum^n_{i=1}d(v_j)=2m\]</span></p></li>
<li><p>设 <span class="math display">\[A^r=A^{r-1}\bullet
A,\,(r\ge2),\,A^r=[a^r_{ij}]_{n\times n}\]</span>，<span
class="math display">\[B^r=A+A^2+\dots+A^r=[b^r_{ij}]_{n\times
n}\]</span></p>
<p>则 <span class="math display">\[a^r_{ij}\]</span> 是从 <span
class="math display">\[v_i\]</span> 到 <span
class="math display">\[v_j\]</span> 的长度为 <span
class="math display">\[r\]</span> 的通路总数，<span
class="math display">\[\sum^n_{i=1}a^r_{ii}\]</span> 即长度为 <span
class="math display">\[r\]</span> 的回路总数</p>
<p>有 <span class="math display">\[a^2_{ii}=d(v_i)\]</span></p>
<p>两点间的最小距离有：<span class="math display">\[G\,连通\Rarr
距离\,d(v_i,v_j)=\min\lbrace r|a^r_{ij}\not=0\}\]</span></p></li>
</ul></li>
<li><p><strong>连通矩阵</strong></p>
<p>设 <span class="math display">\[G=\lang V,E\rang\]</span>
是无向简单图，<span class="math display">\[V=\lbrace
v_1,v_2,\dots,v_n\},E=\lbrace e_1,e_2,\dots,e_m\}\]</span></p>
<p>连通矩阵 <span class="math display">\[P(G)=[p_{ij}]_{n\times
n}\]</span> 有 <span
class="math display">\[p_{ij}=\begin{cases}1,&amp;若\,v_i\,与\,v_j\,连通\\0,&amp;若\,v_i\,与\,v_j\,不连通\end{cases}\]</span></p>
<p>连通矩阵的性质：</p>
<ul>
<li>主对角线都是 <span class="math display">\[1\]</span></li>
<li>连通图的所有元素都是 <span class="math display">\[1\]</span></li>
<li>对角块是连通分支的连通矩阵称为伪对角阵</li>
<li>若 <span
class="math display">\[B^r=A+A^2+\dots+A^r=[b^r_{ij}]_{n\times
n}\]</span>，则 <span class="math display">\[\forall i\not=
j,\,p_{ij}=1\Harr b^{n-1}_{ij}&gt;0\]</span></li>
</ul></li>
</ul>
<h3 id="平面图">2.7 平面图</h3>
<ul>
<li><p><strong>平面图</strong></p>
<p>边与边不在非顶点处相交（简称不相交）的图称为
<strong>平面图</strong>。</p>
<p>可以画在平面上，使得边与边不在非顶点处相交的图称为
<strong>可平面图</strong>。这样的一种画法称为该图的一个
<strong>平面嵌入（平面表示）</strong></p>
<p>相对的，画在曲面上，使得边与边不相交的画法称为
<strong>曲面嵌入</strong>；在球面上的画法称为
<strong>球面嵌入</strong></p>
<p>有：<span class="math display">\[可平面嵌入\Harr
可球面嵌入\]</span>。让球面嵌入对平面投影，就能得到一个平面嵌入。</p></li>
<li><p><strong>面</strong></p>
<p>在平面图中，不含顶点与边的极大连通曲面 <span
class="math display">\[R\]</span> 称为
<strong>区域</strong>。面积无限的区域称为 <strong>外部区域</strong></p>
<p>与 <span class="math display">\[R\]</span>
关联的边和顶点构成的子图称为
<strong>区域边界</strong>。区域及该区域边界构成 <strong>面</strong></p>
<p>面中区域边界的长度 <span class="math display">\[\deg(R)\]</span> 称为
<strong>面的次数</strong>。显然 <span
class="math display">\[\sum^r_{i=1}\deg(R_i)=2m\]</span></p>
<p>另外，任何平面嵌入的内部面，都可能成为另一种平面嵌入的外部面。</p></li>
<li><p><strong>极大平面图、极小非平面图</strong></p>
<p>添加任意一条边后变成非平面图的平面图称为
<strong>极大平面图</strong>。<span class="math display">\[K_5\]</span>
去掉一条边后就是极大平面图</p>
<p><span class="math display">\[n(n\ge 3)\]</span>
阶简单连通平面图是极大平面图的充要条件是：<span
class="math display">\[\forall R,\,\deg(R)=3\]</span></p>
<p>删除任意一条边后变成平面图的非平面图称为
<strong>极小非平面图</strong>。<span
class="math display">\[K_5,\,K_{3,3}\]</span> 就是极小非平面图</p></li>
<li><p><strong>欧拉公式</strong></p>
<p>若 <span class="math display">\[G\]</span> 是平面图，则 <span
class="math display">\[n-m+r=2\]</span>，其中 <span
class="math display">\[r\]</span> 是 <span
class="math display">\[G\]</span> 的面数</p>
<p>欧拉公式的推广形式：若 <span class="math display">\[G\]</span>
是平面图，则 <span class="math display">\[n-m+r=1+p\]</span>，其中 <span
class="math display">\[r\]</span> 是 <span
class="math display">\[G\]</span> 的面数，<span
class="math display">\[p\]</span> 是 <span
class="math display">\[G\]</span> 的连通分支数</p>
<p>于是有以下定理</p>
<ul>
<li><p>若 <span class="math display">\[G\]</span> 是连通平面图
，且各面次数至少是 <span
class="math display">\[\ell(\ell\ge3)\]</span>，则 <span
class="math display">\[m\le\dfrac{(n-2)\ell}{\ell-2}\]</span></p></li>
<li><p>若 <span class="math display">\[G\]</span> 是有 <span
class="math display">\[p\]</span> 个连通分支的连通平面图
，各面次数至少是 <span
class="math display">\[\ell(\ell\ge3)\]</span>，则 <span
class="math display">\[m\le\dfrac{(n-p-1)\ell}{\ell-2}\]</span></p></li>
<li><p>若 <span class="math display">\[n(n\ge 3)\]</span> 阶简单平面图
<span class="math display">\[G\]</span> 有 <span
class="math display">\[m\]</span> 条边，则 <span
class="math display">\[m\le 3n-6\]</span></p>
<p>若 <span class="math display">\[G\]</span> 是简单极大平面图，则 <span
class="math display">\[m=3n-6\]</span></p></li>
<li><p>若 <span class="math display">\[G\]</span> 是简单平面图，则 <span
class="math display">\[\delta(G)\le 5\]</span></p></li>
</ul></li>
<li><p><strong>同胚</strong></p>
<p>插入 <span class="math display">\[2\]</span> 度顶点：把 <span
class="math display">\[(u,v)\]</span> 变成 <span
class="math display">\[(u,w),\,(w,v)\]</span></p>
<p>删除 <span class="math display">\[2\]</span> 度顶点：<span
class="math display">\[\deg(w)=2\]</span>，把 <span
class="math display">\[(u,w),\,(w,v)\]</span> 变成 <span
class="math display">\[(u,v)\]</span></p>
<p>反复删除或插入 <span class="math display">\[2\]</span>
度顶点后同构，则称两个平面图 <strong>同胚</strong></p>
<p>有如下定理：</p>
<ul>
<li><span class="math display">\[图\,G\,是平面图\Harr
G\,没有与\,K_5\,或\,K_{3,3}\,同胚的子图\]</span></li>
<li><span class="math display">\[图\,G\,是平面图\Harr
G\,没有可以边收缩到\,K_5\,或\,K_{3,3}\,的子图\]</span></li>
</ul></li>
<li><p><strong>对偶图</strong></p>
<p>设平面图 <span class="math display">\[G=\lang V,E\rang\]</span>
，其面集合是 <span class="math display">\[R\]</span></p>
<p>另有 <span class="math display">\[G^*=\lang
V^*,E^*\rang\]</span>，面集合为 <span
class="math display">\[R^*\]</span>，若 <span
class="math display">\[V^*\]</span> 与 <span
class="math display">\[R\]</span>、<span
class="math display">\[E^*\]</span> 与 <span
class="math display">\[E\]</span> 可以一一对应，则 <span
class="math display">\[G^*\]</span> 与 <span
class="math display">\[G\]</span> 是 <strong>对偶图</strong></p>
<p>对偶图有如下性质：</p>
<ul>
<li>对偶图必定是连通平面图</li>
<li>环与桥相互对偶</li>
<li>平行边对偶于 2 个面之间的多条边界</li>
<li><span class="math display">\[n^*=r,\,m^*=m\]</span></li>
<li><span class="math display">\[r*=n-p+1\]</span></li>
<li><span
class="math display">\[d_{G^*}(v_i^*)=\deg_G(R_i)\]</span></li>
<li>即使 <span class="math display">\[G_1\cong G_2\]</span> 也不能得出
<span class="math display">\[G_1^*\cong G_2^*\]</span></li>
<li><span class="math display">\[G\,连通\Harr G\cong
G^{**}\]</span></li>
</ul></li>
<li><p><strong>外（可）平面图</strong></p>
<p>若平面图所有的顶点都在一个面的边界上，则称其为
<strong>外平面图</strong></p>
<ul>
<li>充要条件：<span class="math display">\[G\,是外平面图\Harr
G\,不含与\,K_4\,或\,K_{2,3}\,同构的子图\]</span></li>
</ul></li>
<li><p><strong>极大外平面图</strong></p>
<p>加入任意边后不是外平面图的简单外平面图称为
<strong>极大外平面图</strong></p>
<ul>
<li><p>充要条件：</p>
<p>对于 <span class="math display">\[n(n\ge3)\]</span> 阶外平面图 <span
class="math display">\[G\]</span>，其所有顶点在外部面边界上，则</p>
<p><span class="math display">\[\quad\begin{align}
&amp;G\,是极大外平面图\\
\Harr&amp;G\,外部面边界是\,n\frac{}{}圈、内部面边界是\,3\frac{}{}圈
\end{align}\]</span></p></li>
<li><p>必要条件</p>
<p>对于 <span class="math display">\[n(n\ge3)\]</span> 阶外平面图 <span
class="math display">\[G\]</span>，其所有顶点在外部面边界上，则其具有以下性质</p>
<ul>
<li><span class="math display">\[G\]</span> 有 <span
class="math display">\[n-2\]</span> 个内部面</li>
<li><span class="math display">\[m=2n-3\]</span></li>
<li>至少有 <span class="math display">\[3\]</span> 个顶点的度数 <span
class="math display">\[\le3\]</span></li>
<li>至少有 <span class="math display">\[2\]</span> 个顶点的度数 <span
class="math display">\[=2\]</span></li>
<li><span class="math display">\[\kappa=2\]</span></li>
</ul></li>
</ul></li>
<li><p><strong>平面哈密顿图</strong></p>
<p>有如下定理：</p>
<ul>
<li><p><span class="math display">\[4\]</span>
连通平面图是哈密顿图</p></li>
<li><p>对于 <span class="math display">\[n\]</span>
阶简单平面哈密顿图，哈密顿回路内部次数为 <span
class="math display">\[i\]</span> 的面数 <span
class="math display">\[r_i&#39;\]</span>，外部为 <span
class="math display">\[r_i&#39;&#39;\]</span>，则有</p>
<p><span
class="math display">\[\quad\sum^n_{i=3}(i-2)(r_i&#39;-r_i&#39;&#39;)=0\]</span></p></li>
</ul></li>
</ul>
<h3 id="着色">2.8 着色</h3>
<ul>
<li><p><strong>点着色</strong></p>
<p>给无环图的每个顶点指定一种颜色，使得所有相邻顶点拥有不同颜色。</p>
<p>颜色集记为 <span class="math display">\[C=\lbrace
1,2\dots,k\}\]</span>，则着色 <span class="math display">\[f:V\rarr
C,\,\forall u\forall v(u,v\in V\and u\,与\,v\,相邻\rarr f(u)\not=
f(v))\]</span></p>
<p>颜色集的大小 <span class="math display">\[|C|=k\]</span> 则称为
<strong>k-着色</strong></p>
<p>可以 k-着色 但不能 k-1着色的图称为
<strong>k-色图</strong>，着色所需的最少颜色数称为
<strong>色数</strong></p>
<p><strong>点色数</strong>记为 <span
class="math display">\[\chi(G)\]</span>，<strong>边色数</strong> <span
class="math display">\[\chi&#39;(G)\]</span>，<strong>面色数</strong>
<span class="math display">\[\chi^*(G)\]</span></p>
<p>点色数的性质：</p>
<ul>
<li><p><span class="math display">\[\chi(G)=1\Harr
G\,是零图\]</span></p></li>
<li><p><span class="math display">\[\chi(K_n)=n\]</span></p></li>
<li><p><span class="math display">\[\chi(G)=2\Harr
G\,是非零图的二部图\]</span></p></li>
<li><p><span class="math display">\[G\,可以\,2\frac{}{}着色\Harr
G\,是二部图\Harr G\,无奇圈\]</span></p></li>
<li><p><span
class="math display">\[\chi(C_n)=\begin{cases}2,&amp;n\,是偶数\\3,&amp;n\,是奇数\end{cases}\]</span></p></li>
<li><p><span
class="math display">\[\chi(W_n)=\begin{cases}4,&amp;n\,是偶数\\3,&amp;n\,是奇数\end{cases}\]</span></p></li>
<li><p><span
class="math display">\[\chi(G)\le\Delta(G)+1\]</span></p></li>
<li><p><span
class="math display">\[n(n\ge3)阶非完全图\,G\,非奇圈\Rarr\chi(G)\le\Delta(G)\]</span></p></li>
<li><p>对图 <span class="math display">\[G\]</span> 进行着色，设 <span
class="math display">\[V_i=\lbrace v|v\in V(G)\and
v\,着同色\,i\},\,i=1,2,\dots,\chi(G)\]</span></p>
<p>则 <span class="math display">\[\Pi=\lbrace
V_1\,V_2\,\dots\,V_{\chi(G)}\}\]</span> 是 <span
class="math display">\[V(G)\]</span> 的划分。<span
class="math display">\[V_i\]</span> 中的点构成独立集</p>
<p>设 <span class="math display">\[R=\lbrace (u,v)|u,v\in V(G)\and
u,v\,着同色\}\]</span>，则 <span class="math display">\[R\]</span> 是
<span class="math display">\[V(G)\]</span> 上的等价关系</p></li>
</ul></li>
<li><p><strong>色多项式</strong></p>
<p>若标定图中至少有一个顶点着色不同，我们认为其是不同的着色</p>
<p>色多项式 <span
class="math display">\[f(G,k)=图\,G\,的不同的\,k\frac{}{}着色的总数\]</span></p>
<p>对于完全图：<span
class="math display">\[f(K_n,k)=k(k-1)\dots(k-n+1)=f(K_{n-1},k)(k-n+1)\]</span></p>
<p>对于零图：<span class="math display">\[f(N_n,k)=k^n\]</span></p>
<p>色多项式的递推公式：</p>
<ul>
<li><p>若 <span class="math display">\[e\]</span> 是 <span
class="math display">\[G\]</span> 中的边，则 <span
class="math display">\[f(G,k)=f(G-e,k)-f(G\setminus
e,k)\]</span></p></li>
<li><p>若 <span class="math display">\[e\]</span> 不是 <span
class="math display">\[G\]</span> 中的边，则 <span
class="math display">\[f(G,k)=f(G\cup e,k)+f(G\setminus
e,k)\]</span></p>
<p>以此法多次递推后，最终能得到一群完全图。故有</p>
<p><span
class="math display">\[f(G,k)=f(K_{n1},k)+f(K_{n2},k)+\dots+f(K_{nr},k)\]</span>，<span
class="math display">\[\chi(G)=\min(n1,n2,\dots,nr)\]</span></p></li>
</ul>
<p>色多项式的性质：</p>
<ul>
<li><p><span class="math display">\[f(G,k)\]</span> 是 <span
class="math display">\[n\]</span> 次多项式，系数正负号交替</p>
<p><span class="math display">\[k^n\]</span> 系数为 <span
class="math display">\[1\]</span>，<span
class="math display">\[k^{n-1}\]</span> 系数为 <span
class="math display">\[-m\]</span>，<span
class="math display">\[m\]</span> 为边数，常数项为 <span
class="math display">\[0\]</span></p>
<p>最低非零项为 <span class="math display">\[k^p\]</span>，<span
class="math display">\[p\]</span> 是连通分支数。</p>
<p>不同的连通分支相乘</p></li>
<li><p><span class="math display">\[T\,是\,n\,阶树\Harr
f(T,k)=k(k-1)^{n-1}\]</span></p>
<p><span class="math display">\[C\,是\,n\,阶圈\Rarr
f(C,k)=(k-1)^n+(-1)*n(k-1)\]</span></p></li>
<li><p>设 <span class="math display">\[V_1\]</span> 是 <span
class="math display">\[G\]</span> 的点割集，且 <span
class="math display">\[G[V_1]\]</span> 是 <span
class="math display">\[G\]</span> 的完全子图 <span
class="math display">\[K_{|V1|}\]</span></p>
<p>若 <span class="math display">\[G-V_1\]</span> 有 <span
class="math display">\[p\]</span> 个连通分支 <span
class="math display">\[G_1,G_2,\dots,G_p(p\ge2)\]</span>，且 <span
class="math display">\[H_i=G[V_1\cup V(G_i)]\]</span></p>
<p>则 <span
class="math display">\[f(G,k)=\dfrac{\Pi^p_{i=1}f(H_i,k)}{f(G[V_1],k)^{p-1}}\]</span></p></li>
</ul></li>
<li><p><strong>地图</strong></p>
<p>连通无桥平面图的平面嵌入及其所有的面称为
<strong>地图</strong>。平面地图的面称为 <strong>国家</strong>。</p>
<p>若两个国家的公共边界至少有一条公共边，称两个国家
<strong>相邻</strong></p>
<p>有：<span class="math display">\[地图\,G\,能\,k\frac{}{}面着色\Harr
对偶图\,G^*\,能\,k\frac{}{}点着色\]</span></p>
<p>以及：<span
class="math display">\[连通无环平面图\,G\,能\,k\frac{}{}面着色\Harr
对偶图\,G^*\,能\,k\frac{}{}点着色\]</span></p>
<p>五色定理：任何平面图都可以 5-着色</p></li>
<li><p><strong>边着色</strong></p>
<p>给无环图的每条边指定一种颜色，使得所有相邻边拥有不同颜色。</p>
<p>有以下定理：</p>
<ul>
<li><p><span class="math display">\[G\,是简单图\Rarr
\Delta(G)\le\chi&#39;(G)\le\Delta(G)+1\]</span></p></li>
<li><p><span class="math display">\[G\,是二部图\Rarr
\Delta(G)=\chi&#39;(G)\]</span></p></li>
<li><p>对于完全图：<span
class="math display">\[\chi&#39;(K_n)=\begin{cases}n,&amp;n\,为奇数\\n-1&amp;n\,为偶数\end{cases}\]</span></p></li>
<li><p>对图 <span class="math display">\[G\]</span> 进行 k-边着色，<span
class="math display">\[k\ge\chi&#39;(G)\]</span></p>
<p>令 <span class="math display">\[R=\lbrace
(e_i,e_j)|e_i\,与\,e_j\,着同色\,i\}\]</span>，则 <span
class="math display">\[R\]</span> 是 <span
class="math display">\[V(G)\]</span> 上的等价关系</p>
<p>商集合 <span class="math display">\[E/R=\lbrace
E_1,E_2,\dots,E_k\}\]</span> 是 <span class="math display">\[E\]</span>
的划分，划分块中的元素着同色。同色边构成边独立集</p></li>
</ul></li>
</ul>
<h3 id="支配集点覆盖集点独立集">2.9 支配集、点覆盖集、点独立集</h3>
<ul>
<li><p><strong>支配集</strong></p>
<p>对于 <span class="math display">\[G=\lang V,E\rang\]</span>，存在
<span class="math display">\[e=(u,v)\in E\]</span>，则称 <span
class="math display">\[u\]</span> <strong>支配</strong> <span
class="math display">\[v\]</span>（<span
class="math display">\[v\]</span> 支配 <span
class="math display">\[u\]</span>）</p>
<p>若 <span class="math display">\[V^*\subseteq V\]</span> 有 <span
class="math display">\[\forall u\in V-V^*\rarr \exist v\in
V^*,\,u\,支配\,v\]</span>，则称 <span
class="math display">\[V^*\]</span> 是 <strong>支配集</strong></p>
<p>真子集都非支配集的支配集称为 <strong>极小支配集</strong></p>
<p>顶点数最少的支配集称为
<strong>最小支配集</strong>。最小支配集的顶点数 <span
class="math display">\[\gamma_0(G)\]</span> 为
<strong>支配数</strong></p>
<p>有如下定理：</p>
<ul>
<li>若无向图 <span class="math display">\[G\]</span> 无孤立点，<span
class="math display">\[V^*_1\]</span> 是极小支配集，则存在极小支配集
<span class="math display">\[V_2^*\]</span>，且 <span
class="math display">\[V_1^*\cap V_2^*=\empty\]</span></li>
</ul></li>
<li><p><strong>独立集</strong></p>
<p>对于 <span class="math display">\[G=\lang V,E\rang\]</span>，若 <span
class="math display">\[V^*\subseteq V,\,\forall u,v\in
V^*,\,u\,与\,v\,不相邻\]</span>，则称 <span
class="math display">\[V^*\]</span> 是 <strong>独立集</strong></p>
<p>真母集都非独立集的独立集称为 <strong>极大独立集</strong></p>
<p>定点树最多的独立集称为
<strong>最大独立集</strong>，最大独立集的顶点数 <span
class="math display">\[\beta_0(G)\]</span> 为
<strong>点独立数</strong></p>
<p>有如下定理：</p>
<ul>
<li>对于无向图 <span class="math display">\[G\]</span>，<span
class="math display">\[V^*\,是极大独立集\Rarr
V^*\,是极小支配集\]</span></li>
<li>对于无向图 <span class="math display">\[G\]</span>，<span
class="math display">\[\gamma_0(G)\le \beta_0(G)\]</span></li>
</ul></li>
<li><p><strong>团</strong></p>
<p>对于 <span class="math display">\[G=\lang V,E\rang\]</span>，若 <span
class="math display">\[V^*\subseteq V\]</span>，且 <span
class="math display">\[G[V^*]\]</span> 是完全子图，则称 <span
class="math display">\[V^*\]</span> 是 <strong>团</strong></p>
<p>真母集都不是团的团称为 <strong>极大团</strong></p>
<p>顶点数最多的团称为 <strong>最大团</strong>，最大团的顶点数 <span
class="math display">\[\nu_0(G)\]</span> 为 <strong>团数</strong></p>
<p>有如下定理：</p>
<ul>
<li><p>对于无向图 <span class="math display">\[G\]</span>，<span
class="math display">\[V^*\,是\,G\,的团\Harr
V^*\,是\,\overline{G}\,的独立集\]</span></p></li>
<li><p>对于无向图 <span class="math display">\[G\]</span>，<span
class="math display">\[\nu_0(G)=\beta_0(\overline{G})\]</span></p>
<p><span class="math display">\[V^*\,是\,G\,的极大(最大)团\Harr
V^*\,是\,\overline{G}\,的极大(最大)独立集\]</span></p></li>
</ul></li>
<li><p><strong>点覆盖</strong></p>
<p>对于 <span class="math display">\[G=\lang V,E\rang\]</span>，若 <span
class="math display">\[V^*\subseteq V\]</span>，且 <span
class="math display">\[\forall e\in E\]</span>，都有 <span
class="math display">\[\exist v\in V^*,\,v\,关联\,e\]</span>，则称 <span
class="math display">\[V^*\]</span> 是 <strong>点覆盖</strong></p>
<p>真子集都非点覆盖的点覆盖称为 <strong>极小点覆盖</strong></p>
<p>顶点数最小的点覆盖称为 <strong>最小点覆盖</strong>，其顶点数 <span
class="math display">\[\alpha_0(G)\]</span> 为
<strong>点覆盖数</strong></p>
<p>有如下定理：</p>
<ul>
<li><p>对于无向图 <span
class="math display">\[G\]</span>，若其无孤立点，则其点覆盖是支配集。否则，点覆盖加所有孤立点就是支配集</p>
<p>有 <span
class="math display">\[\gamma_0(G)\le\alpha_0(G)\]</span></p></li>
<li><p>对于无向图 <span
class="math display">\[G\]</span>，若其无孤立点，则 <span
class="math display">\[V^*\,是点覆盖\Harr V-V^*\,是独立集\]</span></p>
<p>且 <span class="math display">\[V^*\,是最小(极小)点覆盖\Harr
V-V^*\,是最小(极小)独立集\]</span></p>
<p>此时 <span
class="math display">\[\alpha_0+\beta_0=n\]</span></p></li>
<li><p><span
class="math display">\[\alpha_0,\beta_0,\nu_0,\gamma_0\]</span>
之间的关系：</p>
<ul>
<li><span
class="math display">\[\alpha_0+\beta_0=n\]</span>（无孤立点时）</li>
<li><span class="math display">\[\gamma_0\le\beta_0\]</span></li>
<li><span
class="math display">\[\gamma_0\le\alpha_0\]</span>（无孤立点时）</li>
<li><span
class="math display">\[\nu_0(G)=\beta_0(\overline{G})\]</span></li>
<li><span class="math display">\[\alpha_0,\beta_0,\nu_0\]</span>
都是难解的</li>
</ul></li>
</ul></li>
</ul>
<h3 id="边覆盖匹配">2.10 边覆盖、匹配</h3>
<ul>
<li><p><strong>边覆盖</strong></p>
<p>对于 <span class="math display">\[G=\lang V,E\rang\]</span>，若 <span
class="math display">\[E^*\subseteq E\]</span>，且 <span
class="math display">\[\forall v\in V\]</span> 都有 <span
class="math display">\[\exist e\in E,\,e\,关联\,v\]</span>，则 <span
class="math display">\[E^*\]</span> 是 <strong>边覆盖</strong></p>
<p>真子集都非边覆盖的边覆盖称为 <strong>极小边覆盖</strong></p>
<p>边数最小的边覆盖称为 <strong>最小边覆盖</strong>，其边数 <span
class="math display">\[\alpha_1(G)\]</span> 为
<strong>边覆盖数</strong></p></li>
<li><p><strong>匹配</strong></p>
<p>对于无向图 <span class="math display">\[G=\lang
V,E\rang\]</span>，<span class="math display">\[E^*\subseteq
E\]</span>，若 <span class="math display">\[\forall e,f\in E^*\]</span>
且 <span class="math display">\[e,f\]</span> 不相邻，则 <span
class="math display">\[E^*\]</span> 是 <strong>匹配</strong></p>
<p>真母集都非匹配的匹配称为 <strong>极大匹配</strong></p>
<p>边数最多的匹配称为 <strong>最大匹配</strong>，其边数 <span
class="math display">\[\beta_1(G)\]</span> 称为
<strong>匹配数</strong></p>
<p>匹配中关联的顶点称为 <strong>饱和点</strong>，此外的顶点称为
<strong>非饱和点</strong></p>
<p>没有非饱和点的匹配称为 <strong>完美匹配</strong></p>
<p>有如下定理：</p>
<ul>
<li><p><span class="math display">\[G\,有完美匹配\Harr\forall
V&#39;\subset V(G),p_奇(G-V&#39;)\le|V&#39;|\]</span></p>
<p>其中 <span class="math display">\[p_奇\]</span>
是奇数阶的连通分支数</p>
<p>（推论）无桥的 3-正则图 有完美匹配</p></li>
<li><p>对于无孤立点的无向图 <span
class="math display">\[G\]</span>，定有 <span
class="math display">\[\alpha_1+\beta_1=n\]</span></p>
<p>设 <span class="math display">\[M\]</span>
是其最大匹配，其所有非饱和点 <span class="math display">\[v\]</span>
各取一条关联边组成边集 <span class="math display">\[N\]</span>，则 <span
class="math display">\[W=M\cup N\]</span> 是最小边覆盖</p>
<p>设 <span class="math display">\[W_1\]</span> 是其最小边覆盖，若 <span
class="math display">\[W_1\]</span>
中有邻边即删除其中一边，直至无邻边。设那些删除的边为 <span
class="math display">\[N_1\]</span>，则 <span
class="math display">\[M_1=W_1-N_1\]</span> 为最大匹配</p></li>
<li><p>若无向图 <span class="math display">\[G\]</span> 无孤立点，<span
class="math display">\[M\]</span> 是其匹配，<span
class="math display">\[N\]</span> 是其点覆盖，<span
class="math display">\[Y\]</span> 是独立集，<span
class="math display">\[W\]</span> 是边覆盖，则</p>
<ul>
<li><span class="math display">\[|M|\le|W|\]</span>。若 <span
class="math display">\[|M|=|W|\]</span>，则 <span
class="math display">\[M\]</span> 是完美匹配，<span
class="math display">\[W\]</span> 是最小边覆盖</li>
<li><span class="math display">\[|M|\le|N|\]</span>。若 <span
class="math display">\[|M|=|N|\]</span>，则 <span
class="math display">\[M\]</span> 是最大匹配，<span
class="math display">\[N\]</span> 是最小点覆盖</li>
<li><span class="math display">\[|Y|\le|W|\]</span>。若 <span
class="math display">\[|Y|=|W|\]</span>，则 <span
class="math display">\[Y\]</span> 是最大独立集，<span
class="math display">\[W\]</span> 是最小边覆盖</li>
<li><span class="math display">\[\beta_1\le\alpha_0\]</span>，<span
class="math display">\[\beta_0\le\alpha_1\]</span></li>
</ul></li>
<li><p><span
class="math display">\[\alpha_0,\beta_0,\nu_0,\gamma_0,\alpha_1,\beta_1\]</span>
之间的关系：</p>
<ul>
<li><span
class="math display">\[\gamma_0\le\alpha_0\quad\gamma_0\le\beta_0\quad
n=\alpha_0+\beta_0\]</span></li>
<li><span
class="math display">\[\nu_0(\overline{G})=\beta_0(G)\le\alpha_1\quad\alpha_1+\beta_1=n\]</span></li>
<li><span class="math display">\[\beta_1\le\alpha_1\quad
\beta_1\le\alpha_0\]</span></li>
<li><span class="math display">\[\alpha_1,\beta_1\]</span>
是容易计算的</li>
</ul></li>
</ul></li>
<li><p><strong>交错路径</strong></p>
<p>在匹配中和匹配外交替选取边的路径称为 <strong>交错路径</strong></p>
<p>两个端点都是非饱和点的交错路径称为
<strong>可增广（交错）路径</strong></p>
<p>有如下定理：</p>
<ul>
<li><p>设 <span class="math display">\[M_1,M_2\]</span> 是 <span
class="math display">\[G\]</span> 中的不同匹配，则 <span
class="math display">\[G[M_1\oplus M_2]\]</span> 的每个连通分支是 <span
class="math display">\[M_1,M_2\]</span>
中的边组成的交错圈或交错路径</p></li>
<li><p>设 <span class="math display">\[M\]</span> 是 <span
class="math display">\[G\]</span> 中的匹配，<span
class="math display">\[\Gamma\]</span> 是 <span
class="math display">\[M\]</span> 的可增广路径，则 <span
class="math display">\[M&#39;=M\oplus E(\Gamma)\]</span> 也是匹配，且
<span class="math display">\[|M&#39;|=|M|+1\]</span></p>
<p>这个定理可以求出最大匹配</p>
<p><span class="math display">\[M\,是\,G\,中的最大匹配\Harr
G\,中无\,M\,的可增广路径\]</span></p></li>
</ul></li>
<li><p><strong>二部图的匹配</strong></p>
<p>对于二部图 <span class="math display">\[G=\lang
V_1,V_2,E\rang,\,|V_1|\le|V_2|\]</span>，若匹配 <span
class="math display">\[M\]</span> 有 <span
class="math display">\[|M|=|V_1|\]</span> 则称其为
<strong>完备匹配</strong></p>
<p>有如下定理：</p>
<ul>
<li><p><span class="math display">\[二部图\,G\,有完美匹配\Harr
G\,满足霍尔条件\]</span></p>
<p><strong>霍尔条件</strong>（相异性条件）：<span
class="math display">\[\forall S\subseteq
V_1,\,|S|\le|N(S)|\]</span>。<span class="math display">\[N(S)=\lbrace
u|\exist v\in S,(v,u)\in E\}=\bigcup_{v\in S}\Gamma(v)\]</span></p>
<p>换句话说，对于较少顶点侧的任意点集，其对应的另一侧点集大小不少于该点集大小</p></li>
<li><p><span class="math display">\[二部图\,G\,有完美匹配\Rarr
G\,满足\,t\frac{}{}条件\]</span></p>
<p><strong>t-条件</strong>：二部图 <span class="math display">\[G=\lang
V_1,V_2,E\rang,\,t\ge1\]</span>。<span
class="math display">\[V_1\]</span>
的每个顶点<font color="RED">至少</font>关联 t 条边，且 <span
class="math display">\[V_2\]</span>
的每个顶点<font color="RED">至多</font>关联 t 条边</p></li>
<li><p>k-正则二部图存在 k 个边不重的完备匹配</p></li>
<li><p>二部图 <span class="math display">\[G=\lang
V_1,V_2,E\rang\]</span> 无孤立点，则 <span
class="math display">\[\alpha_0=\beta_1\]</span></p></li>
</ul></li>
</ul>
<h3 id="带权图">2.11 带权图</h3>
<ul>
<li><p><strong>带权图</strong></p>
<p>对于图 <span class="math display">\[G=\lang V,E,W\rang,\,W:E\rarr
R\]</span>。其中 <span class="math display">\[W(e)\]</span> 称为图的
<strong>权</strong></p></li>
<li><p><strong>有效算法</strong></p>
<p>复杂度是多项式函数的算法称为 <strong>有效算法</strong></p>
<p>如 O(n)、O(n<sup>3</sup>)、O(n㏒n)
等复杂度都是有效算法。O(2<sup>n</sup>) 等不是有效算法</p>
<p>有多项式复杂度算法的问题称为 <strong>易解问题</strong>，否则称为
<strong>难解问题</strong></p></li>
<li><p><strong>中国邮递员问题</strong></p>
<p>对于一个带权图，求经过所有边的最短回路</p>
<p>中国邮递员问题是一个易解问题。方法如下：</p>
<ol type="1">
<li>求该带权图 <span class="math display">\[G\]</span>
的所有奇数度顶点间的短程线。这些顶点和短程线构成带权完全图 <span
class="math display">\[K\]</span></li>
<li>求出 <span class="math display">\[K\]</span> 的最小完美匹配 <span
class="math display">\[M\]</span></li>
<li>用 <span class="math display">\[M\]</span> 给 <span
class="math display">\[G\]</span> 沿短程线加边得到 <span
class="math display">\[G^*\]</span>，<span
class="math display">\[G^*\]</span> 的欧拉回路 <span
class="math display">\[\Gamma\]</span> 就是答案</li>
</ol></li>
<li><p><strong>货郎问题</strong></p>
<p>对于一个带权图，求经过所有顶点的最短回路</p>
<p>货郎问题是一个难解问题</p></li>
</ul>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%95%B0%E5%AD%A6/" class="category-chain-item">数学</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%9B%AE/">#基础课目</a>
      
        <a href="/tags/%E6%95%B0%E5%AD%A6/">#数学</a>
      
        <a href="/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/">#离散数学</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>离散数学（1）</div>
      <div>https://i-melody.github.io/2022/10/15/Basic/离散数学/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Melody</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年10月15日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
              <a target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">
              <span class="hint--top hint--rounded" aria-label="NC - 非商业性使用">
                <i class="iconfont icon-nc"></i>
              </span>
              </a>
            
              <a target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">
              <span class="hint--top hint--rounded" aria-label="ND - 禁止演绎">
                <i class="iconfont icon-nd"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  




  
  





  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.13.10/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});
  });
</script>





    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a target="_blank" href="https://hexo.io/zh-cn/" rel="nofollow noopener noopener"><span>Hexo</span></a> <a target="_blank" href="https://hexo.fluid-dev.com/"_blank" rel="nofollow noopener noopener"><span>Fluid</span></a> <i class="iconfont icon-music"></i> <a href="https://space.bilibili.com/17026508" target="_blank" rel="nofollow noopener"><span>Melody 2022-02-19</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>






  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  
      <script>
        MathJax = {
          tex    : {
            inlineMath: { '[+]': [['$', '$']] }
          },
          loader : {
            load: ['ui/lazy']
          },
          options: {
            renderActions: {
              findScript    : [10, doc => {
                document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                  const display = !!node.type.match(/; *mode=display/);
                  const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                  const text = document.createTextNode('');
                  node.parentNode.replaceChild(text, node);
                  math.start = { node: text, delim: '', n: 0 };
                  math.end = { node: text, delim: '', n: 0 };
                  doc.math.push(math);
                });
              }, '', false],
              insertedScript: [200, () => {
                document.querySelectorAll('mjx-container').forEach(node => {
                  let target = node.parentNode;
                  if (target.nodeName.toLowerCase() === 'li') {
                    target.parentNode.classList.add('has-jax');
                  }
                });
              }, '', false]
            }
          }
        };
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.0/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
